{"./":{"url":"./","title":"ABACUS 使用教程","keywords":"","body":"ABACUS使用教程 一、介绍 ABACUS（Atomic-orbtial Based Ab-initio Computation at UStc，中文名原子算筹）是国产开源密度泛函理论软件，相关介绍 ABACUS 的新闻可在ABACUS 新闻稿整理查看，以下是一些常用地址： ABACUS 在 DeepModeling 社区中的 GitHub 仓库地址为： https://github.com/deepmodeling/abacus-develop ABACUS 的 Gitee 镜像仓库地址为： https://gitee.com/deepmodeling/abacus-develop ABACUS 网站访问： http://abacus.ustc.edu.cn/ 文档（包括安装方法、输入输出参数介绍、功能介绍、算例介绍、开发者须知等）： https://abacus.deepmodeling.com/en/latest/ 本教程系列旨在帮助新手用户入门了解 ABACUS 的使用。秉着开源软件的理念，本文档是由开源社区的老师同学们贡献所成。如果你也想贡献一份文档，我们十分欢迎，请参考如何贡献ABACUS使用教程。 本教程中标有 Logo的部分可以直接在Bohrium Notebook上打开。 在Bohrium Notebook上快速学习，见快速开始 ABACUS｜自洽 能带 态密度 结构优化；在Bohrium平台上运行大任务，见教程。 二、ABACUS基本操作教程 ABACUS的编译介绍 官方编译教程 GCC 编译 ABACUS 教程 Intel oneAPI 编译 ABACUS 教程 在超算环境编译 ABACUS 的建议 ABACUS 在曙光 DCU 集群上的编译与使用 ABACUS toolchain 脚本集 (md文档待整理) ABACUS建模介绍 准备晶胞和原子位置等信息的文件STRU：如何转换STRU的格式 准备赝势： 模守恒赝势生成方法简介 数值原子轨道基组生成教程： 数值原子轨道（一）：ABACUS 中的数值原子轨道命名和使用方法 数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道 数值原子轨道（三）：产生高精度数值原子轨道 Kohn-Sham密度泛函理论 电子自洽迭代 带自旋的体系计算：ABACUS磁性材料计算使用教程 +U计算：ABACUS DFT+U使用教程 结构优化：ABACUS 使用教程｜结构优化 分子动力学：ABACUS 分子动力学使用教程 DeePKS方法（缺） ABACUS 隐式溶剂模型使用教程 随机波函数密度泛函理论：ABACUS 随机波函数DFT方法使用教程 无轨道密度泛函理论：ABACUS 无轨道密度泛函理论方法使用教程 采用ABACUS进行表面计算 静电势和功函数 偶极修正 外加电场 补偿电荷 分析结果 能带计算 如何正确画能带，NSCF读电荷密度 用ABACUS-ASE自动产生能带路径 PDOS计算 ABACUS里怎样做DOS和PDOS计算 和其他软件对接 ABACUS+Phonopy 计算声子谱 ABACUS+ShengBTE 计算晶格热导率 ABACUS+Phono3py 计算晶格热导率 ABACUS+DPGEN 使用教程 ABACUS+LibRI 做杂化泛函计算教程 ABACUS+Candela 使用教程 ABACUS+USPEX 接口教程 ABACUS+Hefei NAMD 使用教程 ABACUS+pyatb 能带反折叠计算 ABACUS+ASE接口使用技巧 ABACUS+CINEB教程（缺） ASE-NEB-ABACUS工作流与算例（持续完善中） ABACUS-ASE做NEB计算 （简单算例） 三、使用经验 有VASP使用背景的用户上手ABACUS教程：ABACUS新人使用的一些注意事项 四、开发者文档 ABACUS 开源项目 C++ 代码规范 ABACUS 中使用格式化工具 clang-format ABACUS 注释规范：Doxygen 入门 (c++) ABACUS 的 Github 仓库 Issues 处理流程 ABACUS 线上文档输入参数撰写规范 Introduction to ABACUS: Path to PW calculation - Part 1 Introduction to ABACUS: Path to PW calculation - Part 2 Introduction to ABACUS: Path to PW calculation - Part 3 Introduction to ABACUS: Path to PW calculation - Part 4 Introduction to ABACUS: Path to PW calculation - Part 5 Introduction to ABACUS: Path to PW calculation - Summary 1 Introduction to ABACUS: Path to PW calculation - Part 6 Introduction to ABACUS: Path to PW calculation - Part 7 Introduction to ABACUS: Path to PW calculation - Part 8 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-03 22:38:35 "},"abacus-gcc.html":{"url":"abacus-gcc.html","title":"GCC 编译 ABACUS 教程","keywords":"","body":"GCC 编译 ABACUS 教程 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/19 一、介绍：关于 ABACUS ABACUS（原子算筹）软件同时支持两种基矢量，一种是平面波（Plane wave，PW） 基组，一种是 LCAO (Linear combination of atomic orbitals)或者称 NAO(Numerical atomic orbitals)基组。因为两种基组运行依赖的软件库不完全相同，所以我们分开介绍。 实际上，LCAO 基组依赖的软件库比 PW 基组更多，因此如果用户只使用 PW 基组，并不需要将所有依赖的数学库全都下载安装好。 下面介绍，两种基组分别都依赖那些数学库： PW 基组依赖以下 3 个 数学库： BLAS：BLAS（Basic Linear Algebra Subprograms）是一组基本的线性代数库，用于高效执行常见的基础线性代数运算，如矩阵乘法和向量操作。 LAPACK：LAPACK（Linear Algebra Package）是一个开源的数值线性代数库，用于解决线性代数问题，包括矩阵分解、方程组求解和特征值计算等。 FFTW3：FFTW3（Fastest Fourier Transform in the West 3）是一个高性能、开源的快速傅里叶变换（FFT）库，用于高效计算各种傅里叶变换和逆变换。 LCAO 基组依赖以下 6 个 软件库： BLAS LAPACK FFTW3 ScaLAPACK：ScaLAPACK（Scalable LAPACK）是一种并行计算库，构建在 LAPACK 之上，用于解决大规模线性代数问题，特别适用于分布式和并行计算环境。 CEREAL：CEREAL 是一个 C++ 序列化库，用于将 C++ 对象转换为可存储或传输的数据格式，以及将其反序列化回对象。 ELPA：ELPA（Eigenvalue SoLvers for Petaflop-Applications）是一个用于高性能计算的开源库，旨在解决大规模高性能计算中的特征值问题，特别是密集矩阵的特征值问题。（用户编译安装 abacus 的时候大多在这里出现问题） 二、检查当前服务器基础环境： 1. 查看当前系统版本： root@bohrium-11852-1041346:~# lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 20.04.5 LTS Release: 20.04 Codename: focal 2. 检查当前 GCC 编译器版本： root@bohrium-11852-1041346:~# g++ --version g++ (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0 Copyright (C) 2019 Free Software Foundation, Inc. 3. 检查当前环境是否有 git root@bohrium-11852-1041346:~# git --version git version 2.25.1 三、安装 仅支持 PW 基组的 ABACUS 对于仅支持 PW 基组的 ABACUS，我们同时支持两种版本的编译：串行版本和并行版本。 编译这两个版本的主要区别在于是否需要安装 MPI library。 1. 编译串行版本 1.1 安装依赖库。 sudo apt update sudo apt install -y libopenblas-openmp-dev sudo apt install -y liblapack-dev sudo apt install -y libfftw3-dev 1.2 从仓库克隆代码到本地，并进入目录。 git clone https://github.com/deepmodeling/abacus-develop.git cd abacus-develop/ 1.3 开始编译并安装 abacus。 cmake -B build -DENABLE_MPI=OFF cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus_pw_serial 可执行文件。 abacus_pw_serial 就是串行版本的支持平面波基组的 ABACUS。 2. 编译并行版本 2.1 安装依赖库。（同串行，如果已经安装，则不用重复操作） sudo apt update sudo apt install -y libopenblas-openmp-dev sudo apt install -y liblapack-dev sudo apt install -y libfftw3-dev 2.2 安装 MPI library。这里选择更为常用的 open MPI。 sudo apt install -y libopenmpi-dev 2.3 从仓库克隆代码到本地，并进入目录。 git clone https://github.com/deepmodeling/abacus-develop.git cd abacus-develop/ 2.4 开始编译并安装 abacus。 cmake -B build -DENABLE_LCAO=OFF cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus_pw 可执行文件。 abacus_pw 就是并行版本的支持平面波基组的 ABACUS。 四、安装 支持两种基组的 ABACUS 对于同时支持两种基组的 ABACUS，仅可以编译并行版本。并无串行版本。 在本文最初就提到支持 LCAO 基组的 ABACUS 所依赖软件库的更多。 1. 安装 PW 基组依赖的软件库。（同上，如果已经安装，则不用重复操作） sudo apt update sudo apt install -y libopenblas-openmp-dev sudo apt install -y liblapack-dev sudo apt install -y libfftw3-dev 2. 安装 MPI library。这里选择更为常用的 open MPI。（同上，如果已经安装，则不用重复操作） sudo apt install -y libopenmpi-dev 3. 安装 LCAO 基组依赖的 ScaLAPACK 和 CEREAL 软件库。 sudo apt install -y libscalapack-mpi-dev sudo apt install -y libcereal-dev 4. 安装 ELPA 软件库。（一般这里容易出问题） 如果你的系统是 Ubuntu 22.04，那么你可以以很简单的方式成功安装 ELPA： sudo apt install -y libelpa-dev 如果你的系统不是 Ubuntu 22.04，很可惜，你需要稍微辛苦一点来安装 ELPA。但别急，这也并不难！ 手动编译安装 ELPA 可以分为以下几步： 5. 开始编译并安装 abacus。 cmake -B build cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus 可执行文件。 abacus 就是完整版的 ABACUS，它同时支持两种基矢量，而且还是并行版本！ Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-24 10:09:47 "},"abacus-intel.html":{"url":"abacus-intel.html","title":"Intel oneAPI 编译 ABACUS 教程","keywords":"","body":"Intel oneAPI 编译 ABACUS 教程 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/21 一、前言 非特殊情况，linux 系统会默认安装 GCC（GNU Compiler Collection）编译器套件。因此如果你的机器默认没有 Intel® oneAPI Toolkits，那么建议，你可以直接看上一篇文章：GCC 编译 ABACUS 教程 。 如果您的机器恰好有 Intel® oneAPI Toolkits，那么您也可以使用它来编译 ABACUS。 二、关于 Intel® oneAPI Toolkits Intel® oneAPI Toolkits 分为很多个版本的 Toolkit，这里解释下 Intel® oneAPI Base Toolkit 和 Intel® oneAPI HPC Toolkit 的区别。 简单来说：Intel® oneAPI HPC Toolkit 包含 Intel® oneAPI Base Toolkit。 Intel® oneAPI Base Toolkit 中包含：Intel® oneAPI Math Kernel Library（简称为 MKL），这个软件库里面包含了大量常用的数学库，包括 ABACUS 依赖的 BLAS、LAPACK、FFTW3 和 ScaLAPACK 4 个软件库。 因此使用 Intel oneAPI 来编译 ABACUS，可以省去逐个去安装数学库的过程！ Intel® oneAPI HPC Toolkit 相比于 Intel® oneAPI Base Toolkit 多了一些必要的 Intel 的编译器以及 Intel® MPI Library（ABACUS 想要编译并行版本必须的关键库）。 总结一下，使用 Intel oneAPI 编译 ABACUS，必须确保你的机器中包含 Intel® oneAPI HPC Toolkit。 关于 Intel® oneAPI Toolkits 更详细的信息：https://www.intel.com/content/www/us/en/developer/tools/oneapi/toolkits.html#hpc-kit 三、编译 安装 开启 Intel® oneAPI Toolkits： source /opt/intel/oneapi/setvars.sh 1. 安装 仅支持 PW 基组的 ABACUS 对于仅支持 PW 基组的 ABACUS，我们同时支持两种版本的编译：串行版本和并行版本。 ABACUS 的 PW 基组只依赖：BLAS、LAPACK、FFTW3 三个数学库，而这三个数学库都已经被 Intel® oneAPI Base Toolkit 中包含：Intel® oneAPI Math Kernel Library（简称为 MKL）所包含，因此我们不需要再安装其他的软件库！ 1.1 编译串行版本 CXX=icpx cmake -B build -DENABLE_MPI=OFF cd build && make -j`nproc` 注意，这里必须指定CXX=icpx，不然系统会使用默认的 CXX 编译器。同时这里的 CXX 也不要指定 icpc，icpc 是 Intel® C++ Compiler Classic，会带来一些报错。 可以看到在当前目录下，已经编译成功了 abacus_pw_serial 可执行文件。 abacus_pw_serial 就是串行版本的支持平面波基组的 ABACUS。 1.2 编译并行版本 CXX=icpx cmake -B build -DENABLE_LCAO=OFF cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus_pw 可执行文件。 abacus_pw 就是并行版本的支持平面波基组的 ABACUS。 2. 安装 支持两种基组的 ABACUS 对于同时支持两种基组的 ABACUS，仅可以编译并行版本。并无串行版本。 完整版的 ABACUS 需要依赖更多的软件库：BLAS、LAPACK、FFTW3、ScaLAPACK、CEREAL、ELPA共 6 个。 而前四个数学库（BLAS、LAPACK、FFTW3、ScaLAPACK）都已经被 Intel MKL 所包含，因此我们只需再额外安装CEREAL、ELPA即可。 2.1 安装 CEREAL sudo apt install -y libcereal-dev 2.2 安装 ELPA 如果你的系统是 Ubuntu 22.04，那么你可以以很简单的方式成功安装 ELPA。 sudo apt install -y libelpa-dev 如果你的系统不是 Ubuntu 22.04，很可惜，你需要稍微辛苦一点来安装 ELPA。但别急，这也并不难！ 注意；这里手动编译安装 ELPA 的方法与在 GCC 下编译不太一样，因为要保证 ELPA 和 ABACUS 都是基于 Intel oneAPI 来编译的！ 手动编译安装 ELPA 可以分为以下几步： 下载并进入 ELPA 目录： wget https://elpa.mpcdf.mpg.de/software/tarball-archive/Releases/2021.05.002/elpa-2021.05.002.tar.gz tar xzf elpa-2021.05.002.tar.gz cd elpa-2021.05.002 mkdir build && cd build configure CC=mpiicc CXX=mpiicpc FC=mpiifort ../configure --enable-openmp FCFLAGS=\"-qmkl=cluster\" 编译安装 make -j`nproc` make install ln -s /usr/local/include/elpa_openmp-2021.05.002/elpa /usr/local/include/ 注意：ln -s /usr/local/include/elpa_openmp-2021.05.002/elpa /usr/local/include/ 是非常重要的！（很多用户是这里出的问题！） 2.3 编译安装 ABACUS CXX=icpx cmake -B build cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus 可执行文件。 abacus 就是完整版的 ABACUS，它同时支持两种基矢量，而且还是并行版本！ Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-24 10:18:42 "},"abacus-hcp.html":{"url":"abacus-hcp.html","title":"在超算环境编译 ABACUS 的建议","keywords":"","body":"在超算环境编译 ABACUS 的建议 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/26 由于不同超算环境提供的软件包版本各不相同，因此我们没办法提供给您确切的安装方法。 但是，我们将在本篇文档中介绍一些在超算环境中编译安装 ABACUS 的注意事项和相关知识。 如果在具体编译操作过程中遇到了任何问题，请随时联系我们。 一、关于 ABACUS 首先，再次简单介绍一下 ABACUS。ABACUS（原子算筹）软件同时支持两种基矢量，一种是平面波（Plane wave，PW） 基组，一种是 LCAO (Linear combination of atomic orbitals) 或者称 NAO (Numerical atomic orbitals) 基组。 用户可以编译 仅支持 PW 基组的 ABACUS 或者 同时支持两种基组的 ABACUS。同时，针对 PW 基组的 ABACUS，用户还可以选择编译串行版本或并行版本。但因为这个文档的主题是如何在超算环境中编译 ABACUS（应该没有人在超算上跑串行的 ABACUS 吧），我们接下来只会介绍并行版本的编译方法。如果想要在普通的服务器上安装串行版本的 PW 基组的 ABACUS，可以参考 GCC 编译 ABACUS 教程 · GitBook 和 Intel oneAPI 编译 ABACUS 教程 · GitBook。 二、超算平台的简单介绍： 1. 关于 Modules 一般情况下，大多数超算平台是通过 Environment Modules 来管理基础软件库的。 如何使用 Modules？这里提供一些参考的教程：软件模块使用方法 - 上海交大超算平台用户手册 Documentation 2. 超算上编译 ABACUS 的基本路线 在超算平台上编译 ABACUS，同样也有两种选择： 一种是 基于 GCC（the GNU Compiler Collection）编译 一种是 基于 Intel oneAPI 或者 Intel Parallel Studio 编译 不得不说，使用 Intel oneAPI 将会简单很多！因此，如果你所使用的超算平台正好有 Intel oneAPI ，那么请毫不犹豫的使用它！ 2.1 ABACUS 依赖的软件库 C/C++ 编译器：由于 ABACUS 是由 C++ 语言编写的软件，所以一定需要 C++ 编译器。 Fortran 编译器：Fortran 编译器并不直接用于编译 ABACUS 软件，而是需要用其编译 ABACUS 所依赖的数学库：BLAS、LAPACK、ScaLAPACK 和 ELPA。（这四个软件都是使用 Fortran 语言写的，因此需要依赖 Fortran 编译器） MPI 库：如果要编译并行版本的 ABACUS，那么 MPI Library 是必须的。同时也需要注意，如果你选择自己编译 ScaLAPACK 和 ELPA，那么 MPI Library 也是必须的。 数学库： BLAS：BLAS（Basic Linear Algebra Subprograms）是一组基本的线性代数库，用于高效执行常见的基础线性代数运算，如矩阵乘法和向量操作。 LAPACK：LAPACK（Linear Algebra Package）是一个开源的数值线性代数库，用于解决线性代数问题，包括矩阵分解、方程组求解和特征值计算等。 FFTW3：FFTW3（Fastest Fourier Transform in the West 3）是一个高性能、开源的快速傅里叶变换（FFT）库，用于高效计算各种傅里叶变换和逆变换。 ScaLAPACK：ScaLAPACK（Scalable LAPACK）是一种并行计算库，构建在 LAPACK 之上，用于解决大规模线性代数问题，特别适用于分布式和并行计算环境。 ELPA：ELPA（Eigenvalue SoLvers for Petaflop-Applications）是一个用于高性能计算的开源库，旨在解决大规模高性能计算中的特征值问题，特别是密集矩阵的特征值问题。（用户编译安装 abacus 的时候大多在这里出现问题） CEREAL：CEREAL 是一个 C++ 序列化库，用于将 C++ 对象转换为可存储或传输的数据格式，以及将其反序列化回对象。 如果你只编译 仅支持 PW 基组的 ABACUS，那么你不需要安装 ScaLAPACK、ELPA 和 CEREAL。他们是 LCAO 基组才依赖的软件库。 2.2 基于 Intel oneAPI 编译 ABACUS 首先在此介绍一下 Intel oneAPI 和 Intel Parallel Studio 的区别。用户可能在超算平台上同时看到 Intel oneAPI 和 Intel Parallel Studio。这是因为 Intel Parallel Studio 是 oneAPI 的前身，或者说 Intel Parallel Studio 是 oneAPI 的子集。Intel Parallel Studio 在 2020 年已经停止维护，而 Intel oneAPI 却是在 2019 年 11 月正式提出。因此我们可以将 Intel oneAPI 看作是 新版的 Parallel Studio 或加强版。 Intel oneAPI（Intel® oneAPI Toolkits）同时包含 C/C++ 编译器、 Fortran 编译器 和 Intel MPI Library。因此如果加载了 Intel oneAPI 环境，也就不用再次加载其他的 MPI Library。除此之外，Intel oneAPI 还包含了 Intel® oneAPI Math Kernel Library（简称为 MKL），这个软件库里面包含了大量常用的数学库，包括 ABACUS 依赖的 BLAS、LAPACK、FFTW3 和 ScaLAPACK 4 个软件库。 因此，如果你只编译 支持 PW 基组的 ABACUS，那么 Intel oneAPI 就已经可以解决所有的依赖问题。 如果你要编译 同时支持两种基组的 ABACUS，那么还需要手动编译安装 ELPA 和 CEREAL，安装完成后，可以参考官方文档中的 ABACUS-Installation-Options 编译 ABACUS。 注意： 在使用 Intel oneAPI 编译 ABACUS 的时候，并不意味着软件环境中不需要 GCC。 refer：How the Compiler Uses GCC Intel compilers 需要使用 GCC 中的头文件和库。因此同时也需要加载 GCC。 2.3 基于 GCC 编译 ABACUS GCC（the GNU Compiler Collection）它同时包含 C/C++ 编译器和 Fortran 编译器，但其不包含 MPI Library。因此我们还需要额外的 MPI 库（Open MPI 或者 MPICH）。 由于这是基于 GCC 编译 ABACUS，如果用户所使用的超算环境中没有提供 BLAS、LAPACK、FFTW3、ScaLAPACK、ELPA 和 CEREAL 的 modules，那么这些数学库都需要用户一个个手动编译安装。 在安装完成后，可以参考官方文档中的 ABACUS-Installation-Options 编译 ABACUS。 三、拓展教程 1. ABACUS 高级编译选择： Easy Installation ‒ ABACUS documentation Advanced Installation Options ‒ ABACUS documentation 2. 超算平台使用教程推荐： 上海交大超算平台用户手册 中国科大超算中心用户使用手册 北大超算手册 超算小站 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-26 19:08:07 "},"abacus-dcu.html":{"url":"abacus-dcu.html","title":"ABACUS 在曙光 DCU 集群上的编译与使用","keywords":"","body":"ABACUS 在曙光 DCU 集群上的编译与使用 作者：贾志炜，邮箱：jiazhiwei@stu.pku.edu.cn 审核：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 最后更新时间：2023/07/07 一、介绍 本教程旨在介绍 ABACUS 在 曙光 DCU 计算平台 上的编译与使用。 1. DCU DCU (Deep Computing Unit) 是一款面向人工智能、科学计算的高性能全功能 GPGPU (General-Purpose computing on Graphics Processing Units) 加速卡。 中科海光基于 DCU 硬件提供完整的软件工具链，以 DTK(DCU toolkit)为基础软件层为开发者提供运行、编译、调试和性能分析等功能，并提供多种深度优化的计算加速库。DCU 加速卡支持 ROCm/Hip 并行架构。 曙光计算集群采用 CPU 和 DCU 加速卡（Deep Computing Unit）相结合的异构融合计算体系结构。 2. ABACUS 的异构并行计算 INPUT 文件中 device 参数需设置为 gpu。 目前 GPU/DCU 版本的 ABACUS 仅支持 PW 基组的计算，因此 INPUT 文件中 basis_type 参数仅能设置为 pw。 二、准备 1. 曙光计算平台 用户需要在平台上申请异构计算资源： https://ac.sugon.com/doc/1.0.6/30000/general-handbook/platform/source.html 2. E-shell 曙光计算平台采用 E-shell 来对管理节点进行操作。 可使用网页版或 E-Shell Client。 不可直接运行任务，而是使用 Slurm 调度系统。 采用 modules 工具 来管理环境变量与系统依赖项。许多依赖如编译器版本等可以通过 modules 来处理。 3. slurm Slurm 工作调度工具是面向 Linux 和 Unix 及类似内核的免费和开源工作调度程序，可以方便用户进行作业的提交、管理、监测。 sinfo: 查看系统资源。 squeue: 查看当前作业状态。 salloc: 分配节点的作业提交，用 salloc 申请的节点会在当前终端退出时释放掉。用于程序测试以及中小型任务的提交。 sbatch: 批处理模式的作业提交，需要编写 slurm 作业提交脚本。在 E-shell 的默认目录存有 slurm 脚本模板。在下面的流程中也会介绍提交 ABACUS 任务的脚本案例。 srun: 交互式提交作业命令，有屏幕输出，但容易受网络波动影响，断网或关闭窗口会导致作业中断。 三、流程 1. 配置超算环境 module avail # 列出已有环境 module list # 查看当前已加载环境 module load # 加载环境 module unload # 卸载环境 昆山节点 module purge 1) compiler/devtoolset/7.3.1 2) compiler/rocm/dtk-22.10 3) compiler/cmake/3.17.2 4) mpi/hpcx/2.6.0/gcc-7.3.1 乌镇节点 1) compiler/devtoolset/7.3.1 2) compiler/dtk/23.04 3) compiler/cmake/3.23.1 4) mpi/hpcx/gcc-7.3.1 对于使用其他 DCU 节点（合肥、哈尔滨、西安）的用户，如果 module 中没有找到类似的环境，欢迎在 ABACUS 仓库 提出 issue，我们将尽力协助解决。 2. 编译 ABACUS 依赖软件包 目前按照 DCU 版本已验证的编译方法，有三个数学库需要自行编译。 若曙光平台网络连接不畅，请在软件官网选择合适的软件包，再用曙光平台的 E-File 传送至节点。 FFTW: https://fftw.org/pub/fftw/fftw-3.3.10.tar.gz OpenBLAS: https://github.com/xianyi/OpenBLAS/releases/download/v0.3.21/OpenBLAS-0.3.21.tar.gz ScaLAPACK: https://github.com/Reference-ScaLAPACK/scalapack/archive/refs/tags/v2.2.0.tar.gz 2.1 编译 FFTW tar -zxvf fftw-3.3.10.tar.gz mkdir build ./configure --prefix=/work/home/your_username/fftw-3.3.10/build cd ~/fftw-3.3.10/build make make install FFTW 需要编译单精度版本和双精度版本： cd ~/fftw-3.3.10/build ./configure --prefix=/work/home/your_username/fftw-3.3.10/build --enable-float make make install 2.2 编译 OpenBLAS tar -zxvf OpenBLAS-0.3.23.tar.gz cd OpenBLAS-0.3.23 make USE_OPENMP=1 NO_AVX512=1 FC=\"gfortran -fPIC\" CC=\"gcc -fPIC\" -j8 mkdir build make PREFIX=/work/home/your_username/OpenBLAS-0.3.21/build install 2.3 编译 ScaLAPACK cp SLmake.inc.example SLmake.inc 复制包中提供的 SLmake.inc.example 作为基准，并对 SLmake.inc 的内容作出一部分修改: FC = mpif90 -fPIC CC = mpicc -fPIC BLASLIB = LAPACKLIB = -L/work/home/your_username/OpenBLAS-0.3.21/build/lib -lopenblas make 3. 编译 DCU 版本的 ABACUS git clone https://gitee.com/deepmodeling/abacus-develop # main分支 cd abacus-develop mkdir build cd build CMake 配置： 指定编译器为 clang，关闭 OpenMP、LCAO 计算模块，设定三个数学库的位置，设定 USE_ROCM=ON。 CC=clang CXX=clang++ cmake -B build -DUSE_OPENMP=OFF -DENABLE_LCAO=OFF \\ -DFFTW3_DIR=/work/home/your_username/fftw-3.3.10/build/ \\ -DLAPACK_DIR=/work/home/your_username/OpenBLAS-0.3.21/build/lib \\ -DSCALAPACK_DIR=/work/home/your_username/scalapack-2.2.0/ \\ -DUSE_ROCM=ON Make 编译：make 部分建议不要并行编译。 make 4. 提交任务 salloc（中小型任务与交互性程序测试） salloc -p [队列名] -N 1 -n 32 --gres=dcu:4 ... load text ... salloc: Waiting for resource configuration salloc: Nodes node_num are ready for job # 分配计算节点，可用ssh直接连接 ssh node_num ...交互式进行计算任务 sbatch（大型任务与批量提交） 写一个作业提交脚本，可以参考以下结构： #!/bin/bash #SBATCH --job-name=ABACUS_GPU #SBATCH --partition=kshdnormal #SBATCH --nodes=1 #SBATCH --output=output.log #SBATCH --ntasks-per-node=32 #SBATCH --mail-user=username@email #SBATCH --gres=dcu:4 #dcu个数 #SBATCH --time=01:00:00 #SBATCH --error=error.log #以上的SBATCH信息会由slurm识别 abacus=/work/home/your_username/abacus-develop/build/abacus_pw #设置环境 module purge module load compiler/devtoolset/7.3.1 module load compiler/rocm/dtk-22.10 module load compiler/cmake/3.17.2 module load mpi/hpcx/2.11.0/gcc-7.3.1 #运行脚本 cd your_task_path mpirun -np 4 $abacus sbatch abacus_dcu.slurm 作业已提交，可在“作业管理”中查看。 四、结语 DCU 可以提高 ABACUS 计算性能，也充分利用了 ROCm 并行框架，使得 ABACUS 异构计算能应用在更多的平台上。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-04 10:08:19 "},"abacus-upf.html":{"url":"abacus-upf.html","title":"模守恒赝势生成方法简介","keywords":"","body":"模守恒赝势生成方法简介 作者：陈涛，邮箱：chentao@stu.pku.edu.cn；刘千锐，邮箱：terry_liu@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/30 一、介绍 UPF（unified PP format）是一种类似 XML 格式的文件格式，用于存储赝势及其相关参数。该格式由 Quantum ESPRESSO（QE）团队开发，并已成为许多量子计算软件包的标准格式之一。 ABACUS（截至 v3.2.3）的 Kohn-Sham 密度泛函理论计算主要支持 UPF 格式的模守恒赝势，在使用 ABACUS 过程中，一般可以直接使用网上已经生成好的赝势，常见的下载位置： ABACUS 官网 SG15-ONCV，参考文献：Optimization algorithm for the generation of ONCV pseudopotentials Quantum ESPRESSO 官网中的模守恒赝势 pseudo-dojo 官网（psp8 格式，需要转换） PWmat 官网 但是，在实际计算中，可能这些赝势并不符合当前的需求，这时候就需要自己生成模守恒赝势。可以通过其他格式赝势转换或者利用赝势软件生成两种方式来获得赝势。 注：ABACUS 的无轨道密度泛函理论计算（Orbital-Free Density Functional Theory，简称 OFDFT）需要用到一种特殊的局域势（不包含非局域势），一般采用 BLPS 局域赝势文件而非上文提到的 UPF 文件，如果做 OFDFT 计算的，可以阅读介绍 OFDFT 计算的文档，或者登录 Emily A. Carter 教授主页寻找相关的信息。 二、从其他格式赝势转换 1. 使用 QE upflib 中的 upfconv 进行转换 其支持将 UPF v.1 格式、vdb/van 格式（Vanderbilt US pseudopotential）、cpi/fhi 格式（FHI/abinit）转化成 UPF v.2 格式 path_to_QE/upflib/upfconv.x -u *.upf/UPF/vdb/van/cpi/fhi 注：这里的 path_to_QE 代表下载的 Quantum Espresso 的软件包地址。 注：文件夹 upflib 在 QE 5.x 和 6.x 版本名称为 upftools，在QE 7.x 版本为 upflib。 2. psp8 格式转换 psp8 格式是 ONCVPSP 软件生成的一种赝势格式，在 Abinit 官网（pseudo-dojo）中，其使用的就是 psp8 的格式，目前没有直接将 psp8 格式的赝势直接转换成 UPF 格式的脚本，但可以将 psp8 中输入文件部分摘抄下来，用 ONCVPSP 软件重新生成 UPF 格式的赝势（具体生成见下面 ONCVPSP 的讲解）。 可供参考的批量处理脚本：https://github.com/pipidog/ONCVPSP 三、赝势的生成 下面介绍三个可以生成 UPF 模守恒赝势的软件，分别是 ONCVPSP，Opium，和 ld1.x 1 ONCVPSP 1.1 介绍 ONCVPSP（Optimized Norm-Conservinng Vanderbilt PSeudoPotential）是由 D.R. Hamann 等人提出的优化版模守恒赝势，其有更高的精度与效率。ONCVPSP 依赖 Libxc，支持多种交换关联泛函。 参考文献：Optimized norm-conserving Vanderbilt pseudopotentials。 1.2 安装 1.2.1 安装 Libxc Libxc 网址：Libxc - a library of exchange-correlation functionals for density-functional theory 推荐下载 libxc-4.3.4 然后执行如下命令： cd libxc-4.3.4 ./configure --prefix='PATH/TO/LIBXC' CC=icc FC=ifort make make install 命令执行完毕后即可在 PATH/TO/LIBXC 目录下看到 bin,include 和 lib 三个目录，代表安装成功 1.2.2 安装 oncvpsp 推荐下载 oncvpsp-4.0.1 然后执行 cd oncvpsp-4.0.1，进入文件夹 这时需要修改 make.inc 文件 修改 F77 = ifort, F90 = ifort, CC = icc FFLAGS 删去 -ffast-math LIBS 改为 -qmkl=\"sequential\" LIBS+ 和 FFLAGS 中的地址改为自己的 PATH/TO/LIBXC 具体如下： # System-dependent makefile options for ONCVPSP # This must be carefully edited before executing \"make\" in src # # Copyright （c） 1989-2019 by D. R. Hamann, Mat-Sim Research LLC and Rutgers # University ##### Edit the following lines to correspond to your compilers #### F77 = ifort F90 = ifort CC = icc FCCPP = cpp FLINKER = $（F90） #FCCPPFLAGS = -ansi -DLIBXC_VERSION=301 #Use this for versions 400 ##### Edit the following optimization flags for your system #### FFLAGS = -O3 -funroll-loops CFLAGS = -O3 ##### Edit the following LAPACK and BLAS library paths for your system #### LIBS = -qmkl=\"sequential\" ##### Edit the following for to use libxc if available ##### OBJS_LIBXC = exc_libxc_stub.o # oncvpsp is compatible with libxc # To build oncvpsp with libxc, uncomment the e following lines and edit # the paths to point to your libxc library and include directories # make clean in src before rebuilding after changing this LIBS += -L/PATH/TO/LIBXC/lib -lxcf90 -lxc FFLAGS += -I/PATH/TO/LIBXC/include #LIBS += -L/home/drh/abinit/fallbacks/exports/lib -lxcf90 -lxc #FFLAGS += -I/home/drh/abinit/fallbacks/exports/include OBJS_LIBXC = functionals.o exc_libxc.o 然后执行如下命令： make # 如果make -j报错，可以忽略再make，即可编译成功 安装测试完成后，即可在 src 目录下看到 oncvpsp.x 可以在 ~/.bashrc 中增加如下命令将 oncvpsp.x 加入环境变量，方便直接调用： export PATH=$PATH:/PATH/TO/ONCVPSP/src 1.3 输入文件 输入文件的准备可以参考 PATH_TO_ONCVPSP/doc/32_Ge_annotated.dat，或者参考已知 ONCV 的赝势里面的 部分来写。 这里以铝（Al）为例，输入文件 Al.dat: # ATOM AND REFERENCE CONFIGURATION # atsym, z, nc, nv, iexc psfile Al 13 1 4 4 upf # # n, l, f （nc+nv lines） 1 0 2 2 0 2 2 1 6 3 0 2 3 1 1 # # PSEUDOPOTENTIAL AND OPTIMIZATION # lmax 1 # # l, rc, ep, ncon, nbas, qcut （lmax+1 lines, l's must be in order） 0 1.29163 0 5 8 10.3003 1 2.40653 0 5 8 7.02214 # # LOCAL POTENTIAL # lloc, lpopt, rc（5）, dvloc0 4 5 0.932267 0 # # VANDERBILT-KLEINMAN-BYLANDER PROJECTORs # l, nproj, debl （lmax+1 lines, l's in order） 0 2 0 1 2 0 # # MODEL CORE CHARGE # icmod, fcfact 0 0 # # LOG DERIVATIVE ANALYSIS # epsh1, epsh2, depsh -5.0 3.0 0.02 # # OUTPUT GRID # rlmax, drl 6.0 0.01 # # TEST CONFIGURATIONS # ncnf 0 # nvcnf # n l f 一些可以调整的参数如下： nc：c = core，芯电子层数 nv：v = valence，价电子层数，调整 nc 和 nv 可以改变赝势的价电子数 iexc：生成赝势所用的交换关联泛函，详情可参考 ONCVPSP-4.0.1 目录下 doc 内的 pwscf_exc.txt 文件，常用的如下 iexc==3 .or. iexc==-001009, 'functional=\"PZ\"' iexc==4 .or. iexc==-101130, 'functional=\"PBE\"' psfile：赝势格式，有 upf 和 psp8 两种。ABACUS 支持 upf 的格式 rc: rc 中较小的为赝势的截断半径。在温度较高或密度较大的温稠密体系，通常需要调整赝势的截断半径，推荐小于 0.7 倍维格纳半径，单位为 Bohr；每个 l 对应一个 rc，其中最小的为赝势的截断半径 rc（5）：rc 都要大于等于 rc（5）。例如 Al 的 l=0 的 rc 为 1.29163 Bohr，l=1 的 rc 为 2.40653 Bohr，rc（5） 为 0.932267 Bohr，因此该赝势的截断半径为 1.29163 Bohr。 qcut：通过调整（+-0.1），直到推荐 ECUT 达到最小 dvloc0：通过调整（+-0.5），直到消除赝势的 GHOST 态（可参考文献 Phys. Rev. B 41, 12264 (1990)） 1.4 生成赝势 执行命令： oncvpsp.x Al.out sed -n '//,//p' Al.out > Al.UPF 生成完赝势需要查看 Al.out 文件，确定没有 GHOST 态（可参考文献 Phys. Rev. B 41, 12264 (1990)）： Testing for highly-localized positive-energy ghosts l \\/rc E Basis Diag. E Cutoff 1 0.974041 120.256772 338.98 WARNING - GHOST（+） 如上，出现 WARNING - GHOST 说明有 GHOST，需要调整 dvloc0 （+-0.5）直到消除 GHOST 态 sed 命令是为了从 Al.out 文件中截取赝势文件到 Al.UPF 中 如果同时要画出类似 Phys. Rev. B 88, 085117 (2013) 的图，需要准备输入文件 Al.dat 并执行命令： sh PATH_TO_ONCVPSP/scripts/run.sh Al 可以画出如下的图： 图 1. 局域势函数与非局域势不同轨道角动量对应的半局域径向势函数 图 2. S赝波函数与全电子波函数对比 图 3. S的双投影波函数 图 4. 不同能级波函数在截断半径处log导数对比，其影响散射性质的计算 图 5. 不同轨道角动量对应的截断能 1.5 优化赝势 依次调节不同 l 对应的 qcut（+-0.1），检查对应 ECUT（l） 变化情况，直到 ECUT（l） 达到最小 参考的脚本： !/bin/bash qcut=17 dq=0.1 #遍历l=0的qcut从17到25，间隔为0.1，输出其对应的ECUT while [ `echo \"$qcut test.dat qcut$qcut.out grep -A 5 \"Energy error\" qcut$qcut.out > _tmp.txt E1=`sed -n \"6p\" _tmp.txt | awk '{print $3}'` E2=`sed -n \"13p\" _tmp.txt | awk '{print $3}'` E3=`sed -n \"20p\" _tmp.txt | awk '{print $3}'` E4=`sed -n \"27p\" _tmp.txt | awk '{print $3}'` # echo $qcut $E1 $E2 $E3 $E4 if [ `echo \"$E1>$E2\" | bc` == '1' ] ;then Emax1=$E1 else Emax1=$E2 fi if [ `echo \"$E3>$E4\" | bc` == '1' ];then Emax2=$E3 else Emax2=$E4 fi echo $qcut $Emax1 $Emax2 qcut=`echo \"$qcut+$dq\" | bc` done 不同的 l 都会有对应的能量截断值 ECUT(l)。一般 rc(l) 越小，对应的 ECUT(l) 越大，赝势也就越精确。由于 DFT 计算中的截断能 ECUT 是由赝势中较大的那个 ECUT(l) 决定，如果不同 l 的 ECUT(l) 相差很大，可以适当减小较小的 ECUT（l） 对应 l 的截断半径 rc，使得不同 l 对应的 ECUT(l) 更接近，这样并不会增加赝势计算的 ECUT，却可以提升精度。 这样调完之后如果有 GHOST 态，需要调整 dvloc0 （+-0.5）直到消除 GHOST 态，这个赝势才可使用 2. Opium Opium 软件包可以生成 RRKJ、TM 或 Kerker 径向波函数的赝势，官网有 LDA、GGA 赝势库（但是某些输入文件已经不匹配最新的 4.1 版本，需要稍作修改） 下载 Opium 之后利用 configure 安装： ./configure make 输入文件可以参考官网 LDA、GGA 赝势库，也可以参考 PATH_TO_OPIUM/tests，这里以铝（Al）为例，输入文件 al.param: [Atom] Al 6 100 2.00 -13.0 # reference configuration 200 2.00 -1.4 # reference configuration 210 6.00 -0.4 # reference configuration 300 2.00 -0.1 # reference configuration 310 0.95 -13.0 # reference configuration 320 -1.0 -0.0 # 这条能带是非束缚态，需要将占据数调成负数，官网给错了 [Pseudo] 3 1.85 1.85 1.97 opt [Optinfo] 7.07 10 # rc[a.u.] qc[sqrt（Ry）] Nb 7.07 10 7.07 10 [Configs] 3 # number of valence configurations # 300 2.00 -13.0 # nlm occ eigen（- means auto-generate） 310 1.00 -6.0 320 0.00 -6.0 # 300 1.00 -13.0 310 2.00 -6.0 320 0.00 -6.0 # 300 2.00 -13.0 310 0.00 -6.0 320 0.00 -6.0 [XC] gga [Relativity] srl 这里的参数可以参考官网手册 之后执行 opium al log all #输出在log文件里，依次执行全电子计算、计算赝势、计算非局域势、可移植性测试 opium al log upf #生成al.upf的输出文件 upfconv.x -u al.upf #利用QE的upflib将UPFv.1转化成UPFv.2格式 3. ld1.x QE 的 atomic 模块中的 ld1.x 支持生成赝势。其不仅可以生成模守恒赝势、还支持超软赝势、PAW 方法，支持全相对论、标量（非）相对论赝势（rel, non-rel/sca-rel），其径向波函数支持 TM（更稳定）与 RRKJ 两种方法，支持交换关联近似 7 类 LDA（ pz）,GGA（pbe, pbesol, revpbe, bp, wc, pw91。 下载好 QE 软件后，可以直接安装： ./configure make ld1 3.1 pslibrary 赝势库 推荐 ld1.x 生成其自带的 pslibrary 赝势库，下载好 pslibrary.1.0.0.tar.gz，解压，进入文件夹，修改 QE_path 文件，指定 QE 的路径。然后打开 make_ps 文件，解锁相应赝势： # These two files generate PAW and US PPs for all elements. These are # high accuracy - high kinetic energy cut-off PPs. # . ../paw_ps_high.job #默认打开的 . ../us_ps_high.job # # These two files generate additional PAW and US PPs for some elements. # These are less accurate PP than the previous one but require # lower kinetic energy cut-off or have less projectors or less semicore # states. # . ../paw_ps_low.job . ../us_ps_low.job # Uncomment the following line to generate the old pslibrary 0.3.1 PPs. # 打开下面的注释，可以解锁其余赝势 # #. ../paw_ps_collection.job #可以打开注释 #. ../us_ps_collection.job #可以打开注释 # Uncomment the following line to generate the NC-PPs. Be very careful # these PPs are completely untested. # 虽然可以生成，但其也提示该赝势的准确性并不能保证 # #. ../nc_ps_collection.job #可以打开注释 下面运行 ./make_all_ps 就能看到在一个个生成赝势库里的赝势： Making Ac.pz-spfn-kjpaw_psl.1.0.0.in ... Done Making Ac.pz-spfn-rrkjus_psl.1.0.0.in ... Done Making Ag.pz-n-kjpaw_psl.1.0.0.in ... Done Making Ag.pz-n-rrkjus_psl.1.0.0.in ... Done Making Ag.pz-spn-kjpaw_psl.1.0.0.in ... Done Making Ag.pz-spn-rrkjus_psl.1.0.0.in ... Done Making Al.pz-n-kjpaw_psl.1.0.0.in ... Done Making Al.pz-n-rrkjus_psl.1.0.0.in ... Done Making Al.pz-nl-kjpaw_psl.1.0.0.in ... Done Making Al.pz-nl-rrkjus_psl.1.0.0.in ... Done 如果不想生成所有的元素的赝势，则可以修改 make_ps 的 element，例如： element='C Si Ge' 3.2 生成自己的赝势 参数的详细解释见 PATH_TO_QE/atomic/Doc/INPUT_LD1.html 或线上的文档（不是最新的，建议前者），输入文件可以参考 pslibrary 赝势库的例子。 这里就简单给个 Al（铝）的例子，准备输入文件 al.in： &input title='Al', zed=13.0, rel=1, config='[Ne] 3s2 3p1 3d-2.0 4f-2.0', iswitch=3, dft='PBE' / &inputp pseudotype=2, file_pseudopw='Al.pbe-n-nc.UPF', #输入赝势 lloc=2, nlcc=.true., tm=.true. / 3 3S 1 0 2.00 0.00 2.60 2.60 0.0 3P 2 1 1.00 0.00 2.60 2.60 0.0 3D 3 2 0.00 0.10 2.60 2.60 0.0 运行 ld1.x 即可生成 Al.pbe-n-nc.UPF 模守恒赝势。 四、结尾 ABACUS 使用的是模守恒赝势，基于模守恒赝势还可以产生数值原子轨道，进行基于数值原子轨道的高效率密度泛函理论计算。有些情况下，网上提供的赝势不能满足需求，这个时候赝势的生成需要对赝势理论有比较深入的了解之后，才能调整好相关参数，生成质量较好的赝势。此外，生成之后，应该经过较为充分的测试，才能保证赝势的可移植性和正确性。如果大家有任何问题，欢迎发 email 至文档开头的邮箱。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-20 16:24:10 "},"abacus-nac1.html":{"url":"abacus-nac1.html","title":"数值原子轨道（一）：ABACUS 中的数值原子轨道命名和使用方法","keywords":"","body":"数值原子轨道（一）：ABACUS 中的数值原子轨道命名和使用方法 作者：梁馨元，邮箱：2201111875@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/07/18 一、数值原子轨道的背景知识 1. 数值原子轨道 对电子结构的求解可以在不同的表象下进行，电子的波函数以及势函数也可以在不同基矢量下表示，常用的有平面波和局域轨道等。LCAO（Linear Combination of Atomic Orbitals）方法就是通过局域的原子轨道来求解量子力学问题。其中局域轨道的选取方式有多种，例如高斯轨道（Gaussian type Orbitals，GTOs 或 Gaussians）、数值原子轨道（Numerical Atomic Orbitals）、万尼尔函数（Wannier Functions）等。 2. 数值原子轨道作为基矢量的优点 数值原子轨道作为基矢量有几个优点：第一，基矢量个数相比于一些常用的基矢量（例如平面波和实空间网格）大幅度降低；第二，数值原子轨道是局域的，空间上可以严格截断，采用数值原子轨道来构建体系的哈密顿量的效率可以达到线性标度的时间复杂度。 3. 构造数值原子轨道基组的几种方案 构造精度高、可系统提升数量、可移植性好的原子轨道基组颇有挑战，因此也有多种方案被提出。例如，Junquera 等人提出在一维薛定谔方程中加入不同形式的约束势场，从而求解出具有严格截断的数值原子轨道[1]。Ozaki 在 OpenMX 软件中采用变分的方法来优化局域轨道的形状，从而得出一组最优的数值原子轨道[2]。Volker 等人提出在一个大的局域轨道基组中挑选最合适的局域轨道组成不同等级的基组轨道，该方案用于全电子密度泛函理论软件 FHI-aims 中[3]。Chen 等人提出利用前人提出的溢出函数（Spillage function）[4-5]来构造可系统提高数量的数值原子轨道，其中每个轨道都由一组球贝塞尔函数作为基矢量展开，该轨道被用在 ABACUS（原子算筹）软件中[6]。 二、数值原子轨道的命名方法 1. 数值原子轨道的组成 数值原子轨道（Numerical Atomic Orbitals，简称 NAO）是目前在 ABACUS 程序中支持的一种基矢量。从数学形式上来看，数值原子轨道可以分解为径向函数 flζ 和球谐函数 Ylm 的乘积。 \\phi_{l m \\zeta}(\\mathbf{r})=f_{l \\zeta}(r) Y_{l m}(\\hat{r}), 其中 l 是角量子数，m 是磁量子数，ζ 代表了每个角量子数上对应的多个径向轨道，实际计算中通常采用多于 1 个轨道来增加基矢量的完备性。 2. 数值原子轨道的命名方法 数值原子轨道有一套常用的命名方案用来表示选取的基组大小，早期该命名方案在 SIESTA 软件中被采用[7][8][9][10]，后来在 OpenMX、FHI-aims 和 ABACUS 中也采取这套命名方案。具体来说是，对于每个被电子占据的角量子数 l，若采用 1 条径向轨道，则称该基组为 Single-ζ 轨道，简称 SZ 轨道基组。若采用 2 条径向轨道，则称该基组为 Double-ζ 轨道，简称 DZ 轨道基组。 目前，在许多赝势结合数值原子轨道的程序里，通常会在 DZ 轨道的基础上引入 1 条极化（polar）的径向轨道，即角量子数更高的轨道，来组成 DZP（Double-ζ valence orbitals plus SZ polarization） 轨道基组。此外，还有基组数量更大的 TZDP（Triple-ζ valence orbitals plus DZ polarization） 轨道等。 3. 数值原子轨道基组的个数 数值原子轨道基组的具体个数除了取决于轨道类别（比如 SZ、DZP、TZDP）外，也取决于元素种类、所选取的赝势。 轨道类别：比如对于 O 元素的赝势而言，一般将两个 1s 电子作为核内电子，在构造赝势的时候只考虑它的外层 6 个价电子部分 2s、2p 轨道，则该 O 赝势下的电子的极化轨道为 d 轨道。故它的 SZ（Single-ζ）轨道包含 1 组 s 轨道、1 组 p 轨道，共 1*1+1*3=4 个轨道；DZP 轨道包含 2 组 s 轨道、2 组 p 轨道、1 组 d 轨道，共包含 2*1+2*3+1*5=13 个轨道；TZDP 轨道包含 3 组 s 轨道、3 组 p 轨道、2 组 d 轨道，共包含 3*1+3*3+2*5=22 个轨道。 元素种类：比如同为 DZP 轨道，对于 H 元素（1 个价电子）即为 2 组 s 轨道、1 组 p 轨道（p 轨道也是 H 的极化轨道），共包含 2*1+1*3=5 个轨道。对于 O 元素即为 2 组 s 轨道、2 组 p 轨道、1 组 d 轨道，共包含 2*1+2*3+1*5=13 个轨道。 赝势：比如对于 Fe 元素而言，同为 DZP 轨道。若选取的赝势为，[Ne]3s^23p^64s^23d^6，即[Ne]=1s^22s^22p^6部分为芯电子，3s^23p^64s^23d^6部分为 16 个价电子，则 DZP 轨道包含 2*2 套 s 轨道（3s 和 4s）、2 套 p 轨道（3p）、2 套 d 轨道（3d）、1 套 f 轨道（极化轨道），即每个原子的 DZP 数值原子轨道个数为 2*2*1+2*3+2*5+1*7=27 个轨道。若选取的赝势为[Ar]4s^23d^6，则 DZP 轨道包含 2 套 s 轨道、2 套 d 轨道、1 套 p 轨道，共 2*1+2*5+1*3=15 个轨道。 三、ABACUS 中数值原子轨道的使用方法 1. ABACUS 中的数值原子轨道文件 ABACUS 提供了已经生成好的数值原子轨道库打包文件供下载（官网下载链接），对于绝大多数计算任务，这些数值原子轨道是经过精度和可靠性验证，可以直接使用的。这些轨道文件的开头提供了关于该轨道的重要信息。以 O_gga_7au_100Ry_2s2p1d.orb 轨道文件为例，首先文件名包含的信息有：氧元素（o），GGA 泛函（gga），数值原子轨道截断半径（7au，即 7 Bohr），推荐能量截断值（100 Ry），数值原子轨道个数（2s2p1d，2 个 s 的径向轨道，2 个 p 的径向轨道，1 个 d 的径向轨道）。值得注意的三个点是： ABACUS 里用到的模守恒赝势和轨道是需要匹配的。因为不同的赝势可能有不同的价电子，而数值原子轨道是用来描述这些价电子的，如果赝势的价电子多，则相应的默认数值原子轨道基组数量也会增多。 推荐用户直接使用轨道文件包含的能量截断值做计算。ABACUS 里的数值原子轨道在生成时，是尽量的去匹配平面波输出的波函数，从而优化得到的。而平面波计算是有一个能量截断值的，因此为了尽可能的保证 LCAO 的精度，我们建议直接使用推荐的能量截断值，而不需要真正做计算的时候做体系能量随着能量截断值变化的收敛性测试。当你在 LCAO 计算时改变能量截断值时候，其实只是改变了平面波的个数，这些平面波是用来做一些数值计算的，本质上并没有改变基矢量的个数，而基矢量的个数增加是靠改变基组大小，例如 DZP 到 TZDP 来实现的。 特殊情况可以自己生成数值原子轨道。如果用户有自己特殊的赝势，或者对目前提供的原子轨道的参数或者个数感觉不满意，例如对于导带的描述能力较差，也可以自己生成数值原子轨道，具体生成的方法可以参考这个系列文档的第二和第三篇。 打开以上提到的氧的数值原子轨道文件，文件的开头如下： --------------------------------------------------------------------------- Element O Energy Cutoff(Ry) 100 Radius Cutoff(a.u.) 7 Lmax 2 Number of Sorbital--> 2 Number of Porbital--> 2 Number of Dorbital--> 1 --------------------------------------------------------------------------- SUMMARY END 这里包括元素种类（Element），生成轨道时指定的截断能量值（Energy Cutoff）、截断半径（Radius Cutoff），最大角量子数（Lmax）及各角量子数轨道的个数（Number of * orbital，*为 S、P、D 等轨道角动量）。根据这些信息可以知道该轨道的类别，比如该举例文件即包含 O 的 DZP 轨道。 上述 ABACUS 提供的数值原子轨道文件中，在取名中即包含文件开头的重要信息，包括各角量子数的轨道个数。由这些轨道的文件名即可判断轨道类型。 轨道文件中包含的后续内容为不同类型、不同角量子数（L）的多个径向数值原子轨道（即不同 N）的具体数据，目前轨道是存在均匀格点上的，之后有可能也会支持非均匀格点。 2. 如何选择数值原子轨道文件 用户需要根据精度要求，选择数值原子轨道合适的截断能量值、截断半径及轨道类型。截断能量值、截断半径越大，轨道类型提升（SZ、DZP、TZDP），精度越高，结果更接近平面波。注意对于不同元素，要达到同样的精度，以上数值设置并不一定相同。 3. 如何修改数值原子轨道文件的设置，获得低精度轨道类型文件 在 ABACUS 中生成数值原子轨道文件时，可以设置同时生成多种精度的轨道文件，即设置 SIAB_INPUT 文件中的参数 Save Orbitals，详见篇目（三）。 如果已有一份数值原子轨道文件，但希望直接用此文件进行低精度计算，比如希望使用 DZP 轨道文件进行 SZ 计算。可以修改文件开头的信息实现，具体是 Lmax 及各角量子数轨道个数，将这些参数调整到低精度计算对应的数值。文件的后续内容不需要做更改。 比如对于 O 元素而言，DZP 轨道文件参数如 3.1 所示，若要进行 SZ 基矢量的计算，则将 Lmax 设置为 1，Number of Sorbital/Porbital/Dorbital=1/1/0 即可。 四、参考文献 [1] J. Junquera, Ó. Paz, D. Sánchez-Portal, and E. Artacho, Numerical Atomic Orbitals for Linear-Scaling Calculations, Phys. Rev. B, 64, 235111 (2001). [2] T. Ozaki, Variationally Optimized Atomic Orbitals for Large-Scale Electronic Structures, Phys. Rev. B, 67, 155108 (2003). [3] V. Blum, R. Gehrke, F. Hanke, P. Havu, V. Havu, X. Ren, K. Reuter, and M. Scheffler, Ab Initio Molecular Simulations with Numeric Atom-Centered Orbitals, Comput. Phys. Commun., 180, 2175 (2009). [4] M. Chen, G.-C. Guo, and L. He, Systematically Improvable Optimized Atomic Basis Sets for Ab Initio Calculations, J. Phys.: Condens. Matter, 22, 445501 (2010). [5] M. Chen, G.-C. Guo, and L. He, Electronic Structure Interpolation via Atomic Orbitals, J. Phys.: Condens. Matter, 23, 325501 (2011). [6] Liu Xiao-Hui et al., Introduction to first-principles simulation package ABACUS based on systematically improvable atomic orbitals, Acta Phys. Sin., 64, 187104 (2015). [7] Sánchez‐Portal D, Ordejon P, Artacho E, et al. Density‐functional method for very large systems with LCAO basis sets, J. International Journal of Quantum Chemistry, 65, 453-461 (1997). [8] Artacho E, Sánchez‐Portal D, Ordejón P, et al. Linear‐scaling ab‐initio calculations for large and complex systems, J. Physica Status Solidi (b), 215, 809-817 (1999). [9] Junquera J, Paz Ó, Sánchez-Portal D, et al. Numerical atomic orbitals for linear-scaling calculations, J. Physical Review B, 64, 235111 (2001). [10] Soler J M, Artacho E, Gale J D, et al. The SIESTA method for ab initio order-N materials simulation, J. Phys.: Condens. Matter, 14, 2475 (2002). Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 16:22:24 "},"abacus-nac2.html":{"url":"abacus-nac2.html","title":"数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道","keywords":"","body":"数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/15 在Bohrium Notebook上快速学习： 一、ABACUS 中的数值原子轨道背景知识 1. 数值原子轨道 ABACUS 中的三维数值原子轨道[1]：可以分解为径向部分与角向球谐函数的乘积，即 \\phi_\\mu(\\mathbf{r})=f_{\\mu, l}(\\mathbf{r}) Y_{l m}(\\hat{r}), 其中 \\mu=\\{\\alpha,i,\\xi,l,m\\}，\\alpha是原子种类的指标，i是每个原子种类对应的原子个数的指标，\\xi是角动量l对应的径向函数的个数，m是磁量子数。 径向部分函数：第 \\mu个轨道的径向部分函数可以写为球贝塞尔函数的线性组合(可参考文献[1]) f_{\\mu l}(\\mathbf{r})= \\begin{cases}\\sum_q c_{\\mu q} j_l(q r), & r 其中 j_l(q r)是波矢为q的球贝塞尔函数，r_c是径向部分的截断半径，满足关系j_l(q r_c)=0。q的个数由能量截断值决定（以下会介绍）。在实际计算里，通过用户指定每种元素的数值原子轨道截断半径和能量截断值来确定需要用到多少个球贝塞尔函数。组合系数 c_{\\mu q}是可优化的量，决定了数值原子轨道的形状。 2. 参考体系 参考系统：在ABACUS中构造某个元素对应的数值原子轨道的最普遍方式是为每个元素选取一组参考体系做平面波计算（可以是单k点也可以是多k点），得到这些参考体系的电子波函数，然后通过最小化自定义的一个溢出函数（下面会介绍）来优化c_{\\mu q}系数。换句话说，我们需要选定一组参考系统，生成数值原子轨道基组，并期望它们有良好的迁移性，以便可以在更一般的情况下使用。 Dimer（二聚体）：我们发现二聚体是较为合适的参考系统。具体来说，推荐选择的是若干个不同键长的二聚体（dimer），有时也可选择三聚体（trimer）或四聚体。对同一个元素，我们通常选择几个键长不同的二聚体（例如5-6个），这些键长覆盖二聚体稳定键长附近能量区间，通常可以取与最稳定能量差别为1-2个eV的能量曲线上的点。 周期性体系：数值原子轨道还有一些特殊用途，例如能带插值。面对这种场景，可以选择一系列带多个k点的周期性体系，此时参考态中的每个原子构型就对应了不同k点指标和不同能带指标的波函数，这些波函数会被用于最小化溢出函数来生成数值原子轨道，可以参考文献[2]。 3. 溢出函数 溢出函数（英文为spillage）：由给定参考体系的多个电子波函数与生成的数值原子轨道之间的差别来定义。换个角度理解，溢出函数的大小反映的是由一组“精确”波函数所张成的希尔伯特空间与局域轨道所张成的空间的差别。溢出函数定义如下： \\mathcal{S}=\\frac{1}{N_n} \\sum_{n=1}^{N_n}\\left\\langle\\Psi_n|1-\\hat{P}| \\Psi_n\\right\\rangle, 其中\\Psi_n表示平面波基组下的本征态，N_n是选定的参考电子态的个数，\\hat{P}是由所有原子轨道张成的投影子 \\hat{P}=\\sum_{\\mu v}\\left|\\phi_\\mu\\right\\rangle S_{\\mu v}^{-1}\\left\\langle\\phi_v\\right| \\text, 其中S_{\\mu v}=\\left\\langle\\phi_\\mu \\mid \\phi_v\\right\\rangle是局域轨道\\phi_\\mu与\\phi_v之间的重叠矩阵，投影子用到了重叠矩阵的逆。 轨道正交：事实上，如果我们有了给定的数值原子轨道，我们可以在此基础上再次定义新的溢出函数来得到一组新的数值原子轨道，这也是为什么该算法可以系统性的增加数值原子轨道的原因。定义的方式也比较直接，可以将|\\Psi_n\\rangle和已有原子轨道形成的投影子\\hat{P}正交，公式为 |\\Psi_n^{new}\\rangle=（1-\\hat{P}）|\\Psi_n\\rangle, 这个公式里，左边的波函数经过正交已经不包含原子轨道的成分，这样可以再次作为新的参考体系波函数生成新的数值原子轨道，以上算法已经被实现在SIAB这个程序里。 最小化溢出函数：优化原子轨道时，最终溢出函数值定义为选定的几个二聚体的平均溢出函数值。溢出函数可以用来评估获得的原子轨道基组的质量，溢出函数越小，则原子轨道所张成的空间越接近于参考态波函数。在ABACUS中，通过最小化溢出函数的方式来优化c_{\\mu q}，该系数决定了原子轨道的径向函数的形状。这种方法的好处在于 轨道形状可调：可以由球贝塞尔函数基组的线性组合自动生成，而不需要任何先决条件，因此原则上可获得完全优化的原子轨道。 基组数量可调：可以用统一的方式系统的增加轨道数量，包括增加径向轨道的数量（multi-ζ）和增加更高角动量的轨道（极化轨道）两种方式。为此，我们可以首先生成具有给定角动量的轨道，然后更高级的轨道可以使用相同的程序生成，但是此时只需最小化剩余的希尔伯特空间中的溢出函数，该空间与所有先前生成的原子轨道所张成的空间正交。 参考系统可调：通过选择参考系统及对应能级，可以提高原子轨道基组在不同环境的可迁移性。例如，对于涉及到激发态能级的计算，往往需要在生成数值原子轨道的时候，考虑这组轨道对于非占据态能级的拟合能力，这个时候可以在生成参考体系的时候加入一定数量的非占据能级。 4. 模拟退火算法SA（Simulated Annealing） 我们首先介绍模拟退火法Simulated Annealing（SA）来最小化溢出函数[1]，从而优化球贝塞尔函数的系数c_{\\mu q}。在模拟退火算法中我们用的是Metropolis的算法，需要设置一个初始温度，并且指定温度下降的方式。代码部分我们之后会介绍，这里先简要介绍一下算法。 初始系数：如果没有特别指定，一开始的系数c_{\\mu q}是随机产生的， 每一步SA会更新其中一个系数，当溢出函数被改变的数值在允许接收的范围内时，参数c_{\\mu q}会被更新。 优化过程：当要优化的所有轨道的所有参数c_{\\mu q}都被更新过一次之后，我们称为一步优化。 我们发现大约在每个温度行走500 ~ 1000步就已经足够产生好的原子轨道。最开始的温度我们一般取为1.0e-5，事实上我们发现即便初始温度取得更小，最后的结果也是不错的。 在每一步优化之后，我们将温度乘上一个比率，来达到降温的目的从而得到新的温度，这个参数我们一般取为0.5~0.8，最后的温度一般降到1.0e-9~1.0e-12。接收的概率可以控制在0.2~0.4范围内。 能量截断值：这里的能量截断值实际上是能量截断值，我们知道每个平面波 e^{i\\mathbf{q}\\cdot\\mathbf{r}}都对应一个二阶求导后的动能q^2/2。同样的，每个球贝塞尔函数 j_l(q r)也有一个对应的动能是 q^2/2。在平面波计算里我们通过能量截断值来控制平面波的数量，从而控制计算精度。在生成数值原子轨道的时候，我们也通过能量截断值来控制球贝塞尔函数的个数，从而控制生成的数值原子轨道的精度。 对于ABACUS的平面波计算和产生球贝塞尔函数 j_l(q r)个数的计算，我们建议采用同样的能量截断值，该截断值取得越高，基矢量个数越多同时基组也越完备。对于采用赝势的平面波计算，15~30个球贝塞尔函数已经足够得到质量比较高的数值原子轨道。 数值原子轨道的二阶可导：除了以上操作之外，还有一个需要注意到的地方。为了使数值原子轨道的动能积分是良定义的，需要使原子轨道的二阶导数连续。这可以通过将原子轨道的径向部分乘以一个平滑函数g(r)来实现 g(r)=1-\\exp \\left[-\\frac{\\left(r-r_{\\mathrm{c}}\\right)^2}{2 \\sigma^2}\\right], 该径向轨道会在数值原子轨道的截断值以内起作用，使其在截断值处2阶连续，超过阶段半径之后就严格截断。在我们的测试中，我们发现参数\\sigma对轨道的质量影响不大，所以我们一般固定\\sigma为常数0.1。 数值原子轨道动能和再次使用模拟退火算法：如果仅仅最小化溢出函数值，原子轨道的径向部分经常会出现震荡，原因是震荡有时候有利于溢出函数的值尽可能的低，但震荡厉害的函数往往动能高，可移植性较差。因此，为了去除这些实际上非物理的震荡，在算法中我们还定义了原子轨道的动能： T_{\\mu}=\\sum_{q} c_{\\mu q}^{2} q^{2} / 2+\\kappa, 并再次通过模拟退火算法最小化原子轨道的动能，其中\\kappa则是模拟退火的一个惩罚函数： \\kappa=\\left\\{\\begin{array}{ll} 0, & \\mathcal{S} / \\mathcal{S}_{0}-1\\Delta \\end{array}\\right., 这里\\mathcal{S}\\_{0}是在优化动能之前所得到的数值原子轨道算出来的溢出函数的值，而\\mathcal{S}则是当前在参数c_{\\mu q}下面的溢出函数的值。我们发现参数取\\Delta=0.002~0.005足够使得原子轨道平滑了。轨道动能也是通过同样的模拟退火算法得到，经过动能优化之后，轨道的形状会变平滑，同时溢出函数的值也会相比没有动能优化的轨道会有一点点增加，但是对精度的影响是很小的。 优化动能用的模拟退火算法几乎和优化溢出函数一样，除了一点点参数的区别。 目标函数选择的是所有轨道中最大的动能，而不是像溢出函数一样取平均值。对于每个轨道来说，温度是不一样的，因为每个轨道会有一个不同的动能，在这步动能优化中，我们发现结果对初始的温度不敏感，但最终达到的温度必须取得足够小。实际中我们发现只需要100~200步，动能就可以下降得很快。 所以一般来说优化动能的步数就取得比优化溢出函数要少。 二、ABACUS中产生数值原子轨道的具体流程 注：本文档介绍的是模拟退火算法SA，不适用于基于Pytorch的PyTorch-Gradient方法，关于这两个算法，可以参考本数值原子轨道中文文档系列的第三篇文档。 1. 平面波计算 简化计算量：前文我们提到的溢出函数公式，如果把投影子\\hat{P}带进公式，则可以发现我们不需要在计算溢出函数的时候显示的包含任何基矢量（例如平面波）的操作。实际上，我们只需要先算好数值原子轨道|\\phi_\\mu\\rangle和电子波函数|\\Psi_i\\rangle的重叠矩阵（Overlap Matrix）\\langle \\Psi_i|\\phi_\\mu\\rangle并存下来，以及数值原子轨道之间的重叠矩阵\\langle \\phi_\\mu|\\phi_\\nu\\rangle存下来就可以算溢出函数了。更进一步，我们意识到数值原子轨道|\\phi_\\mu\\rangle的径向部分在程序里是写成了球贝塞尔函数的线性组合，根据线性叠加的原理，我们只需要计算球贝塞尔函数和电子波函数的内积，以及球贝塞尔函数之间的内积，并把这些结果存下来，就可以优化系数c_{\\mu q}了！注意这里指标i遍历体系的所有电子态，包括所有的k点以及能带对应的电子波函数。 换句话说，只需要存储线性代数里的内积结果而不是每个波函数在基矢量下的展开系数就可以优化我们想要的系数，因此数值原子轨道的优化过程可以极大提速！ 采用ABACUS做平面波计算： 因此，第一步我们先调用ABACUS主程序，计算出以上overlap矩阵，首先需要准备INPUT文件如下： INPUT_PARAMETERS suffix H pseudo_dir /home/liuyu/github/abacus-develop/tests/PP_ORB wannier_card INPUTw calculation scf ks_solver dav nspin 1 lmaxmax 1 symmetry 0 nbands 10 ecutwfc 100 scf_thr 1.0e-7 scf_nmax 1000 smearing_method gauss smearing_sigma 0.01 mixing_type pulay mixing_beta 0.4 mixing_ndim 8 printe 1 bessel_nao_ecut 100 // same as ecutwfc bessel_nao_rcut 6 // rcut 如上所示，该INPUT与平常的平面波计算相比，只有3个参数（已标红）需要注意： wannier_card：指定wannier相关参数的输入文件名INPUTw bessel_nao_ecut：球贝塞尔函数的截断能，根据公式\\sqrt{E_{cut}} \\times r_{cut} / \\pi来决定求贝塞尔函数的数量 bessel_nao_rcut：数值原子轨道的截断半径r_{cut} 此外，我们还需要准备输入文件 INPUTw 如下（将来计划会把 INPUTw 文件去掉，把参数加入 INPUT 里）： WANNIER_PARAMETERS out_spillage 2 // output overlap spillage_outdir OUT.H // could be the same as OUT.${suffix} 通过 ABACUS 做平面波基矢量计算可以计算出： 1）电子波函数|\\Psi_i\\rangle和球贝塞尔函数 j_l(q r)之间的 overlap\\langle \\Psi_i|j_l(q r)\\rangle； 2）球贝塞尔函数之间的 overlap\\langle j_{l_2}(q_2 r)|j_{l_1}(q_1 r)\\rangle； 3）电子波函数|\\Psi_i\\rangle之间的 overlap\\langle \\Psi_i|\\Psi_i\\rangle。 这些输出将存在文件 OUT.${suffix}/orb_matrix.0.dat 中，而这个文件将被读入进行数值原子轨道的生成。 2. 编译 SIAB SIAB 的全称是 Systematically Improvable Atomic orbital Basis generator based on spillage formula，目前是包含在 ABACUS 软件里的一个独立程序，可用来读入以上 ABACUS 产生的数据文件并且生成数值原子轨道，具体编译方法如下： 拉取 deepmodeling/abacus-develop 仓库（github 和 gitee 二选一即可，国内建议用 gitee） # github仓库 $ git clone -b develop https://github.com/deepmodeling/abacus-develop.git # gitee仓库 $ git clone -b develop https://gitee.com/deepmodeling/abacus-develop.git 编译 SIAB 模拟退火（SA）方法生成数值原子轨道的代码在 SIAB 文件夹里，采用 C++ 编写，目前 Makefile 仅支持 intel 编译器。 SIAB 程序有串行（make s）和并行（make p）两种版本，一般情况下串行版本即可满足使用需求。 $ cd abacus-develop/tools/SIAB/SimulatedAnnealing/source $ make clean $ make s 编译成功后，在目录 abacus-develop/tools/SIAB/SimulatedAnnealing/source 下可以看到生成数值原子轨道的可执行程序 SIA_s.exe，这里 s 代表编译串行版(serial)。此外，对于并行版本，SIAB 还可以结合 MPI 编译并行版，通过命令 make p 指令得到 SIA_p.exe 可执行程序，这里 p 代表 parallel，但注意并行版只对某些特定算法进行并行，之后对代码进行一个更好整理之后我们会给出并行版的教程。 3. 运行例子 进入 tests_s 目录，可以看到 H-6-0.6.15.dat 文件，这是用来生成数值原子轨道所需要准备的输入文件，从 ABACUS 的平面波自洽迭代计算后获得，现在该文件已经改名为 OUT.${suffix}/orb_matrix.0.dat。 此外，还有一个输入文件 INPUT 如下： 1 // bool: calculate the spillage. 1/0 0 // bool: restart or not. 1/0 1 // bool: output the file. 1/0 1 // integer: number of structures. H-6-0.6.15.dat // Each structure's file name occupies one line 1 // integer: number of k points (for parallel version) 1 // integer: number of pools (for parallel version) 15 // can be ignored now 2 // The way to calculate spillage, 2 means averaged spillage 1.0e-8 // real: start temperature for minimizing spillage 0.5 // real: cooling rate for the temperature in minimizing spillage 2 // integer: number of temperatures (spillage) 500 // integer: number of steps per temperature (spillage) 1.0e-2 // real: starting temperature for the kinetic energy 0.8 // real: cooling rate for temperature in minimizing kinetic energy 1 // integer: number of temperatures (kinetic) 100 // integer: number of steps per temperature (kinetic) 0.05 // real: delta kappa for kinetic energy 49 // integer: selectly output information every n steps 100 // integer: change accept rate every n steps, can be ignored now 0.4 // real: acceptance rate (high), can be ignored now 0.2 // real: acceptance rate (low), can be ignored now 50 // real: max allowed kinetic energy (Rydberg) 0.01 // real: 'dr' for the 1d r grid to compute kinetic energy 1 // integer: 1: Kin 2: Ecut, can be ignored now 1 // bool: to control the number of bands 1 // int, the start band index(>0). 1 // int, the end band index( 2 // Number of levels. # label / na / skip / lmax / each L / 01 2 new 1 1 1 01 2 new 1 1 1 01 2 new 1 1 1 0.01 //dr(a.u.) of uniform mesh. Attention!!dr will affect kinetic energy minmized largely. -6 //xmin 1 //zed, chosen as valence charge. 0.01 //dx 6.0 //xmax 0 // print out the C4, this section can be ignored now 2 ./FILE/Si-S.ORBITAL 0 ./FILE/Si-P.ORBITAL 1 0 // for tests, can be ignored now 14.0 // rcut, only useful for test program 0.01 // dr, for simpson integral 2 // test eigenvalue index 2 // lmax C4：代表 4 个重要参数：\\alpha,\\xi,l,nq，\\alpha是原子种类的指标，\\xi是角动量l对应的径向函数的个数，nq 是对应的球贝塞尔函数的个数。 该输入文件包含 SIAB 程序需要读取的一系列参数，基本上重要参数的说明都有列上去，一些可忽略的参数可以先不用设置，之后我们会推出更详细的关于此输入文件的说明文档。 准备好该输入文件后，可以通过如下命令执行 SIAB 程序： $ ~/abacus-develop/tools/SIAB/SimulatedAnnealing/source/SIA_s.exe 运行完毕后，可以得到一系列输出文件，其中 ORBITAL_1U.dat 则是我们需要的数值原子轨道文件。我们可以通过文件的前几行获取关键信息：这是 H 原子的轨道文件，平面波截断能为 100 Ry，截断半径为 6 Bohr，最大角动量为 1，角动量 s 和 p 的径向函数的个数都为 2，即 2 条 s 轨道和 6 条 p 轨道，共 8 条轨道。为了体现这些关键信息，在使用轨道的时候我们建议重命名该文件为 H_gga_100Ry_6au_2s2p.orb。 --------------------------------------------------------------------------- Element H Energy Cutoff(Ry) 100 Radius Cutoff(a.u.) 6 Lmax 1 Number of Sorbital--> 2 Number of Porbital--> 2 --------------------------------------------------------------------------- SUMMARY END 三、ABACUS 中数值原子轨道的生成脚本 我们需要采用平面波计算不同键长的二聚体，并且存在不同层级的轨道，因此也可以通过一个脚本来实现自动化整个流程：abacus-develop/tools/SIAB/Generate_Orbital_AllInOne.sh。该脚本需要读入一个输入文件 ORBITAL_INPUT 如下： #1.exe_dir #-------------------------------------------------------------------------------- EXE_mpi mpirun -np 4 EXE_pw /home/liuyu/github/abacus-develop/build/abacus EXE_orbital /home/liuyu/github/abacus-develop/tools/SIAB/SimulatedAnnealing/source/SIA_s.exe #-------------------------------------------------------------------------------- #( In this part, the direction of the two used exe is provided ) #2.electronic calculatation #-------------------------------------------------------------------------------- targets 14_Si_60 # element ref_bands 4 6 # reference bands nbands 8 12 # num of bands for calculate Ecut 60 # cutoff energy (in Ry) Rcut 6 7 # cutoff radius (in a.u.) Pseudo_dir /home/liuyu/github/abacus-develop/tests/PP_ORB Pseudo Si_ONCV_PBE-1.0.upf smearing_sigma 0.01 # energy range for gauss smearing (in Ry) #-------------------------------------------------------------------------------- #( In this part , some parameters of calculating are given ) #3.structure information #-------------------------------------------------------------------------------- #the Bond Length list for each STRU BLSTRU1 1.8 2.0 BLSTRU2 2.4 # if skip the orbital optimization for each STRU (1:skip, 0:not skip). SkipSTRU 0 0 # set the objective structure list to fit for orbital optimization ListSTRU dimer trimer #-------------------------------------------------------------------------------- #(In this part, it gives us the bond length of the reference system(in angstrom) ) #4.orbital calculatation #-------------------------------------------------------------------------------- maxL 2 # the max angular momentum Level 2 3 # num of levels to generate orbitals( 该输入文件主要分为 5 个部分： 1. exe_dir EXE_mpi：MPI 并行计算命令，这里我们采用的是 4 核 MPI 并行进行 dimer（或者 trimer）的平面波计算。 EXE_pw：ABACUS 可执行程序的绝对路径。 EXE_orbital：数值原子轨道生成程序 SIA_s.exe 的绝对路径。 2. electronic calculatation targets：可以任取，一般格式是${原子序数}_${元素名}_${截断能}。 ref_bands：参考体系的能带数，取值为电子总数的一半。注意这里有多个取值，原因是我们选择了多组参考构型，既有 dimer，也有 trimer。 nbands：平面波计算中的实际能带数，必须大于 ref_bands，以保证包含非占据态。同理，由于多组参考构型，nbands 也有多个取值。 Ecut：平面波截断能，单位为 Ry。 Rcut：数值原子轨道的截断半径，单位为 Bohr。这里的多个取值表明，采用相同的一套参数，生成多个不同截断半径的数值原子轨道文件，根据第一部分的基础知识，截断半径会极大地影响数值原子轨道的质量，因此该参数可以帮助我们一次性生成多个不同截断半径的数值原子轨道文件。 Pseudo_dir：平面波计算采用的赝势文件所在文件夹的绝对路径。 Pseudo：平面波计算采用的赝势文件名。 smearing_sigma：平面波计算采用 Gaussian smearing 的展宽，单位为 Ry，一般取 0.01 即可。 3. structure information BLSTRU1：第一组参考构型的键长，单位为埃。如上所示，第一组参考构型包含两个构型，键长分别为 1.8 和 2.0 埃。 BLSTRU2：第二组参考构型的键长，单位为埃。如上所示，第二组参考构型包含一个构型，键长为 2.4 埃。 以此类推，可以存在 BLSTRU3、BLSTRU4 等等。 SkipSTRU：是否跳过该组参考构型的优化，一般而言，都取为 0 即可。 ListSTRU：指定 BLSTRU1、BLSTRU2 等等参考体系的具体构型，这里说明 BLSTRU1 是 dimer，BLSTRU2 是 trimer。如果取值缺省（第一个不可缺省），则默认为 dimer。 4. orbital calculatation maxL：最大角动量。 Level1：根据上文可知，轨道可以分为多个层级，这里 level1 是 SZ 层级，最大角动量为 1，角动量 s 和 p 的径向函数的个数为 1 和 1，即 1 条 s 轨道和 3 条 p 轨道。 Level2：同上，这里 level2 的最大角动量为 2，角动量 s，p 和 d 的径向函数的个数为 1，1 和 1，即 1 条 s 轨道，3 条 p 轨道和 5 条 d 轨道。level1 和 level2 合在一起，是 DZP 层级。 Level3：同 Level2。 Level：BLSTRU1 和 BLSTRU2 分别负责一部分轨道的生成，Level 的 2 个取值对应的是 BLSTRU1 和 BLSTRU2 的 endlevel，即 BLSTRU1 用于 level1 和 level2 轨道的生成，BLSTRU2 用于 level3 轨道的生成。 5. Metropolis parameters 如注释所说，这部分参数实际上大多数情况下不需要改变。 Start_tem_S：优化 Spillage 的初始温度，更高的初始温度可以搜索更大的温度范围。 Start_tem_K：优化动能的初始温度，更高的初始温度可以搜索更大的温度范围。 Step_S：优化 Spillage 的步数。 Step_K：优化动能的步数。 Delta_kappa：模拟退火的惩罚函数\\kappa所用的参数\\Delta。 准备好以上输入文件后，通过以下命令即可开始生成轨道： $ ~/abacus-develop/tools/SIAB/Generate_Orbital_AllInOne.sh ORBITAL_INPUT 四、ABACUS 中数值原子轨道的测试流程 在生成轨道之后，为了保证基于数值原子轨道基组的第一性原理计算拥有与平面波基组相当的精度，我们需要针对该元素的一些常见的晶体结构做一些验证性计算。 以 Al 元素为例，我们可以选择 simple cubic（sc），body center cubic（bcc），face center cubic（fcc）和 hexagonal close-packed（hcp）这 4 种常见的晶体结构，采用平面波（Plane wave）基组和数值原子轨道基组计算这些晶体结构的平衡晶格常数、体弹性模量等基态性质，评估两种基组之间的误差随着截断半径、最大角动量以及轨道数量的收敛趋势，选择合适的数值原子轨道文件。例如以下就是用 ABACUS 的平面波和数值原子轨道 DZP 计算的铝的四种体相材料的体积-能量曲线，来自文献[1]。从图中可以看到，DZP 轨道描述不同体相的铝的相对能量还是精度较高的。细心的读者会发现纵坐标给出的是绝对能量，因为两种基矢量采用了相同的赝势，但左图给出的能量更低，这是因为平面波更加完备，所以根据 Honhenberg-Kohn 定理，体系总能量的密度泛函可以在更完备的基矢量下得到更好的收敛，即总能量更低。一般来说，平面波得到的总能量比 DZP 轨道小一些，大概在 0.1-0.2 eV/atom，是比较合理的。如果采用了同样的赝势，但两种基矢量给出的能量差别远远大于这个数值，则要检查一下是不是数值原子轨道产生出了问题。最后，大家有任何问题，欢迎写邮件到文档开头邮箱。 五、参考文献 [1] M. Chen, G.-C. Guo, and L. He, Systematically Improvable Optimized Atomic Basis Sets for Ab Initio Calculations, J. Phys.: Condens. Matter 22, 445501 (2010). [2] M. Chen, G.-C. Guo, and L. He, Electronic Structure Interpolation via Atomic Orbitals, J. Phys.: Condens. Matter 23, 325501 (2011). Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-nac3.html":{"url":"abacus-nac3.html","title":"数值原子轨道（三）：产生高精度数值原子轨道","keywords":"","body":"数值原子轨道（三）：产生高精度数值原子轨道 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：林霈泽，邮箱：linpeize@sslab.org.cn 最后更新时间：2023/06/20 在Bohrium Notebook上快速学习： 一、PTG（PyTorch Gradient）方法 这篇文档是数值原子轨道系列的第三篇文档，除了第二篇文档提到的模拟退火算法之外，还可以使用 Pytorch 中的自动微分算法来最小化溢出函数。首先定义损失函数如下，并可以证明它与溢出函数是等价的： \\Delta \\mathrm{PSI} \\stackrel{\\text { def }}{=} \\frac{1}{N_n} \\sum_{n=1}^{N_m} \\|\\left|\\Psi_n\\right\\rangle-\\left|\\tilde{\\Psi}_n\\right\\rangle \\|^2, 其中 \\left|\\tilde{\\Psi}_n\\right\\rangle \\stackrel{\\text { def }}{=} \\hat{P}\\left|\\Psi_n\\right\\rangle, 且\\hat{P}是由所有原子轨道张成的投影子，即\\hat{P}=\\sum_{\\mu v}\\left|\\phi_\\mu\\right\\rangle S_{\\mu v}^{-1}\\left\\langle\\phi_v\\right| \\text {}。由 \\hat{P}^2=\\hat{P}及 \\left\\langle\\Psi_n|\\Psi_n\\right\\rangle=\\delta_{mn}可知，此处的损失函数\\Delta \\mathrm{PSI}与溢出函数是等价的。 二、PTG_dpsi（PyTorch Gradient with dpsi）方法 为了增加局域轨道做电子结构计算时的精度，损失函数的定义还可以被拓展，即在其中加入波函数的梯度，将总的损失函数定义为： \\Delta \\mathrm{PSI} \\stackrel{\\text { def }}{=} \\frac{1}{N_n} \\sum_{n=1}^{N_m} [\\|\\left|\\Psi_n\\right\\rangle-\\left|\\tilde{\\Psi}_n\\right\\rangle \\|^2+\\|\\left|\\nabla\\Psi_n\\right\\rangle-\\left|\\nabla\\tilde{\\Psi}_n\\right\\rangle \\|^2]. 由于投影波函数\\left|\\tilde{\\Psi}_{n}\\right\\rangle是数值原子轨道的线性组合： \\left|\\tilde{\\Psi}_{n}\\right\\rangle=\\sum_{\\mu} a_{\\mu n}\\left|\\phi_{\\mu}\\right\\rangle, 其中系数的表达式为 a_{\\mu n}=\\sum_{\\nu} S_{\\mu \\nu}^{-1}\\left\\langle\\phi_{\\nu} \\mid \\Psi_{n}\\right\\rangle. 那么投影波函数的梯度可以表示为数值原子轨道梯度的线性组合： \\left|\\nabla \\tilde{\\Psi}_{n}\\right\\rangle=\\sum_{\\mu} a_{\\mu n}\\left|\\nabla \\phi_{\\mu}\\right\\rangle. 因此，损失函数的梯度项可以转化为： \\begin{array}{l} \\|\\left|\\nabla \\Psi_{n}\\right\\rangle-\\left|\\nabla \\tilde{\\Psi}_{n}\\right\\rangle \\|^{2} \\\\ =\\left\\langle\\nabla \\Psi_{n} \\mid \\nabla \\Psi_{n}\\right\\rangle-\\sum_{\\mu} a_{\\mu n}\\left\\langle\\nabla \\Psi_{n} \\mid \\nabla \\phi_{\\mu}\\right\\rangle \\\\ -\\sum_{\\nu} a_{v n}^{*}\\left\\langle\\nabla \\phi_{v} \\mid \\nabla \\Psi_{n}\\right\\rangle+\\sum_{\\mu \\nu} a_{\\mu n} a_{v n}^{*}\\left\\langle\\nabla \\phi_{v} \\mid \\nabla \\phi_{\\mu}\\right\\rangle. \\end{array} 根据经验，使用这个算法生成的双重-ζ + 极化(DZP)基组，精度与模拟退火法或 PTG 法生成的三重-ζ + 双极化(TZDP)甚至四倍-ζ + 三重极化(QZTP)基组相当。 在平面波计算中，除了数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道 提到的 overlap 输出文件 OUT.${suffix}/orb_matrix.0.dat 之外，overlap 输出文件 OUT.${suffix}/orb_matrix.1.dat 同样会作为生成轨道的输入文件之一，该文件保存与波函数梯度相关的如下 overlap 项： 1）电子波函数梯度|\\nabla \\Psi_i\\rangle和局域轨道梯度|\\nabla \\phi_\\mu\\rangle的 overlap，也就是电子波函数梯度|\\nabla \\Psi_i\\rangle以及球贝塞尔函数梯度\\nabla j_l(q r)之间的 overlap\\langle \\nabla \\Psi_i|\\nabla j_l(q r)\\rangle； 2）球贝塞尔函数梯度\\nabla j_l(q r)之间的 overlap\\langle \\nabla j_{l_2}(q_2 r)|\\nabla j_{l_1}(q_1 r)\\rangle； 3）电子波函数梯度|\\nabla \\Psi_i\\rangle之间的 overlap\\langle \\nabla \\Psi_i|\\nabla \\Psi_i\\rangle。 三、安装 Pytorch PTG 和 PTG_dpsi 方法采用 python 语言，无需编译，但是依赖 pytorch 包，下面介绍利用 conda 安装 pytorch 的方法： # 确定conda版本 $ conda -V conda 4.8.3 # 确定python3版本 $ python3 -V Python 3.5.2 # 创建python环境 $ conda create -n pytorch python=3.5 # 激活环境（每次使用pytorch需要激活该环境） $ source activate pytorch # 安装pytorch $ conda install pytorch torchvision torchaudio cpuonly -c pytorch # 安装依赖库 $ pip3 install --user scipy numpy $ pip3 install --user torch_optimizer # 退出python环境（使用完毕后） $ source deactivate 四、产生高精度数值原子轨道流程 首先下载 PTG_dpsi 仓库 # github仓库 git clone -b main https://github.com/abacusmodeling/ABACUS-orbitals 接着准备输入文件 SIAB_INPUT #-------------------------------------------------------------------------------- #1. CMD & ENV EXE_mpi mpirun -np 4 EXE_pw /home/liuyu/github/abacus-develop/build/abacus EXE_opt /home/liuyu/github/ABACUS-orbitals/SIAB/opt_orb_pytorch_dpsi/main.py #-------------------------------------------------------------------------------- #2. Electronic calculatation element Si # Element Name Ecut 100 # in Ry Rcut 6 7 # in Bohr Pseudo_dir /home/liuyu/github/abacus-develop/tests/PP_ORB Pseudo_name Si_ONCV_PBE-1.0.upf sigma 0.01 # energy range for gauss smearing (in Ry) #-------------------------------------------------------------------------------- #3. Reference structure related parameters for PW calculation #For the built-in structure types (including 'dimer', 'trimer' and 'tetramer'): #STRU Name #STRU Type #nbands #MaxL #nspin #Bond Length list STRU1 dimer 8 2 1 1.8 2.0 2.3 2.8 3.8 STRU2 trimer 10 2 1 1.9 2.1 2.6 #-------------------------------------------------------------------------------- #4. SIAB calculatation max_steps 200 # Orbital configure and reference target for each level #LevelIndex #Ref STRU Name #Ref Bands #InputOrb #OrbitalConf Level1 STRU1 4 none 1s1p Level2 STRU1 4 fix 2s2p1d Level3 STRU2 6 fix 3s3p2d #-------------------------------------------------------------------------------- #5. Save Orbitals #Index #LevelNum #OrbitalType Save1 Level1 SZ Save2 Level2 DZP Save3 Level3 TZDP 该输入文件同样包含 5 个部分： 1. CMD & ENV EXE_mpi：MPI 并行计算命令，这里我们采用的是 4 核 MPI 并行进行 dimer（或者 trimer）的平面波计算。 EXE_pw：ABACUS 可执行程序的绝对路径。 EXE_opt：数值原子轨道生成程序 PTG_dpsi 的绝对路径。 2. Electronic calculatation element：元素名。 Ecut：平面波截断能，单位为 Ry。 Rcut：数值原子轨道的截断半径，单位为 Bohr。这里的多个取值表明，采用相同的一套参数，生成多个不同截断半径的数值原子轨道文件，根据第一部分的基础知识，截断半径会极大地影响数值原子轨道的质量，因此该参数可以帮助我们一次性生成多个不同截断半径的数值原子轨道文件。 Pseudo_dir：平面波计算采用的赝势文件所在文件夹的绝对路径。 Pseudo：平面波计算采用的赝势文件名。 sigma：平面波计算采用 Gaussian smearing 的展宽，单位为 Ry，一般取 0.01 即可。 3. Reference structure related parameters for PW calculation STRU Name：参考构型组别 STRU1、STRU2、STRU3...... STRU Type：参考体系构型，一般可取 dimer，trimer，tetramer。 nbands：平面波计算中的实际能带数，必须保证包含非占据态。 MaxL：最大角动量。 nspin：自旋量子数。 Bond Length list：键长取值列表，单位为埃。以 STRU1 为例，这一组共有 5 个不同键长的 dimer 作为生成轨道的参考构型。 4. SIAB calculatation max_steps：优化步数 LevelIndex：轨道分层的 index，取 Level1、Level2、Level3...... Ref STRU Name：该层级的轨道采用哪一组参考构型生成。以上面的输入参数为例，Level1 和 Level2 的轨道采用 STRU1 组别的 dimer 参考构型生成，Level3 的轨道采用 STRU2 组别的 trimerr 参考构型生成。 Ref Bands：拟合参考体系的能带数，若输入“auto”则自动拟合所有基态。 InputOrb：是否在已有的轨道基础上生成新轨道，一般 Level1 设为 none，即没有旧轨道；Level2 一般以 Level1 生成的轨道为基础继续生成轨道，Level3 往后同理。 OrbitalConf：轨道的具体配置，这里 Level1 是 SZ 层级，Level2 是 DZP 层级，Level3 是 TZDP 层级，实际上还可以继续设置更高层级的轨道。 5. Save Orbitals Index：取值 Save1、Save2、Save3...... LevelNum：将特定 Level 的轨道保存到一个轨道文件中。以上面的输入参数为例，分别将 Level1、Level2、Level3 对应的轨道保存到单独的轨道文件中。 OrbitalType：即保存的轨道文件中，该轨道基组所属的层级。以上面的输入参数为例，分别为 SZ、DZP、TDZP。 准备好输入参数文件 SIAB_INPUT 后，运行如下命令即可开始生成轨道： $ python3 ~/github/ABACUS-orbitals/SIAB/SIAB.py SIAB_INPUT 程序正常结束后，轨道会分别保存在 Orbital_Si_SZ、Orbital_Si_DZP、Orbital_Si_TZDP 中，并自动命名成标准格式（如 Si_gga_6au_100Ry_2s2p1d.orb）。 五、参考文献 [1] Peize Lin, Xinguo Ren and Lixin He, Strategy for constructing compact numerical atomic orbital basis sets by incorporating the gradients of reference wavefunctions, Phys. Rev. B 103, 235131 (2021). Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-md.html":{"url":"abacus-md.html","title":"ABACUS 分子动力学使用教程","keywords":"","body":"ABACUS 分子动力学使用教程 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/14 在Bohrium Notebook上快速学习： 一、分子动力学方法简介 分子动力学（Molecular Dynamics，简称 MD）：一种模拟原子体系随时间运动的方法，被广泛的用来研究与原子运动路径相关的一些基本过程，如相变、扩散、化学反应等等。本教程旨在介绍 ABACUS 中的分子动力学功能，分子动力学模拟重要的一件事情是如何选取精度和效率的平衡，其中精度高低主要取决于势函数的准确程度，而效率主要受限于求出每个原子的能量和受力的计算量。 经典分子动力学（Classical MD，简称 CMD）：通过构建描述原子间相互作用的势函数，获得每个原子的受力（受力等于能量对原子位置的导数），再通过积分运动方程来获得每个原子的下一时刻位置，从而获得随时间演化的粒子位置和速度。当系统处在一定的密度、温度和压强等物理条件限制下，可以结合统计物理的方法计算物质的性质。具体来说，采取某个系综后，对粒子位置和速度采样，之后统计出体系的热力学宏观性质。 从头算分子动力学（ab initio molecular dynamics，简称 AIMD）：也称为第一性原理的分子动力学方法（first-principles molecular dynamics，简称 FPMD），该方法采用的是第一性原理方法（例如密度泛函理论）来计算体系的势能面，因此计算量相比于经典分子动力学方法要昂贵很多。 ABACUS 的分子动力学功能：支持第一性原理分子动力学 FPMD 方法，也支持经典的 Lennard-Jones（LJ 对势）的分子动力学模拟。此外，ABACUS 还支持深度势能分子动力学（Deep Potential Molecular Dynamics，简称 DPMD）方法，此时需要编译 DeePMD-kit 软件包并在编译原子算筹软件时进行动态库的链接。 二、文档和算例下载地址 ABACUS 里关于分子动力学方法的线上文档地址为：http://abacus.deepmodeling.com/en/latest/advanced/md.html ABACUS 里关于分子动力学参数的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#molecular-dynamics ABACUS 的 MD 算例下载地址为（国内 gitee）： https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/md 可以采用的下载命令是： git clone https://gitee.com/mcresearch/abacus-user-guide.git 之后进入 /abacus-user-guide/examples/md 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/md 注：算例仓库里面包含 1_AIMD，2_LJMD（采用 Lennard-Jones 经典势做 MD），3_DPMD（采用深度势能方法做 MD）和 4_FIRE（采用 FIRE 算法做结构优化）四个目录。 注：以上算例要在 ABACUS v3.2.1 版本及以上可以运行成功，并且我们强烈建议下载使用 ABACUS 最新版本！ 1. 第一性原理分子动力学（AIMD） 进入 1_AIMD 目录，该目录提供了 8 个输入文件，使用的时候将 INPUT_* 复制为 INPUT 即可（INPUT_* 代表从 INPUT_0 到 INPUT_7 共 8 个不同的 INPUT 文件，对应 8 种不同的 MD 算法）。该算例采用 8 原子的金刚石结构 Si，晶格结构放在 STRU 文件里，布里渊区的 k 点采样放在 KPT 文件里。 8 个 INPUT 文件对应的 MD 方法如下： INPUT_0：采用 NVE 微正则系综 INPUT_1：采用 NVT 正则系综 INPUT_2：采用 Langevin 热库 INPUT_3：采用 Anderson 热库，NVT 系综 INPUT_4：采用 MSST 方法 INPUT_5：采用 Berendsen 热库，NVT 系综 INPUT_6：采用 rescaling 方法，NVT 系综 INPUT_7：采用 rescale_v 方法，NVT 系综 以 INPUT_0 为例： INPUT_PARAMETERS #Parameters (1.General) suffix Si_nve calculation md nbands 20 symmetry 0 pseudo_dir ../../../tests/PP_ORB orbital_dir ../../../tests/PP_ORB #Parameters (2.Iteration) ecutwfc 30 scf_thr 1e-5 scf_nmax 100 #Parameters (3.Basis) basis_type lcao ks_solver genelpa gamma_only 1 #Parameters (4.Smearing) smearing_method gaussian smearing_sigma 0.001 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 chg_extrap second-order #Parameters (6.MD) md_type nve md_nstep 10 md_dt 1 md_tfirst 300 这些参数在 ABACUS 线上文档中均有说明，在这里再进行简单概述： calculation：设置 ABACUS 计算类型，做分子动力学模拟请设置为 md。 esolver_type：给定原子位置进行系统能量的计算，默认 Kohn-Sham 密度泛函理论（ksdft），还可以设置 LJ 势（lj）或者深度势能（dp）。理论上来说，所有的 esolver_type 都可以用于 MD 计算。 chg_extrap：电荷外插法，在 relax 和 md 计算中可用于优化电荷密度初始化，加速电子迭代收敛，MD 中可以设置为 second-order。 md_type：MD 算法种类，默认是正则系统 nvt，这里的例子选择的是 nve，即 NVE 微正则系综。 md_nstep：MD 模拟的总步数。 md_dt：MD 计算每一步的时间步长（单位是 fs），与 md_nstep 共同决定 MD 总时长。 md_tfirst：MD 系统的初始温度（单位是 K）。 2. Lennard-Jones 势函数 进入 2_LJMD 目录，ABACUS 软件包中提供了一个采用 Lennard-Jones（LJ）经典势函数进行 MD 模拟的算例，该算例采用 LJ 对势作为能量求解器来做经典分子动力学，初始结构是边长 20 埃的正方体盒子中的 256 个无序 He 原子。 2.1 LJ 对势 LJ 对势的解析形式如下：u^{ij}表示原子 i 与原子 j 之间的相互作用能，r^{ij}表示这两个原子之间的距离，\\epsilon，\\sigma和r_{cut}则是 LJ 势需要的 3 个参数。LJ 势只考虑截断半径r_{cut}内的近邻原子 j 对中心原子 i 的能量贡献。 \\begin{array}{c} u^{i j}=4 \\varepsilon\\left[\\left(\\frac{\\sigma}{r_{i j}}\\right)^{12}-\\left(\\frac{\\sigma}{r_{i j}}\\right)^{6}\\right] \\\\ \\boldsymbol{F}_{i}=-\\nabla_{i} U=\\sum_{j} 4 \\varepsilon\\left[12\\left(\\frac{\\sigma}{r_{i j}}\\right)^{12}-6\\left(\\frac{\\sigma}{r_{i j}}\\right)^{6}\\right] \\frac{\\boldsymbol{r}_{i}-\\boldsymbol{r}_{j}}{r_{i j}^{2}} H\\left(r_{c u t}-r_{i j}\\right) \\end{array} \\\\ H(x)=\\left\\{\\begin{array}{l} 0\\ \\ \\ \\ (x0) \\end{array}\\right.\\\\ 2.2 STRU LJMD 是经典分子动力学，不需要提供 KPT，赝势和轨道文件，STRU 的前面几部分如下： ATOMIC_SPECIES He 4.0026 LATTICE_CONSTANT 1.889727 LATTICE_VECTORS 20 0 0 0 20 0 0 0 20 ATOMIC_POSITIONS Cartesian He #label 0 #magnetism 256 #number of atoms ATOMIC_SPECIES：不需要提供赝势信息 NUMERICAL_ORBITAL：不需要添加轨道信息 2.3 INPUT INPUT 文件中的参数也需要做少量修改： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md pseudo_dir ../../PP_ORB #Parameters (esolver) esolver_type lj lj_rcut 8.5 lj_epsilon 0.01032 lj_sigma 3.405 cal_force 1 cal_stress 1 #Parameters (MD) md_nstep 5 md_type nve md_dt 1 md_tfirst 300 init_vel 1 esolver_type：指定为 lj 就可以做 Lennard-Jones 经典势函数。 lj_rcut：LJ 对势的参数，即截断半径r_{cut}。 lj_epsilon：LJ 对势的参数，即\\epsilon。 lj_sigma：LJ 对势的参数，即\\sigma。 init_vel：读取 STRU 中的原子速度信息，原子单位制。 3. 深度势能（Deep Potential） ABACUS 软件包中提供了一个 DPMD 的算例，进入 3_DPMD 目录。该算例采用 DP 模型（DeePMD-kit 产生的深度势能模型）作为能量求解器来做基于机器学习的分子动力学，初始结构是 864 个无序铝原子。 3.1 DP 模型 DeePMD-kit 是一种基于机器学习的分子动力学模拟方法，该方法是通过使用第一性原理计算数据对深度神经网络模型进行训练，从而得到通用的多体势能模型（DP 模型）。 3.2 编译方式 ABACUS 采用 DP 模型做 MD 计算需要编译与 DeePMD-kit 的接口，cmake 以及 makefile 编译方式可以参考 ABACUS 线上文档。 3.3 INPUT 文件设置 DPMD 是经典分子动力学，不需要提供 KPT，赝势和轨道文件 INPUT 文件中的参数需要做少量修改： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md esolver_type dp pot_file ../../PP_ORB/Al-SCAN.pb cal_force 1 cal_stress 1 md_nstep 3 md_type msst md_dt 1 md_tfirst 200 md_dumpfreq 1 md_restartfreq 1 msst_qmass 200 msst_vel 0.028 msst_vis 0.3 init_vel 1 esolver_type：设置为 dp pot_file：DP 模型文件路径 md_dumpfreq：MD 输出文件 MD_dump 中原子以及晶胞信息的输出频率 md_restartfreq：结构文件 STRU_MD_${istep} 的输出频率，MD 续算文件 Restart_md.dat 的更新频率 3.4 STRU 文件的设置 首先，我们可以通过如下命令确定 DP 势文件中是否存在关键字“type_map”： $ strings Al-SCAN.pb | grep type_map {\"model\": {\"type_map\": [\"Al\"], \"descriptor\": {\"type\": \"se_e2_a\", \"sel\": [150], \"rcut_smth\": 0.5, \"rcut\": 6.0, \"neuron\": [25, 50, 100], \"resnet_dt\": false, \"axis_neuron\": 16, \"seed\": 1, \"activation_function\": \"tanh\", \"type_one_side\": false, \"precision\": \"default\", \"trainable\": true, \"exclude_types\": [], \"set_davg_zero\": false}, \"fitting_net\": {\"neuron\": [240, 240, 240], \"resnet_dt\": true, \"seed\": 1, \"type\": \"ener\", \"numb_fparam\": 0, \"numb_aparam\": 0, \"activation_function\": \"tanh\", \"precision\": \"default\", \"trainable\": true, \"rcond\": 0.001, \"atom_ener\": []}, \"data_stat_nbatch\": 10, \"data_stat_protect\": 0.01}, \"learning_rate\": {\"type\": \"exp\", \"decay_steps\": 5000, \"start_lr\": 0.001, \"stop_lr\": 3.51e-08, \"scale_by_worker\": \"linear\"}, \"loss\": {\"type\": \"ener\", \"start_pref_e\": 0.02, \"limit_pref_e\": 1, \"start_pref_f\": 1000, \"limit_pref_f\": 1, \"start_pref_v\": 0, \"limit_pref_v\": 0, \"start_pref_ae\": 0.0, \"limit_pref_ae\": 0.0, \"start_pref_pf\": 0.0, \"limit_pref_pf\": 0.0, \"enable_atom_ener_coeff\": false}, \"training\": {\"training_data\": {\"systems\": [\"../deepmd_data/\"], \"batch_size\": \"auto\", \"set_prefix\": \"set\", \"auto_prob\": \"prob_sys_size\", \"sys_probs\": null}, \"validation_data\": {\"systems\": [\"../deepmd_validation\"], \"batch_size\": 1, \"numb_btch\": 3, \"set_prefix\": \"set\", \"auto_prob\": \"prob_sys_size\", \"sys_probs\": null}, \"numb_steps\": 1000000, \"seed\": 10, \"disp_file\": \"lcurve.out\", \"disp_freq\": 100, \"save_freq\": 1000, \"save_ckpt\": \"model.ckpt\", \"disp_training\": true, \"time_training\": true, \"profiling\": false, \"profiling_file\": \"timeline.json\", \"enable_profiler\": false, \"tensorboard\": false, \"tensorboard_log_dir\": \"log\", \"tensorboard_freq\": 1}} 如果存在关键字 type_map，那么 ABACUS 会自动匹配 STRU 和 DP 势文件中的原子种类顺序。 否则，STRU 中的原子种类以及顺序必须与 DP 势文件中的原子种类以及顺序一致。 例如，如果我们用 Al-Cu-Mg 三元合金的 DP 势文件来跑 Al-Mg 二元合金的 MD，那么 STRU 应该如下所示： ATOMIC_SPECIES Al 26.982 Cu 63.546 Mg 24.305 LATTICE_CONSTANT 1.889727000000 LATTICE_VECTORS 4.0 0.0 0.0 0.0 4.0 0.0 0.0 0.0 4.0 ATOMIC_POSITIONS Cartesian Al 0 2 0.0 0.0 0.0 0.5 0.5 0.0 Cu 0 0 Mg 0 2 0.5 0.0 0.5 0.0 0.5 0.5 注：在这个例子中，即使 Cu 原子的数量为 0，也必须在 STRU 中给出 Cu 原子相关信息。 三、MD 输出和续算功能 1. MD 输出文件 ABACUS 的 MD 模拟会产生 3 类输出文件：结构文件 STRU_MD_${istep}，续算文件 Restart_md.dat，信息文件 MD_dump。 1.1 结构文件 STRU_MD_${istep} 参数 md_restartfreq 控制 OUT.${suffix}/STRU/文件夹中结构文件STRU_MD_${istep}的输出频率，该文件格式与输入结构文件 STRU 相同，主要用于 MD 续算。这里 istep 代表离子步，从 0 开始计数。 1.2 续算文件 Restart_md.dat 参数 md_restartfreq 控制 OUT.${suffix}/Restart_md.dat 的更新频率，用于 MD 续算。 1.3 信息文件 MD_dump 参数 md_dumpfreq 控制 OUT.${suffix}/MD_dump 文件的追加输出频率，该文件输出每 md_dumpfreq 步的 MD 信息，包括 MD 步数，晶格常数，晶格矢量，晶格维里，原子编号，原子位置，原子受力，原子速度。其中，晶格维里，原子受力，原子速度可以通过输入参数 dump_virial，dump_force，dump_vel 控制是否输出。 MDSTEP: 0 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 123.045275146001 -3.807535058112 -13.541439282961 -3.807535058112 124.421300186299 24.047959743672 -13.541439282961 24.047959743672 125.016024430342 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 0.000000000000 0.000000000000 0.000000000000 -0.885362725233 0.500467424348 0.150239620206 -0.003506076235 0.000412570794 0.000094403053 1 Si 1.300822817264 1.376389287977 1.354798867769 0.885362725233 -0.500467424348 -0.150239620206 0.003506076235 -0.000412570794 -0.000094403053 MDSTEP: 1 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 123.051574098220 -2.465332696362 -10.608474638302 -2.465332696362 123.587154919736 16.307187552709 -10.608474638302 16.307187552709 123.960669810770 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.389827754452 2.701629481339 2.699621723525 -0.602062173578 0.391990779819 0.096323485153 -0.010548689866 0.004659227844 0.001267888485 1 Si 1.308600113700 1.373562332082 1.353979669688 0.602062173578 -0.391990779819 -0.096323485153 0.010548689866 -0.004659227844 -0.001267888485 MDSTEP: 2 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 122.953007762375 -0.240072876170 -4.211946086929 -0.240072876170 122.930693852071 3.378536464243 -4.211946086929 3.378536464243 122.992607262385 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.376757913710 2.708010452044 2.701308224779 -0.124946902346 0.155367961328 0.009378252255 -0.012739769308 0.006644009927 0.001613591879 1 Si 1.321669954442 1.367181361377 1.352293168434 0.124946902346 -0.155367961328 -0.009378252255 0.012739769308 -0.006644009927 -0.001613591879 MDSTEP: 3 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 122.881221914392 1.206247195689 2.345023988024 1.206247195689 123.110079832453 -8.436042066928 2.345023988024 -8.436042066928 123.123976300784 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.364727401370 2.714719749381 2.702800880457 0.310711926370 -0.086233730382 -0.043760493686 -0.009222308089 0.005510922784 0.001122226311 1 Si 1.333700466782 1.360472064040 1.350800512757 -0.310711926370 0.086233730382 0.043760493686 0.009222308089 -0.005510922784 -0.001122226311 2 MD 续算功能 如果 ABACUS 运行达到指定的 MD 步数，或者计算中断，可以通过 MD 续算功能继续之前的 MD 计算。 以上一个 INPUT 文件为例： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md pseudo_dir ../../PP_ORB esolver_type dp pot_file ../../PP_ORB/Al-SCAN.pb cal_force 1 cal_stress 1 md_nstep 3 md_type msst md_dt 1 md_tfirst 200 md_dumpfreq 1 md_restartfreq 1 md_restart 1 msst_qmass 200 msst_vel 0.028 msst_vis 0.3 init_vel 1 md_restart：控制续算的开关，在 MD 续算时将这个参数设为 1，其他参数不变。当 md_restart 设为 1，ABACUS 会读取${read_file_dir}/Restart_md.dat文件，从中获取当前MD步数istep以及续算所需的其他参数如恒温器以及恒压器的信息，根据istep从OUT.${suffix}/STRU/ 文件夹中读取相应的结构文件 STRU_MD_${istep}，之后就可以进行 MD 续算了。 四、MD 后处理 目前主流的可视化软件如 VESTA、VMD、OVITO 并不支持 ABACUS 的文件格式，因此我们需要通过一些后处理软件实现 ABACUS 的 STRU、MD_dump 文件与常用文件格式的转化。我们比较推荐的后处理软件有： 1 ASE 官网：https://wiki.fysik.dtu.dk/ase/ 用法参考 ABACUS 线上文档：http://abacus.deepmodeling.com/en/latest/advanced/interface/ase.html 2 dpdata github 网址：https://github.com/deepmodeling/dpdata gitee 网址：https://gitee.com/deepmodeling/dpdata 3 案例 现在我们用 LJMD 算例来演示如何采用dpdata+OVITO的方式在 MD 计算完成后制作分子动力学轨迹动画。 3.1 MD 计算 下载案例文件 $ git clone https://gitee.com/mcresearch/abacus-user-guide 进入 LJMD 文件夹 $ cd abacus-user-guide/examples/md/2_LJMD 修改 INPUT 参数，把 md_nstep 改为 100 INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md pseudo_dir ../../PP_ORB #Parameters (esolver) esolver_type lj lj_rcut 8.5 lj_epsilon 0.01032 lj_sigma 3.405 cal_force 1 cal_stress 1 #Parameters (MD) md_nstep 100 md_type nve md_dt 1 md_tfirst 300 init_vel 1 运行 abacus $ abacus 3.2 dpdata 转化格式 安装 dpdata $ git clone https://github.com/deepmodeling/dpdata.git dpdata $ cd dpdata $ pip install . 运行 dpdata，将 MD_dump 文件转化为 GROMACS 的 gro 格式的文件 data.gro $ python3 >>> import dpdata >>> data = dpdata.LabeledSystem(\"./\", fmt=\"abacus/md\") >>> data.to_gro(\"data.gro\") 3.3 OVITO 制作动画 打开 OVITO，点击左上角 load file，选择上一步的 data.gro 文件 右上角 rendering settings 点击 Render active viewport 即可保存动画文件 五、特殊的 MD 方法 1. Fast Inertial Relaxation Engine ABACUS 中实现了一种特殊的基于 MD 的 Fast Inertial Relaxation Engine (FIRE)结构优化方法，该算法比共轭梯度法的标准实现快得多，具有额外的速度修改和自适应时间步长，具有优异的优化效率。 以上面提供的 4_FIRE 算例为例，我们可以介绍一下所需的参数如下： INPUT_PARAMETERS #Parameters (1.General) suffix Si_fire calculation md nbands 6 symmetry 0 pseudo_dir ../../PP_ORB orbital_dir ../../PP_ORB #Parameters (2.Iteration) ecutwfc 30 scf_thr 1e-8 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method gaussian smearing_sigma 0.001 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 chg_extrap second-order #Parameters (6.MD) md_type fire md_nstep 100 md_dt 1 md_tfirst 300 force_thr_ev 0.001 calculation：FIRE 算法是基于 MD 方法的，因此需要将 calculation 设为 md md_type：采用 FIRE 算法，需要设为 fire md_tfirst：MD 需要离子速度，因此需要通过设置初始温度来随机生成离子速度，或者在 STRU 文件中手动设置初始速度 force_thr_ev：离子受力的收敛阈值，当离子受力的每个分量均小于该阈值或者 MD 运行至最大步数时，MD 终止 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-sol.html":{"url":"abacus-sol.html","title":"ABACUS 隐式溶剂模型使用教程","keywords":"","body":"ABACUS 隐式溶剂模型使用教程 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn；孙梦琳，邮箱：sunmenglin@stu.pku.edu.cn 审核：许审镇，邮箱：xushenzhen@pku.edu.cn；陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/01 一、介绍 近年来，电化学表面反应，例如一些电催化系统，无论是在工业界还是科学研究领域，都受到了广泛的关注。而对于一个真实电极表面反应体系，往往需要考虑许多复杂的情况，例如电极与电解液之间的固液界面，在材料模拟中经常遇到和使用。在这种系统的第一性原理计算中应该考虑溶剂化效应，以便获得准确的性质预测。 溶剂化是指溶质和溶剂之间的相互作用，使溶质在溶液中稳定。这种相互作用的强度和性质影响体系的许多特性。在计算化学中，溶剂模型(Solvation model) 是描述溶剂化行为的一种计算方法。 隐式溶剂化模型(Implicit solvation model)是一种处理溶剂化效应的成熟方法，在有限系统和周期系统中得到了广泛的应用。这种方法将溶剂视为连续介质，而不是单独的“显式”溶剂分子，这意味着嵌入隐式溶剂中的溶质以及溶剂自由度的平均值将隐含在溶剂浴的性质中。与“显式”方法相比，这种隐式溶剂化模型可以以低得多的计算成本提供定性正确的结果，特别适用于大型复杂系统。 ABACUS 中实现的隐式溶剂化模型采用了 Mathew、Sundararaman、Letchworth-Waver、Arias 和 Hennig 在 2014 年开发的方法[1]。 二、文档和算例 ABACUS 里关于隐式溶剂模型的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/scf/advanced.html#implicit-solvation-model ABACUS 里关于隐式溶剂模型参数的线上文档地址为：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#implicit-solvation-model ABACUS 的隐式溶剂模型算例下载地址为（gitee）： https://gitee.com/deepmodeling/abacus-develop/tree/develop/examples/implicit_solvation_model/Pt-slab 可以采用的下载命令是： git clone https://gitee.com/deepmodeling/abacus-develop.git 之后进入 /abacus-develop/examples/``implicit_solvation_model/Pt-slab 目录 或者采用 Github 仓库地址： https://github.com/deepmodeling/abacus-develop/tree/develop/examples/implicit_solvation_model/Pt-slab 三、输入参数 INPUT_PARAMETERS #Parameters (1.General) suffix H2 calculation scf ntype 1 nbands 2 symmetry 0 pseudo_dir ./ #Parameters (2.Iteration) ecutwfc 60 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (Solvation Model) imp_sol 1 eb_k 80 tau 0.000010798 sigma_k 0.6 nc_k 0.00037 以算例提供的 INPUT 文件为例，使用隐式溶剂模型方法只需添加如下参数即可： imp_sol：类型是 Bool，指定隐式溶剂模型的开(1)或者关(0)，默认值为 0 eb_k：类型是 Real，溶剂的相对介电常数，水为 80 tau：类型是 Real，有效表面张力参数，用于描述未被静电项捕获的溶质和溶剂之间的空化、分散和排斥相互作用，单位是$Ry/Bohr^2$，默认值为 1.0798e-05 sigma_k：类型是 Real，由溶质的电子结构隐含地确定的扩散腔的宽度（溶质电子密度与 nc_k 的比值，无量纲），默认值为 0.6 nc_k：类型是 Real，介电腔形成时的电子密度值，单位是$Bohr^{-3}$，默认值为 0.00037 注意，eb_k 可根据需要设置为模拟溶剂分子的相对介电常数参数，默认值 80 为水分子情况。tau，sigma_k，nc_k 的默认值均由在水溶液情况下与实验结果拟合得到，如需考虑其他溶剂，可自行测试拟合。 四、预期结果 如图所示，一个氢分子位于超胞中，模拟其处于溶液环境时的状态。将 imp_sol 设为 1，其他参数使用默认值，表示溶剂为水。 在输出文件 OUT.ABACUS/running_scf.log 中，E_sol_el 和 E_sol_cav 分别表示静电作用和空腔作用引起的能量修正。如案例所示，E_sol_el 代表溶质和溶剂分子之间的静电感应作用，贡献的能量修正一般为负值。E_sol_cav 代表溶质分子在溶剂中产生空腔所引起的能量修正，一般为正值。 体系溶剂化能的计算：打开隐式溶剂模型（imp_sol = 1)时体系总能量(结构优化之后)与真空情况（imp_sol = 0)体系总能量（结构优化之后）之差。 五、参考文献 [1] J. Chem. Phys. 140, 084106 (2014), https://doi.org/10.1063/1.4865107 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-02 10:20:41 "},"abacus-sdft.html":{"url":"abacus-sdft.html","title":"ABACUS 随机波函数DFT方法使用教程","keywords":"","body":"ABACUS 随机波函数 DFT 方法使用教程 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/07/11 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍 ABACUS 中随机波函数密度泛函理论（Stochastic Density Functional Theory，以下简称 SDFT）计算功能。目前 ABACUS 使用 SDFT 主要聚焦在高温高压物质的模拟，特别是温稠密物质（Warm Dense Matter，简称 WDM）。在进行温稠密物质计算时（温度高达数十到上千 eV， 1 eV=11604.5 K），传统的 Kohn-Sham 密度泛函理论（KSDFT）需要用到极大数量的占据态电子波函数导致计算困难，而 SDFT 使用随机波函数轨道，可以有效地避开对角化哈密顿矩阵这个问题，应用于高温计算。关于 ABACUS 中实现 SDFT 算法的细节可以参考 Qianrui Liu and Mohan Chen*, \"Plane-wave-based stochastic-deterministic density functional theory for extended systems,\" Phys. Rev. B, 106, 125132 (2022)。本教程中将会展示如何在 ABACUS 计算中使用 SDFT 功能，此外还会介绍混合随机波函数密度泛函理论方法使用（mixed stochastic-deterministic DFT，简称 MDFT），即在 SDFT 计算中，混入一部分的低能 Kohn-Sham 轨道，从而加速结果收敛。 二、软件和算例准备 ABACUS 的软件包（3.2.0 版本）中提供了一个 SDFT 的算例，可以从 Gitee 上下载。可以在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载后解压，之后进入/abacus-user-guide/examples/stochastic 文件夹。算例中有三个文件夹，pw_Si2、pw_md_Al 和 186_PW_SDOS_10D10S。 三、采用 SDFT 进行电子自洽迭代计算 pw_Si2文件夹：这是一个电子温度为 0.6 Ry（约 8.16 eV）的 2 个原子的金刚石结构硅（Si）的电子自洽迭代（Self Consistent Field，简称 SCF）算例，包含布里渊区 K 点的 KPT 文件和包含原子位置的 STRU 文件与传统的 KSDFT 计算并无区别，主要的不同在于输入文件 INPUT，注意目前 SDFT 仅支持 smearing_method 为 fd。INPUT 文件如下： INPUT_PARAMETERS #Parameters (General) calculation scf esolver_type sdft pseudo_dir ../../PP_ORB nbands 4 nbands_sto 64 nche_sto 100 method_sto 1 #Parameters (Accuracy) ecutwfc 50 scf_nmax 20 symmetry 1 #Parameters (Smearing) smearing_method fd smearing_sigma 0.6 以上参数在 ABACUS 的线上文档中均有详细说明，这里再进行简单概述： calculation设置为 scf，代表进行电子自洽迭代计算（self-consistent field）。 esolver_type是选择系统总能量求解方法的，默认为 ksdft（Kohn-Sham density functiona theory），这里需要设置为 sdft 才会使用 SDFT 或者 MDFT 进行计算。 nbands是使用的 Kohn-Sham 轨道的数目（也叫 determinstic orbitals，是通过严格对角化矩阵计算出来的）。如果 nbands 设置为 0，且 nbands_sto（随机轨道数目，这里设成 64）不为 0，则会进行 SDFT 计算；如果 nbands>0，且 nbands_sto>0，则会进行混合 KS 电子轨道和随机轨道（stochastic orbitals）的 MDFT 计算。注意：一般 nbands 设置为能量低于费米能级对应的能带数，计算效率会比较高。 nbands_sto是使用随机波函数（stochastic orbitals）轨道数目，原则上取得越大则随机误差越小，但计算效率也会相应降低。 判断随机波函数个数是否足够的一个经验法则是：测试能量误差。实际计算中，一般可以采用10 个左右不同的随机数种子（可以参考 seed_sto 参数设置随机数种子，下面有介绍）生成的相同数目的随机波函数轨道进行 SDFT 计算，得到系统能量并求得相应误差，增加随机波函数轨道数目直到控制能量误差小于万分之一即可。 当 nbands_sto 设为 0 时， 程序会自动转成 KSDFT 进行计算（ABACUS 3.2.2 版本以后）。 nche_sto是将电子体系的哈密顿量进行切比雪夫展开的阶数，这个数取得越大则用到的切比雪夫展开阶数越多，相应的计算精度也会越高但效率会降低。大致关系为与温度成反比，温度越高，阶数可以取得越小；ecut（正比关系）越大，阶数越大；推荐使用的 nche_sto 的大小是使得输出文件 running_scf.log 中的 Chebyshev Precision 小于 1e-8。 method_sto是进行 SDFT 计算使用的方法：1 代表消耗内存较少但稍慢的方法，2 代表更快但需要更大内存的方法，默认是 2。 此外还有如下参数可能会用到： seed_sto：生成随机轨道的随机种子。默认是 0，代表随时间随机生成；若要控制使用相同的随机种子，可以设置一个大于 1 的整数。 bndpar：将所有并行的进程分成 bndpar 个组，计算所用随机轨道将平均分布在每个组中，可以提高并行效率，默认为 1。值得注意的是，这个参数并不是越大越好，并且不如 K 点并行（kpar参数）有效，实际计算中应该优先使用 K 点并行，然后测试不同大小的 bndpar，确定最佳的 bndpar。 平面波能量截断值 ecut 的测试：由于随机误差的出现，SDFT 的 ecut 的测试与传统的 KSDFT 稍有区别，但是原理是类似的。在确定好 nbands_sto 后，就可以测试 ecut 了。与测试 nbands_sto 类似，在不同的 ecut，需要采用 10 个左右不同的随机种子生成的相同数目的随机波函数轨道进行 SDFT 计算，然后取平均能量。由于温稠密物质能量一般都比较高，因此只要控制相邻二个 ecut（相差为 10 Ry）对应的平均能量差小于一定标准即可（例如万分之一）。 注 1：在这个例子里我们提供的赝势是 Si.pz-vbc.UPF 文件，这个文件包含 4 个硅的价电子。事实上，当温度特别高的时候，一般的赝势可能会面临可移植性差的问题，例如高温会使得内壳层电离。这个时候，要选择合理的赝势进行计算，甚至可能需要自己造一个新的赝势，目前 ABACUS 3.2.0 支持的是模守恒的赝势。 注 2：ABACUS 的 SDFT 和 MDFT 支持多个 k 点采样，因此可以在 KPT 文件里设置不同的 k 点个数，在某些性质的计算里，要注意计算性质随着 k 点的收敛。 四、采用 SDFT 进行分子动力学模拟 pw_md_Al 文件夹：这是一个电子温度为 7.35 Ry（约 100 eV）、包含 16 个铝（Al）原子的结构，我们对其进行分子动力学（Molecular Dynamics，简称 MD）的模拟。INPUT 文件如下： INPUT_PARAMETERS #Parameters (General) calculation md esolver_type sdft pseudo_dir ../../PP_ORB nbands 0 nbands_sto 64 nche_sto 20 method_sto 2 #Parameters (Accuracy) ecutwfc 50 scf_nmax 20 scf_thr 1e-6 symmetry 1 #Parameters (Smearing) smearing_method fd smearing_sigma 7.34986072 #Parameters (MD) md_tfirst 1160400 md_dt 0.2 md_nstep 10 注意要进行分子动力学模拟，calculation 参数需设置为 md。esolver_type 需设置为 sdft，才能进行 SDFT 的计算。这里 nbands 设置为 0，nbands_sto 设置为 64，代表仅仅使用随机轨道而没有 KS 轨道的 SDFT 计算。 五、采用 SDFT 计算态密度 186_PW_SDOS_10D10S 文件夹：采用 SDFT 还可以计算给定体系的态密度（Density of States，简称 DOS）。例如，186_PW_SDOS_10D10S 是一个 1 个 Si 原子的算例，电子温度约为0.6 Ry（约 8.16 eV）。如下所示： INPUT_PARAMETERS #Parameters (1.General) suffix autotest calculation scf esolver_type sdft method_sto 2 nbands 10 nbands_sto 10 nche_sto 120 emax_sto 0 emin_sto 0 seed_sto 20000 pseudo_dir ../../PP_ORB symmetry 1 kpar 1 bndpar 2 #Parameters (2.Iteration) ecutwfc 20 scf_thr 1e-6 scf_nmax 20 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method fd smearing_sigma 0.6 #Parameters (5.Mixing) mixing_type broyden mixing_beta 0.4 out_dos 1 dos_emin_ev -20 dos_emax_ev 100 dos_edelta_ev 0.1 dos_sigma 4 dos_nche 240 npart_sto 2 以上参数在 ABACUS 的线上文档中均有说明，这里再进行简单概述： out_dos：需要设置为 1，才能输出能态密度。 dos_emin_ev：能态密度的能量最小范围，单位 eV。 dos_emax_ev：能态密度的能量最大范围，单位 eV。 dos_edelta_ev：控制输出DOS时的能量间隔，单位 eV。 dos_sigma：能态密度的高斯展宽的因子，单位 eV。 dos_nche：计算能态密度时切比雪夫展开阶数，默认为 100。 npart_sto：当使用 method_sto＝2 运行例如 DOS 的 SDFT 后处理时，将控制使用内存大小为正常的 1/npart_sto，防止内存不够导致无法计算，默认为 1。 注：态密度的输出文件是 OUT 文件夹下的 DOS1_smearing.dat。 六、结尾 总体来讲，随机波函数密度泛函理论方法（SDFT 或者 MDFT）的使用与 KSDFT 并无太大的区别，直接运行 ABACUS 程序即可，但是对一些关键参数的选取会影响精度和效率（例如 nbands, nbands_sto, nche_sto, method_sto, kpar, bnd_par）。对于极端高温计算（>10 eV），使用 SDFT 可以大大提高计算速度，是比普通的 KSDFT 更好的选择。如果大家使用有问题，欢迎写信联系（见上）。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-ofdft.html":{"url":"abacus-ofdft.html","title":"ABACUS 无轨道密度泛函理论方法使用教程","keywords":"","body":"ABACUS 无轨道密度泛函理论方法使用教程 作者：孙亮，邮箱：l.sun@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/07/19 在Bohrium Notebook上快速学习： 一、无轨道密度泛函理论背景知识 无轨道密度泛函理论(Orbital free density functional theory, OFDFT)是一种第一性原理模拟方法，相比于 Kohn Sham DFT (KSDFT)，它的优势之一在于O(N\\ln N)的算法复杂度，这使得 OFDFT 可以用于上万原子甚至更大体系的电子基态计算，或者大体系、长时间的第一性原理分子动力学等。 目前，OFDFT 已被应用于简单金属、合金、半导体、小分子、温稠密物质等体系。 1. 无轨道密度泛函理论 在 OFDFT 的框架下，体系的总能量泛函可以写为 E_{\\rm{OF}}[\\rho] = T_{\\rm{s}}[\\rho] + E_{\\rm{ext}}[\\rho] + E_{\\rm{H}}[\\rho] + E_{\\rm{xc}}[\\rho] + E_{\\rm{II}}. 依次为无相互作用动能T_{\\rm{s}}[\\rho]，电子-离子相互作用能E_{\\rm{ext}}[\\rho]，电子-电子相互作用能E_{\\rm{H}}[\\rho]，交换关联能E_{\\rm{xc}}[\\rho]，离子-离子相互作用能E_{\\rm{II}}，其中\\rho为电荷密度。 为了在粒子数守恒的条件下求解其极小值，利用拉格朗日乘子法，定义 L=E_{OF}[\\rho]-\\mu(\\int{\\rho(r)dr}-N), 可以证明，这里的乘子\\mu就是无相互作用体系中最高占据态的能量，即化学势。为了保证密度处处为正，一般对\\sqrt\\rho进行优化，因此求L对\\sqrt\\rho的导数，为了方便，定义\\phi(r) = \\sqrt {\\rho(r)}，则有 \\frac{\\delta L}{\\delta \\phi}=\\frac{ \\delta E_{OF}[ \\rho ] }{ \\delta \\phi }-2\\mu\\phi=0 \\rightarrow V(r)\\phi(r)=\\mu\\phi(r). \\ \\ \\ \\ \\ \\ \\ \\ (*) 其中V(r)=\\frac{ \\delta E_{OF}[ \\rho ] }{ \\delta \\rho(r) }为势能。这就是 OFDFT 求解的方程，一般用共轭梯度（CG）法、截断牛顿（TN）法或 L-BFGS 等优化算法求解。目前 ABACUS 中实现了 TN 法和两种 CG 法（Polak-Ribire 形式和 Hager-Zhang 形式），默认采用 TN 法。 ABACUS 基于平面波基矢量，实现了上述流程，可以进行基于 OFDFT 的自洽计算，分子动力学计算，以及结构弛豫。 2. 动能泛函 OFDFT 的精度高度依赖于动能泛函（kinetic energy density functional, 简称 KEDF）的精度，目前 ABACUS 中实现了 Thomas-Fermi (TF) [1], von Weizsäcker (vW) [2], TFλvW [3], Wang-Teter (WT) [4], Luo-Karasiev-Trickey (LKT) [5]共五种动能泛函。 下面我们对这些泛函做简单介绍，并且介绍在 ABACUS 的 INPUT 文件中如何设置相关的参数。 2.1 Thomas-Fermi KEDF 设置 INPUT 文件中的 of_kinetic tf 参数 T_{\\rm{TF}}=\\frac{3}{10}(3\\pi^2)^{2/3}\\int{\\rho^{5/3}(r)dr}, 对均匀电子气精确成立，可用于极高温体系，比如处于温稠密状态的金属。 可通过 of_tf_weight 调整其权重，默认为 1。 2.2 von Weizsäcker KEDF 设置 of_kinetic vw T_{\\rm{vW}}=-\\frac{1}{2}\\int{\\sqrt{\\rho(r)} \\nabla^2 \\sqrt{\\rho(r)}dr}, 对单电子、双电子体系（只有一条轨道）严格成立，一般不单独使用。 可通过 of_vw_weight 调整其权重，默认为 1。 2.3 TFλvW KEDF 设置 of_kinetic tf+ T=T_\\text{TF}+\\lambda T_\\text{vW}, 当\\lambda=\\frac{1}{9}时就是TF KEDF的二阶梯度展开，一般\\lambda=\\frac{1}{5}时表现最好。 参数\\lambda可通过of_vw_weight设置，默认为1。 2.4 Wang-Teter KEDF 设置of_kinetic wt T_{\\rm{WT}} = \\frac{3}{10}(3\\pi^2)^{2/3} \\iint{\\rho ^{\\alpha}(r)W(r - r'){\\rho ^{\\beta}}(r') drdr'} + T_{\\rm{vW}} + T_{\\rm{TF}}, 基于 Lindhard 响应函数推导，在简单金属 Li、Mg、Al 中有着不错的表现。是 ABACUS 默认采用的 KEDF。 参数\\alpha,\\beta可通过 of_wt_alpha 和 of_wt_beta 设置，默认值均为\\frac{5}{6}。 2.5 Luo-Karasiev-Trickey KEDF 设置 of_kinetic lkt T_{\\rm{LKT}}= \\int{\\tau_{\\rm{TF}}\\frac{1}{\\cosh as}dr} + T_{\\rm{vW}}, s=\\frac{1}{2(3\\pi^2)^{1/3}}\\frac{|\\nabla\\rho|}{\\rho^{4/3}}. 可用于简单金属和半导体，计算效率较高，但在简单金属中精度低于 WT KEDF。 参数 a 可通过 of_lkt_a 设置，默认值为 1.3。 3. 局域赝势 由于 OFDFT 中舍弃了单电子轨道，无法采用常用的非局域赝势，如模守恒赝势，而必须采用局域赝势。 目前 ABACUS 支持 BLPS (bulk-derived local pseudopotential)。 下载地址： https://github.com/EACcodes/local-pseudopotentials实空间赝势：ABINIT, ABACUS； 倒空间赝势：PROFESS。赝势生成(需要和 ABINIT 7.0.5 结合)：https://github.com/EACcodes/BLPSGenerator覆盖 Li, Mg, Al, Si, P, Ga, As, In, Sb 九种元素 使用 BLPS 时，需要在 ABACUS 里调整的参数有： INPUT 中：pseudo_rcut 16 STRU 中：赝势种类设置为 blps，比如 Al 26.98 al.lda.lps blps 二、ABACUS 中进行 OFDFT 计算的具体流程 1. 自洽计算 1.1 示例 下面是输入文件的示例： INPUT 文件记录 OFDFT 计算所需主要参数 INPUT_PARAMETERS #Parameters (1.General) suffix example calculation scf esolver_type ofdft symmetry 1 pseudo_dir ../../PP_ORB/ pseudo_rcut 16 nspin 1 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 50 #Parameters (3.Basis) basis_type pw #OFDFT of_kinetic wt of_method tn STRU 文件记录元素种类、质量、赝势，晶格矢量，原子坐标等信息 ATOMIC_SPECIES Al 26.98 al.lda.lps blps LATTICE_CONSTANT 7.50241114482312 // add lattice constant LATTICE_VECTORS 0.000000000000 0.500000000000 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 0.500000000000 0.000000000000 ATOMIC_POSITIONS Direct Al 0 1 0.000000000000 0.000000000000 0.000000000000 1 1 1 KPT 文件（因为 OFDFT 没有电子波函数，所以不需要布里渊区的多个 k 点，Gamma 点就可以） K_POINTS 0 Gamma 1 1 1 0 0 0 如上所示，与 KSDFT 的自洽计算相比，OFDFT 自洽计算的输入文件有以下几个区别： INPUT 不需要设置 smearing 和 charge mixing 相关参数，如果设置了也没有关系，这些参数不会影响 OFDFT 计算； 将 esolver_type 设置为 ofdft； 将 pseudo_rcut 设置为 16，以适配 BLPS 赝势。 STRU 将赝势种类设置为 blps。 做完以上调整后，即可使用默认参数进行 OFDFT 的自洽计算。 下面列举一些其它的重要参数： of_kinetic：用于选择动能泛函，可选项有 tf, vw, tf+, wt, lkt，默认值为 wt，具体介绍见 1.2 节； of_method：用于选择优化方法，可选项有 tn, cg1, cg2，分别对应截断牛顿法和两种 CG 法（Polak-Ribire 形式和 Hager-Zhang 形式），默认为 tn。一般而言，效率上 tn > cg2 > cg1； of_full_pw：做快速傅里叶变换（FFT）时，是否使用全部的平面波，默认为 True。建议打开，可以保证计算的稳定性和精度； of_full_pw_dim：控制 FFT 维数的奇偶性，可选项有 0, 1, 2，分别表示可奇可偶，保证为奇数，保证为偶数，默认为 0。FFT 维数为偶数时，可能导致微小的误差，但一般来说可以忽略。需要注意的是，如果打开了 nbspline，则需要设置 of_full_pw_dim 1，否则会导致计算不稳定。 1.2 注意事项 目前 ABACUS 的 OFDFT 模块并不是十分完善，使用时请注意以下几个注意事项： 目前 OFDFT 不支持 gamma only，因此使用 OFDFT 功能时请关闭 gamma_only； 目前 OFDFT 只支持自旋简并，即 nspin 1 的计算； 如果使用 PBE 泛函，建议用 dft_functional XC_GGA_X_PBE+XC_GGA_C_PBE 调用 Libxc 中的 PBE，否则可能导致计算不稳定。 2. 分子动力学与结构弛豫 ABACUS 中支持使用 OFDFT 作为能量、力和应力的求解器，进行分子动力学模拟与结构弛豫。 与使用 KSDFT 进行分子动力学或结构弛豫相比，使用 OFDFT 时，不需要对 MD，relax，或 cell-relax 相关参数进行修改，只需要按照 2.1 中的方式，将能量、力和应力的求解器替换为 OFDFT。 下面是几个实际的 INPUT 例子： 2.1 分子动力学（MD） INPUT_PARAMETERS #Parameters (1.General) suffix test calculation md esolver_type ofdft pseudo_dir ../../PP_ORB pseudo_rcut 16 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #OFDFT of_kinetic wt of_method tn of_full_pw_dim 1 #Parameters (3.Basis) basis_type pw md_restart 0 md_type nvt md_nstep 2 md_dt 0.25 md_tfirst 58022.52706 md_dumpfreq 10 md_tfreq 1.08 md_tchain 1 nbspline 10 2.2 原子结构弛豫（relax） INPUT_PARAMETERS #Parameters (1.General) suffix test calculation relax esolver_type ofdft pseudo_dir ../../PP_ORB pseudo_rcut 16 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #OFDFT of_kinetic wt of_method tn #Parameters (3.Basis) basis_type pw relax_nmax 50 2.3 晶格弛豫（cell-relax） INPUT_PARAMETERS #Parameters (1.General) suffix test calculation cell-relax esolver_type ofdft pseudo_dir ../../PP_ORB pseudo_rcut 16 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #OFDFT of_kinetic wt of_method tn #Parameters (3.Basis) basis_type pw relax_nmax 50 三、参考文献 [1] Fermi E. Statistical method to determine some properties of atoms[J]. Rend. Accad. Naz. Lincei, 1927, 6(602-607): 5. [2] Weizsäcker C F. Zur theorie der kernmassen[J]. Zeitschrift für Physik, 1935, 96(7-8): 431-458. [3] Berk A. Lower-bound energy functionals and their application to diatomic systems[J]. Physical Review A, 1983, 28(4): 1908. [4] Wang L W, Teter M P. Kinetic-energy functional of the electron density[J]. Physical Review B, 1992, 45(23): 13196. [5] Luo K, Karasiev V V, Trickey S B. A simple generalized gradient approximation for the noninteracting kinetic energy density functional[J]. Physical Review B, 2018, 98(4): 041111. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-surface1.html":{"url":"abacus-surface1.html","title":"采用 ABACUS 进行表面计算（一）：静电势和功函数","keywords":"","body":"采用 ABACUS 进行表面计算（一）：静电势和功函数 作者：孙亮，邮箱：l.sun@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/01 一、背景 静电势（electrostatic potential），也叫电势，是指将单位电荷从参考点移动到场内某一点所做的功。 在密度泛函理论的框架下，静电势V_{static}定义为 V_{static} = V_{H}+V_{ext}+V_{efield}+V_{dipole}+... 其中V_{H} = \\int{\\frac{\\rho(r')}{|r-r'|}dr'}为电子产生的静电势，V_{ext}为离子势（赝势的局域部分），V_{field}为外加电场项，V_{dipole}为偶极修正项，输出静电势和输出局域势的差别在于有没有输出交换关联势。 在处理表面等体系时，静电势可用于计算功函数等物理量，并进一步用于催化活性、化学反应机理以及电子输运性质等性质的计算与分析。 ABACUS 提供了直接输出静电势的接口，并提供了对其进行后处理的 python 脚本。 二、ABACUS 中计算静电势具体流程 此功能在平面波基组、原子轨道基组下的 Kohn-Sham DFT（KSDFT），以及随机波函数密度泛函理论和无轨道密度泛函理论中均适用。接下来，我们以平面波基组下的 KSDFT 为例介绍其使用方法，如果需要使用其它的能量求解器，只需要设置 INPUT 文件里的 esolver_type、basis_type 更换能量求解器并设置相应求解器的参数即可。 1. 计算实例 1.1 输出静电势 下面是输入文件的示例： INPUT 文件记录计算所需主要参数，为了输出静电势，只需要设置 out_pot`` ``2 即可（设置 out_pot 1 时，会输出总的局域势，2 相比于 1 少输出了交换关联势，具体可以参考线上文档 https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#out-pot）。 INPUT_PARAMETERS #Parameters (1.General) suffix example calculation scf ntype 1 nbands 40 symmetry 1 pseudo_dir . #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.0074 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.7 out_pot 2 STRU 文件记录元素种类、质量、赝势，晶格矢量，原子坐标等信息 ATOMIC_SPECIES Al 13 Al_ONCV_PBE-1.0.upf LATTICE_CONSTANT 7.6513590200098225 // add lattice constant LATTICE_VECTORS 0.707106781187 0.000000000000 0.000000000000 0.000000000000 0.707106781187 0.000000000000 0.000000000000 0.000000000000 5.000000000000 ATOMIC_POSITIONS Direct Al 0.0 5 0.000000000000 0.000000000000 0.000000000000 1 1 1 0.500000000000 0.500000000000 0.100000000000 1 1 1 0.000000000000 0.000000000000 0.200000000000 1 1 1 0.500000000000 0.500000000000 0.300000000000 1 1 1 0.000000000000 0.000000000000 0.400000000000 1 1 1 KPT 文件 K_POINTS 0 Gamma 20 20 1 0 0 0 如上所示，为了输出静电势，只需要在 INPUT 中设置 out_pot`` ``2，计算完成后即可在 OUTOUT.${suffix} 文件夹下找到下面的 ElecStaticPot.cube 文件。 ElecStaticPot.cube 文件（记录了实空间格点上的静电势，单位是 A.U.，下面的文档中，我们在括号中加入了注释。此文件可以直接在 VESTA 中可视化） Cubefile created from ABACUS SCF calculation. The inner loop is z index, followed by y index, x index in turn. 1 (nspin) 5（总原子数） 0.0 0.0 0.0（原点坐标） 27（沿x轴格点数nx） 0.200383 0.000000 0.000000（晶格矢量a1的1/nx，in Bohr。即晶格常数a*a1/nx） 27（沿y轴格点数ny） 0.000000 0.200383 0.000000（晶格矢量a2的1/ny，in Bohr） 192（沿z轴格点数nz） 0.000000 0.000000 0.199254（晶格矢量a3的1/ny，in Bohr） 13（第一个原子的原子序数） 11（赝势中的价电子数） 0.000000 0.000000 0.000000（该原子位置的笛卡尔坐标，in Bohr） 13 11 2.705164 2.705164 3.825680 13 11 0.000000 0.000000 7.651359 13 11 2.705164 2.705164 11.477039 13 11 0.000000 0.000000 15.302718 （FFT格点上的数据，z坐标变化最快，接下来依次是y, x，一般为6个数据一行，每走完z的一次循环换一行） -1.808618025e+01 -1.683249579e+01 -1.326226499e+01 -8.726520963e+00 -4.859516723e+00 -2.648153424e+00 -1.754646057e+00 -1.082969997e+00 -7.712730497e-01 -5.301070017e-01 -1.865686936e-01 1.178808012e-03 1.531960521e-01 2.434659807e-01 3.236379649e-01 3.580121711e-01 3.871087692e-01 4.067752520e-01 4.191236489e-01 4.303464392e-01 4.269139054e-01 4.072584618e-01 4.012863417e-01 3.694437712e-01 3.419696568e-01 2.751686292e-01 1.986707660e-01 7.265002162e-02 -9.800789596e-02 -3.699329212e-01 ... 5.605648983e-01 5.596641131e-01 5.601221783e-01 5.558024312e-01 5.582286739e-01 5.509517334e-01 5.484144631e-01 5.474458329e-01 5.413456797e-01 5.310960172e-01 5.220139261e-01 5.057932112e-01 4.893954664e-01 4.661977108e-01 4.379332539e-01 3.906110446e-01 3.390039472e-01 2.575599458e-01 1.632711220e-01 1.092880266e-02 -1.657977733e-01 -5.027618535e-01 -7.758727829e-01 -1.023213291e+00 -1.643162715e+00 -2.406825325e+00 -4.139043775e+00 -7.343485448e+00 -1.119104878e+01 -1.435478802e+01 1.2 后处理 为了方便计算沿着 z 方向的平均静电势，我们在 tools/average_pot 下提供了 python 后处理脚本 aveElecStatPot.py，在存放 ElecStaticPot.cube 的文件夹下运行 python path_to_abacus/tools/average_pot 即可在此文件夹中得到存放了平均静电势的 ElecStaticPot_AVE 文件，如下所示。 ElecStaticPot_AVE 文件（存放了沿 z 方向的平均静电势，单位是 A.U.。此文件的前 11 行与 ElecStaticPot.cube 相同，之后的第一列数为沿着 z 轴的格点指标，第二列数为平均静电势） Average electrostatic potential along z axis 1 (nspin) 5 0.0 0.0 0.0 27 0.200383 0.000000 0.000000 27 0.000000 0.200383 0.000000 192 0.000000 0.000000 0.199254 13 11 0.000000 0.000000 0.000000 13 11 2.705164 2.705164 3.825680 13 11 0.000000 0.000000 7.651359 13 11 2.705164 2.705164 11.477039 13 11 0.000000 0.000000 15.302718 iz average 0 -1.021155030e+00 1 -9.476023401e-01 2 -7.542571394e-01 3 -5.200099451e-01 ... 189 -5.039597208e-01 190 -7.447469356e-01 191 -9.431350596e-01 可视化后如图所示： 1.3 功函数 功函数（work function），又称逸出功，描述把电子从固体内部移到真空中所需的最小能量。 在 DFT 计算中，它可以定义为V_{vaccum} - E_F，其中V_{vaccum}为真空静电势，可以在 ElecStaticPot_AVE 中读到，E_F为体系费米能，可以用 grep EFERMI OUT.${suffix}/running_scf.log 命令从 OUT.${suffix}/running_scf.log 文件中提取出来。 对于上面的例子，V_{vaccum} = 0.563\\ \\rm{Ry}，E_F=3.3293551883\\ \\rm{eV}\\approx0.245\\ \\rm{Ry}，因此功函数为V_{vaccum} - E_F = 0.318\\ \\rm{Ry}。 如果大家使用有问题，欢迎写信联系（见上）。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-01 12:34:08 "},"abacus-surface2.html":{"url":"abacus-surface2.html","title":"采用 ABACUS 进行表面计算（二）：偶极修正","keywords":"","body":"采用 ABACUS 进行表面计算（二）：偶极修正 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/08/28 一、偶极修正介绍（Dipole Correction） 偶极矩（Dipole Moment）是一个矢量，由正、负电荷中心距离和其所带电量乘积得到，方向规定为正电中心指向负电中心，采用原子建模表面时，往往表面会产生偶极矩。 ABACUS 在 xyz 三个方向都采用周期性边界条件（Periodic Boundary Conditions），当使用密度泛函理论（Density Functional Theory，简称 DFT）进行表面体系的电子结构计算时常采用超胞（Supercell）近似，这时所研究的体系在真空方向会出现两个表面。当两个表面不对称时（例如在某表面进行吸附原子计算），这两个表面的电荷密度分布就会不同，这个时候两个表面的偶极密度不同且表面附近的静电势（Electrostatic Potential）会呈现不同的值。然而，周期性边界条件的存在会强制使得静电势也要满足周期性边界条件，这个时候周期性边界条件的存在相当于制造了一个非物理的人造电场（Artificial Electric Field）。 通常情况下，降低这个人造电场的方法是加大真空层的厚度，使得相邻的超胞之间没有相互作用，但这往往要大幅增加密度泛函理论的计算量。因此，为了消除周期性边界条件对表面偶极矩带来的影响，我们可以采用偶极修正（Dipole Correction）的方法，通过引入另外一个外电场来抵消这个人造电场，但注意引入的外电场需要存在于真空中（其位置是程序输入参数的一部分）才不至于影响所要研究的表面体系。经过修正后，人造电场将被抵消，真空电势则维持不变。 ABACUS 中实现了偶极修正功能[1]，可以有效的加速静电势收敛，避免超胞的真空取得太长，从而可以降低计算量。该修正功能主要体现在 Hartree 项的处理上，并且存在相应的原子受力的修正，可以用于平面波（Plane-Wave）基组和数值原子轨道（Numerical Atomic Orbitals）基组计算，但注意该功能只能用于带真空层的表面体系。 二、文档与算例 ABACUS 里关于偶极修正的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/scf/advanced.html#dipole-correction ABACUS 里关于偶极修正参数的线上文档地址为：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#electric-field-and-dipole-correction ABACUS 的偶极修正算例下载地址为（gitee）： https://gitee.com/MCresearch/abacus-user-guide/tree/master/examples/dipole_correction/H2O 可以采用的下载命令是： git clone https://gitee.com/MCresearch/abacus-user-guide 之后进入 /abacus-user-guide/examples/``dipole_correction/H2O/ 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/dipole_correction/H2O 三、偶极修正输入参数介绍 INPUT_PARAMETERS #Parameters (1.General) suffix H2O calculation scf nbands 6 symmetry 0 pseudo_dir ../../PP_ORB #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method fixed #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.7 #Parameters (6.Dipole correction) efield_flag 1 dip_cor_flag 1 efield_pos_max 0.0 efield_pos_dec 0.1 efield_amp 0.00 #Parameters (7.Output) out_pot 2 以算例提供的 INPUT 文件为例，使用偶极修正方法只需添加如下参数即可： efield_flag：类型是 Bool，指定外加电场的开(1)或者关(0)，默认值为 0，注意应用偶极修正功能时，efield_flag 必须设为 true dip_cor_flag：类型是 Bool，指定偶极修正的开(1)或者关(0)，默认值为 0 efield_dir：类型是 Int，外加电场方向，可取 0，1，2 分别表示 x，y，z 方向，默认值为 2 efield_pos_max：类型是 Real，锯齿状电势最大值所在分数坐标，范围[0,1)，默认值为 0.5 efield_pos_dec：类型是 Real，锯齿状电势从最大值到最小值的长度（同样以分数坐标为度量），默认值为 0.1，范围[0,1)。以图1为例，0.5 是最大值，0.6 是最小值，那么 0.5 ~ 0.6 的区域必须放置在没有原子的真空层中 图 1. 锯齿状势场分布图 efield_amp：类型是 Real，电场强度，默认值为 0，单位为 a.u.，其中 1 a.u. = 51.4220632*10^10 V/m。在偶极修正时需要设为 0，不为 0 则说明同时添加了外加电场和偶极修正 四、预期结果 如图2所示，一个水分子位于超胞（尺寸为 3\\times3\\times18 Å^3）的中部（即位于9 Å），那么按照上一部分的说明，锯齿应该放在没有原子的真空处，因此我们将电势的最大值所在的位置设为 efield_pos_max 设为 0.0，之后设置电势从最大值到最小值的长度，即将 efield_pos_dec 设为 0.1（在这个例子是 1.8 Å），如此锯齿即位于 0.0~0.1 的区域。 为了验证结果的正确性，我们可以画出静电势沿 Z 轴（c 方向）的变化如图3所示。在水分子上方（9-18 Å）和下方（0-9 Å）的真空层中，静电势在很长一段区间保持常数不变，出现了两个平台，这说明我们的偶极修正功能使用无误。静电势计算和作图方法请参考静电势和功函数计算文档。 图 2. 一个水分子位于超胞中，红色代表氧原子，白色代表氢原子 图 3. 静电势沿超胞Z轴变化图 五、参考文献 [1] Phys. Rev. B 59, 12301 (1999), https://doi.org/10.1103/PhysRevB.59.12301 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-20 16:41:21 "},"abacus-surface5.html":{"url":"abacus-surface5.html","title":"采用 ABACUS 进行表面计算（五）：外加电场","keywords":"","body":"采用 ABACUS 进行表面计算（五）：外加电场 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/08/28 一、介绍 电场是电荷及变化磁场周围空间里存在的一种特殊物质。这种物质与通常的实物不同，它虽然不是由分子原子所构成的，但它却是客观存在的特殊物质，具有通常物质所具有的力和能量等客观属性。许多材料在外加电场作用下会表现出不同寻常的性质，例如：铁电体在外加电场的作用下会产生电极化，也可以通过施加的电场来控制磁性和自发极化，因此在信息储存和传输中有广泛应用；二维材料（如石墨烯）在外加电场下表现出不同的电子性质和可控制的物理性质，这种特性使其具有在电子学领域的广泛应用前景。在电子结构计算中，周期性边界条件下对体系施加电场较为容易，而施加磁场则困难很多。 因此，外加电场是密度泛函理论（Density Functional Theory，简称 DFT）软件中可以被实现且重要的功能。ABACUS 中实现了在表面体系中外加恒定电场的功能[1]。注意，在 ABACUS 中，外加电场功能存在相应的原子受力的修正，可以用于平面波（Plane-Wave）基组和数值原子轨道（Numerical Atomic Orbitals）基组计算，但注意该功能只能用于带真空层的表面体系。 本教程中将会展示如何在 ABACUS 计算中使用加电场功能，为使得这个教程较为有趣，我们举一个半金属二维材料 nanoribbon（见图 1）加电场产生半金属的例子来讲解如何给体系添加电场，该 DFT 的计算工作曾发在 2006 年的 Nature 杂志上，具体可参考文献[2]。在这个教程里，我们使用的是数值原子轨道基矢量（Numerical Atomic Orbitals），碳和氢的轨道半径都是 8 a.u.，但实际上也可以使用平面波基矢量，只是前者效率更高所以在这里采用。我们还会使用到电子的自洽场（self-consistent field，简称 SCF）计算，非自洽计算（non-self-consistent field，简称 NSCF），自旋非极化和极化计算等概念。在不考虑自旋时（即设置 nspin=1 时），计算出的能带图中没有带隙，为金属；考虑自旋之后，带隙打开，成为半导体；在自旋极化基础上，外加恒定电场之后，其中一个自旋表现为半导体，另一个自旋则为金属。 图 1. Nanoribbon结构图，黑框代表超胞大小，有真空。超胞里包含32个碳原子（棕色），超胞里接触真空的2个碳原子（每个表面一个碳原子）被2个氢原子（白色）饱和。 二、软件和算例准备 ABACUS 里关于外加电场的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/scf/advanced.html#external-electric-field ABACUS 里关于外加电场参数的线上文档地址为：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#electric-field-and-dipole-correction ABACUS 的外加电场算例下载地址为（gitee）： https://gitee.com/MCresearch/abacus-user-guide/tree/master/examples/electric_field/ 可以采用的下载命令是： git clone https://gitee.com/MCresearch/abacus-user-guide 下载后解压，之后进入 /abacus-user-guide/examples/``electric_field 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide 三、采用加电场进行二维材料的能带计算 该算例中含有六个文件夹，解释如下： 1_unspin_scf：做非自旋极化（INPUT 文件中的 nspin 设为 1）的自洽场迭代 SCF 计算（INPUT 文件中的 calculation 设为 scf），输出自洽迭代之后的电子密度（将 INPUT 中的 out_chg 设为 1），注意二维材料的 KPT 文件，因为超胞大小是 102.459512146645 Å^3，所以对应的布里渊区 k 点取的是 1101，因为实空间周期长度小的方向对应的布里渊区大，所以需要取更多 k 点得到收敛结果。 2_unspin_band： 采用非自洽计算 NSCF（INPUT 文件中的 calculation 设为 nscf），读入上一个步骤输出的电荷密度（INPUT 文件中的 init_chg 设为 file），从而可以读入体系的基态电荷密度进行能带计算。 3_spin_scf：同 1_unspin_scf 的计算，只是把 nspin 设为 2。 4_spin_band：同 2_unspin_band 的计算，只是把 nspin 设为 2。 5_spin_elec_scf：同 3_spin_scf 的计算，只是又外加了电场的参数。 6_spin_elec_band：同 4_spin_band 的计算，只是又外加了电场的参数。 以下是算例 5 的输入文件（包含电场参数）： INPUT_PARAMETERS #Parameters (General) suffix nanoribbon calculation scf nbands 70 nspin 2 pseudo_dir ../../PP_ORB orbital_dir ../../PP_ORB #Parameters (Basis) basis_type lcao #Parameters (Accuracy) ecutwfc 100 scf_thr 1e-6 scf_nmax 200 #Parameters (Smearing) smearing_method gaussian smearing_sigma 0.001 #Parameters (Charge mixing) mixing_type pulay mixing_beta 0.1 mixing_ndim 20 mixing_gg0 1.5 #Parameters (Efield) efield_flag 1 efield_dir 2 efield_amp 0.0019440124 efield_pos_max 0.95 efield_pos_dec 0.10 以算例提供的 INPUT 文件为例，使用外加电场功能只需添加如下参数即可： efield_flag：类型是 Bool，指定外加电场的开(1)或者关(0)，默认值为 0 efield_dir：类型是 Int，外加电场方向，可取 0，1，2 分别表示 x，y，z 方向，默认值为 2 efield_pos_max：类型是 Real，锯齿状电势最大值所在分数坐标，范围[0,1)，默认值为 0.5 efield_pos_dec：类型是 Real，锯齿状电势从最大值到最小值的长度（同样以分数坐标为度量），默认值为 0.1，范围[0,1)。以图2为例，0.5 是最大值，0.6 是最小值，那么 0.5 ~ 0.6 的区域必须放置在没有原子的真空层中，注意这个例子设置的是 0.95 到 0.10 为电场区间。 图 2. 锯齿状势场分布图 efield_amp：类型是 Real，电场强度，默认值为 0，单位为 a.u.，其中 1 a.u. = 51.4220632*10^10 V/m 以上参数的使用方法在采用 ABACUS 进行表面计算（二）：偶极修正中有更详细的说明。 四、预期计算结果 运行完算例 2_unspin_band 后会通过非自洽计算得到体系非自旋极化能带图，横坐标是对二维材料布里渊区取 k 点，从 Gamma 点（坐标为 0 0 0）取到\\pi点（坐标为 0 0.5 0），取了 100 个 k 点算出来的能带图；纵坐标是能级，将费米面设置为 0，取了费米面附近 2 eV 的能量区间画出能带。以下两张图是同样取法。 运行完算例 4_spin_band 后会得到非自洽计算得到的自旋极化能带图（图 3）。 运行完算例 6_spin_elec_band 后会得到自旋极化加电场的能带图（图 4），注意这里所加的电场为 0.1 V/Å，由输入文件 INPUT 中的 efield_amp 设置，但 efield_amp 的单位是 a.u.，需要换算。 图 3. 采用PBE交换关联泛函和非自旋极化得到的二维nanoribbon的能带图，可以看出费米面附近CBM（Conduction Band Minimum）和VBM（Valence Band Maximum）重合，无带隙。 图 4. 采用PBE交换关联泛函和自旋极化得到的二维nanoribbon的能带图。蓝色和红色代表自旋极化方向不同时对应的两副能带图像，可以看出不加电场时，两个自旋方向的能带图几乎一样，都有带隙。 图 5. 采用PBE交换关联泛函和自旋极化，再给体系加上0.1 V/Å的电场得到的二维nanoribbon的能带图。蓝色和红色代表自旋极化方向不同时对应的两副能带图像，可以看出加了能带之后，其中一个自旋方向的能带图出现费米面附近的交叠，呈现金属性质，另外一个自旋方向的能带图依旧保持在费米面处的能隙。 五、参考文献 [1] Phys. Rev. B 59, 12301 (1999), https://doi.org/10.1103/PhysRevB.59.12301 [2] Nature 444, 347–349 (2006), https://doi.org/10.1038/nature05180 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-20 16:44:22 "},"abacus-surface6.html":{"url":"abacus-surface6.html","title":"采用 ABACUS 进行表面计算（六）：补偿电荷","keywords":"","body":"采用 ABACUS 进行表面计算（六）：补偿电荷 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/08/28 一、介绍 现实中的化学反应多数时候发生在恒定电势条件下，而传统的 DFT 计算软件则是基于恒定电荷的条件。若要在计算模拟中保持恒定电势，在电化学表面反应建模时就需要调整晶胞中的电子数。在开源密度泛函理论软件 ABACUS 里，模拟体系时使用的是周期性边界条件，因此需要添加额外的算法保持模拟过程中同时保证超胞的电中性。其中的一种方案就是当从系统中添加/提取额外的电子时，需要在表面模型的真空区域中实现补偿电荷的分布。 目前 ABACUS 软件中实现了补偿电荷功能[1]，与增减电子数相对应的补偿电荷会以带电平板的形式（不考虑平板厚度）予以补偿进而保持电中性，并且存在相应的原子受力的修正，可以用于平面波（Plane-Wave）基组和数值原子轨道（Numerical Atomic Orbitals）基组计算，但注意目前该功能只能用于带真空层的表面体系。我们以下的例子以一个水分子为例，如图 1 所示。 图 1. 一个水分子位于超胞中，红色代表氧原子，白色代表氢原子 二、文档与算例 ABACUS 里关于补偿电荷的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/scf/advanced.html#compensating-charge ABACUS 里关于补偿电荷参数的线上文档地址为：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#gate-field-compensating-charge ABACUS 的补偿电荷算例下载地址为（gitee）： https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/compensating_charge/H2O 可以采用的下载命令是： git clone https://gitee.com/mcresearch/abacus-user-guide 之后进入 /abacus-develop/``examples/compensating_charge/H2O 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/compensating_charge/H2O 三、偶极修正与补偿电荷结合的表面计算 在采用 ABACUS 进行表面计算（二）：偶极修正文档中，我们给出了水分子层计算中应用偶极修正之后的结果。在此基础上，我们可以进一步应用补偿电荷功能。如图 1 所示，我们采用了完全相同的一个水分子在周期性晶胞的结构，只有 INPUT 文件中添加了补偿电荷相关参数。 INPUT_PARAMETERS #Parameters (1.General) suffix H2O calculation scf nbands 8 symmetry 0 pseudo_dir ../../PP_ORB #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.001 #Parameters (5.Mixing) mixing_type broyden mixing_beta 0.1 #Parameters (6.Dipole correction) efield_flag 1 dip_cor_flag 1 efield_pos_max 0.0 efield_pos_dec 0.1 efield_amp 0.0 #Parameters (7.Compensating charge) gate_flag 1 zgate 0.7 nelec 9 #Parameters (8.Output) out_pot 2 以算例提供的 INPUT 文件为例，使用补偿电荷功能只需添加如下参数即可： gate_flag：类型是 Bool，指定补偿电荷功能的开(1)或者关(0)，默认值为 0 efield_dir：类型是 Int，指定与带电平板垂直的方向，可取 0，1，2 分别表示 x，y，z 方向，默认值为 2 zgate：类型是 Real，指定带电平板（位于真空中）在晶胞中的位置（分数坐标），范围[0,1)，默认值为 0.5 nelec：类型是 Real，设定的体系总电子数，这里是 9 个电子（氧原子因为赝势有 6 个电子，每个氢原子有 1 个电子，总共 8 个电子），即原体系多加了 1 个电子，那么为了保持电中性，带电平板会带 1 个正电荷 block：类型是 Bool，添加势垒以防止电子溢出的功能（可选），1 代表开，0 代表关，默认值为 0 block_down：类型是 Real，势垒的起点（分数坐标），默认是 0.45 block_up：类型是 Real，势垒的终点（分数坐标），默认是 0.55 block_height：类型是 Real，势垒高度，单位是里德堡（Rydberg），默认是 0.1 四、预期结果 如左下图所示，一个水分子位于超胞（尺寸为 3\\times3\\times18 \\mathrm{\\AA^3}）的中部（即位于9 \\mathrm{\\AA}）。按照采用 ABACUS 进行表面计算（二）：偶极修正文档中偶极修正参数设置的说明，锯齿即位于 0.0~0.1 的区域。注意在采用偶极修正/外加电场功能的情况下，带电平板的位置应该在真空区域，并且不同于偶极修正锯齿所在的区域。 为了验证结果的正确性，我们可以画出静电势沿 Z 轴（c 方向）的变化如图 2 所示。与只应用偶极修正功能的静电势相比（可参考表面计算二里面的图 3），在分数坐标 0.7（Z 轴 12.6 埃）处，静电势出现了一个向下的凹陷，这来自于此处的补偿电荷带电平板的影响。 静电势计算和作图方法请参考静电势和功函数计算文档。 图 2. 静电势（Electrostatic Potential）沿超胞Z轴变化图 五、参考文献 [1] Phys. Rev. B 89, 245406 (2014), https://doi.org/10.1103/PhysRevB.89.245406 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-01 12:40:40 "},"abacus-phonopy.html":{"url":"abacus-phonopy.html","title":"ABACUS+Phonopy 计算声子谱","keywords":"","body":"ABACUS+Phonopy 计算声子谱 作者：赵天琦，邮箱：zhaotq13@tsinghua.org.cn；陈涛，邮箱：chentao@stu.pku.edu.cn 审核：刘建川，邮箱：liujianchuan2013@163.com 最后更新时间：2023/08/14 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍采用 ABACUS（基于 ABACUS 3.2.2 版本）做密度泛函理论计算，并且结合 Phonopy 软件计算声子谱的流程。此外，本教程还用到 gnuplot 来绘图。 首先推荐大家阅读以下文档中的详细说明： ABACUS 官方文档：Phonopy - ABACUS documentation Phonopy 相关文档：ABACUS & phonopy calculation — Phonopy v.2.19.1 Gnuplot 主页：gnuplot homepage 二、准备 我们以 FCC Al 这个简单例子来演示使用 有限位移方法 来结合 ABACUS 和 Phonopy 计算声子谱。 1. 下载并安装 Phonopy git clone https://github.com/phonopy/phonopy.git cd phonopy python3 setup.py install 2. 下载 FCC Al 例子 可以从 Gitee 上下载。可以在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载后解压，之后进入 abacus-user-guide/examples/interface_Phonopy 文件夹 三、流程 1. 使用 ABACUS 优化结构 这里我们已经给出一个已经优化好的 FCC Al 结构 ABACUS 中的结构文件名为 STRU： ATOMIC_SPECIES Al 26.982 Al_ONCV_PBE-1.0.upf upf201 NUMERICAL_ORBITAL Al_gga_7au_100Ry_4s4p1d.orb LATTICE_CONSTANT 1.88972612546 LATTICE_VECTORS 4.03459549706 0 0 #latvec1 0 4.03459549706 0 #latvec2 0 0 4.03459549706 #latvec3 ATOMIC_POSITIONS Direct Al #label 0 #magnetism 4 #number of atoms 0 0 0 m 0 0 0 0.5 0.5 0 m 0 0 0 0.5 0 0.5 m 0 0 0 0 0.5 0.5 m 0 0 0 2. 用 Phonopy 产生需要计算的超胞及相应微扰构型 这里我们使用 有限位移方法 计算声子谱，因此需要对晶格进行扩胞并对原子位置进行微扰。执行如下命令即可生成 222 的扩胞并产生微扰结构： phonopy -d --dim=\"2 2 2\" --abacus 这一步 phonopy 会根据晶格对称性自动产生相应个数的微扰结构。由于 FCC 的晶格对称性较强，因此这个例子只产生一个微扰结构：STRU-001。这里类似 K 点的对称性分析，晶体结构对称性越强，所需的微扰结构就越少，对称性稍差的体系一般会产生多个微扰结构。 经验性设置：1）扩胞越大，计算结果越精确，但是计算量也会上升，一般来说扩胞三个方向的 cell 长度均在 10-20 Å 是比较合适的；2）对于优化后的晶胞（复杂体系），原子位置可能不处于高对称点上，phonopy 可能计算存在一定的误差，可以使用 Matertial Studio 等软件把对称性加回去之后，再做上述步骤，这样能够得到准确的声子谱数据（保证计算出来的声子谱满足体系的对称性特征）。 3. 产生 FORCE_SET 文件 接着用 ABACUS 计算原子受力，其中需要注意的是 calculation 需要设置为 scf，并且设置 cal_force 为 1，因为这一步目的是输出原子受力。 小技巧：即为了计算不同的微扰结构的受力，可以在 INPUT 里添加关键字 stru_file 来指定 STRU 文件的路径和文件名：stru_file ./STRU-001 INPUT 内容如下： INPUT_PARAMETERS #Parameters (1.General) suffix Al-fcc calculation scf esolver_type ksdft symmetry 1 pseudo_dir ./psp orbital_dir ./psp cal_stress 1 cal_force 1 stru_file STRU-001 #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-7 scf_nmax 50 #Parameters (3.Basis) basis_type lcao gamma_only 0 #Parameters (4.Smearing) smearing_method mp smearing_sigma 0.015 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.7 mixing_gg0 1.5 算完之后用以下命令产生 FORCE_SET 文件： phonopy -f ./disp-001/OUT/running_scf.log ./disp-002/OUT/running_scf.log ... 即要指定所有微扰构型算完之后的 running_scf.log 文件位置。如果运行有错，需要首先检查是否所有构型都已正常结束，且其中有力输出（可以找“FORCE”来确认）。 4. 设置 band.conf 文件计算得到声子谱 执行如下命令： phonopy -p band.conf --abacus band.conf 内容如下： ATOM_NAME = Al DIM = 2 2 2 MESH = 8 8 8 PRIMITIVE_AXES = 0 1/2 1/2 1/2 0 1/2 1/2 1/2 0 BAND = 1 1 1 1/2 1/2 1 3/8 3/8 3/4 0 0 0 1/2 1/2 1/2 BAND_POINTS = 101 BAND_CONNECTION = .TRUE. 这一步结束之后会有 band.yaml 文件输出 以上参数在 Phonopy 的线上文档中均有详细说明，这里再进行简单概述： ATOM_NAME：指定结构文件中的元素种类。 DIM：扩胞的大小，需要跟 3.2 用Phonopy产生需要计算的超胞及相应微扰构型 中的“dim”一致。 MESH：q 点的采样网格。‘8 8 8’意味着采用 888 的 q 点网格，默认以（0，0，0）为中心。 PRIMITIVE_AXES：输入晶胞到目标原胞的转换矩阵，并将根据原胞基矢量作为声子计算的坐标系。这里是 FCC 的原胞转换矩阵。 BAND：采样能带的 q 点路径。不同晶格的高对称点不同，具体可以使用 SeeK-path，自动生成 q 点路径。 BAND_POINTS：给出了包括能带路径末端的采样点的数量。 BAND_CONNECTION：在能带交叉处辅助连接能带。 5. 绘制声子谱 本教程使用 gnuplot 绘制声子谱，在 Ubuntu 上 gnuplot 的安装如下： sudo apt-get install gnuplot 用如下命令输出 gnuplot 格式的声子谱，并使用 gnuplot 绘制声子谱并存为 Al-FCC_plot.png： phonopy-bandplot --gnuplot > pho.dat gnuplot plot_pho.gp plot_pho.gp 内容如下： set terminal pngcairo size 1920, 1080 font 'Arial, 36' ## 格式，大小和字体 set output \"Al-FCC_plot.png\" ###输出的文件名 set ylabel 'Frequency (THz)' set ytics 2 unset key x1 = 0.13115990 x2 = 0.17753200 x3 = 0.31664810 xmax = 0.43023590 ymin = 0 ymax = 12 set xrange [0:xmax] set yrange [ymin:ymax] set xtics (\"{/Symbol G}\" 0, \"X\" x1, \"K\" x2, \"{/Symbol G}\" x3, \"L\" xmax) set arrow 1 nohead from x1,ymin to x1,ymax lt 2 set arrow 2 nohead from x2,ymin to x2,ymax lt 2 set arrow 3 nohead from x3,ymin to x3,ymax lt 2 plot 'pho.dat' using 1:($2) w l lw 3 FCC Al 的声子谱： 也可使用 Origin 绘图，pho.dat 的第一列就是上图的横轴（K 点路径），其中高对称 K 点位置见 pho.dat 的第二行，第二列就是上图的纵轴（声子频率，单位 THz）。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-shengbte.html":{"url":"abacus-shengbte.html","title":"ABACUS+ShengBTE 计算晶格热导率","keywords":"","body":"ABACUS+ShengBTE 计算晶格热导率 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/15 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍采用 ABACUS（基于 ABACUS 3.2.0 版本）做密度泛函理论计算，并且结合 ShengBTE 软件计算晶格的热导率的流程。其中，整个计算过程中还用到了：1）采用 Phonopy 程序来计算二阶力常数，2）采用 ASE 程序进行原子结构的转换，3）采用 ShengBTE 的 thirdorder 程序计算三阶力常数，4）最后使用 ShengBTE 来计算材料的晶格热导率。 上述提到了一些需要结合的外部软件，这里推荐大家阅读这些软件的相关文档和说明： ShengBTE：https://bitbucket.org/sousaw/shengbte/src/master/ phonopy：http://abacus.deepmodeling.com/en/latest/advanced/interface/phonopy.html ASE：http://abacus.deepmodeling.com/en/latest/advanced/interface/ase.html thirdorder: https://bitbucket.org/sousaw/thirdorder/src/master/ 二、准备 ABACUS 的软件包中提供了一个 ABACUS+ShengBTE 计算晶格热导率的算例，可以从 Gitee 上下载。算例中包含采用数值原子轨道的 LCAO（Linear Combination of Atomic Orbitals）和采用平面波基矢量的 PW（Plane Wave，平面波）两个文件夹。每个文件夹下分别又包含了 2nd、3rd 和 shengbte 这三个文件夹，分别保存了使用 phonopy 计算二阶力常数（2nd）、thirdorder 计算三阶力常数（3rd）和 ShengBTE 计算晶格热导率（shengbte）的相关文件。 三、流程 以 LCAO 文件夹为例，我们这里提供的测试案例是包含 2 个原子的金刚石结构 Si 结构，采用的模守恒赝势是 Si_ONCV_PBE-1.0.upf，以及原子轨道文件采用的是 Si_gga_7au_100Ry_2s2p1d.orb（GGA 泛函，7 au 截断半径，100 Ry 能量截断，以及包含 2s2p1d 的 DZP 轨道）。 1. 计算二阶力常数 要计算二阶力常数，除了 ABACUS 之外，还需要结合 Phonopy 和 ASE。首先，进入 2nd 文件夹。 1.1 结构优化 做晶格热导率计算之前要先对模拟的材料体系的进行原子构型的优化。下面是采用 ABACUS 做结构优化（relax）后得到的原子构型文件 STRU。在这个例子里，为了简单起见，结构优化过程采用的是 2*2*2 的布里渊区 k 点采样，平面波的能量截断值 ecut（LCAO 里面也用到了平面波基矢量）为 100 Ry，注意实际计算中应该要采用更收敛的 k 点采样。 ATOMIC_SPECIES Si 28.0855 Si_ONCV_PBE-1.0.upf NUMERICAL_ORBITAL Si_gga_7au_100Ry_2s2p1d.orb LATTICE_CONSTANT 1.88972612546 LATTICE_VECTORS 0 2.81594778072 2.81594778072 #latvec1 2.81594778072 0 2.81594778072 #latvec2 2.81594778072 2.81594778072 0 #latvec3 ATOMIC_POSITIONS Direct # direct coordinate Si #label 0 #magnetism 2 #number of atoms 0.875 0.875 0.875 m 0 0 0 0.125 0.125 0.125 m 0 0 0 注意：第一行 Si 的质量 28.0855 在计算中不起作用。 1.2 计算二阶力常数 调用 Phonopy 软件产生需要计算的超胞及相应微扰的多个原子构型，命令如下： phonopy setting.conf --abacus -d 其中 setting.conf 文件的内容为： DIM = 2 2 2 ATOM_NAME = Si 这里我们采用的 Si 的例子只需要产生 1 个微扰构型 STRU-001 即可，对所有微扰构型（这里 Si 的例子只有 1 个）进行 SCF 计算（SCF 代表 Self-consistent field，这里代表进行密度泛函理论的电子迭代自洽计算）获得原子受力，算完之后用以下命令产生 FORCE_SET 文件： phonopy -f OUT.DIA-50/running_scf.log 小技巧：在 ABACUS 的输入文件 INPUT 中可以设置变量 stru_file，该变量对应的原子构型文件为 STRU-001 则 ABACUS 可以直接读取该结构文件。 下一步，设置 band.conf 文件计算得到声子谱以及二阶力常数： phonopy -p band.conf --abacus 这里出现的 band.conf 文件，其内容如下（具体参数含义可以查看 Phonopy 说明文档）： ATOM_NAME = Si DIM = 2 2 2 MESH = 8 8 8 PRIMITIVE_AXES = 1 0 0 0 1 0 0 0 1 BAND = 0.0 0.0 0.0 0.5 0.0 0.5 0.625 0.25 0.625, 0.375 0.375 0.75 00 0.0 0.0 0.5 0.5 0.5 BAND_POINTS = 101 BAND_CONNECTION = .TRUE. FORCE_CONSTANTS = WRITE FULL_FORCE_CONSTANTS = .TRUE. 这一步结束之后，Phonopy 软件会产生 band.yaml（用于绘制声子谱）和 FORCE_CONSTANTS 文件。其中，FORCE_CONSTANTS 文件包含的数据即为二阶力常数，注意这里务必设置 FULL_FORCE_CONSTANTS = .TRUE.，输出全部的二阶力常数，否则 ShengBTE 读取数据会报错。 此外，可以使用如下命令输出 gnuplot 格式的声子谱，用于绘制声子谱： phonopy-bandplot --gnuplot > pho.dat 1.3 后处理 注意 ShengBTE 软件要求 FORCE_CONSTANTS_2ND 文件里数据的单位为 eV/Å^2，但是 ABACUS 结合 phonopy 计算的 FORCE_CONSTANTS 单位为 eV/(Å*au)，其中 au 是原子单位制，1 au=0.52918 Å。可以使用 2nd 目录下提供的 au2si.py 脚本进行单位转换，生成 FORCE_CONSTANTS_2ND 文件，命令如下： python au2si.py 在 shengbte 文件夹中提供了 FORCE_CONSTANTS_2ND 文件供参考计算结果。 2. 计算三阶力常数 要计算三阶力常数，需要结合 thirdorder 程序，计算后输出三阶力常数文件 FORCE_CONSTANTS_3RD。但是，thirdorder 目前只支持读取 VASP 和 QE 的输入输出文件。因此，这里我们是通过将 ABACUS 的结构文件和输出受力分别转换为 POSCAR 和 vasprun.xml 来使用 thirdorder，请先进入 3rd 文件夹，具体步骤将在以下叙述。 2.1 获得微扰构型 首先将 ABACUS 软件进行结构优化（relax）后的 STRU 文件转化为 POSCAR（目录下已给出转化过的 POSCAR，或者需要自己动手进行这个转换）。 之后，运行 thirdorder_vasp 程序，产生微扰过后的一系列原子构型文件 3RD.POSCAR.*，例如这个例子一共产生了 40 个构型： thirdorder_vasp.py sow 2 2 2 -2 运行 pos2stru.py，将上述 POSCAR 转化为 STRU 文件，注意该脚本里调用了 ASE 软件包的函数（需提前安装好 ASE）： python pos2stru.py 注意：这里不能调用 dpdata 软件进行转化。因为 dpdata 会强制将晶格改为下三角矩阵，相当于旋转了晶格，会导致原子间受力方向也相应旋转，从而发生错误。 2.2 计算微扰构型的原子受力 可以参考目录下 run_stru.sh 使用脚本批量产生 SCF-* 文件夹并提交计算，这里需要采用 ABACUS 对 40 个原子构型分别进行 SCF 计算，会有些耗时。建议每个 SCF 单独在 SCF-* 文件夹内运行，这里的 INPUT 中的scf_thr 需要至少小到1e-8才能得到收敛的结果。 计算完成后，运行 aba2vasp.py，将 ABACUS 计算的原子受力包装成 vasprun.xml 格式，放置在每个 SCF-* 文件夹中，命令如下： python aba2vasp.py vasprun.xml 格式示意： 1.865e-05 -0.04644196 -0.00153852 -1.77e-05 -0.00037715 -0.00149635 1.973e-05 0.002213 -0.00149461 -1.976e-05 0.00065303 -0.0014804 8.31e-06 -0.0003306 -0.00024288 -8.25e-06 -0.00038306 -0.00025385 1.071e-05 0.00060621 -0.00025797 -1.05e-05 -0.00014553 -0.00027532 0.00668053 0.00645634 -0.04642593 -0.00668085 0.00645595 -0.00040122 -0.00650454 0.00628877 -0.00025123 0.00650504 0.00628892 -0.00028948 -0.00039591 2.479e-05 0.00223371 0.00039608 2.426e-05 0.0006732 0.0003264 3.122e-05 0.00052874 -0.00032589 3.415e-05 -0.00023577 -2.908e-05 -0.00832477 0.00635709 3.737e-05 -0.00125057 -7.444e-05 -2.582e-05 0.00656076 0.00636285 2.566e-05 -0.00049974 -6.661e-05 -5.431e-05 0.00502637 0.00639077 4.553e-05 -0.00180978 0.0001325 -3.609e-05 -0.00676473 0.00638092 3.806e-05 5.503e-05 0.00012759 -0.00670704 0.00646596 0.01310437 0.00670119 3.673e-05 0.00602948 0.00036366 0.00627899 -0.00657272 -0.00036508 2.288e-05 0.00026009 0.00648649 0.0064463 -0.00036521 -0.00648098 1.594e-05 0.00671469 -0.00034493 0.00630074 0.00662932 0.00034331 4.157e-05 -0.0002028 最后执行如下命令： find SCF-* -name vasprun.xml|sort -n|thirdorder_vasp.py reap 2 2 2 -2 即可得到三阶力常数文件 FORCE_CONSTANTS_3RD。在 shengbte 文件夹中提供了 FORCE_CONSTANTS_3rd 文件供参考计算结果。 3. 运行 ShengBTE 得到晶格热导率 进入 shengbte 文件夹，里面已经准备好 CONTROL（ShengBTE 的参数文件）、FORCE_CONSTANTS_2ND（二阶力常数文件）、FORCE_CONSTANTS_3RD（三阶力常数文件）这三个文件，使用如下命令运行 ShengBTE 即可得到晶格热导率，其中 Ref 文件夹中给出了计算结果供参考： mpirun -n 10 ShengBTE 四、结尾 对于 ABACUS 中使用平面波（PW）来做 ShengBTE 的计算也是采用以上类似的流程，但要注意使用平面波时，计算三阶力常数的 INPUT 中scf_thr 需要至少小到1e-12。通过计算结果可以发现，PW 和 LCAO 基组计算出的 Si 的晶格热导率是接近的，300 K 下均在 100 W/(m K) 左右，而实验中 Si 在 300 K 的热导率在 150 W/(m K) 附近。这是因为作为教学例子，这里使用的是 2*2*2 的扩胞以及 2*2*2 的 K 点，导致计算结果偏小，实际科研中需要测试扩胞的大小以及 K 点的采样方案来达到收敛的结果。以上就是 ABACUS(3.2.0)+ShengBTE 计算晶格热导率的全部流程，如果有什么问题，欢迎通过邮件联系。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-dpgen.html":{"url":"abacus-dpgen.html","title":"ABACUS+DPGEN 使用教程","keywords":"","body":"ABACUS+DPGEN 使用教程 作者：刘建川，邮箱：liujianchuan2013@163.com 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/15 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍结合 ABACUS（中文名原子算筹，这里基于 ABACUS 3.2.0 版本）和 DPGEN 软件结合生成机器学习 DP 势，这里 ABACUS 扮演了提供第一性原理训练数据的作用。本教程以碳化硅（SiC）材料为案例，并且教大家使用 DPGEN autotest 功能，计算 SiC 的 Equation of State (EOS)和弹性常数等性质。先介绍主要软件和计算平台： DPGEN软件：是一个结合第一性原理软件来自动产生训练数据标签的软件，如果不熟悉 DPGEN 的读者，这里可以推荐大家先阅读 DPGEN 的相关原理文档和说明，熟悉这部分的读者可以跳过： https://docs.deepmodeling.com/projects/dpgen/en/latest/ https://bohrium-doc.dp.tech/docs/software/DP-GEN https://bohrium-doc.dp.tech/docs/software/DP-GEN_init https://bohrium-doc.dp.tech/docs/software/DP-GEN_autotest https://www.sciencedirect.com/science/article/pii/S001046552030045X?via%3Dihub 计算平台：由于本案例通过 Bohrium 平台教学，所以所用到的 machine.json 文件仅限于 Bohrium 平台使用，如需在其他平台上使用，可参考下面网址，修改 machine.json 文件： https://docs.deepmodeling.com/projects/dpgen/en/latest/run/example-of-machine.html 二、准备 1. 案例下载地址 本教程用到的所有输入文件，均可点击这里下载。 (https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/abacus-dpgen) 此外，在 Linux 下可以采用的下载命令是： git clone https://gitee.com/mcresearch/abacus-user-guide.git 之后进入 /abacus-user-guide/examples/md 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/md 下载完之后，应该可以看到三个文件夹： init，run，以及 auto-test init 文件夹：包含用于 dpgen init_bulk 步骤所需的输入文件，用户可参考其设置自己的体系参数。 run 文件夹：包含用于 dpgen run 步骤所需的输入文件，用户可参考其设置自己的体系参数。 auto-test 文件夹：包含用于计算弹性常数等性质的输入文件，用户可参考其设置自己的体系参数。 2. 安装相关软件 这里默认读者已经安装好了 ABACUS 软件，本算例中 ABACUS 计算采用的是数值原子轨道的 LCAO（Linear Combination of Atomic Orbitals）方法，因为一般来说 LCAO 会比平面波效率更高，此外读者也可以把密度泛函理论计算部分改成平面波基矢量（后续会讲到）。 开始之前，请务必安装/更新 dpgen 和 dpdata（用来转换数据）到最新版本： 1. 安装/更新 dpdata pip install --user git+``https://gitee.com/deepmodeling/dpdata.git@devel 2. 安装/更新 dpgen pip install --user git+``https://gitee.com/deepmodeling/dpgen.git@devel 三、结合 DPGEN 生成 DP 数据的流程 DPGEN 使用流程如下，接下来我们将一一展开介绍： 1. 准备赝势和数值原子轨道文件 本例子所需文件有： 模守恒赝势文件，格式为*.upf，也可以使用其他 ABACUS 支持的赝势格式，注意 ABACUS 目前不支持 PAW 方法或者超软赝势。 数值原子轨道文件，格式为*.orb，注意这里的数值原子轨道文件要和赝势文件匹配，也就是数值原子轨道是由指定赝势产生的，关于如何生成数值原子轨道，我们会提供中文教程。 注：在 ABACUS 官网上可以下载到赝势和数值原子轨道文件： http://abacus.ustc.edu.cn/pseudo/list.htm 本例采用的赝势和轨道是： C 的 PBE 模守恒 ONCV 模守恒赝势：C_ONCV_PBE-1.0.upf Si 的 PBE 模守恒 ONCV 模守恒赝势：Si_ONCV_PBE-1.0.upf C 的 PBE 模守恒 ONCV 赝势对应的数值原子轨道：C_gga_9au_100Ry_3s3p2d.orb Si 的 PBE 模守恒 ONCV 赝势对应的数值原子轨道：Si_gga_9au_100Ry_3s3p2d.orb 注：如果是使用平面波基矢量来做密度泛函理论计算，则不需要提供数值原子轨道文件，结合 DPGEN 使用的流程是一致的（仅需要删除调用轨道文件的输入参数即可）。如果采用其他 ABACUS 支持的赝势文件，可自行生成轨道文件（请参考本教程系列的其它相关中文教程）. 注：这里 C_gga_9au_100Ry_3s3p2d.orb 的意思是 C 元素、采用 GGA 泛函、轨道截断半径是 9 a.u.（轨道截断半径越大，则 ABACUS 所需求解 Kohn-Sham 方程的时间会越长，而且这个时间对于轨道半径极其敏感，推荐可以测试不同轨道半径，选取合适的、截断半径小的轨道可以加速计算），100 Ry 是推荐的平面波截断值（哪怕用了数值原子轨道，程序里还是会用平面波来做某些物理量的计算，比如模守恒赝势的局域赝势部分），3s3p2d 表示 3 个 s 径向轨道、3 个 p 轨道、2 个 d 轨道。 2. 准备原子体系的结构文件 本步骤所需的描述原子结构的文件有： *.cif 可以从多个渠道下载所需体系的结构文件，本案例主要从 materials project 网站下载 cif 文件，使用的 SiC 对应多个原子构型，主要有 3C、2H、4H、6H 四个构型，采用哪些构型取决于用户所研究的体系和性质，一般可选取所关心的物质温度和压强区间内可能出现的结构。本案例主要采用3C 和 2H构型来演示。 3C-SiC：https://materialsproject.org/materials/mp-8062?formula=SiC 2H-SiC: https://materialsproject.org/materials/mp-7140?_skip=15&formula=SiC 4H-SiC: https://materialsproject.org/materials/mp-11714?formula=SiC 6H-SiC: https://materialsproject.org/materials/mp-7631?formula=SiC 得到了 cif 之后，可以使用下列方法把 cif 转换成 STRU 文件： 1. 安装 ASE-ABACUS 接口： git clone https://gitlab.com/1041176461/ase-abacus.git cd ase-abacus python3 setup.py install 2. 设置环境变量（可选） ABACUS 支持两种基组：平面波（PW）和数值原子轨道（LCAO）。赝势和轨道文件的存放路径可以通过环境变量设置，分别为：ABACUS_PP_PATH 和 ABACUS_ORBITAL_PATH,设置方法如下： PP=${HOME}/pseudopotentials ORB=${HOME}/orbitals export ABACUS_PP_PATH=${PP} export ABACUS_ORBITAL_PATH=${ORB} PW 计算只需要设置 ABACUS_PP_PATH 。 LCAO 需要两个都设置：ABACUS_PP_PATH and ABACUS_ORBITAL_PATH 。 3. CIF 转 STRU from ase.io import read, write from pathlib import Path cs_dir = './' cs_vasp = Path(cs_dir, 'SiC.cif') # 修改为自己的cif文件名 cs_atoms = read(cs_vasp, format='cif') cs_stru = Path(cs_dir, 'STRU') pp = {'Si':'Si_ONCV_PBE-1.0.upf','C':'C_ONCV_PBE-1.0.upf'} # 修改为所对应的赝势文件名 basis = {'Si':'Si_gga_9au_100Ry_3s3p2d.orb','C':'C_gga_9au_100Ry_3s3p2d.orb'} # 修改为所对应的轨道文件名 write(cs_stru, cs_atoms, format='abacus', pp=pp, basis=basis) 运行上述 python 脚本，把 cif 转成 ABACUS 所需的 STRU 文件。 3. 产生初始训练数据 本步骤所需文件有： 原子结构文件：STRU 数值原子轨道文件：*.orb 赝势文件：*.upf 布里渊区 k 点采样：KPT 提交任务的文件：machine.json DPGEN 的输入参数文件：param.json 为每一个构型新建一个名为 init 的文件夹。进入该文件夹后，为每个构型都新建一个单独的文件夹，之后单独运行 dpgen init_bulk 命令，用于产生接下来的 dpgen run 步骤的初始数据集。本案例所提供的初始原子构型为 3C 和 2H 结构，并把赝势文件、轨道文件、STRU 文件放入对应的文件夹里。按照下面链接的案例准备适合自己机器的 machine.json 文件，并分别放入 3C 和 2H 文件夹。 https://docs.deepmodeling.com/projects/dpgen/en/latest/run/example-of-machine.html 本教程所用到的文件可以从 Gitee 下载，修改为符合自己的配置即可。 接下来准备 param.jsion 文件，本步骤最关键的设置也是 param.json 文件设置，案例如下： { \"init_fp_style\": \"ABACUS\", \"stages\": [1,2,3,4], \"cell_type\": \"diamond\", \"super_cell\": [1, 1, 1], \"elements\": [\"Si\",\"C\"], \"from_poscar\": true, \"from_poscar_path\": \"./STRU\", \"potcars\": [\"Si_ONCV_PBE-1.0.upf\",\"C_ONCV_PBE-1.0.upf\"], \"orb_files\": [\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C_gga_9au_100Ry_3s3p2d.orb\"], \"relax_incar\": \"./INPUT_rlx\", \"md_incar\" : \"./INPUT_md\", \"relax_kpt\": \"./KPT\", \"md_kpt\": \"./KPT\", \"md_nstep\": 10, \"scale\": [0.99,1.00,1.01], \"skip_relax\": false, \"pert_numb\": 10, \"pert_box\": 0.03, \"pert_atom\": 0.01, \"deepgen_templ\": \"../generator/template/\", \"coll_ndata\": 5000, \"_comment\": \"that's all\" } init_fp_style 关键字需设置为 ABACUS，如果 from_poscar 为 true，则会读取 from_poscar_path 指定的 STRU 文件，且 cell_type 关键字失效。super_cell 用于括胞，推荐直接使用括胞之后的 STRU 文件，则 super_cell 设置为[1, 1, 1]。括胞一般根据需求而定，使得三个方向的 cell 长度约为 6 埃以上（经验性的）。其中还用到了 *.``upf 和 *.``orb 文件，修改为自己所计算的体系即可。 init_bulk 的基本操作流程分为以下 4 个顺序步骤： 生成初始(平衡)结构：输出文件存储在 00.place_ele。 产生 MD 起始构象：放缩扰动 00.place_ele 中的结构，输出文件存储在 01.scale_pert。 执行 AIMD：取 01.scale_pert 起始构象调用 vasp 执行少步数 AIMD，输出文件存储在 02.md。 整理初始数据：调用 dpdata 提取 02.md 中 AIMD 各 snapshots 的数据作为初始数据，输出文件存储在 02.md。 param.json 中将使用 stages 关键词的取值 1~4 控制以上 4 步的执行，操作中，各步骤(2, 3, 4 在所需前一步输出文件存在的前提下)可独立执行。 其他具体参数含义可参考 dpgen 官网： https://docs.deepmodeling.com/projects/dpgen/en/latest/init/init-bulk-jdata.html 另外，还需准备两个 ABACUS 输入文件 INPUT_rlx 和 INPUT_md。 INPUT_rlx 主要用于优化所下载的结构，如下： INPUT_PARAMETERS #Parameters (1.General) suffix ABACUS calculation cell-relax #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type lcao #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.002 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 cal_stress 1 INPUT_md 主要用于产生一定数量的 AIMD 轨迹，用于 DPGEN 迭代的输出数据，如下： INPUT_PARAMETERS #Parameters (1.General) suffix ABACUS calculation md #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type lcao #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.002 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 cal_stress 1 #MD chg_extrap second-order md_type 2 md_tfirst 300 md_tlast 300 md_nstep 10 md_tfirst 10 md_tfreq 0.5 注：ABACUS 的 MD 关键字在此 3.2.0新版本有所更改，如果是使用的最新版本，请严格参考手册设置关键字，如md_type在新版本里改为了nvt、npt等形式，而不再用数字（如：2）等： 此外，还需准备一个存放布里渊区 k 点的文件，名为 KPT： K_POINTS 0 Gamma 4 4 4 0 0 0 也可在 INPUT 文件里直接指定 kspacing 参数（注意该参数可选 1 维或者 3 维，如果是表面系统可选 3 维因为真空方向不需要太多 k 点）。 用户可自行根据所研究体系，设置、更改上述参数。 所有以上输入文件准备完毕后，采用如下命令分别对 3C 和 2H 结构运行 dpgen： nohup dpgen init_bulk param.json machine.json 1>log 2>err& 上述命令采用后台提交 dpgen，等所有计算完成之后，dpgen 会自动收集训练 DP 势所需的数据，且转换为 DeePMD-kit 的数据格式，保存在 ./STRU.01x01x01/02.md/sys-0036-0036/deepmd 目录里。 4. 进行数据采样的迭代 run主流程包含一系列迭代，各迭代会根据所选系综在给定的温度、压力或体积等条件下进行 DPMD 采样与筛选，实现同步学习，所有迭代希望能够有效覆盖训练可靠模型所需的势能面上样本空间。每个迭代依次：基于init 准备的初始训练数据与之前迭代积累的训练数据|训练多个新的模型->使用当前的模型进行DPMD采样，根据模型间预测偏差(model-deviation)|挑选候选 snapshot 构象->将本轮候选 snapshot 构象进行第一性原理标定并加入数据集|扩展数据集 。 以上每个迭代中包含的 3 个步骤分别被命名为 00.train，01.model_devi，02.fp，细节如下： 00.train: 使用 init 准备的初始训练数据与之前迭代积累的训练数据，调用 DeepMD-kit 训练多个 (默认 4 个) 模型。模型间的唯一区别来自于初始化神经网络时使用不同的随机数种子。 01.model_devi: 指代 model-deviation。 调用 LAMMPS 使用 00.train 的 1 个模型进行 MD 模拟。对于任一 MD 中 snapshot，模型间预测偏差越大意味着当前模型系综对该 snapshot 构象的精度越低，通过引入模型偏差作为误差判据并设定上下限, 挑选出有希望有效改进模型对 PES 整体预测精度的 snapshot 构象，作为准备加入训练数据集的候选构象。 02.fp: 调用 ABACUS 对 01.model_devi 选取的候选构象进行第一性原理定标(单点计算)，并调用 dpdata 收集整理所得数据加入到训练数据集中。 run 执行后，相关文件即存储在....../iter.*(迭代序号)/步骤文件夹内。以上每个迭代中的每个步骤在实现中被分解为 3 个阶段。以 00.train 为例，3 阶段分别对应: 0：make_train ，为训练任务准备脚本；1： run_train，依据机器配置上传文件并执行训练任务；2：post_train，收集整理分析训练任务的结果。01.model_devi 与 02.fp 的实现步骤与之类似，分别使用 3，4，5 及 6，7，8 来标记其阶段。 用输出文件record.dpgen来记录进程已经执行过及当前正在执行的阶段。如进程中断后需要续算，DP-GEN将根据此文件的记录来自动恢复run主进程。用户也可根据需求手动修改record.dpgen中的记录，来控制接下来将执行哪一阶段的任务：例如，删除最后一阶段(可能未执行完成即中断)的记录，并从前一个已完成阶段后恢复任务。可以通过查看record.dpgen文件监控当前任务的执行阶段。 本步骤所需文件有： STRU *.orb *.upf machine.json （可以直接用 dpgen init bulk 里的） param.json dpgen init bulk 产生的初始训练数据 主要步骤如下： 1. 新建一个文件夹，命名为：run，并进入此目录里 2. 在 run 文件夹里面新建 init_conf 和 init_data 文件夹，用于存放 dpgen init bulk 产生的构型和初始训练数据 3. 为了区分不同构型和初始训练数据，在 init_conf 和 init_data 文件夹里新建名为 3C 和 2H 的两个文件夹 4. 拷贝 dpgen init bulk 产生的构型和初始训练数据至 init_conf 和 init_data 文件夹里，如： cp -rf yourPath/init/3C/STRU.01x01x01/02.md/sys-0032-0032 yourPath/run/init_conf/3C cp -rf yourPath/init/2H/STRU.01x01x01/02.md/sys-0036-0036 yourPath/run/init_conf/2H cp -rf yourPath/init/3C/STRU.01x01x01/02.md/sys-0032-0032/deepmd/* yourPath/run/init_data/3C cp -rf yourPath/init/2H/STRU.01x01x01/02.md/sys-0036-0036/deepmd/* yourPath/run/init_data/2H 5. 拷贝 machine.json、*.orb 和 *.upf 文件到 run 文件夹 6. 新建一个 param.json 文件，如下案例： { \"type_map\": [\"Si\",\"C\"], \"mass_map\": [28.085,12.011], \"init_data_prefix\": \"./init_data\", \"init_data_sys\": [ \"3C\", \"2H\" ], \"sys_format\":\"abacus/stru\", \"sys_configs_prefix\": \"./init_conf\", \"sys_configs\": [ [\"3C/sys-0032-0032/scale-1.000/00****/STRU\"], [\"2H/sys-0036-0036/scale-1.000/00****/STRU\"] ], \"_comment\": \" that's all \", \"numb_models\": 4, \"default_training_param\": { \"model\": { \"type_map\": [\"Si\",\"C\"], \"descriptor\": { \"type\": \"se_e2_a\", \"sel\": \"auto\", \"rcut_smth\": 0.5, \"rcut\": 6.0, \"neuron\": [25, 50, 100], \"resnet_dt\": true, \"axis_neuron\": 12, \"seed\": 1 }, \"fitting_net\": { \"neuron\": [240, 240, 240], \"resnet_dt\": false, \"seed\": 1 } }, \"learning_rate\": { \"type\": \"exp\", \"start_lr\": 0.001, \"stop_lr\": 3.5e-8, \"decay_steps\": 2000 }, \"loss\": { \"start_pref_e\": 0.02, \"limit_pref_e\": 2, \"start_pref_f\": 1000, \"limit_pref_f\": 1, \"start_pref_v\": 0.0, \"limit_pref_v\": 0.0 }, \"training\": { \"stop_batch\": 400000, \"disp_file\": \"lcurve.out\", \"disp_freq\": 100, \"numb_test\": 10, \"save_freq\": 1000, \"save_ckpt\": \"model.ckpt\", \"disp_training\": true, \"time_training\": true, \"profiling\": false, \"profiling_file\": \"timeline.json\", \"_comment\": \"that's all\" } }, \"model_devi_dt\": 0.002, \"model_devi_skip\": 1000, \"model_devi_f_trust_lo\": 0.05, \"model_devi_f_trust_hi\": 0.10, \"model_devi_clean_traj\": true, \"model_devi_merge_traj\": true, \"model_devi_jobs\": [ {\"sys_idx\": [0,1], \"temps\":[50, 250, 450, 650], \"press\": [0, 100, 1000, 5000, 10000, 20000, 50000], \"trj_freq\": 10, \"nsteps\": 3000, \"ensemble\": \"npt-tri\", \"_idx\": \"01\"}, {\"sys_idx\": [0,1], \"temps\":[50, 250, 450, 650], \"press\": [0, 100, 1000, 5000, 10000, 20000, 50000], \"trj_freq\": 10, \"nsteps\": 3000, \"ensemble\": \"npt-tri\", \"_idx\": \"02\"} ], \"fp_style\": \"abacus\", \"shuffle_poscar\": false, \"fp_task_max\": 100, \"fp_task_min\": 5, \"fp_accurate_threshold\": 0.999, \"fp_accurate_soft_threshold\": 0.998, \"fp_pp_path\": \"./\", \"fp_pp_files\": [\"Si_ONCV_PBE-1.0.upf\",\"C_ONCV_PBE-1.0.upf\"], \"fp_orb_files\": [\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C_gga_9au_100Ry_3s3p2d.orb\"], \"user_fp_params\":{ \"ntype\": 2, \"symmetry\": 0, \"basis_type\": \"lcao\", \"ecutwfc\": 100, \"scf_thr\": 1e-6, \"scf_nmax\": 100, \"smearing_method\": \"gauss\", \"smearing_sigma\": 0.002, \"mixing_type\": \"pulay\", \"mixing_beta\": 0.3, \"cal_force\": 1, \"cal_stress\": 1, \"kspacing\": 0.08 } } type_map: 用列表方式设置了体系元素，注意顺序要和 STRU 结构文件里一致 mass_map: 记录了对应的原子质量，和 type_map 对应 init_data_prefix：指定初始训练集的位置所在目录，如：./init_data init_data_sys：定位到初始训练集的具体目录，用列表调用多个，即：./init_data/2H sys_format：指定为 ABACUS 计算的结构，即：abacus/stru sys_configs_prefix：指定探索步所需调用的结构目录，如：./init_conf sys_configs：指定具体的某个构型的目录，用列表调用多个，即：./init_conf/3C/sys-0032-0032/scale-1.000/00****/STRU。其中 00为通配符，dpgen 会遍历 00所有文件夹的 STRU 文件 model_devi_f_trust_lo 和 model_devi_f_trust_hi：可由“init 数据” 中力绝对值的平均值，然后取该值的 20%-50%，设置成 trust level 的上下限。可通过以下 python 脚本计算：（注意指定初始数据位置） import dpdata import numpy as np do06=dpdata.Labeledsystem(\"./\"，\"deepmd/raw\") forces = np.absolute(d006[\"forces\"]) af = np.average(forces) f_trust_lo = af*0.2 f_trust_hi = af*0.5 print(f_trust_lo,f_trust_hi) 如果体系温度升高后力的幅度变大，trust level 也要增大设置 model_devi_jobs 里面每一行代表一轮，每轮设置参数为 LAMMPS 进行 MD 模拟的参数 fp_style 指定，使用 ABACUS 进行 SCF 计算 user_fp_params 里面记录 ABACUS 做 SCF 所需的参数 其他参数含义见：https://docs.deepmodeling.com/projects/dpgen/en/latest/run/index.html 1. 准备好所有输入文件之后，运行命令： nohup dpgen run param.json machine.json 1>log 2>err& 为后台提交，等待迭代计算完成即可。 2. 实时监测每轮的 accurate 数据，在 dpgen.log 文件里有记录 1）模型精度是判断每个迭代中的训练是否收敛的重要指标。 2）掌握训练策略有利于快速迭代和收敛。 3）经验性：一般体系在 5-8 轮迭代内会上升到 80% 以上，若没有提升，如下方法排查： a. 检查是否是探索步已经崩溃了，收集了许多不合理的结构 b. 检查train的loss是否是收敛 c. dp test查看fp数据是否偏差很大，或者有不合理的情况 d. 检查是否是温度设置过高而导致的结构变形严重 e. 及时调整trust level，体系温度升高后力的幅度变大，trust level也要增大设置 3. 一些经验 探索步已经崩溃的解决方案 原因：DPMD 跑崩的情况一般发生在 训练温度 高于 熔点，而这个温区的结构是从“有序”到“无序态”的 ，其构型易变，采样空间增大，导致训练难度增加。DPMD 跑崩表明当前势函数对这类构型描述较差，大概率是因为前期数据集中这类构型采集的较少；特别是无序态结构的原子距离变小。 策略：在熔点附近的 参数设置需要平滑缓慢对待，增加“MD 轨迹保存频率”；缩短“MD 模拟步数”或降低“MD 步长”，增加迭代次数，其 DP 训练势函数稳定后再延长 MD 模拟步数。 ABACUS 收敛性测试 对每种体系一定要先做各个参数的收敛性测试，特别是：K 点、能量截断，也可测试 scf_thr 降低计算量。另外，对于赝势文件也一定要做性质测试，看是否能够正确描述目标体系的性质 每隔几轮做一次 dp test 初始数据得到后，第一轮生成了 dp 势之后，一定要检查 trian 步骤收敛情况和做 dp test。dp test 用如下命令： dp test -m frozen_model.pb -s ./collect_data -n 2000 -d out.out frozen_model.pb 为生成的 4 个模型中的某一个，2000 为 collect_data 里面单个结构的总数。out.out 会生成 out.e.out out.f.out out.f.out 三个偏差数据文件，用于作图判断模型优劣屏幕会输出每个构型力、能量等误差平均值，也可用*.out 文件做出 DP 和 DFT 偏差图，如： 经验性的，力的精度在 1e-2 量级，能量精度在 5e-3 量级，说明模型比较好。 四、计算材料 EOS 和弹性常数的流程 本例子里提供了一个 auto-test 文件夹，进入之后可以结合 DPGEN 的 auto-test 命令计算材料 EOS、弹性常数的流程 auto-test 的详细流程，可以从如下网页教程查阅： https://bohrium-doc.dp.tech/docs/software/DP-GEN_autotest 这里贴上如何使用 ABACUS 来计算材料 EOS、弹性常数的相关输入文件 relaxation.json： { \"structures\": [\"conf\"], \"interaction\": { \"type\": \"abacus\", \"incar\": \"./INPUT\", \"potcar_prefix\":\"./\", \"potcars\": {\"Si\": \"Si_ONCV_PBE-1.0.upf\",\"C\": \"C_ONCV_PBE-1.0.upf\"}, \"orb_files\": {\"Si\":\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C\":\"C_gga_9au_100Ry_3s3p2d.orb\"} }, \"relaxation\": { \"cal_type\": \"relaxation\", \"cal_setting\":{ \"input_prop\": \"./INPUT\" } } } property.json： { \"structures\": [\"conf\"], \"interaction\": { \"type\": \"abacus\", \"incar\": \"./INPUT\", \"potcar_prefix\":\"./\", \"potcars\": {\"Si\": \"Si_ONCV_PBE-1.0.upf\",\"C\": \"C_ONCV_PBE-1.0.upf\"}, \"orb_files\": {\"Si\":\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C\":\"C_gga_9au_100Ry_3s3p2d.orb\"} }, \"properties\": [ { \"type\": \"eos\", \"vol_start\": 0.9, \"vol_end\": 1.1, \"vol_step\": 0.02 }, { \"type\": \"elastic\", \"norm_deform\": 1e-2, \"shear_deform\": 1e-2 } ] } INPUT： INPUT_PARAMETERS calculation cell-relax symmetry 0 basis_type lcao ecutwfc 100.0 scf_thr 1.0e-06 scf_nmax 100 smearing_method gauss smearing_sigma 0.002 mixing_type pulay mixing_beta 0.3 cal_force 1 cal_stress 1 kspacing 0.10 在当前目录建立一个 conf 文件夹，把 STRU 文件放进去，依次运行下面命令： dpgen autotest make relaxation.json nohup dpgen autotest run relaxation.json machine.json & dpgen autotest post relaxation.json dpgen autotest make property.json nohup dpgen autotest run property.json machine.json & dpgen autotest post property.json 计算完成之后，会在 conf/elastic_00/result.out 文件里记录弹性常数、模量等信息，conf/eos_00/result.out 里记录 EOS 等数据。 以上即为采用 ABACUS 3.2.0 和 DPGEN 软件结合的介绍，若有任何问题，欢迎给我们反馈。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-libri.html":{"url":"abacus-libri.html","title":"ABACUS+LibRI 做杂化泛函计算教程","keywords":"","body":"ABACUS+LibRI 做杂化泛函计算教程 作者：梁馨元，邮箱：2201111875@stu.pku.edu.cn 审核：林霈泽，邮箱：linpeize@sslab.org.cn 最后更新时间：2023/08/21 在Bohrium Notebook上快速学习： 一、介绍 杂化泛函（Hybrid Functional）是指在密度泛函理论框架中的交换关联项里面加入一部分的 Hartree Fock (简称 HF)的精确交换能。开源密度泛函理论软件 ABACUS 可以结合另一款国产开源软件 LibRI 软件进行杂化密度泛函计算，目前仅支持在数值原子轨道基组下使用该功能。可以通过 dft_functional 参数指定所使用的杂化泛函类型，如可以选择 hf (Hartree-Fock), pbe0(PBE0), hse(HSE06)以及 scan0 杂化泛函。本教程以 HSE 杂化泛函为例，介绍如何在 ABACUS 里调用 LibRI 做杂化泛函自洽迭代、求力和应力以及结构优化。 注 1：使用 ABACUS+LibRI 做杂化泛函计算时，最大并行核数是N_a^4N_K^3，其中N_a是原子个数，N_k是 k 点个数。计算资源超出时可以运行，但会造成浪费。 注 2：使用 ABACUS+LibRI 做杂化泛函计算时，因为内存消耗比较大，推荐给定计算资源的前提下，先尽量使用 OpenMP 多线程并行，再考虑使用 MPI 多进程并行。 二、杂化泛函的使用 1. ABACUS 编译准备 如果要在 ABACUS 中使用杂化泛函进行计算，需要在编译 ABACUS 的时候也编译 Libxc、LibRI 和 LibComm 三个软件包，具体请见线上文档 Advanced Installation Options ‒ ABACUS documentation。 注意在链接 LibRI、LibComm 时如果报错未定义的引用等，可以先注意检查 ABACUS 源代码下 deps 文件夹下是否包含 LibRI、LibComm 两个文件夹。如果未包含这两个文件夹，或文件夹中无内容，在本地Github仓库中可以尝试如下两条语句，以获取这两个子仓库内容： git submodule init git submodule update --remote --recursive 2. 采用杂化泛函进行电子自洽迭代计算 本教程在 Gitee 上准备了一个硅晶体使用杂化泛函做自洽计算（SCF）的例子（Gitee 的下载链接），以下是 INPUT 文件及相关的参数。由 dft_functional 设置为 hse 可知，该例子使用的杂化泛函为 HSE 泛函。KPT 文件取的是 444 的布里渊区 k 点。 INPUT_PARAMETERS calculation scf basis_type lcao ntype 1 nbands 8 ecutwfc 60.0 scf_nmax 100 dft_functional hse scf_thr 1e-7 杂化泛函相关的完整参数列表及解释见 Full List of INPUT Keywords / exact-exchange ‒ ABACUS documentation。这里再进行简单概述： 泛函相关参数： exx_hybrid_alpha：杂化泛函中加入的 HF 精确交换能（Fock 交换能）的比例α，即有E_x=αE_{x}^{HF}+(1-α)E_{x}^{LDA/GGA}。如果 dft_functional 设置为 hf，则默认值为1。目前其他杂化泛函的默认值是0.25。但是，如果是 SCAN0 泛函，有的文献取的是 0.1，所以需要根据你想取的值进行设定[1]。 exx_hse_omega：为 HSE 泛函中的区间分割参数（range-separation parameter）\\omega，即有\\frac{1}{r}=\\frac{erfc({\\omega}r)}{r}+\\frac{erf({\\omega}r)}{r}。默认值为0.11（bohr^{-1}），此时为 HSE06 泛函[2]。 exx_lambda：在 basis_type 设置为 lcao_in_pw 的情况下，用于补偿使用 lcao_in_pw 方法评估精确交换能时 G=0 处的发散点。默认值为0.3。 exx_real_number：该参数设定为 True 时，强制 LibRI 使用 double 数据类型，当设定为 False 时，强制 LibRI 使用 complex 数据类型。当gamma_only=1 时，默认为 True，gamma_only=0 时默认为 False。 循环相关参数： exx_separate_loop：ABACUS 提供了两种迭代方法来评估精确交换能E_{exx}。当 exx_separate_loop 设置为False时：采用单层循环，即先进行 GGA 循环，然后进行 Hybrid 循环，在该过程中，使用电子迭代来更新E_{exx}对应的哈密顿量H_{exx}。当 exx_separate_loop 设置为True时：采用双层循环，在内层循环中，进行自洽迭代并更新密度矩阵，在外层循环中，根据在内层循环中收敛的密度矩阵来计算H_{exx}。默认值为 True，即采用双层循环计算。单层循环有利于难以自洽收敛的体系达到收敛，但会显著增加内存消耗。 exx_hybrid_step：在 exx_separate_loop 设置为 True 的情况下，外层循环的最大迭代步数。默认值为100。 exx_mixing_beta：在 exx_separate_loop 设置为 True 的情况下，内层循环每次迭代时，密度矩阵混合的 mixing_beta 取值，默认为1.0。 exx_pca_threshold：为了加速四中心积分\\langle ik\\vert\\ jl\\rangle的计算，ABACUS 采用 LRI 方法，将原子轨道的乘积在辅助基函数(ABF)的基础上展开，即\\Phi_i\\Phi_j \\approx \\sum_aC_{ij}^aP_a，并利用 PCA 减小辅助基函数(ABF)的大小(即P_a个数)。阈值越大，ABF 的数目越少，计算速度越快，计算精度越低。一个相对安全的值是1e-4，也是默认值。 exx_ccp_rmesh_times：此参数决定计算 Columb 势所需的截断半径比原子轨道的截断半径大多少倍。对于 HSE 泛函，设置为 1 就足够了。但是对于 PBE0，必须使用一个大得多的数字。当使用 HSE 泛函时，默认值为1.5，其他情况下默认值为5。 张量筛选相关参数： 针对杂化泛函计算过程中的物理量进行筛选可以加速计算。具体来说，exx_c_threshold、exx_v_threshold、exx_dm_threshold、exx_c_grad_threshold、exx_v_grad_threshold 分别是针对C_{ij}^a、V_{ab}=\\langle P_a\\vert\\ P_b\\rangle、密度矩阵、\\nabla C_{ij}^a、\\nabla V_{ab}。阈值越大，筛掉的张量越多，计算速度越快，计算精度越低。具体请查看完整 INPUT 参数文档。 Cauchy-Schwartz 不等式相关参数： exx_cauchy_threshold：在实际中，Fock 交换矩阵是稀疏的，利用 Cauchy-Schwartz 不等式，我们可以在进行显式求值之前找到每个矩阵元素的上界。小于 exx_cauchy_threshold 的值将被截断。阈值越大，筛掉的张量越多，计算速度越快，精度越低。一个相对安全的值是1e-7，也是默认值。不等式算法参见参考文献[3]。 exx_cauchy_force_threshold、exx_cauchy_stress_threshold与exx_cauchy_threshold类似，区别在于它们分别针对的是求力、应力计算中的 Fock 交换矩阵元。 opt_orb 相关参数：当dft_functional设置为 opt_orb 时使用，opt_orb 参考文献[4]。本功能仅用于生成 opt 辅助基组，不进行杂化泛函计算。 exx_opt_orb_lmax：球贝塞尔函数的最大角动量 L 值，opt-ABF 的径向部分用球贝塞尔函数的线性组合生成。 exx_opt_orb_ecut：球贝塞尔函数展开的截断，在优化 opt-ABF 的时候采用的是球贝塞尔函数基组。 exx_opt_orb_tolerence：解球贝塞尔函数零点时的阈值。 3. 杂化泛函计算代价 杂化泛函的计算精度高，与此同时它的计算代价也比较高。在 ABACUS 的输入参数文件 INPUT 中，若 exx_separate_loop 参数设为 True（默认），仅在 SCF 步骤中就涉及两层循环。每次内层循环完成，外层循环往前推进一步时，屏幕输出 Updating EXX and rerun SCF。 一次 SCF 需要的时间至少是以上两个循环涉及的单次电子迭代时间之和。对于单次电子迭代所需时间，在此提出一些已有的经验。以一步电子迭代的时间为衡量尺标，使用 DZP 基组，CPU 型号为 Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz，使用 4 核计算一个水分子为 0.6s 左右，使用 14 个核计算 32 个水分子为 0.8s 左右，使用 14 个核计算 64 个水需要 1.9s 左右。 若将 exx_separate_loop 参数设为 False，即使用单层循环时，首先会进行 GGA 迭代直到自洽收敛，然后屏幕输出 Entering 2nd SCF, where EXX is updated，进行 Hybrid 迭代，此时每进行一次电子步得到新的密度后，都会更新一次精确交换能。以一步电子迭代 + 更新精确交换能的时间为衡量尺标，使用 DZP 基组，CPU 型号为 Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz，使用 4 核计算一个水分子为 0.7s 左右，使用 14 个核计算 32 个水分子为 115s 左右，使用 14 个核计算 64 个水需要 330s 左右。对于更大的体系，如 2048 个 Si 原子的晶体，使用 DZP 基组，CPU 型号为 Intel(R) Xeon(R) Silver 4310 CPU @ 2.10GHz，用一个节点（56 核）算时，PBE 下一步电子迭代大概需要 380s，而 HSE 一步电子迭代 + 更新精确交换能大概需要 1680s。 在进行杂化泛函计算时推荐尽量使用多线程计算（OpenMP），此时内存开销相对较小，计算速度相对较快。 三、使用杂化泛函做结构优化 1. 数据准备 在 Gitee 上我们准备了一个简单的使用杂化泛函做结构优化的例子。该例子是在 LCAO 基组下，使用 HSE 泛函，优化单个水分子的结构。文件夹中 log.ref 是使用 3.2.1 版本的 ABACUS 软件包，v0.1.0 版本的 LibRI 和 LibComm 计算所得的屏幕输出。 2. 输入文件 准备计算所需的 INPUT 文件、STRU 文件、KPT 文件，以及 H、O 原子对应的数值原子轨道文件。其中 INPUT 文件如下。注意该文件中指明了计算类型为 relax，即不对晶胞做优化（cell relax），只对原子位置做优化（relax）。更多结构优化类型请看文档 Geometry Optimization ‒ ABACUS documentation。 INPUT_PARAMETERS calculation relax basis_type lcao ntype 2 ecutwfc 60.000000 scf_nmax 100 gamma_only 1 dft_functional hse relax_nmax 100 scf_thr 1e-6 force_thr_ev 1e-2 在该例子中，结构优化包括多个离子步，每个离子步中都要做一次 SCF。由 INPUT 文件可知，SCF 收敛的标准由 scf_thr=1e-6 指定，或达到 SCF 的最大步数 scf_nmax=100，并计算受力。根据上一个离子步计算得到的受力，计算下一个离子步的原子位置，计算收敛的标准此时为 force_thr_ev=1e-2，或达到离子步的最大步数 relax_nmax=100。STRU 文件如下，可见在结构弛豫步骤中，三个原子都可以移动。 ATOMIC_SPECIES O 16.00 O_ONCV_PBE-1.0.upf H 1.00 H_ONCV_PBE-1.0.upf LATTICE_CONSTANT 1 LATTICE_VECTORS 28 0 0 0 28 0 0 0 28 ATOMIC_POSITIONS Direct O #label 0 #magnetism 1 #number of atoms 0.677639488918 0.5227809096584 0.232500040128 m 1 1 1 H #label 0 #magnetism 2 #number of atoms 0.641808457616 0.5785821615863 0.228644198512 m 1 1 1 0.708889637644 0.5204300746076 0.175087721492 m 1 1 1 NUMERICAL_ORBITAL O_gga_6au_60Ry_2s2p1d.orb H_gga_6au_60Ry_2s1p.orb 3. 结果 结构弛豫（relax）后的原子结构可见 OUT.ABACUS/STRU_ION_D。由输出文件可知，即使该例子中采用了相对稳定的构型，且 scf_thr 仅设为 1e-6，使用 HSE 做结构弛豫的计算代价仍然很高，使用 6 个核（Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz）计算需要 5 分钟左右。 四、参考文献 [1] Staroverov V N, Scuseria G E, Tao J, et al. Comparative assessment of a new nonempirical density functional: Molecules and hydrogen-bonded complexes[J]. The Journal of chemical physics, 2003, 119(23): 12129-12137. [2] Aliaksandr V. Krukau, Oleg A. Vydrov, Artur F. Izmaylov, Gustavo E. Scuseria; Influence of the exchange screening parameter on the performance of screened hybrid functionals. J. Chem. Phys. 14 December 2006; 125 (22): 224106. [3] Lin P, Ren X, He L. Efficient hybrid density functional calculations for large periodic systems using numerical atomic orbitals. Journal of Chemical Theory and Computation, 2021, 17(1): 222–239. [4] Lin P, Ren X, He L. Accuracy of localized resolution of the identity in periodic hybrid functional calculations with numerical atomic orbitals[J]. The Journal of Physical Chemistry Letters, 2020, 11(8): 3082-3088. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-candela.html":{"url":"abacus-candela.html","title":"ABACUS+Candela 使用教程","keywords":"","body":"ABACUS+Candela 使用教程 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/08/23 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍采用 Candela 分析 ABACUS（基于 3.2.4 版本）分子动力学轨迹，计算径向分布函数（Radial Distribution Function，简称 RDF），静态结构因子（Static Structure Factor，简称 SSF），离子-离子动态结构因子（Ion-ion Dynamic Structure Factor，简称 DSF）以及均方差位移（Mean Square Displacement，简称 MSD）流程。 上述性质的具体描述可以参考：Qianrui Liu et al 2020 J. Phys.: Condens. Matter 32 144002，径向分布函数（RDF）见文中公式（12），静态结构因子（SSF）见公式（13），离子-离子动态结构因子（DSF）见公式（15，16，17）以及均方差位移（MSD）见公式（18）。 Candela 全称 Collection of ANalysis DEsigned for Large-scale Atomic simulations，目前支持分析 QE、ABACUS、LAMMPS 和 VASP 的分子动力学轨迹，Github 主页：https://github.com/MCresearch/Candela 二、准备 1. 下载并安装 Candela git clone https://github.com/MCresearch/Candela.git cd Candela make -j4 #使用intel oneapi编译器 若使用 Intel Oneapi 编译器，按照上述流程操作，在编译完成后即可在 bin 目录下看到 candela 可执行文件 若使用其他编译器，需要按照 Candela 目录下 Makefile.vars 修改相应的 CXX 2 下载例子 可以从 Gitee 上下载。在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载完成后解压，之后进入 abacus-user-guide/examples/candela 文件夹 算例中包含 RDF、SSF、DSF、MSD 四个文件夹和 MD_dump 文件。其中 MD_dump 是 32 原子的铝的 MD 轨迹 三、流程 1 计算径向分布函数 进入 RDF 文件夹，INPUT 文件即为 Candela 的输入文件，具体如下： calculation pdf geo_in_type ABACUS geo_directory ../MD_dump geo_1 0 geo_2 100 geo_interval 2 geo_ignore 50 geo_out Al_rdf.txt ntype 1 natom 32 rcut 2.3 dr 0.01 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 pdf（Pair Distribution Function）即计算径向分布函数 geo_in_type：读取的 MD 轨迹的格式，目前支持分析 pw.x（QE2），cp.x（QE），ABACUS（ABACUS）、LAMMPS（LAMMPS）和 VASP（VASP） geo_directory：MD 轨迹的位置 geo_1：MD 轨迹起始的索引 geo_2：MD 轨迹结束的索引 geo_interval：Candela 读取 MD 轨迹的间隔 geo_ignore：需要跳过的 MD 轨迹帧数 geo_out：输出的文件名，默认为 result.dat ntype：原子种类 natom：原子数 rcut：计算 RDF 的截断半径，一般取晶格的一半，单位为 Angstrom dr：计算 RDF 的 r 的间隔，单位为 Angstrom 执行如下命令： mpirun -n 2 candela 即可得到 RDF，输出到 Al_rdf.txt，其中第一列为 r，单位为 Angstrom，第二列即为对应的 RDF，第三列为对第二列积分的结果。 2 静态结构因子 进入 SSF 文件夹，INPUT 文件具体如下： calculation ssf geo_in_type ABACUS geo_directory ../MD_dump geo_1 0 geo_2 100 geo_interval 2 geo_ignore 50 ssf_out Al_ssf.txt ntype 1 natom 32 struf_dgx 1.32656 struf_dgy 1.32656 struf_dgz 1.32656 struf_ng 6 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 ssf，即计算静态结构因子 ssf_out：输出的文件名 struf_dgx：倒空间中的间隔，一般取 2\\pi/a，其中a为x方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} struf_dgy：一般取 2\\pi/b，其中b为y方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} struf_dgz：一般取 2\\pi/c，其中c为z方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} struf_ng：上述倒空间中的间隔的数量 执行如下命令： mpirun -n 2 candela 即可得到 SSF，输出到 Al_ssf.txt（原始的计算结果）以及 sm-Al_ssf.txt（平滑的计算结果），其中第一列为 q，单位为\\mathrm{Angstrom^{-1}}，第二列即为对应的 SSF。 3 离子-离子动态结构因子 进入 DSF 文件夹，离子-离子动态结构因子需要对中间散射函数（Intermediate Scattering Function）进行傅里叶变换得到，因此需要先计算中间散射函数，INPUT 文件具体如下： calculation isf2 geo_in_type ABACUS geo_directory ../MD_dump geo_1 50 geo_2 100 geo_interval 1 isf_outfile isf.txt ntype 1 natom 32 isf_nt1 11 isf_nt2 40 dt_snapshots 0.00006 isf_target_q 2.65 isf_dgx 1.32656 isf_dgy 1.32656 isf_dgz 1.32656 isf_ngx 6 isf_ngy 6 isf_ngz 6 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 isf2，即计算中间散射函数 isf_outfile：输出的文件名 isf_nt1：中间散射函数的时间长度 isf_nt2：用于平均中间散射函数的时间长度，注意需要控制 interval*(nt1+nt2) dt_snapshots：MD 轨迹每一帧之间的时间步长，单位为 ps isf_target_q：中间散射函数计算的目标 q，单位为\\mathrm{Angstrom^{-1}} isf_dgx：倒空间中的间隔，一般取 2\\pi/a，其中a为x方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} isf_dgy：一般取 2\\pi/b，其中b为y方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} isf_dgz：一般取 2\\pi/c，其中c为z方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} isf_ngx：上述倒空间中 x 方向的间隔的数量 isf_ngy：上述倒空间中 y 方向的间隔的数量 isf_ngz：上述倒空间中 z 方向的间隔的数量 执行如下命令： mpirun -n 2 candela 即可得到 ISF，输出到 isf.txt，其中第一列为时间，单位为 ps，第二列即为对应的 ISF。 接着执行如下命令得到离子-离子动态结构因子，其中PathtoCandela指的是Candela的下载目录： python PathtoCandela/examples/e3_dsf/onedsf.py 0.00006 0.0006 其中第一个参数 0.00006 = dt_snapshots * geo_interval，为 ISF 的时间步长，单位为 ps；第二个参数 0.0006，为对 ISF 做傅里叶变换的总时长，单位为 ps。这里 onedsf.py 默认读取 isf.txt，并输出到 dsf.txt，其中第一列为\\hbar \\omega，单位为 meV，第二列即为对应的 DSF。 4 均方差位移 进入 MSD 文件夹，INPUT 文件具体如下： calculation msd_multiple geo_in_type ABACUS geo_directory ../MD_dump geo_1 0 geo_2 100 geo_interval 1 geo_ignore 50 ntype 1 natom 32 msd_n 2 msd_t0 0.003 msd_t 0.0015 msd_dt0 0.0015 msd_dt 0.00006 msd_natom 32 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 msd_multiple，即计算均方差位移 msd_n：计算均方差位移的段数，目的是将 MD 轨迹分成若干段，分别计算均方差位移 msd_t0：计算均方差位移的起始时间，单位为 ps msd_t：每段均方差位移的时长，单位为 ps msd_dt0：两段均方差位移起始位置的间隔，单位为 ps。若设置等于 msd_t，则每段均方差位移之间的时间距离为 0 msd_dt：获取的 MD 轨迹每一帧之间的时间步长（等于geo_interval * dt，其中 dt 为 MD 轨迹每一帧之间的时间步长），单位为 ps msd_natom：需要设置为计算的原子数 执行如下命令： mpirun -n 2 candela 即可得到 MSD，输出到 MSD_each.txt 和 MSD_total.txt。其中 MSD_each.txt 第一列为时间，单位为 ps，第二列到最后一列即为对应的每段的 MSD，单位为\\mathrm{Angstrom^{2}}；MSD_total.txt 第一列为时间，单位为 ps，第二列为平均的每段的 MSD，单位为\\mathrm{Angstrom^{2}}。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-uspex.html":{"url":"abacus-uspex.html","title":"ABACUS+USPEX 接口教程","keywords":"","body":"ABACUS+USPEX 接口教程 作者：柳向阳，邮箱：xiangyangliu@mail.ustc.edu.cn；郭晓庆，邮箱：xiaoqing.guo@mail.nwpu.edu.cn 审核：牛海洋，邮箱：haiyang.niu@nwpu.edu.cn；陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/14 一、背景介绍 近年来，随着高性能计算机的快速发展，晶体结构预测算法已然成为计算材料学的核心研究手段之一，极大地促进了新材料设计与研发的进程。Artem R.Oganov 教授课题组开发的进化类晶体结构预测算法 USPEX 是当前主流的全局搜索类算法之一。软件自 2004 年发布以来，该算法已被广泛应用于科研人员的研究工作中。晶体结构预测算法的主要作用是生成结构以及控制结构的演进，结构预测的效率及可靠性除却算法本身的影响外还对结构弛豫软件有极强的依赖性。ABACUS（原子算筹）作为一款国产开源密度泛函理论软件，同时兼具高精度和高效率，可适用于从小体系到上千原子体系的电子结构优化、原子结构弛豫、分子动力学等计算。因此实现晶体结构预测算法 USPEX（https://uspex-team.org/en）和第一性原理软件 ABACUS 的结合会给广大研究人员在结构预测研究中带来便利。 本教程旨在为大家提供一个 USPEX-ABACUS 接口的实现教程，方便大家程序配置。本教程以单质硅（Si）的结构预测为例, 介绍了该接口使用所需的输入文件和参数设置。 如需了解更多关于 USPEX 的使用信息，请参考 USPEX 官方文档：USPEX Documentation ‒ USPEX 二、接口介绍 当前发行的 USPEX 提供了分别以 matlab 和 python 为核心编程语言的两个版本，前者的版本编号为 USPEX-vXX（如 USPEX_v10.5），后者的版本编号为 USPEX-YEAR-XX（如 USPEX 2023.0.2），需要注意的是当前只有 python 版本可以自定义外部接口。该教程中的接口是在 USPEX 2023.0.2 和 ABACUS 3.3.0 版本进行编写测试的，如发生版本变更引起的异常，根据报错再行修改。 首先通过 USPEX 官网（USPEX 下载 ‒ USPEX）下载 USPEX 2023.0.2 软件（注册后即可免费下载），解压后根据所使用的 python 版本，选择软件压缩包进行安装，例如 pip install uspex-2023.0.2-cp310-cp310-linux_x86_64.whl。 注：若系统提示需要安装虚拟环境，可以在 USPEX 2023.0.2 目录下激活虚拟环境后重新进行安装。 python -m venv tutorial-env source tutorial-env/bin/activate 该接口共包含三个文件 (1) USPEX/components.py（对接口进行注册） (2) USPEX/Stages/Interfaces/ASEInterfacesAdapter.py（完成 ASE 接口中的读 read 和写 write 功能） (3) USPEX/Stages/Interfaces/ABACUS_Interface.py（接口实体，主要功能是准备 Abacus 的输入文件和读取 Abacus 的计算结果） 注：以上路径中 USPEX 为主目录。 上述文件可在 Github 仓库下载：https://github.com/gxq1219/Interface_USPEX-ABACUS/tree/master 安装完成后将以上文件复制到对应的路径下，并且需要手动添加环境变量，例如:export PATH=python3.10/site-packages/USPEX:$PATH，然后将 USPEX 2023.0.2 目录下的 random_cell 复制到设置的环境变量路径下。 该接口需要安装 ase-abacus 版本的 ase 库，测试版本为 ase-3.23.0b1 安装 ase-abacus 接口 git clone https://gitlab.com/1041176461/ase-abacus.git cd ase-abacus python3 setup.py install 此次测试是在 QSUB 任务管理系统下进行测试，如果更换任务管理系统，应修改 USPEX 输入文件 input.uspex 中的 taskManager 和 TM，此外需修改 USPEX/Stages/TaskManager 中所选任务管理方式中对任务队列状态识别的方式，如在 QSUB.py 文件中应根据所使用平台修改 def _parseJobID 中的内容识别出提交任务的 ID，以及下文的 def isReady 和 def isExist 等函数。 QSUB.py 示例（第 56 行的函数，根据自己超算平台修改，功能是执行 qsub sub.sh 后从屏幕输出的文本中提取出 jobID）： \"\"\" USPEX.Stages.TaskManagers.QSUB ============================== \"\"\" import logging from os.path import join as pj logger = logging.getLogger(__name__) class QSUB: shortname = 'QSUB' _RUNSCRIPT = 'jobscript' def __init__(self, header : str, connector): \"\"\" :param header: description of params of TaskManager :param connector: for remote submission \"\"\" self.connector = connector self.header = header def _prepareSubmission(self, COMMAND_EXEC : str, JOB_NAME : str, inputFile : str, outputFile : str, errorFile : str) -> str: \"\"\" Preparing jobscript for submission :param commandExec: :param jobName: :return: jobscript as string \"\"\" content = '' for line in self.header.split('\\n'): if ' -N ' in line: logger.info('Job name found in HEADER will be overwritten') elif ' -o ' in line: logger.info('Output file name found in HEADER will be overwritten') elif ' -e ' in line: logger.info('Error file name found in HEADER will be overwritten') else: content += line + '\\n' content += f'#PBS -N {JOB_NAME}\\n' content += f'#PBS -o {outputFile}\\n' content += f'#PBS -e {errorFile}\\n' content += f'cd $PBS_O_WORKDIR\\n' content += f'\\n{COMMAND_EXEC}\\n' return ''.join(content) async def submit(self, command: str, jobname: str, input: str, output: str, error: str, calcFolder : str) -> int: content = self._prepareSubmission(command, jobname, input, output, error) with open(pj(calcFolder, self._RUNSCRIPT), 'wt') as f: f.write(content) await self.connector.sync_l2r(pj(calcFolder, self._RUNSCRIPT)) returncode, out, err = await self.connector.execute(f'qsub {self._RUNSCRIPT}', cwd=calcFolder) logger.debug(f'process returned code {returncode}') if returncode != 0: logger.error(err) logger.error(out) jobID = self._parseJobID(out, err) logger.info(f\"Job ID is {jobID}\") return jobID def _parseJobID(self, output : str, error : str) -> int: \"\"\" :param output: :param error: :return: jobID \"\"\" if '.mgmt' in output: tmp = output.index('.mgmt') return int(output[:tmp]) elif 'job' in output: tmp = output.index('job') + 4 return int(output[tmp:]) elif 'comput100' in output: tmp = output.index('comput100')-1 return int(output[:tmp]) else: return int(output) async def isReady(self, jobID): returncode, out, err = await self.connector.execute(f'qstat {jobID}') return not (' R ' in out or ' Q ' in out) async def isExist(self, jobID): returncode, out, err = await self.connector.execute(f'qstat {jobID}') return len(out) > 0 async def kill(self, jobID): returncode, out, err = await self.connector.execute(f'qdel {jobID}') #logger.info(f'Process with jobID={jobID} killed.') 三、流程（以 Si 为例） 1. 准备 USPEX 的输入文件 input.uspex { optimizer: { type: GlobalOptimizer target: { type: Atomistic conditions: {externalPressure: 0.00001} compositionSpace: {symbols: [Si] blocks: [[4]]} } optType: enthalpy selection: { type: USPEXClassic popSize: 4 initialPopSize: 4 bestFrac: 0.6 optType: (aging enthalpy) fractions: { heredity: (0.4 0.7 0.5) softmodemutation: (0.2 0.5 0.3) randSym: (0.05 0.5 0.1) randTop: (0.05 0.5 0.1) } } } stages: [abacus1 abacus2 abacus3 abacus4 abacus5] numParallelCalcs: 4 numGenerations: 25 stopCrit: 10 } #define abacus1 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.20, taskManager: TM} #define abacus2 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.16, taskManager: TM} #define abacus3 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.12, taskManager: TM} #define abacus4 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.08, taskManager: TM} #define abacus5 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.05, taskManager: TM} #define TM { type : QSUB, header:\"#PBS -S /bin/bash #PBS -N single #PBS -l nodes=1:ppn=16 #PBS -j oe #PBS -V\" } 注意：ABACUS在任务提交时，应注意指定OMP_NUM_THREADS，防止内存不足引起计算错误 2. 准备 Specific 文件夹 所需文件：INPUT_X（使用ABACUS弛豫）、ATOMIC_SPECIES、NUMERICAL_ORBITAL以及轨道和赝势文件。 INPUT 文件内容和个数由用户自行设置（需要与 input.uspex 中 stages 对应），具体可参考 uspex 官方文档。 需要注意的是：INPUT 的 suffix 需指定为 USPEX； 需给出 ATOMIC_SPECIES 和 NUMERICAL_ORBITAL 两个文件指定所使用的 upf 文件和 orb 文件。 ATOMIC_SPECIES 内容：元素符号 质量 赝势文件名 NUMERICAL_ORBITAL 内容：元素符号 轨道文件名 3. 根据计算实际需求添加 Seeds 结构（可选，非必须） 4. 提交运算 nohup ./uspex-sub.sh >> log & ### content of uspex-sub.sh #!/bin/sh while true;do data >> log uspex -r >> log sleep 300 ### Users can adjust this value to manipulate the frequency of the call to uspex. done 5. 计算结果 如果程序可以正常提交任务，log文件中会打印如下内容： 2023-08-09 16:52:47,115 - USPEX.Optimizers.Target - INFO - Following utilities was not initialized: ['PowderSpectrumAnalyzer', 'SingleCrystalSpectrumAnalyzer']. 2023-08-09 16:52:47,115 - USPEX.Optimizers.Target - INFO - Permutation does not work when number of symbols in calculation is 1. 2023-08-09 16:52:47,123 - USPEX.Stages.GenerationController - INFO - Calculation initialized from input parameters. 2023-08-09 16:52:47,441 - USPEX.Selection.USPEXClassic - INFO - System 0 successfully created by RandSym operator. 2023-08-09 16:52:47,866 - USPEX.Selection.USPEXClassic - INFO - System 1 successfully created by RandSym operator. 2023-08-09 16:52:48,638 - USPEX.Selection.USPEXClassic - INFO - System 2 successfully created by RandSym operator. 2023-08-09 16:52:48,767 - USPEX.Selection.USPEXClassic - INFO - System 3 successfully created by RandSym operator. 2023-08-09 16:52:48,788 - USPEX.Stages.Executor - INFO - System 0 with tag 1 will be submitted now. 2023-08-09 16:52:48,788 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,792 - USPEX.Stages.Executor - INFO - System 1 with tag 1 will be submitted now. 2023-08-09 16:52:48,792 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,796 - USPEX.Stages.Executor - INFO - System 2 with tag 1 will be submitted now. 2023-08-09 16:52:48,797 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,801 - USPEX.Stages.Executor - INFO - System 3 with tag 1 will be submitted now. 2023-08-09 16:52:48,801 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,812 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37768 2023-08-09 16:52:48,818 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37769 2023-08-09 16:52:48,822 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37770 2023-08-09 16:52:48,825 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37771 如果程序可以正常输出结果，在 results1/Individuals 中会打印相关的信息，示例如下： +----+------------------+-------------+---------------+--------------+---------------+-----------------+---------------+--------------+ | ID | Origin | Composition | Enthalpy (eV) | Volume (A^3) | SYMMETRY (N) | Structure order | Average order | Quasientropy | +----+------------------+-------------+---------------+--------------+---------------+-----------------+---------------+--------------+ | 0 | RandSym | Si: 4 | -425.452 | 59.320 | P6/mmm (191) | 0.334 | 0.334 | -0.000 | | 2 | RandSym | Si: 4 | -418.078 | 59.320 | I4/mmm (139) | 0.287 | 0.287 | -0.000 | | 3 | RandSym | Si: 4 | -425.038 | 59.320 | P4_332 (212) | 0.392 | 0.392 | -0.000 | | 4 | Softmodemutation | Si: 4 | -428.592 | 59.320 | I4/mmm (139) | 0.325 | 0.325 | 0.000 | | 5 | Softmodemutation | Si: 4 | -428.592 | 59.320 | I4/mmm (139) | 0.325 | 0.325 | 0.000 | | 6 | Heredity | Si: 4 | -427.892 | 59.320 | P2_1/m (11) | 0.202 | 0.215 | 0.077 | | 8 | Softmodemutation | Si: 4 | -427.882 | 59.320 | P2_1/m (11) | 0.201 | 0.215 | 0.076 | | 9 | Softmodemutation | Si: 4 | -427.887 | 59.320 | P2_1/m (11) | 0.202 | 0.215 | 0.075 | | 10 | Heredity | Si: 4 | -428.645 | 59.320 | Cmce (64) | 0.261 | 0.261 | 0.000 | | 11 | Softmodemutation | Si: 4 | -428.644 | 59.320 | Cmce (64) | 0.261 | 0.261 | 0.000 | | 12 | Softmodemutation | Si: 4 | -428.645 | 59.320 | Cmce (64) | 0.261 | 0.261 | 0.001 | | 14 | Heredity | Si: 4 | -428.628 | 59.320 | Cmce (64) | 0.263 | 0.263 | 0.000 | | 15 | Heredity | Si: 4 | -428.928 | 59.320 | Cmcm (63) | 0.291 | 0.291 | 0.000 | | 16 | Heredity | Si: 4 | -428.949 | 59.320 | P2_1/m (11) | 0.283 | 0.284 | 0.006 | | 17 | RandSym | Si: 4 | -422.987 | 59.320 | C2/m (12) | 0.250 | 0.250 | 0.000 | | 19 | Softmodemutation | Si: 4 | -428.927 | 59.320 | Cmcm (63) | 0.291 | 0.291 | 0.000 | | 20 | Softmodemutation | Si: 4 | -428.928 | 59.320 | Cmcm (63) | 0.290 | 0.290 | 0.000 | | 21 | Heredity | Si: 4 | -428.926 | 59.320 | Cmcm (63) | 0.290 | 0.290 | 0.000 | 四、结语 建议大家在使用前，首先选择小体系进行测试；此外大家也可根据自己的实际需要对接口文件进行修改扩充，有相关问题可通过邮件方式沟通。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-14 15:07:32 "},"abacus-namd.html":{"url":"abacus-namd.html","title":"ABACUS+Hefei NAMD 使用教程","keywords":"","body":"ABACUS+Hefei NAMD 使用教程 作者：李源波，邮箱：liyuanbo9812@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/01 一、介绍 激发态动力学一直是凝聚态物理中的重要问题，在激发状态下，凝聚态体系中的准粒子会发生复杂的相互作用，涉及到不同时间尺度的超快过程，因此，研究凝聚态体系的激发态动力学不仅需要从时间、空间、能量和动量等多个维度对其进行描述，还需要描述不同准粒子之间的动态耦合，而目前商用的第一性原理软件无法满足这样的需求。针对这一问题，中国科学技术大学赵瑾教授团队发展了自主可控的激发态动力学软件 Hefei-NAMD（https://hefei-namd.org/code/），基于面跳跃算法（Surface Hopping）与经典路径近似，初步实现激发态动力学在时间、空间、动量、能量、自旋等多个维度上的描述，并可以研究激发态电子、空穴、激子、声子、极化子等准粒子的动态相互作用。Hefei-NAMD 程序采用模块化架构，包含单粒子动力学、自旋动力学、动量空间动力学以及 GW+rtBSE 模块。目前程序使用周期性边界条件，可处理上百个原子，且与密度泛函软件 VASP、Quantum Espresso 等存在接口，Hefei-NAMD 和 ABACUS v3.2 建立的接口（主要针对局域轨道算法，涉及波函数与局域轨道下的交叠矩阵等信息，用来计算非绝热耦合项和电子跃迁概率）和提供的相关案例，可以进一步拓宽 Hefei-NAMD 的使用范围。 本教程旨在介绍采用 ABACUS（基于 ABACUS 3.2.0 版本）做分子动力学计算，将结果作为 Hefei NAMD 软件的输入文件进行后续非绝热分子动力学计算的流程。 这里推荐大家阅读 Hefei NAMD 软件的相关文档和说明： http://staff.ustc.edu.cn/~zqj/posts/Hefei-NAMD-Training/ https://github.com/QijingZheng/Hefei-NAMD https://github.com/vtzf/abacus-namd（这个是拥有与 ABACUS 接口的 Hefei NAMD 仓库，功能与上面的仓库是一样的），第一步请先下载这个链接上面的 python 代码。 二、计算流程 我们这里提供的测试案例是包含 2 个原子的金刚石结构 Si 结构，采用的模守恒赝势是 Si_ONCV_PBE-1.0.upf，以及原子轨道文件采用的是 Si_gga_8au_60Ry_2s2p1d.orb（GGA 泛函，8 au 截断半径，60 Ry 能量截断，以及包含 2s2p1d 的 DZP 轨道）。 1. 用 ABACUS 进行分子动力学(MD)计算 1.1 输入文件 INPUT 大部分参数为做分子动力学计算所需要参数，具体含义可以参考 ABACUS 的分子动力学教程。为了后续用 Hefei NAMD 进行非绝热分子动力学计算，ABACUS 会输出每一步分子动力学模拟的哈密顿量矩阵 H、交叠矩阵 S、波函数文件。因此需将相关的 ABACUS 的 INPUT 文件中的输入参数 out_wfc_lcao 和 out_mat_hs 都设置为 1，表示输出这些物理量。计算完成后，在 OUT.*** 文件夹中，每一个分子步都对应一个文件夹 MD_n，在每个文件夹中会有 data-0-H、data-0-S、LOWF_GAMMA_S1.dat 三个文件储存我们需要输出的物理量。 INPUT_PARAMETERS #Parameters (General) suffix autotest pseudo_dir ../../tests/PP_ORB orbital_dir ../../tests/PP_ORB nbands 8 calculation md #Parameters (Accuracy) ecutwfc 50 scf_nmax 20 basis_type lcao md_nstep 10 cal_stress 1 stress_thr 1e-6 cal_force 1 force_thr_ev 1.0e-3 ks_solver genelpa mixing_type pulay mixing_beta 0.7 md_type nve md_restart 0 md_tfirst 10 init_vel 1 read_file_dir ./ gamma_only 1 out_wfc_lcao 1 out_mat_hs 1 1.2 结构文件 STRU ATOMIC_SPECIES Si 1 Si_ONCV_PBE-1.0.upf NUMERICAL_ORBITAL Si_gga_8au_60Ry_2s2p1d.orb LATTICE_CONSTANT 10.2 LATTICE_VECTORS 0.5 0.5 0 #latvec1 0.5 0 0.5 #latvec2 0 0.5 0.5 #latvec3 ATOMIC_POSITIONS Cartesian Si #label 0 #magnetism 2 #number of atoms 0 0 0 m 1 1 1 v 1.75205850628e-05 0.000155425594558 -3.99334763874e-05 0.241 0.255 0.250999999999 m 1 1 1 v -1.75205850628e-05 -0.000155425594558 3.99334763874e-05 2. 用 Hefei NAMD 进行非绝热分子动力学（NAMD）计算 Hefei NAMD 代码为 python 代码，在 src 目录下，建议使用 python 3.9。需要的 python 库有 Numpy，Scipy，Numba，MPI4py（>= 3.1.3）。 2.1 设置 NAMD 计算参数 在 Args.py 中设置 NAMD 的各种参数，在 Args.py 的注释中有关于各种参数具体含义的详细介绍。 # NAMD parameter # manual input start dftdir = '/public/share/zhaojin/tuyy/abacus/sh/OUT.autotest1/' namddir = '../namd_test/' # output NAMD output file in namddir dt = 1 # MD time step (fs) start_t = 1 # start MD step end_t = 2000 # end MD step istart_t = 901 # isample start MD step iend_t = 1000 # isample end MD step LCHARGE = True # output atom projected charge density atom = [13,26]# atom number of all species (only needed in atomic basis) orbital = [27,13]# atomic orbital basis number (only needed in atomic basis) whichA = [0,13,14,15] # atom index for projected charge density (starts from 0) LRANGE = True # select range of band, change iband # if not given, LRECOMB specifies energy range # if LRECOMB not given, energy range: [0,nbands] LHOLE = True # Hole/electron transfer dE = 2.0 # initial energy from VBM/CBM (eV) LPHASE = True # phase correction TEMP = 300 # temperature in Kelvin NACTIME = 1000 # time for used NAC (i_end_t-state_t+NACTIME 2.2 读取 ABACUS 的输出文件 运行 NAC.py 即可将 ABACUS 的输出文件转成 Hefei NAMD 需要的 NATXT 和 EIGTXT 文件。 在超算上计算的话，可以直接使用用 sub_scripts 目录下的 sub_nac 脚本提交任务，用户可在 sub_nac 中自行修改节点数等信息。 sbatch sub_nac 2.3 进行非绝热分子动力学计算 运行 SurfHop.py 即可进行 NAMD 的计算。 在超算上计算的话，可以直接使用用 sub_scripts 目录下的 sub_sh 脚本提交任务，用户可在 sub_sh 中自行修改节点数等信息。 sbatch sub_sh 输出文件中，SUPROP 文件中包含了电子驰豫能量和电子占据数随时间的演化，PSICT 文件则包含波函数系数随时间的演化。可用 https://github.com/QijingZheng/Hefei-NAMD/tree/master/scripts 中的脚本进行画图。 三、结语 本篇主要介绍了如何利用 ABACUS 和 Hefei NAMD 进行非绝热分子动力学的计算，简单来说就是通过 ABACUS 跑分子动力学得到每一步的波函数和哈密顿量等信息，Hefei NAMD 再读入这些信息进行非绝热分子动力学的计算。关于非绝热分子动力学的详细介绍则可以查看 Hefei NAMD 的相关网站（见最上面的网站），如有问题欢迎联系。 四、参考文献 Zheng, Q.; Chu, W.; Zhao, C.; Zhang, L.; Guo, H.; Wang, Y.; Jiang, X.; Zhao, J. Ab initio nonadiabatic molecular dynamics investigations on the excited carriers in condensed matter systems. Wiley Interdiscip. Rev. Comput. Mol. Sci. 2019, 9, e1411. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-02 10:24:57 "},"develop-C++.html":{"url":"develop-C++.html","title":"ABACUS 开源项目 C++ 代码规范","keywords":"","body":"ABACUS 开源项目 C++ 代码规范 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/04 ABACUS（Atomic-orbtial Based Ab-initio Computation at UStc，中文名原子算筹）是国产开源密度泛函理论软件，相关介绍 ABACUS 的新闻可在 ABACUS 新闻稿整理查看。此文档用于给 ABACUS 开发者提供代码编程规范方面的建议。 前言 让任何开发者都可以快速读懂别人的代码，这点对于 ABACUS 项目很重要。此外，使代码易于管理的方法之一是加强代码一致性，这需要从代码规范开始着手。 一、命名约定 1. 普通变量的命名统一是小写，并使用下划线命名法 以下是四种命名方法：下划线命名法、匈牙利命名法、驼峰式命名法、帕斯卡命名法 string table_name; // 下划线命名法（推荐） - 用下划线区分单词（推荐使用） string sTableName; // 匈牙利命名法 - 前缀字母用变量类型缩写，单词首字母大写 string tableName; // 驼峰命名法 - 混合大小写（不推荐使用） string TableName; // 帕斯卡命名法 - 每个单词首字母大写（不推荐使用) 下划线命名法：推荐使用 匈牙利命名法：目前 ABACUS 中有些变量（例如指针），首字母为数据类型（指针为 p），可以考虑用这种方式命名，但不推荐用大写字母 驼峰命名法/帕斯卡命名法：目前 ABACUS 大部分的代码不是用这种命名方式的，为了代码风格统一，所以不推荐使用 2. 函数命名 建议使用下划线命名法且所有字母全部小写，建议小于 18 个字符 void calculate_area() { // function body } 3. private 的类数据成员在最后以下划线结尾 private 的类数据成员和普通变量的命名方式一样，但要在最后以下划线结尾，以区分自己是 private 的类数据成员。 class TableInfo { ... private: string table_name_; // 好 - 后加下划线 string tablename_; // 好 static Pool* pool_; // 好 }; 4. 只有全局变量用全大写命名 在 ABACUS 中，例如 NBANDS（能带数），NLOCAL（局域轨道数目）这种全大写的变量名是全局变量，其它的不建议用大写字母给变量命名。另外，ABACUS 将通过重构或者删除的方式逐步淘汰全局变量，因此不建议增加新的全局变量。 二、关于头文件 1. 只有在真正需要使用某个库/头文件时才 #include 它们 不需要的 #include 删除。 2. #include避免使用快捷目录 . (当前目录) 或 .. (上级目录) 项目内头文件应按照项目源代码目录的树结构排列，避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录)。例如 source/module_hsolver/diago_cg.h 文件是这样引用 module_base 的头文件： #include \"diagh.h\" #include \"module_base/complexmatrix.h\" 3. #include 顺序（clang-format 可以自动） 使用标准的头文件包含顺序，这样可以可增强可读性，避免隐藏依赖。 foo.cpp 中包含头文件的次序如下： 与源文件对应的头文件：dir2/foo2.h（这种优先的顺序排序保证当 dir2/foo2.h 遗漏某些必要的库时， dir/foo.cpp 的构建会立刻中止） C 系统文件 C++ 系统文件 其他库的 .h 文件 本项目内 .h 文件 4. 头文件需要 #define 保护 #ifndef FOO_BAR_BAZ_H_ #define FOO_BAR_BAZ_H_ ... #endif // FOO_BAR_BAZ_H_ 5. 避免使用前置声明 使用 #include 包含需要的头文件，尽量避免使用前置声明（见以下例子解释什么是前置声明）。 // 什么是前置声明？ // MyClassB.h // Bad: Overuse of forward declarations class MyClassB; class MyClassA { public: void DoSomething(MyClassB* obj_b); }; void MyClassA::DoSomething(MyClassB* obj_b) { // ... } 在这段代码中，MyClassB 被声明为一个类，但没有给出其定义。这被称为前置声明（Forward Declaration），它告诉编译器 MyClassB 是一个存在的类，但不提供该类的详细信息。 6. 当函数只有 10 行甚至更少时，才将其定义为内联函数 只有当函数只有 10 行甚至更少时才将其定义为内联函数（关键字 inline）。 三、关于类（Class） 1. 先声明类的成员变量，再声类的成员函数 2. 将public 部分放在最前，之后是protected数据，最后是private 3. 不使用运算符重载 若要使用，建议提交 issue 讨论 4. 什么时候用 struct？ 只有数据成员、没有成员函数时可以用 struct 5. 类型转换使用static_cast<>() 建议使用 C++ 的类型转换，如 static_cast<>()。 不要使用 int y = (int)x 或 int y = int(x) 等转换方式。 用 static_cast 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时。 用 const_cast 去掉 const 限定符。 用 reinterpret_cast 指针类型和整型或其它指针之间进行不安全的相互转换。 仅在你对所做一切了然于心时使用。 6. 继承采用 public 继承 如果你想使用私有继承，你应该替换成把基类的实例作为成员对象的方式去定义类。 7. 不过度使用实现继承，可以考虑组合 例如，如下案例： class Engine { public: void start() { /* 启动引擎 */ } }; class Car { public: Car(const std::string& n, Engine& e) : name_(n), engine_(e) {} void drive() { engine_.start(); std::cout 四、关于函数（Function） 1. 函数传参：不变参数用 const 和 & 函数的输入参数与输出参数: 在一个函数中，不变的量，我们可以看作是函数的输入参数；变化的量，我们可以看作是函数的输出参数。 在输入参数中可以选择 const T* （指向常量对象的指针，不能通过这个指针来修改其指向的对象的值。然而，你可以改变指针本身的值）。 也可以使用 const T& （不能通过这个引用来修改其引用的对象的值，在其生命周期内不能重新引用另一个对象）。 所以，建议使用 const T&，若要使用 const T*，则应给出相应的理由，否则会使读者感到迷惑。 void Foo(const string &in, string *out); // 输入参数：in （const + 引用&） // 输出参数：out（指针变量） 2. 函数传参：会变的参数用指针 什么是引用参数: 在 C 中, 如果函数需要修改输入变量的值, 参数必须为指针, 如 int foo(int *pval)。 在 C++ 中, 函数还可以声明为引用参数: int foo(int &val)。 引用参数在语法上是值变量却拥有指针的语义（变量可以被改变！）。 3. 每个函数不超过 50 行 建议编写简短，凝练的函数，有特殊情况的除外。 4. 函数返回值（return 的值）多使用值返回和引用返回，避免使用指针返回 五、关于作用域 1. 变量要初始化 无初始化的变量可能会引起结果不稳定（例如出现随机数），因此建议养成习惯，对所有变量的值要初始化，见下面的例子： int i; i = f(); // 坏——初始化和声明分离 int j = f(); // 好——初始化时声明 vector v; // 坏——初始化和声明分离 v.push_back(1); v.push_back(2); vector v = {1, 2}; // 好——初始化时声明 2. 将局部变量置于最小作用域 在 if, while 和 for 语句中： 变量不是对象，则变量应当在内部声明与初始化，这样子这些变量的作用域就被限制在这些语句中了，举例而言： while (const char* p = strchr(str, '/')) { str = p + 1; } 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数。这会导致效率降低。建议将构造函数调用次数减少以提高程序效率。 Foo f; // 构造函数和析构函数只调用 1 次 for (int i = 0; i 3. 仅在局部作用域使用using namespace 使用 using namespace 语句来引入命名空间中的所有名称可能会导致名称冲突。因此，建议在需要时使用它并仅在局部作用域内使用（例如只在调用的时候使用）。 // 建议不在程序开头使用，而是在具体用到std库的函数内使用该语句 using namespace std; 4. 用全局函数要加命名空间 以下是两种建议的方式，或者用类，或者用 namespace // 类的静态成员函数 class MyMath { public: static int add(int a, int b) { return a + b; } static int sub(int a, int b) { return a - b; } }; // or // 命名空间内的非成员函数 namespace my_math { int add(int a, int b) { return a + b; } int sub(int a, int b) { return a - b; } } 5. 优先使用命名空间的非成员函数 能使用命名空间的非成员函数，就不用类的静态成员函数。 // 使用命名空间内的非成员函数 namespace my_math { int add(int a, int b) { return a + b; } int sub(int a, int b) { return a - b; } } int main() { int x = 3, y = 5; int z = my_math::add(x, y); // 调用 my_math 命名空间中的函数 return 0; } // 不要使用类的静态成员函数模拟命名空间 class MyMath { public: static int add(int a, int b) { return a + b; } static int sub(int a, int b) { return a - b; } }; int main() { int x = 3, y = 5; int z = MyMath::add(x, y); // 调用 MyMath 静态方法 return 0; } 六、其他 C++ 特性 1. 每个代码文件不超过 500 行 太长的代码阅读理解和维护的成本都太高，因此不建议一个文件太长。如果有文件超过 500 行，建议重构，把对象进一步的划分。 2. 禁止用 C++11 之后版本的语法 目前的主要考虑是用新语法会使得编译器编译成功的概率降低，另外提高开发者的开发门槛。因此，我们规定不能使用 C++11 之后的语法。 3. 多用前置自增 (++i) 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增，自减运算符。 不考虑返回值的话，前置自增 (++i) 通常要比后置自增 (i++) 效率更高。 4. 尽可能用 sizeof(a) 代替 sizeof(int) 这里 a 是一个参数名 原因：当代码中变量类型改变时会自动更新。 5. 多使用列表初始化 C++11 中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下： // Vector 接收了一个初始化列表。 // 不考虑细节上的微妙差别，大致上相同。 // 可以任选其一。 vector v{\"foo\", \"bar\"}; vector v = {\"foo\", \"bar\"}; // 可以配合 new 一起用。 auto p = new vector{\"foo\", \"bar\"}; // map 接收了一些 pair, 列表初始化大显神威。 map m = {{1, \"one\"}, {2, \"2\"}}; // 初始化列表也可以用在返回类型上的隐式转换。 vector test_function() { return {1, 2, 3}; } // 初始化列表可迭代。 for (int i : {-1, -2, -3}) {} // 在函数调用里用列表初始化。 void TestFunction2(vector v) {} TestFunction2({1, 2, 3}); 6. 初始化时：整数用0，实数用0.0，指针用nullptr，字符 (串) 用'\\0' C++11 引入了一个新的关键字 nullptr，用来表示空指针。相对于传统的 NULL 或 0，nullptr 更加明确、类型安全。使用 nullptr 可以避免一些潜在的编程错误，比如将整数值误传给函数，导致出现不可预期的行为。 因此，建议在 C++11 及以上的版本中使用 nullptr 来表示空指针。 7. 少用 auto，使用前需对 auto 有更全面的了解 auto 是 C++11 引入的关键字，它可以让编译器自动推导出变量的类型。之后，C++14 和 C++17 对 auto 的使用也有了一些扩展和改进。 C++11：auto 只能用于定义局部变量，并且必须初始化。例如： auto i = 42; // 推导出 i 的类型为 int auto f = 3.14f; // 推导出 f 的类型为 float auto s = \"hello\"; // 推导出 s 的类型为 const char* C++14：auto 可以用于定义函数返回值类型，使得函数定义更加简洁。例如： auto add(int x, int y) { return x + y; } // 推导出返回类型为 int auto divide(double x, double y) { return x / y; } // 推导出返回类型为 double C++17：auto 进一步扩展为 auto 和模板结合使用时，可以直接指定模板类型参数，从而实现更加灵活的类型推导。例如： std::vector v{1, 2, 3}; auto it = v.begin(); // 推导出 it 的类型为 std::vector::iterator auto [first, second] = std::make_pair(1, 3.14); // 使用结构化绑定和 auto 推导出 first 和 second 的类型 但是大家注意，在 abacus 中，我们只支持 C++11 的标准，C++14/17 语法是不接受的。 8. auto 和 for 的混合使用时注意事项 在 C++11 中，auto 和 for 循环的结合使用已成为一种常见的编程范式，它可以让代码更加简洁、易读，并且减少了手动指定类型的错误。 int arr[] = {1, 2, 3}; for (auto i : arr) // 相当于复制 { std::cout 9. constexpr 替代宏定义和 const 常量 在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。（真正的常量在编译时和运行时都不变） #define PI 3.14159 // PI 是一个宏定义常量，它不会进行类型检查，容易出错； const double kE = 2.71828; // kE 是一个 const 常量，它不能用于编译期计算。 constexpr double kGravity = 9.8; constexpr 可以替代宏定义和 const 常量的主要原因是： 类型安全：使用 constexpr 定义的常量会进行类型检查，避免了宏定义可能带来的类型错误，同时也比 const 常量更加严格。 编译时计算：constexpr 声明的变量或函数在编译时就可以被求值，而不需要在运行时计算。这比宏定义和 const 常量更高效，尤其是在需要多次使用同一个值的情况下。 更好的可读性和可维护性：使用 constexpr 可以使代码更加清晰易懂，减少了宏定义可能导致的代码混乱问题。同时，由于 constexpr 可以使用函数、类等 C++ 语言特性，因此更加灵活，对于复杂的计算也更容易维护和修改。 因此，在 C++11 及以上的版本中，建议使用 constexpr 来替代宏定义和 const 常量，以提高代码的可读性、可维护性和效率。 七、关于 ABACUS 中常用的关键词缩写 有些名字很长，我们希望尽量言简意赅的表达出一些关键词的意思。原则是一般 3-5 个字母的范围下尽量说清楚一个变量的含义。这些统一的命名会出现在函数名或者变量名里。 1. 两个字符 pw：代表plane wave平面波 op：代表具有multi-device和multi-precision支持的算子（operator），和Operator模块含义不同 2. 三个字符 fft：快速傅里叶变换 kpt：布里渊区kpoint的缩写 nao：代表numerical atomic orbitals （nao经常用来表示number of atomic orbitals，不知道会不会混） orb：orbital，轨道 hmt：代表hamilt或者hamiltonian pot：代表potential chg：代表charge den：代表density（电荷密度尽量都用chg） scf：代表自洽迭代self consistent field thr：代表threshold tab：代表table kin：代表kinetic，动能的 cal：代表calculate opt：代表optimize gen：代表generate 3. 四个字符 iter：代表iteration init：代表初始化initializaiton read：读入 stru：代表structure veff：代表有效势 vloc：代表局域势 Reference Google C++ Style Guide Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-14 14:54:25 "},"develop-format.html":{"url":"develop-format.html","title":"ABACUS 中使用格式化工具 clang-format","keywords":"","body":"ABACUS 中使用格式化工具 clang-format 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/03 一、引言 良好统一的代码风格在多人协同开发中至关重要，这一点在 ABACUS 团队里也尤其重要，特别是考虑到大部分的开发者都是研究生，没有经过特别系统的编程训练，那么好的代码风格能够降低阅读代码的障碍，加快开发效率，甚至可以防止一些不必要的 bug 的产生。 clang-format 是一个开源的代码格式化工具，它可以帮助程序员自动调整源代码的格式，以符合指定的编码风格规范。clang-format 可以在保持代码功能不变的情况下，自动处理缩进、空格、括号、逗号等细节，提高代码的可读性和一致性。 二、在 ABACUS 中使用 clang-format clang-format 支持包括 LLVM、Google、Chromium、Mozilla、WebKit 等在内的多种代码风格，如果不指定自定义的代码风格，每次对代码进行格式化时使用的将是 clang-format 默认的风格。 clang-format 还支持在已有的代码风格基础之上自定义一个名为 .clang-format 的代码风格文件，clang-format 就可以根据文件中定义的规则对代码进行格式化。 在 ABACUS 开源项目中，开发者已经制定了针对 ABACUS 项目的代码风格文件 .clang-format，其位于项目的根目录下。（https://github.com/deepmodeling/abacus-develop/blob/develop/.clang-format） 注意事项：ABACUS 开源项目中的.clang-format是依赖于 clang-format-14 标准的，因此请确保你的 clang-format 不低于 14 版本。 1. 在系统上安装 clang-format clang-format 有诸多版本可供使用，目前最新版本为 clang-format 18。不同版本所支持的格式化选项不尽相同，但向后兼容。 安装统一版本的 clang-format（ABACUS 项目中统一选择 clang-format-14） # Linux上，以Ubuntu为例： sudo apt install clang-format-14 # 验证是否安装成功，并查看安装的版本号： clang-format-14 --version ⚠ 这里应注意，不能通过 sudo apt install clang-format 命令进行安装，因为对于不同的 Ubuntu 发行版而言，通过该命令安装得到的 clang-format 版本是不同的。 安装完成后，我们能够使用的命令名是 clang-format-14，我们将其提级为 clang-format： sudo update-alternatives --install /usr/bin/clang-format clang-format /usr/bin/clang-format-14 100 后面当我们使用 clang-format 命令时，指代的即为 clang-format-14。 # 此时再次验证安装的版本号：（应为 14 版本） clang-format --version 2. 基于 vscode 使用 clang-format 基于 vscode 使用 clang-format，我们可以选择安装支持 clang-format 的插件，即可更方便的使用 clang-format。 但由于插件商场有很多插件都支持 clang-format 功能，且其支持的 clang-format 版本经常变化。所以我们应尽量选择支持更为稳定的插件进行使用。 通过 vscode 进行 C++ 开发时，我们一般会安装微软官方的 C/C++ 插件，打开该插件的安装目录我们会发现，该插件已经封装了一个内置的 clang-format。那为什么不直接使用这个 C/C++ 插件内置的 clang-format 呢？ 不同版本的 C/C++ 插件内置的 clang-format 版本往往不同，就带来不必要的麻烦。 为了使用统一的 clang-format-14，我们建议在 vscode 中安装 Clang-Format（Xaver Hellauer） 插件 。 安装完成后，打开“File -> Preferences -> Settings”，搜索“format”，如下图： 将 Default Formatter 刚换为新下载的 Clang-Format 插件。 之后在一个文件内，通过 \"option\" + \"shift\" + \"F\" 快捷键，即可实现对当前代码文件的格式化。 3. 基于命令行使用 clang-format 除了使用 vscode ，可能还会有使用命令行进行开发的开发者。 使用方式： clang-format -style=file -i demo.cpp 三、参考文献： 使用 clang-format 进行 C++ 代码风格管理 Clang-Format 用法详解 Clang-Format Style Options — Clang 14.0.0 documentation C++ programming with Visual Studio Code 基于 vscode 使用 clang-format（旧版） Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-03 22:31:03 "},"develop-dox.html":{"url":"develop-dox.html","title":"ABACUS 注释规范：Doxygen 入门 (c++)","keywords":"","body":"ABACUS 注释规范：Doxygen 入门 (c++) 作者：金祖鑫，邮箱：jinzx@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/15 一、简介 开源密度泛函理论软件 ABACUS 目前由众多社区开发者共同开发，因此有一个统一的代码注释规范是非常重要的，本文主要推荐以 Doxygen 工具为辅助的代码注释格式。 1. 什么是 Doxygen Doxygen 是一款支持包括 C/C++, Python, Fortran 等多种语言的静态程序分析与文档生成工具。通过搜集并整理代码中的信息，包括但不限于 函数的调用/被调用 类的成员以及继承、协作关系 文件夹之间的依赖关系 头文件 include 关系 Doxygen 不仅能自动生成包含以上信息的图表与列表，也能将代码中采用特定格式的注释附到相应位置，最终生成内容翔实的文档。在适当的 Doxygen 配置与良好的代码注释下，Doxygen 自动生成的文档能为开发者提供诸多便利，降低阅读代码的难度，从而促进开发者社区的建设。 2. 功能与文档范例 Doxygen 可以生成某个函数的调用与被调用图(call & caller graph)。以开源密度泛函理论软件 ABACUS 代码为例，其中负责计算三次样条插值的函数 ModuleBase::CubicSpline::eval，doxygen 可将其调用关系自动可视化为如下图表： Doxygen 可以将类的继承关系生成图表。下图展示了 ModuleESolver::ESolver 的一系列继承 Doxygen 可以生成类的协作图（collaboration diagram）。下图展示了 container::Tensor 的成员以及成员的成员之间的关系： Doxygen 可以生成文件夹之间的依赖关系图。下图展示了 source/module_basis 及其内部成员文件夹与其他文件夹的耦合。 Doxygen 可以将头文件的 include 关系可视化成图表 (include dependency graph)。下图（部分地）展示了 module_basis/module_nao/numerical_radial.h 包含与被包含的情况： 大量项目使用 Doxygen 生成文档 (https://www.doxygen.nl/projects.html)。对科学计算开发者而言一个著名的例子是 LAPACK 的在线文档 https://www.netlib.org/lapack/explore-html/ 二、如何使用 Doxygen Doxygen 可以自动识别代码逻辑并生成以上例子中的函数调用、类的继承与协作、文件夹依赖以及头文件依赖等图表。但是，对理想的开发者文档而言代码注释中的信息亦不可或缺。在最终生成的文档中，除以上自动生成的图表外，Doxygen 会将类的成员与函数一一列举，并识别代码中特定格式的注释后将其附在对应位置。 1. 如何写能被 Doxygen 识别的注释 通常开发者会希望一部分精心撰写的注释——比如类的功能介绍或者函数参数的含义——出现在开发者文档里，而不希望文档充斥着临时变量的描述或某一行意义的解释。Doxygen 充分考虑了这一点。事实上，普通的注释均会被 Doxygen 忽略；只有特定格式的注释会被 Doxygen 识别。下面的代码是一个简单的例子。尽管其中各处都附上了注释，但这些均不会出现在最终生成的文档中： // A class that represents a circle. // This toy class will be used to demonstrate the usage of Doxygen. class Circle { public: // Initializes a Circle object with a given radius. // A unit circle is assumed by default. Circle(double r = 1.0); // Rescales a Circle object. // The radius of the given Circle object is multiplied by the given factor. static void rescale(Circle* circ, // pointer to the Circle object double factor // radius rescaling factor ); private: double r_; // radius of the Circle object static constexpr double PI = 3.14159265358979324; }; 以上代码生成的文档如下。Doxygen 会自动将成员变量和函数一一列举，但由于注释不符合特定格式，因而不会出现在文档相应位置。 下面介绍如何写能被 Doxygen 识别的注释以及一些基本用法。 1.1 基本格式 在 c++ 中 Doxygen 会识别以下三种注释格式： Javadoc-style /** * This is a Javadoc-style comment */ Qt-style /*! * This is a Qt-style comment */ Extended c++ style /// This is the so-called extended c++-style comment //! This also works! 以上三种格式本身均是合法的 C++ 注释，只是在 // 和 / / 的基础上添加了额外的 '*' ，'!' 或 '/' 。一旦文档中出现了以上三者之一，Doxygen 便会将之后的注释内容填入文档的相应位置。这三种基本格式是所有 Doxygen 用法的基础，所有的进阶功能（如 group，module，equation 等）均需在这三者之一开启的注释行/块内实现。这三种基本格式可以混用，开发者可以按自己的习惯选择一种或多种使用。 Doxygen 默认注释作用于之后的类、变量或函数（允许有空行）。如我们希望注释作用于之前的对象，则可在基本格式后立刻添加 ' //！ this comment line applies to print(), even though there's an empty line below void print(); /// 1.2 详细与简略描述 如之前例子所示，Doxygen 自动生成类的文档时会先把成员函数与变量罗列在开头，随后才是每个成员的介绍（当然，由于之前的例子里没有采用 doxygen 格式，详细描述为空）。只要使用了基本格式，Doxygen 就会自动将注释附在对应成员处。比如若将之前构造函数前的 // 注释替换为 /// : /// Initializes a Circle object with a given radius. /// A unit circle is assumed by default. Circle(double r = 1.0); 这些内容即会出现在原先为空的 Constructor & Destructor Documentation 下 Circle()的描述里: Doxygen 还允许让一些简略描述出现在类文档的开头部分。有两种方式可以实现这一目的。较为正式的方式是在注释块里添加 @brief 或者 \\brief。以这种方式指定的简略描述可以跨多行（如下面开头 Circle 类的注释）。另一种较为轻便的方式是使用单行的 extended C++ style 注释，如下面 Circle 的构造函数。【多行的 extended c++ style 注释只会被当做详细描述】 /** * @brief A class that represents * a circle. * * This toy class will be used to demonstrate the usage of Doxygen */ class Circle { public: /// Initializes a Circle object with a given radius. /*! * A unit circle is assumed by default. */ Circle(double r = 1.0); /*! * \\brief Rescales a Circle object. * * The radius of the given Circle object is multiplied by the given factor. * */ static void rescale(Circle* circ, double factor ); private: double r_; /// 以上代码生成的 Doxygen 文档在开头罗列部分会出现对应的简略描述；详细介绍部分则会包括所有的注释（包括 brief）。 1.3 函数参数 一个开发者写的函数经常会被很多其他开发者使用。除对函数整体功能的描述外，每个参数含义的注释也十分重要。Doxygen 支持两种给函数参数添加注释的方式。较为正式的方式是在注释块内添加 @param 或 \\param： /*! * \\brief Rescales a Circle object. * * The radius of the given Circle object is multiplied by the given factor. * * @param [in,out] circ Pointer to the Circle object to be rescaled. * @param [in] factor Radius rescaling factor. */ static void rescale(Circle* circ, double factor ); 较为轻便的方式是在函数声明的参数列表里直接添加（加在参数后注意要使用 ' /*! * \\brief Rescales a Circle object. * * The radius of the given Circle object is multiplied by the given factor. */ static void rescale(Circle* circ, /// [in], [out] 或 [in, out] 可以提示该参数是输入还是输出参数。这并非 Doxygen 的强制要求，但十分推荐。 以上两种参数注释方式对 Doxygen 而言是等价的，开发者可按习惯选择一种使用，生成的函数描述如下： 1.4 数学公式 有时一些函数严格对应了某个公式，这种情况下直接用数学公式作为注释的效果可能胜过大段的文字描述。Doxygen 允许开发者以 Latex 的语法实现公式注释。如有在文字中嵌入公式的需求，可以采用 \\f$ ... \\f$： /// A constant that represents the value of \\f$ \\pi \\f$. static constexpr double PI = 3.14159265358979324; 单行公式由 \\f[ ... \\f] 实现： /*! * @brief Returns the area of the current Circle object. * * The area of the a circle is given by * * \\f[ S = \\pi r^2 \\f] */ double area() const; 如有多行公式的需求，Doxygen 支持调用 eqnarray 等 latex 数学环境： /*! * @brief Returns the circumference of the current Circle object. * * The circumference of the a circle is given by * * \\f{eqnarray*}{ * L &= \\pi d \\\\ * &= 2 \\pi r * \\f} * */ double circumference() const; 【在配置文件中采用 “USE_MATHJAX = YES” 可以调用 mathjax 渲染公式得到更好的视觉效果】 1.5 列表 Doxygen 还有大量用法可供用户生成理想的文档。 对齐的 '-', '+' 或 '*' 可自动生成列表 (bullet list)；'-#'则可用来生成带序号的列表： /** * @brief A class that represents * a circle. * * This toy class will be used to demonstrate the usage of Doxygen * * List of functionalities: * -# initialize a Circle object with a given radius * - a unit circle is assumed by default * -# get the radius of the current Circle object * -# get the area of the current Circle object * -# get the circumference of the current Circle object * -# rescale a Circle object by a factor * */ class Circle */ */ 1.6 Member Group & Module 变量或函数可以由 @{ ... ``@} 归类为 member group 并附上相应注释，这能使文档更有层次感： ///@{ @name Properties /// Functions that return the properties of the current Circle object. /// Gets the radius of the current Circle object. double radius() const { return r_; } /*! * @brief Returns the area of the current Circle object. * * The area of the a circle is given by * * \\f[ S = \\pi r^2 \\f] */ double area() const; /*! * @brief Returns the circumference of the current Circle object. * * The circumference of the a circle is given by * * \\f{eqnarray*}{ * L &= \\pi d \\\\ * &= 2 \\pi r * \\f} * */ double circumference() const; ///@} 有共性的类之间亦可归类组成 Modules: /// @defgroup shape Shape Module /// @brief A module that contains various shape classes. /// /// This module contains the following classes: /// - Circle /// - Rectangle /// - Triangle /// @addtogroup shape /// @{ class Circle { ... }; ///@} /// @addtogroup shape /// @{ class Rectangle { ... }; ///@} /// @addtogroup shape /// @{ class Triangle { ... }; ///@} 更多用法可参考官方文档 Doxygen Manual: Overview 2. 如何生成文档 上一节介绍了 Doxygen 支持的注释格式以及一些常见的使用方式。以下以 Ubuntu 用户为例介绍让开发者在本地生成 html 文档的方法： 1. 安装 doxygen 与 graphviz sudo apt install doxygen graphviz 2. 生成 Doxygen 的配置文件 doxygen -g 默认的配置文件名为 Doxyfile。 3. 修改配置文件 配置文件内已经包含介绍各选项的注释。常用的选项包括： INPUT：用以生成文档的文件夹或文件路径 RECURSIVE：是否遍历给定路径下的所有子文件夹 EXCLUDE：是否要排除一些子文件夹或子文件 EXTRACT_PRIVATE, EXTRACT_STATIC, EXTRACT_PRIV_VIRTUAL：文档是否要包括私有成员/静态成员/私有虚函数 CALL_GRAPH, CALLER_GRAPH: 文档是否要包含函数调用/被调图 PREDEFINED：预编译宏 MACRO_EXPANSION：是否要展开宏定义 EXPAND_ONLY_PREDEF：是否只展开 PREDEFINED 的宏定义 一个可供参考的 Doxyfile 可见于 Doxygen 使用 （赵天琦） 完整的配置选项可参考官网 Doxygen Manual: Configuration 4. 运行 doxygen 假设配置文件叫 my_doxyfile： doxygen my_doxyfile 附录：Doxygen 与 VS Code Visual Studio Code 上有 doxygen 插件 Doxygen Documentation Generator - Visual Studio Marketplace 可供 VS Code 用户方便使用。 【注：前文中有提到对 doxygen 而言三种基本注释格式可以混用；混用的注释会合并在一起作用于注释后的对象。这个特性与 VS Code 中鼠标悬停于类或函数上时出现的预览窗口不兼容；如注释格式混用则会导致前一种格式的注释被忽略】 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-15 19:30:43 "},"develop-issue.html":{"url":"develop-issue.html","title":"ABACUS 的 Github 仓库 Issues 处理流程","keywords":"","body":"ABACUS 的 Github 仓库 Issues 处理流程 作者：赵天琦，邮箱：zhaotq@aisi.ac.cnmailto:zhaotq@aisi.ac.cn； 审核：陈默涵，邮箱：mohanchen@pku.edu.cnmailto:mohanchen@pku.edu.cn 最后更新时间：2023/10/01 一、Github 的 Issues 机制 1. 简介 Github 的 Issues GitHub 上的 Issues 机制是一个用于跟踪和讨论项目相关问题、需求、任务和改进的功能。它为开发者们提供了一个集中式的平台，使得项目的参与者们能够跟踪项目进展、报告错误、提出新功能、讨论改进方向等。 2. Issues 对 ABACUS 软件的作用 ABACUS（原子算筹）是一款国产密度泛函理论（Density Functional Theory，简称 DFT）软件，其涉及到的功能繁多，仅 2023 年上半年统计到的输入参数就有三百多个，应用的对象也很广，在材料、物理、化学、能源和工程等多个领域都有应用。因此，常见的问题是开发者开发出的功能不能包含所有可能的应用对象，因此软件在某些特定场合出现效率不高甚至某个功能无法运行的情况是时有发生的。另外一方面，ABACUS 项目参与的开发人员广泛，不同开发者对同一个软件代码进行修改，容易引发新的 bug。因此，建立一个良好的用户和开发者，乃至开发者之间互动交流的平台，对于发现软件问题，不断改善软件质量和提高稳定性易用性方面具有重要作用。Github 上的 Issues 机制则承担起了这一部分功能。因此，将 Issues 机制建立好是不断提升 ABACUS 软件，使其快速迭代的重要措施。 3. Issues 功能介绍 创建 Issue：项目的任何参与者都可以新建一个 Issue。创建 Issue 时，需要填写标题、描述（可以使用 Markdown 语法格式化描述内容）、分配处理人（Assignees，可选）、添加分类标签（Labels，可选）、关联项目看板（Projects，可选）和设置里程碑（Milestones，可选）。 标签（Labels）：标签是用来对 Issues 进行分类和过滤的。项目维护者可以创建自定义标签，例如：bug、feature、documentation、enhancement 等。这有助于组织和优先处理不同类型的问题。 里程碑（Milestones）：里程碑用于对 Issues 进行分阶段管理和规划。项目维护者可以创建里程碑并为其分配截止日期，这样有助于按照计划进行项目开发。 指派（Assignees）：在 Issue 上指派处理人意味着将该 Issue 的负责人分配给特定的项目参与者。这有助于清楚地了解谁负责解决某个问题。 评论和讨论：项目的参与者们可以在 Issue 下面发表评论，进行讨论。评论支持 Markdown 语法，因此可以方便地插入代码、图片和链接等。 引用和关联 Issue：在评论和提交（Commit）中，可以通过输入类似 #issue编号 的格式引用其他 Issue，这有助于将讨论串联起来。此外，还可以使用关键字（如：close、fix、resolve 等）在提交信息中自动关闭相关 Issue。 通知和订阅：当您参与某个 Issue 时（如创建、评论或被指派），如果您希望及时收到回复，建议您关注是否会收到邮件通知（关注一下 Github 的功能） 关闭和重开 Issue：当某个问题被解决或者不再适用时，项目维护者或 Issue 创建者可以关闭 Issue。如果后续发现问题没有解决或者需要重新讨论，可以重新打开 Issue。 二、ABACUS 项目的 Issues 标签分类 提交 Issues 会让提交者（提交者可以是用户或者开发者）选择标签，以下是 ABACUS 开发者团队推荐的标签及其使用场景 分类 ： Bug Report（开发者/用户）: 用于报告代码问题，例如崩溃、错误或意外行为。 Code Quality（开发者）：用于报告与代码质量相关的问题，例如代码不规范、设计不良、全局类或去全局变量使用不当、或者可维护性问题，开发者会用重构来解决相关问题。 Docs（开发者/用户）：用于报告与软件文档相关的问题，例如缺少或不完整的文档，或难以理解的文档。 Feature Request（开发者/用户）：用于请求新功能或对现有功能进行增强。 Performance（开发者/用户）：用于报告与用户角度下软件性能相关的问题，例如响应时间慢、资源使用率高或可扩展性问题。 Questions（开发者/用户）：软件安装、软件易用性等用户或开发者需要帮助解决的问题。 Tests （开发者）：用于报告与测试相关的问题，例如测试失败、缺少或不完整的测试或测试自动化问题 优先级： Priority High: 通常指的是需要尽快解决的紧急问题，如 CI 不通过，新 PR 全部报错 Priority Medium: 重要且需要近期解决的问题，如... Priority Low：可能是一些不紧急但需要解决的问题，如需求调整、性能优化 专题 DFTU, EXX, big system 等用于记录一些专题类 Issues，以方便开发者系统解决同一个主题的 Issues 三、Issues 处理流程 1. 介绍 提交的Issues会在24小时内得到开发者团队的回复。当前Issues处理的闭环方式有： 提交PR修改代码，解决对应Issues，之后关闭相应的Issue。 ISSUE历史大于两周以上，且ISSUE提出者不对有效回应做回应，则提醒用户后关闭 属于Discussion机制而不属于Issues的范围，会转移到Github的Discussion模块：例如用户的想法，用户的建议，用户对社区的问题等以用户的满意程度为指标的问题 2. 创建一个 ISSUE 有多种方法可以创建 ISSUE，您可以选择最方便的方法来。本例将使用 GitHub UI。有关其他创建 ISSUE 的方法的更多信息，请参考 Github 文档“创建 ISSUE”。以下是具体步骤： 在 GitHub 上，导航到 ABACUS 仓库的主页。 https://github.com/deepmodeling/abacus-develop.git 在 ABACUS 仓库名称下面，单击“Issues”。 单击“New issue”。 选择一个最适合您的 ISSUE 的一个标签模版，点击“Get started”。如果 ABACUS 提供的默认模版不符合您的 ISSUE 类型，可以选择“Open a blank issue”。 3. 填入 ISSUE 信息 给您的 ISSUE 一个描述性的标题。标题应该一眼就能传达问题的内容。 添加一个解释 ISSUE 目的的描述，包括任何可能有助于解决问题的细节。例如，如果这是一个 bug 报告，描述重现 bug 的步骤、预期结果和实际结果。 您可以使用 Markdown 添加格式、链接、表情等。有关更多信息，可参阅“在 GitHub 上撰写”。 以下是 ABACUS 的 Bug report 类型 ISSUE 的模版，您可以根据 ISSUE 模版示例来填入 ISSUE 信息。其中带“*”的项是必填项。 4. ISSUE 的任务列表 请注意“Task list for Issue attackers”是为了帮助开发者检查 ISSUE 解决的进度，并不是要求您选择解决 ISSUE 需要完成哪些工作。所以您只需要提供足够详细的信息以帮助开发者来解决 ISSUE。如果您提供的信息已经完成其中的一些任务列表，可以在相应的任务前打对勾，但是如果没有可以不用关心“Task list for Issue attackers”。当然，了解解决一个 ISSUE 所需要经过的一般步骤，有助于您了解 ABACUS 代码的开发过程。如果您想通过自定义的任务列表给开发者一些提示，可以参考 Github 文档“About task lists”。 5. 添加 ISSUE 标签 如果您选择 ISSUE 模版，创建完 ISSUE 之后会自然有相应的标签出现，如： 此外，您也可以参考 ABACUS 的专题标签（例如 DFTU, EXX 等）添加相应的标签，或者通过“Edit labels”创建新标签： 6. 提交 ISSUE 点击“Submit new issue”以创建您的 ISSUE。您可以在创建问题后编辑上述任何字段。您的 ISSUE 有一个唯一的 URL，您可以与团队成员分享，或在其他 ISSUE 或 Pull Requat 中引用。 7. 与开发者交流 创建 ISSUE 后，通过添加评论与开发者或其他协作者交流对话。您可以键入 @ 邀请协作者或团队关注评论。 要在同一仓库中可以链接相关问题，您可以键入#，后跟 ISSUE 标号或部分标题，然后单击要链接的问题。有关更多信息，请参见““在 GitHub 上撰写””。 8. 查看 ISSUE 解决进度 查看 ISSUE 解决有 3 种方式，如下图所示： 可以通过“task list”的完成进度查看 ISSUE 的解决进度 新建的 ISSUE 会被自动加入 ABACUS ISSUEs 项目，开发者通过讨论之后会在其中加入\"Iteration\"解决周期，\"Priority\"优先级，\"Collaborators\"开发者单位，\"Project\"是否纳入近期的开发者项目等信息，您也可以在这里看到 ISSUEs 的进展。 Assignees 是解决 ISSUE 的开发者，需要 ABACUS 管理员进行分诊。 9. 关闭 ISSUE 以第 1 步和第 2 步同样的方式找到想要关闭的 ISSUE。 点击“Close issue”，关闭 ISSUE。 如果要添加关闭 ISSUE 的原因，可以在“Leave a comment”处添加关闭原因，然后点击“Close with comment”，关闭 ISSUE。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-02 11:02:27 "},"develop-input.html":{"url":"develop-input.html","title":"ABACUS 线上文档输入参数撰写规范","keywords":"","body":"ABACUS 线上文档输入参数撰写规范 作者：刘建川，邮箱：liujianchuan2013@163.com 审核：陈默涵，邮箱：mohanchen@pku.edu.cn；韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 最后更新时间：2023/10/03 一、背景 ABACUS 代码仓库地址：https://github.com/deepmodeling/abacus-develop ABACUS 线上文档地址：https://abacus.deepmodeling.com/en/latest/ （ ABACUS 线上文档是包括开发者在内的所有用户了解 ABACUS 软件使用方法的重要渠道。） 本文档关注：“关键字”部分的文档 对应的文档地址：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html 对应的代码地址：https://github.com/deepmodeling/abacus-develop/blob/develop/docs/advanced/input_files/input-main.md 更新方式：目前对该文档的更新同样是通过 PR 的方式提交到 ABACUS 的 Github 仓库上，因此任何人都可以通过提交 PR 的方式对文档做出修改，我们也鼓励用户如果发现问题后可以主动修复文档。 二、规范格式 每个输入参数都应遵循以下格式： Name of Parameter Type: Availability: (可选) Description: Default: Unit: (可选) Example: (可选) 按照上述顺序排列，上述所有字段需加粗，后面使用英文冒号（不加粗），冒号后空一格开始写内容（不加粗） 上述关键字用黑色实心圆，关键字后的介绍不用加粗 错误示范：Type:Integer 错误示范：Type: integer 错误示范：Type: integer 正确示范：Type: Integer 错误示范：Default: 0 错误示范: Default: false 正确示范：Default: False 1. Name of Parameter 这个参数代表了参数的名称，建议起参数名称的时候遵从以下规范（xxx 由设定参数名的开发者指定）： 输出某物理量的参数：建议以 out_xxx 为参数名，其中 out 是 output 的缩写。可参考的变量名有 out_chg（输出电荷密度），out_pot（输出势函数），out_dm（输出密度矩阵 density matrix） 收敛阈值相关参数：建议以 xxx_thr 为参数名，其中 thr 是 threshold 的缩写。可参考的变量名有 scf_thr（电子自洽迭代的收敛阈值），force_thr（结构弛豫时原子中的最大受力域值），和 stress_thr(晶格优化时的应力收敛阈值) 计算某物理量的参数：建议以 cal_xxx 为参数名，其中 cal 是 calculate 的缩写 初始化某物理量的参数：建议以 init_xxx 为参数名，其中 init 是 initialize 的缩写。可参考的变量名有 init_wfc（初始化波函数）, init_chg（初始化电荷密度）, init_vel（初始化原子速度） 结构弛豫相关参数：建议以 relax_xxx 为参数名，其中 relax 代表（结构）弛豫 并行策略相关参数：建议以 xxxpar 为参数名，其中 par 是代表 parallel，即并行。可参考的变量名有 kpar（k 点并行），bndpar（能带并行） 其它参数：建议先寻找 ABACUS 目前支持的参数名来设计相关参数 2. Type Type：冒号之后首字母大写，输入参数的种类，有 Integer，Real 和 String 三种类型。对于 Boolean 类型，Default 字段后的内容统一写：True 或 False（首字母大写），且先写 True，再写 False 注意 Real 类型不要写成 double 或者 float 类型 3. Availability（Optional） 如果是完整的一句话就首字母大写，如果是单词或短语就小写 4. Description 冒号之后首字母大写 如果有 Note 的标注，可在 Description 字段下，单独写一个 Note，不用加粗。 Description 字段里如果有涉及到 1 和 0 是表示 True 或 False，统一改成 True 或 False。 字段如果是完整句子，末尾要加英文句号：\".\"，若是单词和短语则不加。其他字段均不加。 String 类型的参数 直接列出所有选项 当一个参数有多种取值时，按照从小到大顺序描述不同的取值，例如 propagator 这个参数，就在 description 里面描述参数是 0，1，2 三种情况下的波函数演化方法。 不写“when set to”、“if set to”，直接写参数后，再写该参数的描述 5. Default 参数默认的数值，分成有单位的和没有单位的两种。如果是小数，建议采用科学计数法表示，“e”一律小写，如: 2e-6 6. Unit（Optional） 如有需要使用 Unit 来标定输入参数的单位，紧接在 Unit 后面描述单位，另外内容里如果涉及到写单位，需要用空格隔开，如：U (eV) 单位撰写需符合标准： 错误示范：KBar 错误示范：ev 正确示范：kbar 正确示范：eV 7. Example（Optional） 如有案例，可添加相关例子的链接和简单描述。如果需要，可以添加上述的 Example 字段描述案例。 三、其他问题 所有简写应该大写，以及后面用括号写出全称，每一个关键字的描述出现了简写均需要写全称，如:“soc”改成“SOC（spin-orbital-coupling）”。即使最常见的如 PW、MD 等也均写出全称 对参数的描述保持客观，如：不写“An important parameter”这种话 相关的参数建议放在文档上靠近的地方。举例：symmetry 参数是控制是否打开对称性操作的参数，而 symmetry_prec 是用来控制对称性操作的精度，这两个参数就可以放在一起先后介绍，并且在介绍的时候，可以提及相关的参数 一些太长的输出，单独开辟一个专区去介绍 如关键字告诉了用户输出了文件，建议告诉用户文件名称和文件保存的路径 注意语法问题 标点符号格式要一致 注意不要出现乱码 以上若有问题或者建议，欢迎写信给作者！虽然我们邮箱基本不会收到类似邮件，但开源精神的意义就在于提供了这种可能性，然后坚信更好的事情会到来。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-03 22:28:26 "},"develop-path1.html":{"url":"develop-path1.html","title":"Introduction to ABACUS: Path to PW calculation - Part 1","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 1 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 1 &#x1F4A1;写在前面 作为 SIAB（Systematically Improvable Atomic orbital Basis, link）数值原子轨道生成程序的数据上游，本系列文档将首先从平面波基组/SCF（Self-Consistent Field，即自洽场迭代）讲起，将《从 SIAB 到 ABACUS》的讲述延续下去，之后再探索 SIAB 的下游，即涉及 NAOs 的 LCAO method（basis_type = 'lcao'）。 本系列文档的预期受众：新晋 ABACUS 开发者 &#x1F3A8;写在前面 实际上，在 2023 Q1（第一季度），ABACUS 发布了面向团队内部的代码编程规范，因此在代码阅读过程中可能遇到各种还没有被更正的变量命名，请格外注意。代码的缩进与其他格式则由 2023.5 发布的新 Pull request 标准，采用clang-format-16标准执行。 &#x1F4C3;写在前面 本系列文档内容的组织原则为： 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 首先通过位于根目录下的 main.cpp 进入程序： int main(int argc, char **argv) { ModuleIO::parse_args(argc,argv); Parallel_Global::read_mpi_parameters(argc,argv); Driver DD; DD.init(); // Driver 在本文档中，我们跳过所有关于记录时间的函数，只关心最主要的部分。在 main.cpp 中定义的 Driver 类对象 DD，其类成员函数 Driver::init() 在根目录 driver.cpp 下被定义： void Driver::init() { this->reading(); this->atomic_world(); INPUT.close_log(); } Driver::reading() 首先从 Driver::init() 来到其所调用第一个函数 Driver::reading()： void Driver::reading(void) { INPUT.Init(GlobalV::global_in_card); .... } Input 便发现 Driver 类可能有数据成员 INPUT，查看头文件 driver.h，并没有关于 Input INPUT 的声明，并且 Driver 类实际上并无任何数据成员，因此需要从 #include 中寻找： #include \"driver.h\" #include \"module_io/input.h\" #include \"module_io/input_conv.h\" #include \"module_hamilt_pw/hamilt_pwdft/global.h\" #include \"module_base/memory.h\" #include \"module_base/timer.h\" #include \"module_esolver/esolver.h\" #include \"module_io/cal_test.h\" #include \"module_io/print_info.h\" #include \"module_io/winput.h\" 追踪到 input.h，发现外部变量声明： extern Input INPUT; 在 input.cpp 中则有 Input INPUT; 这一 INPUT 的变量定义。类似地，我们在更多的被 include 文件中寻找 extern 变量，这些变量都会在程序运行一开始被定义，直到程序结束时才会销毁： // module_hamilt_pw/hamilt_pwdft/global.h namespace GlobalC { // line 284 extern pseudopot_cell_vnl ppcell; // line 292 extern UnitCell ucell; extern Parallel_Grid Pgrid; extern Parallel_Kpoints Pkpoints; extern Restart restart; // Peize Lin add 2020.04.04 即是说例如对于 UnitCell ucell，其数据成员全部会在程序运行一开始被创建。 Input::init() Driver 首先调用的 INPUT 的成员函数 Input::Init()（ABACUS 中很多类都具有 init() 函数，但存在函数名无法体现其功能的问题，可能会在后续工作中修改），该成员函数定义在 source/module_io/input.cpp，同时也发现了 Input INPUT 的定义： //source/module_io/input.cpp Input INPUT; void Input::Init(const std::string &fn) { this->Default(); bool success = this->Read(fn); this->Default_2(); #ifdef __MPI Parallel_Common::bcast_bool(input_error); Parallel_Common::bcast_bool(success); Bcast(); #endif bool out_dir = false; if(!out_app_flag && (out_mat_hs2 || out_mat_r || out_mat_t || out_mat_dh)) out_dir = true; ModuleBase::Global_File::make_dir_out(this->suffix, this->calculation, out_dir, GlobalV::MY_RANK, this->mdp.md_restart, this->out_alllog); Check(); } Input::init() 唯一参数为 fn，实际被传入参数 GlobalV::global_in_card（这里 GlobalV 代表 Global Variables，是全局变量的意思，一般用全大写的变量名，C++ 区分字母大小写，Fortran 不区分）。这一参数在 module_base/global_variable.cpp 中被定义，类似的文件还有 stru_file 和 global_kpoint_card： //source/module_base/global_variable.cpp std::string global_in_card = \"INPUT\"; std::string stru_file = \"STRU\"; std::string global_kpoint_card = \"KPT\"; 因此 Input::init() 函数实际上将要打开 INPUT 文件。 Input::Default() Input::init() 调用 Input::Default() 函数， //source/module_io/input.cpp void Input::Init(const std::string &fn) { this->Default(); // Read(fn); this->Default_2(); .... 其定义为： //source/module_io/input.cpp void Input::Default(void) { suffix = \"ABACUS\"; stru_file = \"\"; // xiaohui modify 2015-02-01 kpoint_file = \"\"; // xiaohui modify 2015-02-01 pseudo_dir = \"\"; orbital_dir = \"\"; // liuyu add 2021-08-14 read_file_dir = \"auto\"; wannier_card = \"none\"; latname = \"none\"; calculation = \"scf\"; esolver_type = \"ksdft\"; pseudo_rcut = 15.0; // qianrui add this parameter 2021-5 pseudo_mesh = false; // qianrui add this pararmeter ntype = 0; ... 即 Input::Default() 函数为所有变量赋默认值。当前所展示的这些变量实际上均为 Input 类的数据成员，而非 GlobalV 等全局类。全局类的存在是为了避免出现巨大的形参表。在 Input::Default() 之后，调用 Input::Read() 函数读取 INPUT 文件，并确定是否读取成功。 Input::Read() //source/module_io/input.cpp void Input::Init(const std::string &fn) { this->Default(); bool success = this->Read(fn); // Default_2(); .... Input::Read() 函数： //source/module_io/input.cpp bool Input::Read(const std::string &fn) { .... std::ifstream ifs(fn.c_str(), std::ios::in); ifs.clear(); ifs.seekg(0); char word[80]; char word1[80]; .... while (ifs.good()) { ifs >> word1; if (ifs.eof()) break; strtolower(word1, word); if (strcmp(\"suffix\", word) == 0) read_value(ifs, suffix); else if (strcmp(\"stru_file\", word) == 0) read_value(ifs, stru_file); ... &#x1F527;重构思考 Input::read() 函数的功能为读取 INPUT 文件（创建 ifstream 类对象 ifs），之后使用对 N 行参数定义，使用最多 N 次 if 判断 strcmp 的方法进行参数读取，若参数读取成功，被传递给 Input 类的数据成员（覆盖）。 由于我们现在考察针对 PW（Plane Wave，平面波）的相关功能，因此额外注意包含 pw 的相关字段： bool Input::Read(const std::string &fn) { .... if (basis_type == \"pw\" && gamma_only != 0) // pengfei Li add 2015-1-31 { gamma_only = 0; GlobalV::ofs_running 这里 \"gamma_only\" 不为 0，是因为目前 ABACUS 不支持只计算单个布里渊区 k=（0，0，0）（通常称为 Gamma 点）的算法，只用 Gamma 点的算法可以把平面波基矢量减少一半，但目前 ABACUS 还不支持。 Input::Default_2() //source/module_io/input.cpp void Input::Init(const std::string &fn) { this->Default(); bool success = this->Read(fn); this->Default_2(); // 接下来 Input 类成员调用其 Input::Default_2() 方法： //source/module_io/input.cpp void Input::Default_2(void) // jiyy add 2019-08-04 { if (GlobalV::MY_RANK != 0) return; if (vdw_s6 == \"default\") { if (vdw_method == \"d2\") vdw_s6 = \"0.75\"; else if (vdw_method == \"d3_0\" || vdw_method == \"d3_bj\") vdw_s6 = \"1.0\"; } if (vdw_s8 == \"default\") { if (vdw_method == \"d3_0\") vdw_s8 = \"0.722\"; else if (vdw_method == \"d3_bj\") vdw_s8 = \"0.7875\"; } ... if (calculation == \"scf\") { if (mem_saver == 1) { mem_saver = 0; ModuleBase::GlobalFunc::AUTO_SET(\"mem_saver\", \"0\"); } this->relax_nmax = 1; } else if (calculation == \"relax\") { if (mem_saver == 1) { mem_saver = 0; ModuleBase::GlobalFunc::AUTO_SET(\"mem_saver\", \"0\"); } cal_force = 1; if (!this->relax_nmax) this->relax_nmax = 50; } 在首先设置 Default，即参数默认值后再覆盖，然后再调用 Default_2 的好处是可以再次覆盖某些参数的实际取值，并根据 case-by-case 地，调整某些值。实际上，此处暗示了一些已经成熟的参数搭配方式，即是说根据特征的任务，实际上都有其一套参数赋值方案。 void Input::Default_2(void) // jiyy add 2019-08-04 { .... if (basis_type == \"pw\") { if (ks_solver == \"default\") { ks_solver = \"cg\"; ModuleBase::GlobalFunc::AUTO_SET(\"ks_solver\", \"cg\"); } else if (ks_solver == \"cg\") { GlobalV::ofs_warning 考虑到一般而言第一性原理软件分支功能众多，且对于 ABACUS，其功能的扩展需要入侵性修改众多代码，行数过多，易扩展性有待提高（关于程序的易扩展性设计方案，见之后单独文档）。因此以下我们首先假设情景为使用 PW 进行 SCF 计算。 ModuleBase::Global_File::make_dir_out() //source/module_io/input.cpp .... void Input::Init(const std::string &fn) { .... bool out_dir = false; if(!out_app_flag && (out_mat_hs2 || out_mat_r || out_mat_t || out_mat_dh)) out_dir = true; ModuleBase::Global_File::make_dir_out(this->suffix, this->calculation, out_dir, GlobalV::MY_RANK, this->mdp.md_restart, this->out_alllog); // 区别于之前的 Input 类中成员函数，这里突然调用的函数变成了 ModuleBase 类。这个函数的功能为读取 INPUT 文件之后，在 INPUT 中定义的 out_dir、suffix 等，在这里可以拼合成为完整路径，并使用 C++/Linux interface 来根据具体任务创建不同的具体输出路径（jump to the code）： //source/module_io/input.cpp void ModuleBase::Global_File::make_dir_out(const std::string &suffix, const std::string &calculation, const bool &out_dir, const int rank, const bool &restart, const bool out_alllog) { std::string prefix ; #ifdef __EPM #ifdef __MPI prefix = \"OUT_EPM_MPI.\"; #else prefix = \"OUT_EPM.\"; #endif #else prefix = \"OUT.\"; #endif GlobalV::global_out_dir = prefix + suffix + \"/\"; GlobalV::global_stru_dir = GlobalV::global_out_dir + \"STRU/\"; GlobalV::global_matrix_dir = GlobalV::global_out_dir + \"matrix/\"; #ifdef __MPI MPI_Barrier(MPI_COMM_WORLD); #endif int make_dir = 0; std::string command0 = \"test -d \" + GlobalV::global_out_dir + \" || mkdir \" + GlobalV::global_out_dir; if(calculation == \"md\") { int make_dir_stru = 0; std::string command1 = \"test -d \" + GlobalV::global_stru_dir + \" || mkdir \" + GlobalV::global_stru_dir; ....} if((out_dir) && calculation == \"md\") { int make_dir_matrix = 0; std::string command1 = \"test -d \" + GlobalV::global_matrix_dir + \" || mkdir \" + GlobalV::global_matrix_dir; times = 0; ....} std::stringstream ss,ss1; if(out_alllog) { ss &#x1F527;重构思考 这部分定义出了相当多的输出文件和目录，然而多个输出文件往往不利于对 ABACUS 新上手使用者，容易在繁多的文件中迷路，因此可以考虑重新设计输出信息。 最后调用 Input::check() 函数对某些参数进行核对。 Input_Conv 返回 Driver::reading()，来到 Input_Conv::Convert(). void Driver::reading(void) { INPUT.Init(GlobalV::global_in_card); Input_Conv::Convert(); // Input_Conv::Convert() 这个函数实现了从 Input 类对象的数据成员到 GlobalV 和 GlobalC 等全局变量集合的转换。相当于从 Input 到 GlobalV 和 GlobalC，以及其他直接的类的参数上载： 其他内容见 ABACUS 第一版开发手册（02. IO 模块，目前暂为飞书内部文档）： void Input_Conv::Convert(void) { .... else if (INPUT.stru_file != \"\") { GlobalV::stru_file = INPUT.stru_file; } GlobalV::global_wannier_card = INPUT.wannier_card; if (INPUT.kpoint_file != \"\") GlobalV::global_kpoint_card = INPUT.kpoint_file; .... GlobalC::ucell.setup(INPUT.latname, INPUT.ntype, INPUT.lmaxmax, INPUT.init_vel, INPUT.fixed_axes); if (INPUT.calculation == \"relax\" || INPUT.calculation == \"cell-relax\") { if (INPUT.fixed_ibrav && !INPUT.relax_new) { ModuleBase::WARNING_QUIT(\"Input_Conv\", \"fixed_ibrav only available for relax_new = 1\"); } .... GlobalV::fixed_atoms = INPUT.fixed_atoms; } for(int i=0;i &#x1F527;重构思考 对模拟体系的完全与分层次描述，是每个模拟软件包的核心设计要求。INPUT 的数据成员不仅录入到 GlobalV, GlobalC，还录入到 BFGS_Basic, Ions_Move_Basic 等类中，或许部分扰乱了这种层级。 winput &#x1F4DD;开发者旁注 本部分内容已经过时，在未来发行版中将会完全弃用 void Driver::reading(void) { INPUT.Init(GlobalV::global_in_card); Input_Conv::Convert(); .... winput::Init(GlobalV::global_wannier_card); // 接下来来到 Wannier 函数计算部分，调用 Init()函数，传入参数为 wannier 文件的具体路径（winput 相关的这部分功能目前已经基本不使用，相关读入参数都在 INPUT 里面实现，后续版本会把这部分代码删除）。 在 Input::Default() 中，该量被设置为 \"none\"，在 Input::Read() 中，该量对应于关键词 wannier_card 被读入。实际上，一般将 wannier_card 赋值为 INPUTw。 winput::Init() void winput::Init(const std::string &fn) { Default(); Read(fn); Check(); #ifdef __MPI Bcast(); #endif } winput::Default() wannier_card 部分同样具有 Default() 函数， void winput::Default() { //======================== // part1 : control //======================== target = \"test\"; wlmr_dir = \"./\"; rcut = 10; before_iter = false; after_iter = false; begin_stop_flag = false; end_flag = false; ... } 其中各变量均为 winput 中数据成员，类型附加 static 关键词。 winput::Read() &#x1F527;重构思考 此处仍然使用 if(strcmp()) 方法读入输入文件中参数 void winput::Read(const std::string &fn) { if(GlobalV::MY_RANK!=0) return; std::ifstream ifs(fn.c_str(), std::ios::in); ifs.clear(); ifs.seekg(0); char word[80]; .... while (ifs.good()) { ifs >> word; for(auto &i : word) { i = tolower(i); } //parameters for users if (strcmp(\"target\", word) == 0) {read_value(ifs, target);} else if (strcmp(\"trial\", word) == 0) {read_value(ifs, trial);} ... winput::check() 则同样地，进行一些检查。 变量分发举例：winput::Bcast()和 Input::Bcast() 和 Input 一样，winput::Bcast() 对读入所有参数进行节点间广播： #include \"module_base/parallel_common.h\" #ifdef __MPI void winput::Bcast(void) { Parallel_Common::bcast_string( target ); Parallel_Common::bcast_bool( before_iter ); ... Parallel_Common::bcast_double( rcut ); ... Parallel_Common::bcast_string( wlmr_dir ); ... Parallel_Common::bcast_int( imp_pao ); ... 同理在 Input::Bcast() 中： #ifdef __MPI void Input::Bcast() { Parallel_Common::bcast_string(suffix); Parallel_Common::bcast_string(stru_file); // xiaohui modify 2015-02-01 Parallel_Common::bcast_string(pseudo_dir); // Parallel_Common::bcast_string(pseudo_type); // mohan add 2013-05-20 (xiaohui add 2013-06-23) Parallel_Common::bcast_string(orbital_dir); Parallel_Common::bcast_string(kpoint_file); // xiaohui modify 2015-02-01 Parallel_Common::bcast_string(wannier_card); ... Prallel_Common 属于 module_base 中 parallel_common.h 中声明的自建命名空间，其声明大致如下： namespace Parallel_Common { void bcast_complex_double( std::complex *object, const int n); ... void bcast_complex_double( std::complex &object); ... } 举例其中 Prallel_Common::bcast_int()： void Parallel_Common::bcast_int(int &object) { MPI_Bcast(&object, 1, MPI_INT, 0, MPI_COMM_WORLD); } 其中 MPI_Bcast() 为 MPI 内部函数，其参数表中分别传入了需广播数据的内存地址、、数据类型，以及。 ▶ 离开 winput，回到 source/driver.cpp Driver::reading()，只剩下如下内容： std::stringstream ss1; ss1 Driver::atomic_world() Driver::atomic_world() 函数中执行的内容其实只有 Driver::driver_run() 函数： void Driver::atomic_world(void) { this->driver_run(); } 不要忘记我们已经完成 Driver::reading() 函数内容，到达 Driver::atomic_world()。这一点从本文档设置的分级目录中也可以看得到。 void Driver::init() { this->reading(); this->atomic_world(); // Driver::driver_run() esolver ESolver 是 ABACUS 内部工作流的驱动，根据当前模拟任务所属阶段，按顺序调用各个所需模块， &#x1F4DD;开发者旁注 原则上讲，ESolver 不应当含有 Device 和 FPTYPE 模板参数，未来将会被舍弃 Driver::driver_run() 定义在 source/driver.cpp 文件中，是实际驱动 ABACUS 各模块的驱动（driver）。首先创建 ESolver 类指针，并利用 ModuleESolver::init_esolver() 将其初始化： void Driver::driver_run() { ModuleESolver::ESolver *p_esolver = nullptr; ModuleESolver::init_esolver(p_esolver); ... ModuleESolver::init_esolver() 我们目前只关注 pw 基的方法，首先调用 ModuleESolver::determine_type() 函数，读取具体在 INPUT 中定义的计算类型（GlobalV::ESOLVER_TYPE 和 GlobalV::BASIS_TYPE）： void init_esolver(ESolver*& p_esolver) { std::string esolver_type = determine_type(); 作为回溯，GlobalV::ESOLVER 和 GlobalV::BASIS_TYPE 的赋值在 module_io/input_conv.cpp： GlobalV::BASIS_TYPE = INPUT.basis_type; // line 320 GlobalV::ESOLVER_TYPE = INPUT.esolver_type; // line 273 其在 INPUT 中关键词为（module_io/input.cpp）： else if (strcmp(\"basis_type\", word) == 0) //line 843 { read_value(ifs, basis_type); ... else if (strcmp(\"esolver_type\", word) == 0)// line 685 { read_value(ifs, esolver_type); } ... ModuleESolver::determine_type() 接下来根据 basis_type 和 esolver_type 两关键词对 esolver_type 进行赋值（❗ 此处已经出现 esolver 一词多义，在 ModuleESolver 域中实际上是 [能量计算方法]_[基组](_[任务类型]） 的合并）： std::string determine_type() { std::string esolver_type = \"none\"; if (GlobalV::BASIS_TYPE == \"pw\") { if(GlobalV::ESOLVER_TYPE == \"sdft\") esolver_type = \"sdft_pw\"; else if(GlobalV::ESOLVER_TYPE == \"ofdft\") esolver_type = \"ofdft\"; else if(GlobalV::ESOLVER_TYPE == \"ksdft\") esolver_type = \"ksdft_pw\"; } else if (GlobalV::BASIS_TYPE == \"lcao_in_pw\") { #ifdef __LCAO if(GlobalV::ESOLVER_TYPE == \"sdft\") esolver_type = \"sdft_pw\"; else if(GlobalV::ESOLVER_TYPE == \"ksdft\") esolver_type = \"ksdft_pw\"; #endif } else if (GlobalV::BASIS_TYPE == \"lcao\") { #ifdef __LCAO if(GlobalV::ESOLVER_TYPE == \"tddft\") esolver_type = \"ksdft_lcao_tddft\"; else if(GlobalV::ESOLVER_TYPE == \"ksdft\") esolver_type = \"ksdft_lcao\"; #endif } else { if(GlobalV::ESOLVER_TYPE == \"lj\") esolver_type = \"lj_pot\"; else if(GlobalV::ESOLVER_TYPE == \"dp\") esolver_type = \"dp_pot\"; else if(esolver_type == \"none\") { ModuleBase::WARNING_QUIT(\"ESolver\", \"No such esolver_type combined with basis_type\"); } } return esolver_type; } 得到 esolver_type，返回 ModuleESolver::init_esolver()，之后根据其由 esolver_type 定义的不同内容，为创建的 p_esolver 指定对应类型的内存空间，此时注意到各类 ESolver_* 实际上都是对 ModuleESolver::ESolver 父类的继承，而 p_esolver 为父类指针： if (esolver_type == \"ksdft_pw\") { #if ((defined __CUDA) || (defined __ROCM)) if (GlobalV::device_flag == \"gpu\") { if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); return; } #endif if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); } #ifdef __LCAO else if (esolver_type == \"ksdft_lcao\") p_esolver = new ESolver_KS_LCAO(); else if (esolver_type == \"ksdft_lcao_tddft\") p_esolver = new ESolver_KS_LCAO_TDDFT(); #endif else if (esolver_type == \"sdft_pw\") p_esolver = new ESolver_SDFT_PW(); else if (esolver_type == \"ofdft\") p_esolver = new ESolver_OF(); else if (esolver_type == \"lj_pot\") p_esolver = new ESolver_LJ(); else if (esolver_type == \"dp_pot\") p_esolver = new ESolver_DP(INPUT.mdp.pot_file); } 各种 esolver 的继承关系如下所示。例如 ESolver_KS_PW 和 ESolver_KS_LCAO，均公有继承自 ESolver_KS： // module_solver/esolver_ks_pw.h namespace ModuleESolver { template class ESolver_KS_PW : public ESolver_KS // module_esolver/esolver_ks_lcao.h namespace ModuleESolver { class ESolver_KS_LCAO : public ESolver_KS ESolver_KS 则公有继承自 ESolver_FP： // module_solver/esolver_ks.h namespace ModuleESolver { template class ESolver_KS : public ESolver_FP ESolver_FP 公有继承自 ESolver： // module_solver/esolver_fp.h namespace ModuleESolver { class ESolver_FP : public ESolver 而 p_esolver 为 ModuleESolver::ESolver 类指针，自然可以如此赋值。其他关于各种 ESolver 的层级关系，可见第一版开发者手册的 09. ESolver 模块 （目前暂为飞书内部文档) 。接下来我们假设 esolver_type == \"ksdft_pw\"，则我们需要关注前面已经展示过的（module_esolver/esolver.cpp ModuleESolver::init_esolver(): line 93）： if (esolver_type == \"ksdft_pw\") { #if ((defined __CUDA) || (defined __ROCM)) if (GlobalV::device_flag == \"gpu\") { if (GlobalV::precision_flag == \"single\") { p_esolver = new ESolver_KS_PW(); } else { p_esolver = new ESolver_KS_PW(); } return; } #endif if (GlobalV::precision_flag == \"single\") { p_esolver = new ESolver_KS_PW(); } else { p_esolver = new ESolver_KS_PW(); } } 我们首先只关注 p_esolver = new ESolver_KS_PW();，即精度为浮点双精度，使用 cpu 为计算设备的情况。 不难发现，关于 ESolver_KS_PW 类的具体实现，同时使用数据类型和设备作为模板： namespace ModuleESolver { template ESolver_KS_PW::ESolver_KS_PW() { this->classname = \"ESolver_KS_PW\"; this->basisname = \"PW\"; this->device = psi::device::get_device_type(this->ctx); #if ((defined __CUDA) || (defined __ROCM)) if (this->device == psi::GpuDevice) { hsolver::createBLAShandle(); hsolver::createCUSOLVERhandle(); } #endif } 其代入的设备类型 psi::DEVICE_CPU，是 psi 命名空间的变量。 至此，ModuleESolver::init_esolver() 退出，p_esolver 有值 &ESolver_KS_PW()，来到设置模拟体系的结构部分。 附录 配置便捷高效 Vscode C++ 工作环境（Windows） 在大型程序的代码阅读过程中，往往遇到变量和函数数量大，源文件、头文件不计其数的情况。因此高效、快速寻找当前感兴趣变量/函数/类/命名空间的上下游就十分重要。Vscode 是由 Microsoft 开发的集成开发环境，具有轻量、灵活、功能健全、插件开发者活跃、程序迭代较快等优点，因此推荐 Vscode 作为 ABACUS 的编辑器。 Vscode 下载链接：Download Visual Studio Code - Mac, Linux, Windows 在选择“是否把 vscode 添加到 PATH 环境变量”时，如无特殊需求，建议选择“是”，同时在选择“是否将 vscode 添加到右键菜单”时，选择“是”。 相关资料：新人教程文档（目前暂为飞书内部文档) Vscode C++ 插件 配置完成 Vscode 后，在其扩展商店搜索“C/C++”，即可顺利一并安装三个插件，用于 C++ 程序的开发工作。 Mingw64 GNU compilers 为了让 C++ 开发环境变得更加智能，需要联合编译器，让编译器寻找变量、函数、类、命名空间等之间跨文件的引用关系。为了实现这一点，见 Microsoft Vscode 关于 C++ 编译器的官方配置教程： Get Started with C++ and Mingw-w64 in Visual Studio Code 之后在 vscode setting.json 添加 “C_Cpp.default.compilerPath” 值，且可选 \"C_Cpp.default.cppStandard\" 值，对于 ABACUS，通常选择 \"c++11\" 或 \"c++14\"。 Mingw64 fftw3, mpi and googletest libraries 为了能够尽可能多避免 vscode 浏览 ABACUS 代码过程中报错，可以选择安装发行在 msys2 系列平台上的 fftw3 和 msmpi 库： fftw3: https://packages.msys2.org/package/mingw-w64-i686-fftw?repo=mingw32 msmpi: https://packages.msys2.org/package/mingw-w64-x86_64-msmpi Googletest: https://packages.msys2.org/base/mingw-w64-googletest 其他常见的库也可以在 https://packages.msys2.org/进行搜索后，复制命令在 msys2 prompt 进行下载安装 CMake ABACUS 使用 CMake 便捷编译，因此也可以在本地配置 CMake。 下载、安装 CMake：Download | CMake 将安装好的 CMake 一并放入 PATH 环境变量，之后在 Vscode setting.json 中添加 “cmake.generator”，以及 \"cmake.cmakePath\" 值，设置 \"cmake.additionalCompilerSearchDirs\"。 将本地 Vscode 连通 Bohrium 平台进行高效编译开发 Bohrium 平台提供在线云计算服务，对于 ABACUS 开发工作，可以在其服务器上进行软件编译。 Bohrium 网站： 之后请 follow 单元测试环境搭建教程：新人教程文档 （目前暂为飞书内部文档) 变量、函数、类的声明、定义、调用快捷跳转 对准想要查看其声明、定义和调用（引用）的量，点击鼠标右键： 若跳转到声明（.h 文件），发现其声明旁未添加注释，或注释并非 Doxygen 格式，可以在 Vscode 扩展应用商店下载 Doxygen 插件后，发现菜单出现“生成 Doxygen 注释”，将注释内容复写为 Doxygen 格式。 相关材料：自动文档 Doxygen 使用说明 （目前暂为飞书内部文档) 给你的开发加点魔法：Github.copilot vscode 部署 首先进行 Github 学生认证：https://education.github.com/pack 然后在 vscode 上 Extension 界面下载 Github copilot 插件。vscode 通过最下角 Github 账号登录来验证 Github.copilot 的使用权限（完成学生认证后自动拥有 Github.copilot 的使用权限）。 系列链接 上篇：从 SIAB 到 ABACUS（一）：准备工作（施工中 &#x1F6A7;） 下篇：Introduction to ABACUS: Path to PW calculation - Part 2 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-04 22:18:52 "},"develop-path2.html":{"url":"develop-path2.html","title":"Introduction to ABACUS: Path to PW calculation - Part 2","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 2 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 2 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 承接上篇对 INPUT 文件的解析，本篇延续 ABACUS workflow，介绍和 STRU 文件中信息读取紧密相关的 UnitCell 类。 Driver Driver::atomic_world() Driver::driver_run() ucell 在 driver_run.cpp 中直接调用了 GlobalC 的数据成员 UnitCell ucell 的成员函数 UnitCell::setup_cell()， // driver_run.cpp void Driver::driver_run() { .... GlobalC::ucell.setup_cell(GlobalV::stru_file, GlobalV::ofs_running); 则自然回忆回溯在何时 ucell 被声明、定义、初始化的（尽管在上篇中已经明确提到）。寻得在 module_hamilt_pw/hamilt_pwdft/global.h 中，有关于 ucell 为 extern 变量的声明： namespace GlobalC { extern UnitCell ucell; 同时在 module_hamilt_pw/hamilt_pwdft/global.cpp 中，有其定义： namespace GlobalC { UnitCell ucell; 则对于需要使用到 UnitCell 对象 ucell 的场合，只需要包含 module_hamilt_pw/hamilt_pwdft/global.h 头文件即可，其中 ucell 为全局类（将来可能会把这个全局类去掉，换成指定范围内可以使用的模块）。 UnitCell:setup_cell() ucell 的一些数据成员在 Input_Conv::Convert() 函数中赋值： // line 266 GlobalC::ucell.setup(INPUT.latname, INPUT.ntype, INPUT.lmaxmax, INPUT.init_vel, INPUT.fixed_axes); GlobalC::UnitCell::setup() 函数除了导入前四个量外，根据最后一个传入参数，控制 UnitCell ucell 中晶格矢量的约束条件 lc[0], lc[1] 和 lc[2]。可见 lc[i] 实际上可能会出现在晶格矢量的 rescale factor 里，额外使用 lc[i] 作为变化量的 factor，若为 0，固定，则该晶格矢量在程序运行中不会有变化。 void UnitCell::setup(const std::string& latname_in, const int& ntype_in, const int& lmaxmax_in, const bool& init_vel_in, const std::string& fixed_axes_in) { this->latName = latname_in; this->ntype = ntype_in; this->lmaxmax = lmaxmax_in; this->init_vel = init_vel_in; if (fixed_axes_in == \"None\") this->lc[0] = 1; this->lc[1] = 1; this->lc[2] = 1; else if (fixed_axes_in == \"volume\") { this->lc[0] = 1; this->lc[1] = 1; this->lc[2] = 1; if (!GlobalV::relax_new) { ModuleBase::WARNING_QUIT( \"Input\", \"there are bugs in the old implementation; set relax_new to be 1 for fixed_volume relaxation\"); } } else if (fixed_axes_in == \"shape\") { if (!GlobalV::relax_new) { ModuleBase::WARNING_QUIT(\"Input\", \"set relax_new to be 1 for fixed_shape relaxation\"); } this->lc[0] = 1; this->lc[1] = 1; this->lc[2] = 1; } else if (fixed_axes_in == \"a\") this->lc[0] = 0; this->lc[1] = 1; this->lc[2] = 1; ....//omit b and c else if (fixed_axes_in == \"ab\") this->lc[0] = 0; this->lc[1] = 0; this->lc[2] = 1; ....//omit without b and c else if (fixed_axes_in == \"abc\") this->lc[0] = 0; this->lc[1] = 0; this->lc[2] = 0; else ....//warning and quit return; } 回到 Driver::driver_run() 的 line 33（Link），其所调用 UnitCell::setup_cell() 函数首先根据前文提到在 Input_Conv::Convert() 中调用的 UnitCell::setup() 函数，确定了 UnitCell::ntype，因此使用 ntype 重新为 magnet.start_magnetization 分配内存空间。UnitCell::magnet 成员变量在 module_cell/unitcell.h 中被声明。类似的还有 ucell.atoms 等。 void UnitCell::setup_cell(const std::string &fn, std::ofstream &log) { delete[] magnet.start_magnetization; magnet.start_magnetization = new double[this->ntype]; this->atoms = new Atom[this->ntype]; this->set_atom_flag = true; class UnitCell { public: Magnetism magnet; // magnetism Yu Liu 2021-07-03 在 Driver::driver_run() 中调用 UnitCell::setup_cell() 时，传入参数 GlobalV::stru_file 和文件流对象 GlobalV::ofs_running，前者具有默认值 STRU（Introduction to ABACUS: Path to PW calculation - Part 1 Input::init()），后者同样具有默认值，见 global_file.cpp。 STRU file parse 若 STRU 文件存在，读取其中内容： const int error = this->read_atom_species(ifa, log); ok2 = this->read_atom_positions(ifa, log, GlobalV::ofs_warning); ifa 即为打开 STRU 的 ifstream 文件流对象，log 为 GlobalV:ofs_running 变量。 Basic structure of STRU file: examples 在开始阅读 STRU 文件解析程序部分之前，首先展示几种 STRU 文件样例： // with latname = 'fcc' in INPUT file ATOMIC_SPECIES Si 28.00 Si_ONCV_PBE-1.0.upf // label; mass; pseudo_file NUMERICAL_ORBITAL Si_gga_8au_60Ry_2s2p1d.orb //numerical_orbital_file LATTICE_CONSTANT 10.2 // lattice scaling factor (Bohr) ATOMIC_POSITIONS Direct //Cartesian or Direct coordinate. Si // Element type 0.0 // magnetism 2 // number of atoms 0.00 0.00 0.00 0 0 0//the position of atoms and other parameter specify by key word 0.25 0.25 0.25 1 1 1 // with latname = 'none' or do not set it in INPUT file ATOMIC_SPECIES Si 28.00 Si_ONCV_PBE-1.0.upf upf201 // label; mass; pseudo_file; pseudo_type NUMERICAL_ORBITAL Si_gga_8au_60Ry_2s2p1d.orb //numerical_orbital_file LATTICE_CONSTANT 10.2 // lattice scaling factor (Bohr) LATTICE_VECTORS 0.5 0.5 0.0 // latvec1 0.5 0.0 0.5 // latvec2 0.0 0.5 0.5 // latvec3 ATOMIC_POSITIONS Direct //Cartesian or Direct coordinate. Si // Element type 0.0 // magnetism(Be careful: value 1.0 refers to 1.0 bohr mag, but not fully spin up !!!) 2 // number of atoms 0.00 0.00 0.00 0 0 0 0.25 0.25 0.25 1 1 1 ATOMIC_SPECIES Pt 195.08 Pt_ONCV_PBE-1.0.upf LATTICE_CONSTANT 1.8897259886 // 1 Angstrom, but unit required is Bohr, so it is this value LATTICE_VECTORS 8.4359998703 0.0000000000 0.0000000000 -4.2179999352 7.3057901940 0.0000000000 0.0000000000 0.0000000000 25.1919994354 ATOMIC_POSITIONS Cartesian // Cartesian (Unit is LATTICE_CONSTANT) Pt 0.0 27 0.000000000 0.000000000 3.288052246 1.405985941 0.811746362 1.643526123 0.000000000 1.623492723 0.000000000 2.811971882 0.000000000 3.287052246 ... // directly start after ATOMIC_POSITIONS' title Fe 1.0 2 0.0 0.0 0.0 m 0 0 0 mag 1.0 angle1 90 angle2 0 0.5 0.5 0.5 m 1 1 1 mag 1.0 angle1 90 angle2 180 &#x1F527;重构思考 将来可以增添 xyz 格式的原子信息文件到 ABACUS 的接口以增强易用性。 UnitCell::read_atom_species() ⚙UnitCell::read_atom_species() 函数实际上读取除原子坐标外的所有信息，如晶格矢量 latvec 等。这些变量都是 UnitCell 的数据成员。具体读取的 section 有 ATOMIC_SPECIES, NUMERICAL_ORBITAL, NUMERICAL_DESCRIPTOR, ABFS_ORBITAL, LATTICE_CONSTANT, LATTICE_VECTORS, LATTICE PARAMETERS 等。 int UnitCell::read_atom_species(std::ifstream &ifa, std::ofstream &ofs_running) { int error = 0; delete[] atom_label; this->atom_mass = new double[ntype]; delete[] atom_mass; this->atom_label = new std::string[ntype]; delete[] pseudo_fn; this->pseudo_fn = new std::string[ntype]; delete[] pseudo_type; this->pseudo_type = new std::string[ntype]; delete[] orbital_fn; this->orbital_fn = new std::string[ntype]; ... if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"ATOMIC_SPECIES\") ) { ... #ifdef __LCAO if(GlobalV::BASIS_TYPE==\"lcao\" || GlobalV::BASIS_TYPE==\"lcao_in_pw\") { if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"NUMERICAL_ORBITAL\") ) { for(int i=0; i> orbital_fn[i]; } if(GlobalV::deepks_setorb) { if (ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"NUMERICAL_DESCRIPTOR\")) { ifa >> descriptor_file; } } else descriptor_file = GlobalV::global_orbital_dir + orbital_fn[0]; } ... #ifdef __EXX if( GlobalC::exx_info.info_global.cal_exx ) { if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"ABFS_ORBITAL\") ) { for(int i=0; i> ofile; GlobalC::exx_info.info_ri.files_abfs.push_back(ofile); } } } if (GlobalV::rpa_setorb) { if (ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"ABFS_ORBITAL\")) { GlobalV::rpa_orbitals.resize(ntype); for (int i = 0; i > GlobalV::rpa_orbitals[i]; } } .... if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_CONSTANT\") ) { ModuleBase::GlobalFunc::READ_VALUE(ifa, lat0); lat0_angstrom = lat0 * 0.529177 ; this->tpiba = ModuleBase::TWO_PI / lat0; this->tpiba2 = tpiba * tpiba; } ... if(latName==\"none\"){ if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_VECTORS\") ) { ifa >> latvec.e11 >> latvec.e12; ModuleBase::GlobalFunc::READ_VALUE(ifa, latvec.e13); ifa >> latvec.e21 >> latvec.e22; ModuleBase::GlobalFunc::READ_VALUE(ifa, latvec.e23); ifa >> latvec.e31 >> latvec.e32; ModuleBase::GlobalFunc::READ_VALUE(ifa, latvec.e33); // read e(i)3 in this way is to change to the next line } if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_PARAMETERS\") ) { ModuleBase::WARNING_QUIT(\"UnitCell::read_atom_species\",\"do not use LATTICE_PARAMETERS without explicit specification of lattice type\"); } } else{ if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_VECTORS\") ) { ModuleBase::WARNING_QUIT(\"UnitCell::read_atom_species\",\"do not use LATTICE_VECTORS along with explicit specification of lattice type\"); } if(latName==\"sc\"){//simple-cubic, ibrav = 1 latvec.e11 = 1.0; latvec.e12 = 0.0; latvec.e13 = 0.0; latvec.e21 = 0.0; latvec.e22 = 1.0; latvec.e23 = 0.0; latvec.e31 = 0.0; latvec.e32 = 0.0; latvec.e33 = 1.0; else if(latName==\"fcc\"){//face-centered cubic, ibrav = 2 ...} else if(latName==\"bcc\"){//body-centered cubic, ibrav = 3 ...} ... else if(latName==\"triclinic\"){//triclinic, ibrav = 14 double bba = 0.0; double cba = 0.0; double cosab = 0.0; double cosac = 0.0; double cosbc = 0.0; double sinab = 0.0; double term = 0.0; if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_PARAMETERS\") ) { ifa >> bba >> cba >> cosab >> cosac; ModuleBase::GlobalFunc::READ_VALUE(ifa, cosbc); sinab = sqrt(1.0-cosab*cosab); } latvec.e11 = 1.0; latvec.e12 = 0.0; latvec.e13 = 0.0; latvec.e21 = bba * cosab; latvec.e22 = bba * sinab; latvec.e23 = 0.0; latvec.e31 = cba * cosac; latvec.e32 = cba * (cosbc - cosac*cosab) / sinab; term = 1.0 + 2.0 * cosab*cosac*cosbc - cosab*cosab - cosac*cosac - cosbc*cosbc; term = sqrt(term)/sinab; latvec.e33 = cba * term; } else{ std::cout 我们约定，LATTICE_CONSTANT无量纲，LATTICE_VECTORS有量纲，STRU文件中原子坐标无量纲。 UnitCell::read_atom_positions() &#x1F527;重构思考 同样地，UnitCell::read_atom_positions() 函数也不仅仅读取原子的位置，还额外读取各种具体涉及每个原子的速度、固定、磁化等等信息。 首先来到读取 STRU ATOMIC_POSITIONS 部分： bool UnitCell::read_atom_positions(std::ifstream &ifpos, std::ofstream &ofs_running, std::ofstream &ofs_warning) { if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifpos, \"ATOMIC_POSITIONS\")) { ModuleBase::GlobalFunc::READ_VALUE( ifpos, Coordinate); STRU 第二行指定坐标类型，被读取为 UnitCell::Coordinate。UnitCell::Coordinate 在 STRU 里有不同选项，⚙ 决定原子的具体位置和单位： if(Coordinate != \"Cartesian\" && Coordinate != \"Direct\" && Coordinate != \"Cartesian_angstrom\" && Coordinate != \"Cartesian_au\" && Coordinate != \"Cartesian_angstrom_center_xy\" && Coordinate != \"Cartesian_angstrom_center_xz\" && Coordinate != \"Cartesian_angstrom_center_yz\" && Coordinate != \"Cartesian_angstrom_center_xyz\" ) { ModuleBase::WARNING(\"read_atom_position\",\"Cartesian or Direct?\"); ofs_warning 这将决定最后实际的原子坐标： // module_cell/read_atom.cpp: line 695 if(Coordinate==\"Direct\") { atoms[it].taud[ia] = v; atoms[it].tau[ia] = v * latvec; } else if(Coordinate==\"Cartesian\") { atoms[it].tau[ia] = v ; } else if(Coordinate==\"Cartesian_angstrom\") { atoms[it].tau[ia] = v / 0.529177 / lat0; } else if(Coordinate==\"Cartesian_angstrom_center_xy\") { latcenter.x = (latvec.e11 + latvec.e21 + latvec.e31)/2.0; latcenter.y = (latvec.e12 + latvec.e22 + latvec.e32)/2.0; latcenter.z = 0.0; atoms[it].tau[ia] = v / 0.529177 / lat0 + latcenter; ... &#x1F527;重构思考 ABACUS 代码中现在分原子类型导入数据，尽管在代码中分种类管理原子是十分自然的选择，但 ABACUS 将这种选择表露在用户端，因此 STRU 中关于原子位置的定义也必须按类型分开输入。 接下来是按原子种类循环 ATOMIC_POSITIONS section: int na = 0; this->nat = 0; assert(ntype>0); for (int it = 0;it &#x1F527;重构思考 进入循环体，检查在 ATOMIC_POSITIONS section 中原子定义的顺序是否和 ATOMIC_SPECIES 相同 &#x1F4DD;开发者旁注 已在重构计划中 ModuleBase::GlobalFunc::READ_VALUE(ifpos, atoms[it].label); bool sequence_match = false; for(int it2=0; it2atoms[it].label == this->atom_label[it2] ) { if (it2 == it) sequence_match = true; } } if(!sequence_match) { ... return 0; } 读取当前原子类型的 starting_magnetization、原子总数 na ModuleBase::GlobalFunc::READ_VALUE(ifpos, magnet.start_magnetization[it] ); ... ModuleBase::GlobalFunc::READ_VALUE(ifpos, na); this->atoms[it].na = na; .... this->nat += na; .... 在当前 type 下刷新 type-specific 的原子性质： // positions and positional constraints delete[] atoms[it].tau; delete[] atoms[it].taud; delete[] atoms[it].mbl; atoms[it].tau = new ModuleBase::Vector3[na]; atoms[it].taud = new ModuleBase::Vector3[na]; atoms[it].mbl = new ModuleBase::Vector3[na]; // evoluation delete[] atoms[it].vel; delete[] atoms[it].dis; atoms[it].vel = new ModuleBase::Vector3[na]; atoms[it].dis = new ModuleBase::Vector3[na]; // magnetization delete[] atoms[it].mag; delete[] atoms[it].angle1; delete[] atoms[it].angle2; delete[] atoms[it].m_loc_; atoms[it].mag = new double[na]; atoms[it].angle1 = new double[na]; atoms[it].angle2 = new double[na]; atoms[it].m_loc_ = new ModuleBase::Vector3[na]; ⚙ 然后在 ATOMIC_POSITIONS 中读取： atoms[it].mass = this->atom_mass[it]; ❗ 此处的 atoms[it].mass 与 this->atom_mass[it] 的用法与 atomis[it].label 与 this->atom_label[it] 不同：传值 vs 核对。 接下来读取类中每个原子的速度信息，在做分子动力学模拟的时候可能需要用到： for (int ia = 0;ia > v.x >> v.y >> v.z; 然而，当前 STRU 文件在 ATOMIC_POSITIONS 的设计比较复杂，其可以包括任何一组 atom-specific 数据，且数量和顺序均不受限制，这导致判断条件变得复杂，详见 module_cell/read_atoms.cpp:line 536 - 567（link）。 atoms[it].mag 的赋值并非直接读取： else if ( tmpid == \"mag\" || tmpid == \"magmom\") { set_element_mag_zero = true; double tmpamg=0; ifpos >> tmpamg; tmp=ifpos.get(); while (tmp==' ') tmp=ifpos.get(); // ASCII code 48 to 57 are 0 to 9 the Arabic number if((tmp >= 48 && tmp > atoms[it].m_loc_[ia].y>>atoms[it].m_loc_[ia].z; atoms[it].m_loc_[ia].x=tmpamg; atoms[it].mag[ia]=sqrt(pow(atoms[it].m_loc_[ia].x,2) +pow(atoms[it].m_loc_[ia].y,2) +pow(atoms[it].m_loc_[ia].z,2) ); input_vec_mag=true; } else { ifpos.putback(tmp); atoms[it].mag[ia]=tmpamg; } } ⚙ 若 mag/magmom 后有一个值，则读取其值赋给 atoms[it]::mag[ia]，将 input_vec_mag 置为 false，若有三个值，则三个值依次被传入 atoms[it].m_loc_[ia].x, atoms[it].m_loc_[ia].y 和 atoms[it].m_loc_[ia].z，并将 input_vec_mag 置为 true，之后其向量模长为 atoms[it]::mag[ia]，然后在使用 angle1, angle2 来重新生成 mag。 if(GlobalV::NSPIN==4) { if(GlobalV::NONCOLIN) { if(input_angle_mag) { atoms[it].m_loc_[ia].z = atoms[it].mag[ia] * cos(atoms[it].angle1[ia]); if(sin(atoms[it].angle1[ia]) > 1e-10 ) { atoms[it].m_loc_[ia].x = atoms[it].mag[ia] * sin(atoms[it].angle1[ia]) * cos(atoms[it].angle2[ia]); atoms[it].m_loc_[ia].y = atoms[it].mag[ia] * sin(atoms[it].angle1[ia]) * sin(atoms[it].angle2[ia]); .... else if (input_vec_mag) { double mxy=sqrt(pow(atoms[it].m_loc_[ia].x,2)+pow(atoms[it].m_loc_[ia].y,2)); atoms[it].angle1[ia]=atan2(mxy,atoms[it].m_loc_[ia].z); if(mxy>1e-8) { atoms[it].angle2[ia]=atan2(atoms[it].m_loc_[ia].y,atoms[it].m_loc_[ia].x); .... else { // isn't this corresponds to common unrestricted case? atoms[it].m_loc_[ia].x = 0; atoms[it].m_loc_[ia].y = 0; atoms[it].m_loc_[ia].z = atoms[it].mag[ia]; } .... else if(GlobalV::NSPIN==2) { atoms[it].m_loc_[ia].x = atoms[it].mag[ia]; atoms[it].m_loc_[ia].y = 0; atoms[it].m_loc_[ia].z = 0; ... &#x1F914;批判性思考 然而，在 Quantum ESPRESSO 中，并不允许出现 nspin=4 且 noncolinear=.false. 的情况，在 ABACUS≤3.3.0 中是允许的，你怎么看？ Quantum ESPRESSO 相关信息：pw.x input description ABACUS 对 nspin=4 情况的参数处理： //module_io/input_conv.cpp line 376 if (INPUT.noncolin || INPUT.lspinorb) { GlobalV::NSPIN = 4; } if (GlobalV::NSPIN == 4) { GlobalV::NONCOLIN = INPUT.noncolin; // wavefunctions are spinors with 2 components GlobalV::NPOL = 2; // set the domag variable to make a spin-orbit calculation with zero magnetization GlobalV::DOMAG = false; GlobalV::DOMAG_Z = true; GlobalV::LSPINORB = INPUT.lspinorb; GlobalV::soc_lambda = INPUT.soc_lambda; if (INPUT.cal_force || INPUT.cal_stress) { ModuleBase::WARNING_QUIT(\"input_conv\", \"force & stress not ready for soc yet!\"); } if(INPUT.gamma_only_local) { ModuleBase::WARNING_QUIT(\"input_conv\", \"soc does not support gamma only calculation\"); } } else { GlobalV::LSPINORB = false; GlobalV::NONCOLIN = false; GlobalV::DOMAG = false; GlobalV::DOMAG_Z = false; GlobalV::NPOL = 1; } Input::noncolin 等变量使用默认值初始化为： //input.cpp line 409 noncolin = false; lspinorb = false; soc_lambda = 1.0; Summary 经过 UnitCell::read_atom_species() 和 UnitCell::read_atom_positions()，以下量被赋值： // lattice info. // unit UnitCell::Coordinate; // lattice constant (real space) UnitCell::lat0; UnitCell:: lat0_angstrom; // lattice constant (reciprocal space) UnitCell::tpiba; UnitCell::tpiba2; // lattice vectors UnitCell::latvec; UnitCell::latcenter; UnitCell::a1; UnitCell::a2; UnitCell::a3; // atoms overall info. UnitCell::nat; // types UnitCell::ntype; UnitCell::atom_mass; UnitCell::atom_label; // supplementary element-specific info. // pseudopotential UnitCell::pseudo_fn; UnitCell::pseudo_type; // numerical orbital UnitCell::orbital_fn // atom type specific info. // atom type overall info. UnitCell::atoms::label; UnitCell::atoms::na; // atom position info. （constraint included） UnitCell::atoms::taud; UnitCell::atoms::tau; UnitCell::atoms::mbl; // atom move info. (velocities and displacements) UnitCell::atoms::vel; UnitCell::atoms::dis; // atom magnetization info. UnitCell::magnet::starting_magnetization; UnitCell::atoms::mag; // nspin = 4; noncolinear case UnitCell::atoms::m_loc_; UnitCell::atoms::angle1; UnitCell::atoms::angle2; UnitCell::setup_cell(): the rest, and an example of backtracking unclear variable 离开 STRU 文件的解析部分，接下来计算了初始磁化强度： //after read STRU, calculate initial total magnetization when NSPIN=2 if(GlobalV::NSPIN == 2 && !GlobalV::TWO_EFERMI) { for(int it = 0;itntype; it++) { for(int ia = 0; iaatoms[it].na; ia++) { GlobalV::nupdown += this->atoms[it].mag[ia]; } } } 由于 INPUT 中参数众多，因此在前文中对参数有所遗漏。但基于前文已有内容介绍，关于 GlobalV::TWO_EFERMI 变量，可以通过如下方式查找其意义： 在 module_io/input_conv.cpp 中寻找该变量，是何变量赋其值，发现： if (std::abs(INPUT.nupdown) > 1e-6) { GlobalV::TWO_EFERMI = true; GlobalV::nupdown = INPUT.nupdown; } 因此 GlobalV::TWO_EFERMI 变量实际依赖于 INPUT.nupdown。 接下来在 module_io/input.cpp 中寻找含 INPUT.nupdown 的 if(strcmp(...)) 单元，查看在 INPUT 文件中是何参数赋予其具体值： else if (strcmp(\"nupdown\", word) == 0) { read_value(ifs, nupdown); } 即 INPUT.nupdown 在 INPUT 中也为 nupdown。接下来打开 Full keyword list 寻找其解释。 得到结果，即 nupdown 为 spin up 和 spin down 电子数量差值： 因此该部分逻辑为：若未使用 nupdown 来指定单电子数量，则对每种原子内每个原子，累加其 mag/magmom，即磁矩模长，赋予 GlobalV::nupdown。❗ 但对于两种方式均赋予，但值不一致的情况未进行处理。 接下来根据在 STRU 中读取的晶胞参数，计算晶胞体积，并计算倒空间矢量（在上篇中已经对 latvec, G, GT, GGT 有所介绍，invGGT 的意义也不言自明）： this->omega = std::abs( latvec.Det() ) * this->lat0 * lat0 * lat0 ; this->GT = latvec.Inverse(); this->G = GT.Transpose(); this->GGT = G * GT; this->invGGT = GGT.Inverse(); this->GT0 = latvec.Inverse(); this->G0 = GT.Transpose(); this->GGT0 = G * GT; this->invGGT0 = GGT.Inverse(); 然后建立从[原子索引]到[原子种类]和[种类内原子索引]的映射： this->set_iat2itia(); 即该函数的函数名实际应该写为：set_iat2ia_iat2it()： void UnitCell::set_iat2itia(void) { delete[] iat2it; delete[] iat2ia; this->iat2it = new int[nat]; this->iat2ia = new int[nat]; int iat = 0; for (int it = 0; it iat2it[iat] = it; this->iat2ia[iat] = ia; ++iat; } } return; } 至此，UnitCell::setup_cell() 函数的内容全部结束。 回溯：how many objects are created when we see \"init_esolver()\"? 在阅读整个程序的过程中，还有一个重要的方面需要注意：伴随变量的创建，尤其是创建类对象时，其中同样非简单数据类型的数据成员又是在何时初始化，拥有具体数值？由于 Driver.h 中并无任何变量的声明（如前所述，有变量直接被声明为 extern），且 Input.h 中声明变量的值分别靠 Input::Default()、Input::Read() 和 Input::Default2() 给定，且关系简单直接，因此只剩下 ESolver 和其派生类需要注意。 Constructor: ESolver() class ESolver { .... ESolver() { classname = \"ESolver\"; } ESolver 类的构造函数非常简单，因为其是所有具体 ESolver_* 的抽象基类，所以本身的操作设计原则应该尽可能抽象且共通。关于设计抽象基类和编程范式的问题，请见文档（暂缺失） Constructor: ESolver_FP() ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); pw_big = static_cast(pw_rho); pw_big->setbxyz(INPUT.bx, INPUT.by, INPUT.bz); sf.set(INPUT.nbspline); this->symm.epsilon = this->symm.epsilon_input = INPUT.symmetry_prec; } check 其头文件中变量声明： namespace ModuleESolver { class ESolver_FP : public ESolver { public: ModulePW::PW_Basis* pw_rho; ModulePW::PW_Basis_Big* pw_big; ....// constructor and destructor declarations omitted elecstate::ElecState* pelec = nullptr; Charge chr; ModuleSymmetry::Symmetry symm; psi::Psi>* psi = nullptr; psi::Psi* psid = nullptr; Structure_Factor sf; K_Vectors kv; private: ....// member function(s) omitted }; 创建当前类和子类对象时，该构造函数被调用，Charge 类对象 chr、ModuleSymmetry::Symmetry 类对象 symm、Structure_Factor 类对象 sf，以及 K_Vectors 类对象 kv 被创建并分配内存，而 ModulePW::PW_Basis 类 pw_rho、ModulePW::PW_Basis_Big 类 pw_big、elecstate::ElecState 类 pelec、psi::Psi> 类 psi，以及 psi::Psi 类 psid 则为指针，只创建但并未调用其所属类的构造函数。 Special topic: 继承与多态 在 ESolver_FP 的构造函数中有两行格外醒目： ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); pw_big = static_cast(pw_rho); 对于 ESolver 本身，其指针对象 p_esolver 实际上也有类似操作： //Some API to operate E_Solver void init_esolver(ESolver*& p_esolver) { //determine type of esolver based on INPUT information std::string esolver_type = determine_type(); //initialize the corresponding Esolver child class if (esolver_type == \"ksdft_pw\") { #if ((defined __CUDA) || (defined __ROCM)) if (GlobalV::device_flag == \"gpu\") { if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); return; } #endif if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); } #ifdef __LCAO else if (esolver_type == \"ksdft_lcao\") p_esolver = new ESolver_KS_LCAO(); else if (esolver_type == \"ksdft_lcao_tddft\") p_esolver = new ESolver_KS_LCAO_TDDFT(); #endif else if (esolver_type == \"sdft_pw\") p_esolver = new ESolver_SDFT_PW(); else if(esolver_type == \"ofdft\") p_esolver = new ESolver_OF(); else if (esolver_type == \"lj_pot\") p_esolver = new ESolver_LJ(); else if (esolver_type == \"dp_pot\") p_esolver = new ESolver_DP(INPUT.mdp.pot_file); } “为基类指针分配派生类内存空间，以降低代码复写、提高代码复用率”这种操作称为 C++ 的多态编程，举简单例子如下： //a.cpp #include class a{ public: a() {}; ~a() {}; void TestFunction(); void AnotherFunction(); int GetPrivate(){return this->private_;} bool SetPrivate(int p){this->private_ = p; return true;} void GetPrivateAddress(){std::coutprivate_) //b.cpp #include \"a.cpp\" class b: public a{ public: b() {}; ~b() {}; void TestFunction(); void AnotherFunction(); int GetPrivate(){return this->private_;} bool SetPrivate(int p){this->private_ = p; return true;} void GetPrivateAddress(){std::coutprivate_) //main.cpp #include \"b.cpp\" using namespace std; int main() { a* p_a; p_a = new b(); coutTestFunction(); b* p_tmp = static_cast(p_a); coutTestFunction(); coutTestFunction(); coutAnotherFunction(); coutAnotherFunction(); coutSetPrivate(10); coutGetPrivate()GetPrivate()SetPrivate(20); coutGetPrivate()GetPrivate()GetPrivateAddress(); p_tmp->GetPrivateAddress(); delete p_a; return 0; } //result /* call p_a's member function before static_cast This is a function of a Memory address of p_a is 0x55ee8123beb0 Memory address of p_tmp is 0x55ee8123beb0 call p_tmp's member function after static_cast This is a function of b call p_a's member function after static_cast This is a function of a call p_a's member function This is another function of a call p_tmp's member function This is another function of b now test member variable accessibility p_a's private member is 10 p_tmp's private member is 0 p_a's private member is 10 p_tmp's private member is 20 Re-check memory address of p_a and p_tmp: Memory address of p_a is 0x55ee8123beb0 Memory address of p_tmp is 0x55ee8123beb0 Check private member variables' address 0x55ee8123beb0 0x55ee8123beb4 */ 为基类指针分配派生类内存空间，使得基类和派生类指针指向同一个内存地址（基派生类对象的起始内存位置, line 21, 22: 0x55ee8123beb0），但对于上例，基类需要 4 个字节存储基类对象，而派生类需要 4+4 个字节存储基类对象：因为派生类对象创建时会首先创建其中的基类部分，而实际上即使不进行如此操作，单一创建派生类对象时，在派生类中访问基类数据成员则需要额外以基类的名称作为域标识加以区分。此时基类指针相当于切换成对派生类内存空间的基类视角，即基类指针只能看到派生类存储中的基类部分，但看不到派生类所额外派生的部分，也因此上例共占用内存空间 4+4 字节而非 4+4+4 字节。 举例对于不使用基类指针的情况，在派生类的方法中直接访问其基类数据成员，需要写为： void b::PrintBaseAndDerivedClassVariable() { std::coutprivate_ 而使用指针方法则应该写为： std::coutprivate_private_ 另一点需要注意的是虚函数。实际上，因为基类指针使用派生类指针进行初始化，因此其“语境”为派生类，所以对于虚函数而言，调用的基函数实际为派生类的相应函数。如果使用基类指针调用非虚函数，则调用的是基类的同名函数（examples provided by New Bing Creative）。 注意：不能使用基类指针（即使已经申请派生类内存空间）访问派生类中声明和定义（但基类中无虚函数声明）的函数。 // polymorphism_example.cpp#include using namespace std; class A { public: virtual void f() { cout (p_a); // 以B* p_b=static_cast(p_a)给p_b初始化 p_a->f(); // 调用B::f()，因为f()是虚函数，会根据实际类型进行动态绑定 p_a->g(); // 调用A::g()，因为g()不是虚函数，会根据声明类型进行静态绑定 p_b->f(); // 调用B::f()，因为f()是虚函数，会根据实际类型进行动态绑定 p_b->g(); // 调用B::g()，因为g()不是虚函数，会根据声明类型进行静态绑定delete p_a; // 释放内存空间return 0; } //result /* B::f() A::g() B::f() B::g() */ 当释放内存空间时，则可以使用基类指针为柄，也可以使用派生类指针为柄，编译器将自主判断实际内存占用情况并进行释放（如果声明析构函数为虚函数，则会动态连接并达到如此期望，否则不能）。因此对于 PW_Basis 类对象 pw_rho 而言，其中被声明为虚函数的有： //file module_basis/module_pw/pw_basis.h class PW_Basis { public: .... virtual ~PW_Basis(); .... virtual void initgrids( const double lat0_in, //unit length (unit in bohr) const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors (unit in lat0) const double gridecut //unit in Ry, ecut to set up grids ); .... virtual void initgrids( const double lat0_in, const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors const int nx_in, int ny_in, int nz_in ); .... protected: .... virtual void distribute_r(); //file module_basis/module_pw/pw_basis.h class PW_Basis_Big: public PW_Basis { public: .... virtual void initgrids(const double lat0_in,const ModuleBase::Matrix3 latvec_in, const double gridecut){ .... } .... virtual void initgrids( const double lat0_in, const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors const int nx_in, int ny_in, int nz_in ){ .... } .... protected: .... virtual void distribute_r(){ .... } 派生类的析构函数也可以声明为 virtual。这些函数实际上调用 PW_Basis_Big 此派生类中声明和定义的版本。 其余的数据成员在构造函数中进行初始化均总结于下表： 数据成员 所属类 是否在当前类（ESolver_FP）的构造函数中被调用构造函数 chr Charge 是 symm ModuleSymmetry::Symmetry 是 sf Structure_Factor 是 kv K_Vectors 是 pw_rho ModulePW::PW_Basis 是 pw_big ModulePW::PW_Basis_Big 是 ⚙ 然而，PW_Basis_Big 和 PW_Basis 的关系（后文也有 PW_Basis_K 和 PW_Basis_K_Big）实际并不符合程序设计的抽象理念，这一点将在随后介绍。 变量 声明时赋初值 调用构造函数所赋初值 Charge 类 rho, rho_save, rhog, rhog_save, kin_r, kin_r_save, rho_core, rhog_core, rhopw nulllptr nrxx, nxyz, ngmc, nspin allocate_rho, allocate_rho_final_scf false prenspin 1 Symmetry 类 symm_flag available true s1, s2, s3, a1, a2, a3, p1, p2, p3 ntype, nat, na, istart, itmin_type, itmin_start newpos, rotpos, ptrans, ncell, index cel_const, pcel_const, pre_const symflag_fft, sym_test, pbrav, real_brav, ilattname, plattname gmatrix,kgmatrix, gtrans symop, nop, s_flag, nrot, pgnumber, spgnumber, pgname, spgname optlat,plat nrotk,max_nrotk -1 tab 12 Structure_Factor 类 nbspline, strucFac, eigts1, eigts2, eigts3 c_eigts1, c_eigts2, c_eigts3, z_eigts1, z_eigts2, z_eigts3 nullptr K_Vectors 类 kvec_c, kvec_d, kvec_d_ibz, wk, wk_ibz, ngk, isk, ibz2bz, nmp nspin, nks, nkstot, nkstot_ibz,k_nkstot 0 koffset kc_done, kd_done false k_kword PW_Basis 类 classname \"PW_Basis\" ig2isz, istot2ixy, is2fftixy, d_is2fftixy, fftixy2up, nst_per, npw_per, startz, numz, numg, numr, startg, startr, gdirect, gcar, gg, startnsz_per, ig2igg, gg_uniq nullptr device \"cpu\" precision \"double\" nst, nstnz, nstot, npw, npwtot, nrxx, startz_current, nplane, ngg, ggecut, gridecut_lat, full_pw_dim, poolrank, fftnx, fftny, fftnz, fftnxyz, fftnxy, nx, ny, nz, nxyz, nxy, liy, riy, lix, rix, ng_xeq0, nmaxgr 0 ig_gge0 -1 lat0, tpiba, tpiba2, omega, distribution_type, poolnproc, 1 xprime false PW_Basis:public PW_Basis_big 类 bx, by, bz 1 bxyz, nbx, nby, nbz, nbzp, nbxx, nbzp_start 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 1 下篇：Introduction to ABACUS: Path to PW calculation - Part 3 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-04 22:37:12 "},"develop-path3.html":{"url":"develop-path3.html","title":"Introduction to ABACUS: Path to PW calculation - Part 3","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 3 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 3 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class Trigger: ESolver_FP::Init() 承接上篇中已经导入的结构信息，以及了解到构造函数及其伴随的变量初始化和 ABACUS 里应用到的 C++ 多态编程，接下来即将（逐渐）步入 ABACUS 的核心内容。我们暂时跳过位于 source/driver_run.cpp:driver_run() 的： // 3. For these two types of calculations // nothing else need to be initialized if(GlobalV::CALCULATION == \"test_neighbour\" || GlobalV::CALCULATION == \"test_memory\") { p_esolver->Run(0, GlobalC::ucell); ModuleBase::QUIT(); } 直接来到第 44 行，ModuleESolver::ESolver::Init() 函数对 esolver 进行更多的设置： // driver_run.cpp: line 44 p_esolver->Init(INPUT, GlobalC::ucell); 然而查找该函数的定义和声明时，发现该函数在 module_esolver/esolver.h 被声明为纯虚函数，类似的还有 un(), cal_Energy(), cal_Force(), cal_Stress() 等。 namespace ModuleESolver { class ESolver { public: .... virtual void Init(Input& inp, UnitCell& cell) = 0; virtual void Run(int istep, UnitCell& cell) = 0; virtual void cal_Force(ModuleBase::matrix& force) = 0; virtual void cal_Stress(ModuleBase::matrix& stress) = 0; .... 考虑到我们之前已经根据 basis_type 和 esolver_type 确定基类（ESolver）指针 p_esolver 所指向内存空间所存储变量为 ESolver_KS_PW，因此我们首先只关注该纯虚函数在 esolver_ks_pw 的实例化。 查看 module_esolver/esolver_ks_pw.cpp 中该函数的定义： namespace ModuleESolver { .... template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { ESolver_KS::Init(inp, ucell); 从上篇中可知，ESolver_KS_PW 有从 ESolver_KS 的继承，ESolver_KS 是从 ESolver_FP（FP 代表 First-Principles）的继承，ESolver_FP 是从 ESolver 的继承，因此 ESolver 各子类中 Init() 函数均保持结构统一，且第一行为父类的 Init() 函数： module_esolver/esolver_ks.cpp： namespace ModuleESolver { .... template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { ESolver_FP::Init(inp,ucell); module_esolver/esolver_fp.cpp： namespace ModuleESolver { .... void ESolver_FP::Init(Input& inp, UnitCell& cell) { cell.read_pseudo(GlobalV::ofs_running); 同时由于多层的继承关系，p_esolver 现在具有所有的数据成员，ESolver_FP 具有数据成员： namespace ModuleESolver { class ESolver_FP : public ESolver { public: ModulePW::PW_Basis* pw_rho; ModulePW::PW_Basis_Big* pw_big; elecstate::ElecState* pelec = nullptr; Charge chr; ModuleSymmetry::Symmetry symm; psi::Psi>* psi = nullptr; psi::Psi* psid = nullptr; Structure_Factor sf; K_Vectors kv; }; } 同理，ESolver_KS 的数据成员，也被 ESolver_KS_PW 继承。ESolver_FP::Init() 首先调用 UnitCell::read_pseudo() 函数进行赝势文件读取，而将赝势文件读取任务放在 FP 层级下，也暗示对于 ABACUS 的第一性原理方法实现来讲，都需要使用赝势。 Pseudopotential import: UnitCell::read_pseudo() void UnitCell::read_pseudo(std::ofstream &ofs) { read_cell_pseudopots(GlobalV::global_pseudo_dir, ofs); 在解读赝势文件读取功能之前，首先需要对赝势文件的结构和信息做一定程度的了解。 ONCV pseudopotential file Section 0: Norm-conserving conditions, generation of pseudopotential and header of exact UPF file 赝势的意义不言自明，其中模守恒赝势需满足如下条件： \\epsilon^\\text{ps}_l=\\epsilon_l（赝势得到的能级和全电子方法求解的能级一样，这里 ps 代表 pseudopotentials） \\phi^\\text{ps}_l(r)无节点（赝波函数没有结点，nodeless） 在截断半径之外（r>r_c）有\\phi^\\text{ps}_l(r)=\\phi_l(r)（赝波函数在截断半径之后一致） \\int_{r（电子数守恒，即模守恒） 生成赝势的步骤如下： -\\frac{\\hbar^2}{2m}\\frac{d^2}{dr^2}\\phi_{l}(r)+[\\frac{\\hbar^2}{2m}\\frac{l(l+1)}{r^2}+V(r)]\\phi_l(r)=\\epsilon_l\\phi_l(r)，解得(\\phi_l(r)-\\epsilon_l) pair 满足上述四个模守恒条件前提下生成(\\phi^\\text{ps}_l(r)-\\epsilon^\\text{ps}_l) pair，使得-\\frac{\\hbar^2}{2m}\\frac{d^2}{dr^2}\\phi^\\text{ps}_{l}(r)+[\\frac{\\hbar^2}{2m}\\frac{l(l+1)}{r^2}+V(r)]\\phi^\\text{ps}_l(r)=\\epsilon^\\text{ps}_l\\phi^\\text{ps}_l(r)成立 V_l(r)=\\frac{1}{\\phi^\\text{ps}_l(r)}[\\epsilon^\\text{ps}_l-\\frac{\\hbar^2}{2m}\\frac{l(l+1)}{r^2}+\\frac{\\hbar^2}{2m}\\frac{d^2}{dr^2}]\\phi^\\text{ps}_l(r)，解得V_l(r)。 扣除V_l(r)中 Hartree、xc 部分，得到V^\\text{ps}_l(r)：V^\\text{ps}_l(r)=V_l(r)-V^\\text{H}[\\rho^\\text{ps}(r)]-V^\\text{xc}[\\rho^\\text{ps}(r)]。\\rho^\\text{ps}(r)=\\frac{1}{4\\pi}\\sum_i^\\text{occ}{f_{i}|\\phi^\\text{ps}_l(r)|^2} 更多细节见：www.tcm.phy.cam.ac.uk 从 UPF 文件（注意 UPF 文件也有不同的版本，目前 ABACUS 都支持，若有不支持的，可以提 Github 的 issues 进行讨论）开始，截止到 之前，提供了赝势文件的作者信息，引用信息以及生成赝势文件所使用的程序和相应输入文件，并附带输入文件参数中的解释。由于此块内容对实际计算并不起作用，因此暂时略过。 Section 1: 部分尽管已经位于所谓“not human readable”区域，但也并非如此。这部分“标签”（HTML 语境）/block 实际上包含了众多精简过的信息，如元素名称（element）、赝势类型（pseudo_type，模守恒，norm-conserving，NC），相对论效应（relativistic），是否为超软赝势等等信息。当前 Al 理论上其原子序数 13，因此有 13 个电子，但此处 z_valence 参数为 11，即有两个 1s 电子被赝化，只留下 2s, 2p, 3s, 3p 电子共 2+6+2+1 个。对于某些元素，甚至有大核赝势与小核赝势之分，根据赝化电子数量不同进行区分。显而易见地，赝化电子数量越多，则计算量越小，但计算结果的精确程度可能更低。 Section 2: 0.0000 0.0100 0.0200 0.0300 0.0400 0.0500 0.0600 0.0700 5.9200 5.9300 5.9400 5.9500 5.9600 5.9700 5.9800 5.9900 6.0000 6.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 这部分开始出现了关于实空间格点相关量的定义。在 tag 中不仅指定数据类型为实数，也指定当前数据的长度（size），以及数据存储的列数（columns = 8）。PP_R 为格点坐标，PP_RAB 则为格点间距。 Section 3: -4.5793174225E+01 -4.5788454271E+01 -4.5774276797E+01 -4.5750659428E+01 -3.6912752197E+00 -3.6850921941E+00 -3.6789298138E+00 -3.6727880140E+00 -3.6666666933E+00 -3.6605657501E+00 从 部分开始，正式开始写入赝势的具体数值，建立在 和 所描述的实空间格点上。\\hat{V}=\\hat{V}^\\text{loc}+\\hat{V}^\\text{NL}。 正是赝势的局域势部分。 Section 4: 0.0000000000E+00 8.1959788337E-02 1.6389680452E-01 2.4578292762E-01 -1.2623857798E-05 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 5.3707838603E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 -8.2930195943E-01 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 -6.5836757852E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 -4.6797927123E+00 完全非局域部分，\\hat{V}^\\text{NL}=\\sum_{ij}{|\\beta_i\\rangle D_{ij}\\langle\\beta_j|}。其中|\\beta_i\\rangle一般被称为非局域势投影子（projector）。 Section 5: and 0.0000000000E+00 3.6337392512E-03 1.4532726686E-02 3.2690254089E-02 为赝波函数， 则为赝电荷密度在实空间格点上的数据。一个简单的赝势文件信息提取脚本： ParseUpfWordByWord.py &#x1F914; 玩玩看！ Quantum ESPRESSO 官网上提供了更多关于 UPF 文件格式的信息：Unified Pseudopotential Format - QUANTUMESPRESSO ❗注意 读入的投影子 projector |\\beta\\rangle和 pswfc \\tilde{\\phi}(r)已经乘径向坐标r。 UnitCell::read_cell_pseudopots() link to Github -> link void UnitCell::read_cell_pseudopots(const std::string &pp_dir, std::ofstream &log) { std::stringstream ss; ss pseudo_fn[i]; error = upf.init_pseudo_reader( pp_address, this->pseudo_type[i] ); 赝势文件的读取 type-by-type，每次创建 Pseudopot_upf 类对象 upf，之后调用 upf.init_pseudo_reader() 对文件进行读取，需要指定文件的地址（pp_address）和赝势类型（UnitCell::pseudo_type[i]）。Pseudopot_upf::init_pseudo_reader() 为每种赝势文件进行判断，之后进行不同的解析。为方便起见，这里我们只关注 ABACUS 的常用赝势类型，即模守恒 upf。跟随“转到定义”，来到 module_cell/read_pp.cpp 文件（link）： int Pseudopot_upf::init_pseudo_reader(const std::string &fn, std::string &type) { std::ifstream ifs(fn.c_str(), std::ios::in); if (type == \"auto\") { set_pseudo_type(fn, type); } if (type == \"upf\") { int info = read_pseudo_upf(ifs); return info; } else if (type == \"vwr\") { int info = read_pseudo_vwr(ifs); return info; } else if (type == \"upf201\") { int info = read_pseudo_upf201(ifs); return info; } else if (type == \"blps\") { int info = read_pseudo_blps(ifs); return info; } return 0; } 选择 read_pseudo_upf() 函数，跳转到位于 module_cell/read_pp_upf100.cpp 的该函数定义。read_pseudo_upf() 函数分标签读取 upf 格式赝势文件中信息，每个标签都有单独的解析器： while (ifs.good()) { ifs >> dummy; if(dummy==\"\") { ierr = 1; read_pseudo_header(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); break; } } if ( ModuleBase::GlobalFunc::SCAN_BEGIN(ifs, \"\") ) { read_pseudo_mesh(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); } if (this->nlcc) { ModuleBase::GlobalFunc::SCAN_BEGIN(ifs, \"\"); read_pseudo_nlcc(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); } ModuleBase::GlobalFunc::SCAN_BEGIN(ifs, \"\"); read_pseudo_local(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); 与 类似的还有 , , , 从 则可以读取旋轨耦合相关信息： if (has_so) { ModuleBase::GlobalFunc::SCAN_BEGIN (ifs,\"\"); read_pseudo_so (ifs); ModuleBase::GlobalFunc::SCAN_END (ifs,\"\"); } 每个具体 tag 的解析函数 Pseudopot_upf::read_pseudo_xxx() 均赋值于数据成员，声明在 module_cell/read_pp.h 中（link）。 Functions in Pseudopot_upf class Variables value assgined explain void read_pseudo_header(std::ifstream &ifs); this->nv``this->psd``this->tvanp``this->nlcc``this->xc_func``this->zp``this->etotps``this->ecutwfc``this->ecutrho``this->lmax``this->mesh``this->nwfc``this->nbeta``this->els``this->lchi``this->oc Version numberElement labelIf ultrasoft pseudopotentialIf noncolinear correction addedXc functionalAtomic chargesTotal energySuggested energy cutoff for wavefunctionSuggested energy cutoff for charge densityMaximal angular momentum includedNumber of points in radial meshNumber of wavefunctionsNumber of projectorsDim nwfc, labels of orbitalDim nwfc, angular momentum of orbitalDim nwfc, occupation of orbital void read_pseudo_mesh(std::ifstream &ifs); this->r``this->rab Dim this->mesh, realspace mesh of radiusDim this->mesh, void read_pseudo_nlcc(std::ifstream &ifs); this->rho_atc Dim this->mesh, void read_pseudo_local(std::ifstream &ifs); this->vloc Dim this->mesh, Vlocal void read_pseudo_nl(std::ifstream &ifs); this->kkbeta this->lll this->beta``this->dion``this->nd Dim this->nbeta, number of mesh points of projectors.Dim this->nbeta, angular momentum for projectors.Dim this->nbetathis->mesh.Dim this->nbetathis->nbeta.Number of nonzero D_{ij} void read_pseudo_pswfc(std::ifstream &ifs); this->chi Dim this->nwfc*this->mesh, void read_pseudo_rhoatom(std::ifstream &ifs); this->rho_at Dim this->mesh, atomic electron density on realspace mesh void read_pseudo_addinfo(std::ifstream &ifs); Not implemented Not implemented void read_pseudo_so(std::ifstream &ifs); this->nn this->jchi``this->jjj Dim this->nwfc, quantum number of wavefunctionDim this->nwfc, j=l+s, where s=\\pm\\frac{1}{2}.Dim this->nbeta, j=l+s, where s=\\pm\\frac{1}{2}, for projector. 我们假设 ONCV.upf 格式赝势文件顺利读取完毕，upf.init_pseudo_reader() 返回 0（error == 0），来到条件判断： if(error==0) { if(this->atoms[i].flag_empty_element) upf.set_empty_element(); error_ap = upf.average_p(GlobalV::soc_lambda); } Pseudopot_upf::set_empty_element() 的作用为设置 Vloc、dion 和 rho_at 均为 0，Pseudopot_upf::average_p() 则属于自旋轨道耦合（spin-orbital coupling）功能，这里先不介绍。 我们来到 line 82, if(GlobalV::MY_RANK==0) { atoms[i].ncpp.set_pseudo_nc( upf ); .... } 实际上 ABACUS 目前只能处理模守恒的赝势类型。显然该行实现的为将赝势信息从upf到atoms[i].ncpp的拷贝，而 upf 的意义也不言自明：UPF file parser。解析 UPF 文件后传值给 atoms[i].ncpp void pseudo_nc::set_pseudo_nc(const Pseudopot_upf &upf) { this->set_pseudo_h(upf); this->set_pseudo_atom(upf); this->set_pseudo_vl(upf); delete[] lll; lll = new int[nbeta]; for (int i = 0;i kkbeta = 0; for (int nb = 0;nb kkbeta = (upf.kkbeta[nb] > kkbeta) ? upf.kkbeta[nb] : kkbeta; } this->betar.create(upf.beta.nr, upf.beta.nc); this->betar = upf.beta; this->dion.create(nbeta, nbeta); this->dion = upf.dion; } 该函数属于类 pseudo_nc，而 pseudo_nc 对象为 atom 的数据成员，atoms 则为 UnitCell 的数据成员。pseudo_nc::set_pseudo_h()，pseudo_nc::set_pseudo_atom 和 pseudo_nc::set_pseudo_vl 的内容在此省略，但其分别为将 Hamilton, 原子性质和 Vlocal 相关数据从 upf 对象拷贝。之后(1)使用 lll 刷新为 upf 对象的 projectors 的角动量，然后计算出磁角动量区分时的 projector 个数。(2)取所有 projector 衰减到 0 时候的最大最普适半径。 赝势信息后处理 回到 module_cell/unitcell.cpp line 663，接下来为每个原子创建目录，在目录中写 [原子label].NONLOCAL 文件。[label].NONLOCAL 文件中内容包含 , 和 三个 tag。 中包含内容： ofs \" label ncpp.pp_type ncpp.lmax \" 中包含内容为 projector 数量 atom->ncpp.nbeta、对应于每个原子的 projector 的角动量为指标的 dion 矩阵： ofs \" ncpp.nbeta ncpp.nbeta; ib++) { for(int ib2=0; ib2ncpp.nbeta; ib2++) { ofs ncpp.lll[ib] ncpp.lll[ib2] ncpp.dion(ib,ib2)\" 中包含内容为 projector 仅其值大于 1.0e-10 的值。首先仍然输出当前原子的 projector 索引，以及角动量，然后截断 projector: int cut_mesh = atom->ncpp.mesh; for(int j=atom->ncpp.mesh-1; j>=0; --j) { if( std::abs( atom->ncpp.betar(i,j) ) > 1.0e-10 ) { cut_mesh = j; break; } } if(cut_mesh %2 == 0) ++cut_mesh; 之后按照截断后的网格重新存储 projector 的 realspace grid, projector value, rab 数据，分三列分别存储： for(int j=0; jncpp.r[j] ncpp.betar(i, j) ncpp.rab[j] \" 赝势信息分发：UnitCell::bcast_unitcell2(void) #ifdef __MPI 接下来对赝势信息进行MPI进程（processor）间的分发： #ifdef __MPI bcast_unitcell2(); #endif // module_cell/unitcell.cpp:bcast_unitcell2() void UnitCell::bcast_unitcell2(void) { for (int i = 0; i // module_cell/atom_spec.cpp:Atom::bcast_atom2() void Atom::bcast_atom2() { this->ncpp.bcast_atom_pseudo(); } // module_cell/atom_pseudo.cpp::Atom_pseudo::bcast_atom_pseudo() void Atom_pseudo::bcast_atom_pseudo(void) { .... Parallel_Common::bcast_int( lmax ); .... Parallel_Common::bcast_double( etotps ); .... Parallel_Common::bcast_bool( tvanp ); .... Parallel_Common::bcast_string( psd ); .... // below two 'bcast_double' lines of codes seem to have bugs, // on some computers, the code will stuck here for ever. // mohan note 2021-04-28 Parallel_Common::bcast_double( dion.c , nbeta * nbeta); Parallel_Common::bcast_double( betar.c, nr * nc ); } #endif 赝势信息核对 接下来跨原子种类检验泛函是否一致： for(int it=0; it STRU 结构检查：UnitCell::check_structure() 检验结构中任意两原子之间距离是否大于其固定倍数（ check_structure(GlobalV::MIN_DIST_COEF); 计算轨道数：UnitCell::cal_natomwfc() UnitCell::cal_natomwfc() 函数计算所有种类的原子轨道数量加和，对于非 nspin=4，即非 soc（自旋轨道耦合）情况，角量子数 l 和 s 非耦合，l 单独可以作为好的量子数来区分量子态，因此对于每个赝势中定义的 wfc，若其对应 occupation 大于等于 0（即有效 wfc），则对应于其角量子数 l，轨道数量增加 2l+1，即计数其磁量子数 m，也相当于对 alpha 和 beta spin 的单独计数。对于 nspin=4 的情况，若考虑 soc，则轨道数对 j=l+s 的情况，当前原子种类当前角量子数对应轨道数量记为 2l+1+1，否则为 2l+1。对于非 soc 但 nspin=4，当前原子种类轨道当前角量子数对应轨道数量记(2l+1)*2： void UnitCell::cal_natomwfc(std::ofstream &log) { this->natomwfc = 0; for (int it = 0;it = 0) { if(GlobalV::NSPIN==4) { if(atoms[it].ncpp.has_so) { tmp += 2 * atoms[it].ncpp.lchi[l]; if(fabs(atoms[it].ncpp.jchi[l] - atoms[it].ncpp.lchi[l] - 0.5) 接下来调用 UnitCell::cal_nwfc() 函数，计算并赋值 波函数 index 到角动量，zeta 和磁量子数的表格， 跨原子种类的最大原子数，以及最大 wfc 数量， 轨道数量和： GlobalV::NLOCAL = 0; for(int it=0; it 建立 UnitCell::itia2iat（种类 index，种类内原子 index）->（原子全局 index）映射表、UnitCell::iat2iwt（原子全局 index）->（波函数全局 index）映射表、UnitCell::iwt2iw（波函数全局 index）->（波函数种类内 index）映射表、UnitCell::iwt2iat（波函数全局 index）->（原子全局 index）映射表、UnitCell::iwt2iw（波函数全局 index）->（波函数种类内 index）映射表。 计算跨原子种类最大角量子数 UnitCell::lmax 和某 l 对应最大 zeta 数 UnitCell::nmax，以及跨原子种类的类内 zeta 数总和最大值 UnitCell::nmax_total 寻找赝势中最大角量子数 UnitCell::lmax_ppwf。 价电子数核对 核对赝势中定义的价电子数与 ABACUS 预置库中原子的最小价电子数 获取最大格点数量：UnitCell::cal_meshx() 计算跨原子种类的最大格点数量，存储在 UnitCell::meshx 中，目前 ABACUS 代码中变量命名后缀 x 可能代表 max，正如之前看到 npwx 等。 至此，我们离开函数 UnitCell::read_pseudo()，回到 ModuleESolver::ESolver_FP::Init() 函数。 &#x1F4C3;和 Quantum Espresso 对齐的赝势参数 读入 UPF 格式的模守恒赝势之后，如果要和 QE 的结果做 apple-to-apple 的比较，使得总能量受力等性质计算一致，可以把基矢量调成平面波(basis_type 设成 pw)，然后在 INPUT 文件中，把 pseudo_rcut 设成 10（默认是 15），pseudo_mesh 设成 1 即可（默认是 0）。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 2 下篇：Introduction to ABACUS: Path to PW calculation - Part 4 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-04 23:11:45 "},"develop-path4.html":{"url":"develop-path4.html","title":"Introduction to ABACUS: Path to PW calculation - Part 4","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 4 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 4 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class Trigger: ESolver_FP::Init() 平面波格点初始化：PW_Basis:: initgrids() 完成了 INPUT 和 STRU，以及赝势文件的读取环节，接下来我们来到平面波的初始化设置相关部分。 void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... if (inp.nx * inp.ny * inp.nz == 0) this->pw_rho->initgrids(inp.ref_cell_factor * cell.lat0, cell.latvec, inp.ecutrho); else this->pw_rho->initgrids(inp.ref_cell_factor * cell.lat0, cell.latvec, inp.nx, inp.ny, inp.nz); ⚠️ 注意，PW_Basis::initgrids() 为虚函数（virtual），尽管使用基类指针（pw_rho），实际调用的函数也是与之同名但不同内容的派生类（PW_Basis_Big）成员函数。这一点靠 ESolver_FP 的构造函数实现： ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); pw_big = static_cast(pw_rho); pw_big->setbxyz(INPUT.bx, INPUT.by, INPUT.bz); sf.set(INPUT.nbspline); this->symm.epsilon = this->symm.epsilon_input = INPUT.symmetry_prec; } 在 INPUT 文件中，nx, ny 和 nz 为 FFT 网格大小相关参数，但一般应用场景而言，几乎无用户亲自设置它（对于用户主动设置 nx, ny 和 nz 的情况，ecutrho/ecutwfc 值的设置无效，将会根据格点情况被重新赋值）。在 Input::Default() 中，三个变量的默认值均为 0，因而常规来讲实际唤起 PW_Basis::initgrads() 函数的版本计算了 nx, ny 和 nz，其算法和 SIAB 程序完全相同（view source code: https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_basis/module_pw/pw_init.cpp#L156）： INPUT 中 ecutrho 确定以动量\\mathbf{k}=(0,0,0)为球心的球半径 在倒空间确定所有在“球”中的格点（均为整数坐标，因现在最小可分辨距离为倒格子矢量长度，见下 Fig.1），其中每个点都对应一个平面波 以倒空间内 x/y/z 最大/小值为边界组成正方形盒子，进行（2, 3, 5）质数分解，得到可能更大的盒子尺度（nx, ny 和 nz） 相较于 PW_Basis::initgrids()，PW_Basis_Big::initgrids() 还初始化了 nbx, nby 和 nbz 的值，尽管对于平面波而言整个 PW_Basis_Big 都是冗余功能（PW_Basis_Big 只是在 LCAO 里面做格点积分的时候会用到）： virtual void initgrids(const double lat0_in,const ModuleBase::Matrix3 latvec_in, const double gridecut) { // generation of nx, ny and nz are omitted here .... if(!this->bz) { this->autoset_big_cell_size(this->bz, ibox[2], this->poolnproc); } if(!this->bx) { if(ibox[0] == ibox[2]) this->bx = this->bz; else this->autoset_big_cell_size(this->bx, ibox[0]); } if(!this->by) { if(ibox[1] == ibox[2]) this->by = this->bz; else this->autoset_big_cell_size(this->by, ibox[1]); } this->bxyz = this->bx * this->by * this->bz; if(ibox[0]%this->bx != 0) ibox[0] += (this->bx - ibox[0] % this->bx); if(ibox[1]%this->by != 0) ibox[1] += (this->by - ibox[1] % this->by); if(ibox[2]%this->bz != 0) ibox[2] += (this->bz - ibox[2] % this->bz); .... this->nbx = this->nx / bx; this->nby = this->ny / by; this->nbz = this->nz / bz; delete[] ibox; } 回忆 PW_Basis_Big::bx, by 和 bz 的值则在 namespace ModuleESolver { ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); .... pw_big->setbxyz(INPUT.bx, INPUT.by, INPUT.bz); 设置。回溯 INPUT.bx，在 input.cpp 就可以发现： //line 2664 if (basis_type == \"pw\") // xiaohui add 2013-09-01 { .... bx = 1; by = 1; bz = 1; } 接下来从 Input 对象中拷贝了平面波类 PW_Basis 的数据成员， void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->initparameters(false, inp.ecutrho); void PW_Basis:: initparameters( const bool gamma_only_in, const double pwecut_in, const int distribution_type_in, const bool xprime_in ) { this->xprime = xprime_in; this->gamma_only = gamma_only_in; // if use gamma point only, when convert real function f(r) to F(k) = FFT(f), // we have F(-k) = F(k)*, so that only half of planewaves are needed. this->fftny = this->ny; this->fftnx = this->nx; if (this->gamma_only) { if (this->xprime) this->fftnx = int(this->nx / 2) + 1; else this->fftny = int(this->ny / 2) + 1; } this->fftnz = this->nz; this->fftnxy = this->fftnx * this->fftny; this->fftnxyz = this->fftnxy * this->fftnz; this->ggecut = pwecut_in / this->tpiba2; //ggecut should be no larger than gridecut if(this->ggecut > this->gridecut_lat) this->ggecut = this->gridecut_lat; this->distribution_type = distribution_type_in; } ❗ 注意：这里还完成了倒空间格点数量 fftnx, fftny 和 fftnz 的赋值。因为 FFT 变换前后的格点数量一般相同，因此 fftnx = nx，fftny = ny，...。 然后对平面波在 MPI 进程间进行分发： //module_esolver/esolver_fp.cpp void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->setuptransform(); void PW_Basis::setuptransform() { ModuleBase::timer::tick(this->classname, \"setuptransform\"); this->distribute_r(); this->distribute_g(); this->getstartgr(); this->ft.clear(); if(this->xprime) this->ft.initfft(this->nx,this->ny,this->nz,this->lix,this->rix,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); else this->ft.initfft(this->nx,this->ny,this->nz,this->liy,this->riy,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); this->ft.setupFFT(); ModuleBase::timer::tick(this->classname, \"setuptransform\"); } PW_Basis::setuptransform()（link） 并行机制简述 并行池 到这里，我们不得不开始对平面波的 MPI 并行机制有一个大致的认识。在 ABACUS 中，CPU（=processor）首先根据不同的布里渊区 k 点分组被划分成不同的并行池（parallelizaiton pool），每个 pool 都包含几个 k 点，在每个 pool 里面会有完整的对该 k 点求解 Kohn-Sham 方程的过程。因此，在每个 pool 中采用一定数量的 CPU 进程来完成计算。在 INPUT 文件中，KPAR 参数决定了并行池的数量（即 pool 的个数）。换句话说，ABACUS 的 k 点并行机制为，将 k 点（设其数量为 nkpt）分配在 KPAR 个 pool 中，若一共有 nproc 个 processor，则： 每个 pool 有 nproc/KPAR 个 processor 每个 pool 均分得到 nkpt/KPAR 个 k 点进行计算-> 最多有多少个 k 点同时进行计算（因为均分到每个 pool 的 kpt 将串行计算） KPAR：defines the number of groups the k points are divided into, or the number of kpts on which wavefunctions are solved simultaneously. 另外注意，自旋是通过 k 点这个 index 被包含进计算的。即对同 1 个 k 点的自旋上下是通过在程序里设置两个 k 点来完成计算的。例如，我们采用 444=64 个 k 点进行运算，如果不开对称性，那么 nspin=1 时程序执行的是 64 个 k 点，npsin=2 时程序执行的是 64*2=128 个 k 点。 MPI 进程编号：rank rank 是一个在 MPI 并行里常被用到的变量。在拥有不止一个 processor 的时候，每个 processor 都具有唯一的编号，称为 rank。如果在每个 processor 都有 rank 的基础上还定义了 pool，以及在每个 pool 中的 processor 数量，则 processor 除了有跨 pool 的全局 rank，也可以有 pool 之内的局部 rank，这部分内容见 module_base/global_variable.cpp: int NPROC = 1; int KPAR = 1; int MY_RANK = 0; int MY_POOL = 0; int NPROC_IN_POOL = 1; int RANK_IN_POOL = 0; .... 在 ABACUS 中，部分文件 I/O 操作仅使用 rank0 的 processor 执行（module_cell/read_cell_pseudopots.cpp: line 32）： if(GlobalV::MY_RANK==0) { pp_address = pp_dir + this->pseudo_fn[i]; error = upf.init_pseudo_reader( pp_address, this->pseudo_type[i] ); //xiaohui add 2013-06-23 if(error==0) // mohan add 2021-04-16 { if(this->atoms[i].flag_empty_element) // Peize Lin add for bsse 2021.04.07 { upf.set_empty_element(); } //average pseudopotential if needed error_ap = upf.average_p(GlobalV::soc_lambda); //added by zhengdy 2020-10-20 } } 并行策略 于是问题便到来：在并行条件下，代码究竟是如何执行的？ 对于多核 CPU，是否运行在其上的所有程序都进行了并行化？ 答：否。对于运行在常见操作系统上的软件，并不需要进行显式的并行化，因为系统具有分配算法，会根据当前硬件情况，自动把软件的执行在不同核间进行分配和任务调度。但究竟并行效率和结果如何，取决于操作系统自身。 一个自编程序如果没有进行显式的并行化，直接使用 mpirun 等方式运行，会发生什么？ 答：相同的代码会在每个 processor 上运行一遍。 CPU 和 processor 的关系是什么？ 答：CPU=processor，在并行计算的语境下。 特别地，对于 C++ 而言，没有显式并行化却使用 mpirun 方式运行的程序，若其中包括创建对象等操作，是否意味着每个 processor 都创建了单独的对象，并且都放在了各自的内存空间？ 答：取决于并行策略。对于 OpenMP，processor 间内存共享，即只创建一个对象，之后每个 processor 同时往同一个内存区域读写内容。对于 MPI，processor 间内存相互独立，即每个 processor 在各自隔离的内存上都创建相同对象，之后每个 processor 再独立进行内存区域的读写。 5w. 进程、线程之间是什么关系？ 进程（process）包含线程（thread）。以下为 ChatGPT 生成内容： A process is an instance of a program that is being executed. It has its own memory space, system resources, and execution context. A process can contain multiple threads, each of which can execute independently and concurrently within the same process. Processes are managed by the operating system and can communicate with each other through inter-process communication mechanisms. A thread, on the other hand, is a lightweight unit of execution within a process. It shares the same memory space and system resources as the process it belongs to, but has its own execution context. Multiple threads within a process can execute concurrently and share data and resources within the process. Threads are managed by the operating system or by the application itself, depending on the programming language and platform. OpenMP-MPI 混合编程 通常来讲，尽管 OpenMP 提供了线程并行，但由于共享内存可能并不存在于 processors 之间，或 computer, nodes 之间，且没有适合的内存共享系统（multi-socket server），此时如果以 OpenMP 放心运行，则可能得出错误结果或直接报错——因为内存无法访问。对于这种情况，需要使用 MPI（Message passing interface）来维持无内存共享处理单元之间的信息交换，以及信息分发和分布计算，而在处理单元内部，即可以共享内存的域内，则可以通过 OpenMP 技术来进行线程级并行。 实空间格点分发 在简单介绍完并行机制后，我们知道，对于未显式以并行方式实现的函数，其运行将在每一个 processor。在接下来的平面波分发过程中，请始终牢记这一理念，尤其在 processor-local 变量和 processor-global 变量的传值过程中。 稍加回溯： void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->setuptransform(); void PW_Basis::setuptransform() { this->distribute_r(); this->distribute_g(); .... 而 ModuleESolver::ESolver_FP::Init() 为 ModuleESolver::ESolver_KS::Init() 所调用，ModuleESolver::ESolver_KS::Init() 为 ModuleESolver::ESolver_KS_PW::Init() 所调用，ModuleESolver::ESolver_KS_PW::Init()则为 p_esolver 所调用，p_esolver 虽然属于 ModuleESolver::ESolver 类指针，但由于 basis_type 和 esolver_type 被划定指向 ModuleESolver::ESolver_KS_PW 类内存空间，因此其原本纯虚函数 ModuleESolver::ESolver::Init() 的调用指向 ModuleESolver::ESolver_KS_PW::Init()。p_esolver 在 driver_run 中被创建，driver_run 来源于 atomic_world() 函数，atomic_world() 函数则在 driver.cpp 中被调用。 回到正题： 实空间：PW_Basis::distribute_r() ❗Attention 注意，此时实际调用的也是 PW_Basis_Big 而非 PW_Basis 的 distribute_r() 函数。 namespace ModulePW { class PW_Basis_Big: public PW_Basis { public: virtual void distribute_r() { delete[] this->numz; this->numz = new int[this->poolnproc]; delete[] this->startz; this->startz = new int[this->poolnproc]; ModuleBase::GlobalFunc::ZEROS(this->numz, this->poolnproc); ModuleBase::GlobalFunc::ZEROS(this->startz, this->poolnproc); int npbz = this->nbz / this->poolnproc; int modbz = this->nbz % this->poolnproc; this->startz[0] = 0; for(int ip = 0 ; ip poolnproc ; ++ip) { this->numz[ip] = npbz*this->bz; if(ip numz[ip]+=this->bz; if(ip poolnproc - 1) this->startz[ip+1] = this->startz[ip] + numz[ip]; if(ip == this->poolrank) { this->nplane = numz[ip]; this->startz_current = startz[ip]; } } this->nbzp = this->nplane / this->bz; this->nrxx = this->numz[this->poolrank] * this->nxy; this->nbxx = this->nbzp * this->nbx * this->nby; this->nbzp_start = this->startz[this->poolrank] / this->bz; return; } 基于上一部分简单介绍的并行机制，ABACUS 使用 mpirun 运行，因此上述代码会被每个 processor 所单独运行。直至上述代码片段的第 25 行 if(ip == this->poolrank) {.... 该判断不会 always true。因此 PW_Basis::distribute_r() 将 3D 实空间格点，按照 z 方向进行分发，分给了不同的 processors，并赋值 this->npz，this->nplane, this->startz_current 和 this->nrxx，意义分别为当前 processor 的 z 方向格点数量、xy 平面数量、z 格点的起始索引以及当前 processor 所分得实空间格点总数（分配后 z 方向格点 ×xy 平面格点）。 图 1. PW_Basis::distribute_r()：设一个pool中有5个processors 倒空间：PW_Basis::distribute_g() 倒空间格点的分发采用了和实空间不同的方式，这主要是因为倒空间“球”的存在（ecutwfc 和 ecutrho），使得非空间中所有点都需要考虑在内，而实空间则并非如此。更一般而言，有限的实空间带来无限的倒空间（即实空间 delta 函数需要无限数量的平面波展开）延展，而有限的倒空间（倒空间 delta 点）带来无限的实空间延展（如一个平面波）。 &#x1F527;重构信息 由于目前所考虑基函数为平面波，因此需要同时追踪平面波所属 processor，平面波的 Direct (x, y, z)坐标等信息，ABACUS 现有版本通过多个繁杂的函数，建立了许多映射关系，而从 2d 到 1d 的索引 fold 让代码可读性和代码扩展编写难度进一步上升。实际上，映射关系所携带的信息本质上是“属性”，因此仅需为“属性”寻找正确的归属主体，或平面波或 processor。而 2d 到 1d 的索引映射同样可以进行封装。 倒空间的分发策略现有两种实现： void PW_Basis::distribute_g() { ModuleBase::timer::tick(this->classname, \"distributeg\"); if(this->distribution_type == 1) { this->distribution_method1(); } else if(this->distribution_type == 2) { .... } 由于 PW_Basis::initparameters() 对其有默认调用 method1，因此这里我们先只关心 method1。 void PW_Basis::distribution_method1() { int *st_bottom2D = new int[fftnxy]; int *st_length2D = new int[fftnxy]; .... if (poolrank == 0) { .... this->count_pw_st(st_length2D, st_bottom2D); .... int* st_i = new int[this->nstot]; int* st_j = new int[this->nstot]; int* st_length = new int[this->nstot]; this->collect_st(st_length2D, st_bottom2D, st_i, st_j, st_length); .... this->startnsz_per = new int[this->poolnproc]; this->divide_sticks_1(st_i, st_j, st_length); .... this->get_istot2ixy(st_i, st_j); .... delete[] st_length; delete[] st_i; delete[] st_j; delete[] this->startnsz_per; this->startnsz_per=nullptr; } this->npw = this->npw_per[this->poolrank]; this->nst = this->nst_per[this->poolrank]; this->nstnz = this->nst * this->nz; this->get_ig2isz_is2fftixy(st_bottom2D, st_length2D); delete[] st_bottom2D; delete[] st_length2D; } 分发最小单元：“棍子” - 准备工作 穿过布里渊区的整数点（2pi/a 的整数倍）都代表一个三个 index 的平面波，而一系列的点在截断半径以内沿着某个方向就组成了所谓的“stick”（代表平面波集合的“棍子”，一个“棍子”包含了多个平面波，简称就叫“棍子”）。 PW_Basis::count_pw_st() 函数（Link）计算了每个(x,y)对应的“棍子”的底部和“长度”，即对倒空间只分辨(x,y)，则会得到沿 z 方向的点的集合，被称为“棍子”。而“棍子”区域内部每一个点都代表一个平面波。“棍子”的底部对应于最小的 iz 值，“根子”的长度则为当前(x,y)所包含的平面波数量： for (int ix = ix_start; ix nx; if (y ny; int index = x * this->fftny + y; int length = 0; for (int iz = iz_start; iz GGT * f); if (modulus ggecut || this->full_pw) { if (length == 0) st_bottom2D[index] = iz; ++this->npwtot; ++length; .... } } if (length > 0) { st_length2D[index] = length; ++this->nstot; } } } count_pw_st(st_length2D, st_bottom2D)\">图 2. this->count_pw_st(st_length2D, st_bottom2D) 在倒空间分发平面波时，由于 x/y/z 均等在正负半轴 span，因此常常会涉及到 C++ 不支持负数索引的问题（btw: Python 和 FORTRAN 支持负数索引，但支持方式不同），ABACUS 当前所采取的策略是： if (xnx; if (yny; if (znz; 而在 gamma_only 情况下，由于 F(-k)=F^\\dagger(k) \\\\ 因此倒空间可以缩减（reduce），此两种情况均对倒空间 xy 平面上格点采样有所影响： “棍子”的分发和分发记录 PW_Basis::collect_st() 和 PW_Basis::divide_sticks_1() 分别排序与分发“棍子”到不同 processor： 按照棍子从长到短顺序进行排序，即 st_length2D 由大到小排序，然后适用于 st_bottom2D 等变量 将排在最前面的“棍子”对应平面波分配给任意一个 processor， 如此直到所有 processor 全部被分配过平面波/“棍子” 若还有“棍子”，则寻找具有最小平面波数量的 processor（若平面波数量相等，则寻找最少的“棍子”）继续分配。 重复过程 4 如此一来记录被分配在每个 processor 上的平面波和棍子数量： 变量（所属 PW_Basis 类） 意义 this->npw_per 各 processor 被分配平面波数量 this->nst_per 各 processor 被分配“棍子”数量 this->fftixy2ip 从“棍子”translated (x,y)-pair 到 processor index 的映射，即通过“棍子”所在(x,y)到 processor 的映射关系：cpp // module_basis/module_pw/pw_distributeg_method1.cpp:line 282 this->fftixy2ip[st_i[is] * this->fftny + st_j[is]] = ipmin; translated pair 实际为一维索引，使用 x*fftny + y。进而 fftixy2ip[st_i[is] * this->fftny + st_j[is]] 实现了从“棍子”索引到 processor 索引的映射。 this->startnsz_per 每个包含“棍子”的 processor 其第一个 z-axis grid point 的编号，从 0 开始，跨 processor。 关于 this->startnsz_per 意义的介绍，见辅助阅读材料：Appendix.2 平面波倒空间分发详解。 请自行阅读 PW_Basis::collect_st() 和 PW_Basis::divide_sticks_1() 函数代码： PW_Basis::collect_st()：https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_basis/module_pw/pw_distributeg_method1.cpp#L122 PW_Basis::divide_sticks_1()：https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_basis/module_pw/pw_distributeg_method1.cpp#L247 分发后在 processor 间的广播则显而易见： void PW_Basis::distribution_method1() { .... if (poolrank == 0) this->count_pw_st(st_length2D, st_bottom2D); #ifdef __MPI MPI_Bcast(&this->npwtot, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&this->nstot, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&liy, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&riy, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&lix, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&rix, 1, MPI_INT, 0, this->pool_world); #endif if(poolrank == 0) { #ifdef __MPI .... this->collect_st(st_length2D, st_bottom2D, st_i, st_j, st_length); .... this->divide_sticks_1(st_i, st_j, st_length); .... } #ifdef __MPI MPI_Bcast(st_length2D, this->fftnxy, MPI_INT, 0, this->pool_world); MPI_Bcast(st_bottom2D, this->fftnxy, MPI_INT, 0, this->pool_world); MPI_Bcast(this->nst_per, this->poolnproc, MPI_INT, 0 , this->pool_world); MPI_Bcast(this->npw_per, this->poolnproc, MPI_INT, 0 , this->pool_world); #endif this->npw = this->npw_per[this->poolrank]; this->nst = this->nst_per[this->poolrank]; this->nstnz = this->nst * this->nz; .... 映射表：OOP？ 在倒空间平面波的分发过程中，共建立过四个映射表，分别是 this->fftixy2ip, this->istot2ixy, this->ig2isz 和 this->is2fftixy，其意义分别为： 映射表名称 意义 来源 备注 this->fftixy2ip（同上表） 从“棍子”xy 平面折合坐标到 processor index 的映射，即通过“棍子”所在(x,y)到 processor 的映射，可以用来在 processor 之间 switch PW_Basis::divide_sticks_1()(Link) 折合：索引的 2d->1d：index_folded = x*this->fftny + y;index = x*this->ny + y;折叠：gamma_only 时，实际 fftnx 或 fftny 是 0.5 倍实空间格点数量（nx 或 ny）。 this->istot2ixy 从“棍子”索引到非折叠倒空间折合坐标的映射 PW_Basis::get_istot2ixy()(Link) this->ig2isz 从平面波的 processor 内索引，到其倒空间平移后 z 坐标的映射 PW_Basis::get_ig2isz_is2fftixy(Link) this->is2fftixy 每个 processor 各有一份，建立从 procesor 内“棍子”索引到其折叠后倒空间 xy 平面折合坐标的映射 PW_Basis::get_ig2isz_is2fftixy(Link) 映射表的建立是为了解决实际问题，因此需要思考从建立起来的映射表，可以获得何种信息（processor-local 和 processor-global）。 对其中两个由 rank0 processor 建立的映射表也进行了分发： void PW_Basis::distribution_method1() { .... if(poolrank == 0) { #ifdef __MPI .... this->collect_st(st_length2D, st_bottom2D, st_i, st_j, st_length); .... this->divide_sticks_1(st_i, st_j, st_length); .... this->get_istot2ixy(st_i, st_j); .... #else .... #endif } #ifdef __MPI .... MPI_Bcast(this->fftixy2ip, this->fftnxy, MPI_INT, 0, this->pool_world); MPI_Bcast(this->istot2ixy, this->nstot, MPI_INT, 0, this->pool_world); .... #endif .... } 分发后处理 void PW_Basis::setuptransform() { ModuleBase::timer::tick(this->classname, \"setuptransform\"); this->distribute_r(); this->distribute_g(); this->getstartgr(); .... void PW_Basis::getstartgr() { if(this->gamma_only) this->nmaxgr = ( this->npw > (this->nrxx+1)/2 ) ? this->npw : (this->nrxx+1)/2; else this->nmaxgr = ( this->npw > this->nrxx ) ? this->npw : this->nrxx; this->nmaxgr = (this->nz * this->nst > this->nxy * nplane) ? this->nz * this->nst : this->nxy * nplane; delete[] this->numg; this->numg = new int[poolnproc]; delete[] this->startg; this->startg = new int[poolnproc]; delete[] this->startr; this->startr = new int[poolnproc]; delete[] this->numr; this->numr = new int[poolnproc]; for (int ip = 0;ip numg[ip] = this->nst_per[poolrank] * this->numz[ip]; for (int ip = 0;ip numr[ip] = this->nst_per[ip] * this->numz[poolrank]; this->startg[0] = 0; for (int ip = 1;ip startg[ip] = this->startg[ip-1] + this->numg[ip-1]; this->startr[0] = 0; for (int ip = 1;ip startr[ip] = this->startr[ip-1] + this->numr[ip-1]; } 即 this->numg, this->numr 分别是： 从当前 processor 从实空间 z 方向格点/xy 平面到所有 processors 的倒空间 sticks 的映射数量， 以及当前 processor 从倒空间到所有 processors 所拥有 this->numz，即实空间 z 方向格点/xy 平面数量的映射数量。 this->startg 和 this->startr 则为 this->numg 和 this->numr 的 correspondence 的 starting index。 下面将要调用 PW_Basis::ft:clear() 函数，再之后将和 FFTW 以及 MPI 库进行交互，完成 FFT 操作的准备工作。但至此，所有平面波和实空间格点的分发工作已经完成。 Special topic: utilization of FFTW library in ABACUS void PW_Basis::setuptransform() { .... this->ft.clear(); if(this->xprime) this->ft.initfft(this->nx,this->ny,this->nz,this->lix,this->rix,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); else this->ft.initfft(this->nx,this->ny,this->nz,this->liy,this->riy,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); this->ft.setupFFT(); .... } 暂略 PW_Basis::collect_local_pw() 接下来以一个简单的函数来检验之前的学习效果： void PW_Basis::collect_local_pw() { if(this->npw ig_ggeq0 = -1; // change name of this variable from ig_gge0 to ig_ggeq0 delete[] this->gg; this->gg = new double[this->npw]; delete[] this->gdirect; this->gdirect = new ModuleBase::Vector3[this->npw]; delete[] this->gcar; this->gcar = new ModuleBase::Vector3[this->npw]; ModuleBase::Vector3 f; for(int ig = 0 ; ig npw ; ++ig) { int isz = this->ig2isz[ig]; int iz = isz % this->nz; int is = isz / this->nz; int ixy = this->is2fftixy[is]; int ix = ixy / this->fftny; int iy = ixy % this->fftny; if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; f.x = ix; f.y = iy; f.z = iz; this->gg[ig] = f * (this->GGT * f); this->gdirect[ig] = f; this->gcar[ig] = f * this->G; if(this->gg[ig] ig_ggeq0 = ig; } } 在这个函数里，折合索引的还原分别由 int isz = this->ig2isz[ig]; int iz = isz % this->nz; int is = isz / this->nz; 和 int ixy = this->is2fftixy[is]; int ix = ixy / this->fftny; int iy = ixy % this->fftny; 完成，负数索引的还原则由 if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; 完成。因为当前不同 prcoessor 已经具有不同数量被分发的实空间格点和倒空间格点（即平面波），因此即使每个 processor 执行上述相同的代码内容，其结果也将不相同。 ⚙ 坐标的打包和解包功能可能适合封装成为函数进行调用，或抽象更高级的数据结构，通过重载括号的方式使用。 void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->collect_local_pw(); .... PW_Basis::collect_uniqgg() void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->collect_uniqgg(); .... 这个函数的功能为单调地（递减）存储平面波的模，即对于倒空间中点所对应的平面波的能量，对于包含兼并的情况则只存储一次，分别存放在 tmpgg2 和 gg_uniq 中，而 tmpgg 则是费空间的存储方式：每个平面波都有其对应存储的模长，且一一对应。 void PW_Basis::collect_uniqgg() { if(this->npw ig_gge0 = -1; delete[] this->ig2igg; this->ig2igg = new int [this->npw]; int *sortindex = new int [this->npw]; double *tmpgg = new double [this->npw]; double *tmpgg2 = new double [this->npw]; ModuleBase::Vector3 f; for(int ig = 0 ; ig npw ; ++ig) { int isz = this->ig2isz[ig]; int iz = isz % this->nz; int is = isz / this->nz; int ixy = this->is2fftixy[is]; int ix = ixy / this->fftny; int iy = ixy % this->fftny; if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; f.x = ix; f.y = iy; f.z = iz; tmpgg[ig] = f * (this->GGT * f); if(tmpgg[ig] ig_gge0 = ig; } ModuleBase::GlobalFunc::ZEROS(sortindex, this->npw); ModuleBase::heapsort(this->npw, tmpgg, sortindex); int igg = 0; this->ig2igg[sortindex[0]] = 0; tmpgg2[0] = tmpgg[0]; double avg_gg = tmpgg2[igg]; int avg_n = 1; for (int ig = 1; ig npw; ++ig) { if (std::abs(tmpgg[ig] - tmpgg2[igg]) > 1.0e-8) { tmpgg2[igg] = avg_gg / double(avg_n); ++igg; tmpgg2[igg] = tmpgg[ig]; avg_gg = tmpgg2[igg]; avg_n = 1; } else { avg_n++; avg_gg += tmpgg[ig]; } this->ig2igg[sortindex[ig]] = igg; } tmpgg2[igg] = avg_gg / double(avg_n); this->ngg = igg + 1; delete[] this->gg_uniq; this->gg_uniq = new double [this->ngg]; for(int igg = 0 ; igg ngg ; ++igg) gg_uniq[igg] = tmpgg2[igg]; delete[] sortindex; delete[] tmpgg; delete[] tmpgg2; } 因此调用出平面波模长的方法为 this->gg_uniq[this->ig2igg[ipw]]。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 3 下篇：Introduction to ABACUS: Path to PW calculation - Part 5 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-05 10:45:42 "},"develop-path5.html":{"url":"develop-path5.html","title":"Introduction to ABACUS: Path to PW calculation - Part 5","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 5 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 5 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class 盯紧数据流：Constructor the ESolver_KS() 跟随继承关系，我们从 ESolver_FP 来到 ESolver_KS，之后我们还会进入下一层 ESolver_KS_PW。和之前一样，我们仍然需要关心从 ESolver_FP 到 ESolver_KS，多了哪些数据成员，数据成员在何时被分配内存，何时拥有具体数值，对之后理解程序的整体流程控制十分重要。 check 头文件中数据成员的声明，并且牢记父类的各成员也在当前类中存在： namespace ModuleESolver { template class ESolver_KS : public ESolver_FP { public: ....// constructor and destructor declarations omitted // present class parent class inherited // （will not re-introduce here） double scf_thr; ModulePW::PW_Basis* pw_rho; double drho; ModulePW::PW_Basis_Big* pw_big; int maxniter; elecstate::ElecState* pelec = nullptr; int niter; Charge chr; bool conv_elec; ModuleSymmetry::Symmetry symm; int out_freq_elec; psi::Psi>* psi = nullptr; psi::Psi* psid = nullptr; Structure_Factor sf; K_Vectors kv; ....// member function(s) omitted protected: hsolver::HSolver* phsol = nullptr; hamilt::Hamilt* p_hamilt = nullptr; ModulePW::PW_Basis_K* pw_wfc = nullptr; Charge_Mixing* p_chgmix = nullptr; wavefunc wf; Charge_Extra CE; std::string basisname; 从构造函数中查看哪些量被初始化： namespace ModuleESolver { template ESolver_KS::ESolver_KS() { .... scf_thr = GlobalV::SCF_THR; drho = 0.0; maxniter = GlobalV::SCF_NMAX; niter = maxniter; out_freq_elec = GlobalV::OUT_FREQ_ELEC; pw_wfc = new ModulePW::PW_Basis_K_Big(GlobalV::device_flag, GlobalV::precision_flag); ModulePW::PW_Basis_K_Big* tmp = static_cast(pw_wfc); tmp->setbxyz(INPUT.bx,INPUT.by,INPUT.bz); p_chgmix = new Charge_Mixing(); p_chgmix->set_rhopw(this->pw_rho); p_chgmix->set_mixing(INPUT.mixing_mode, INPUT.mixing_beta, INPUT.mixing_ndim, INPUT.mixing_gg0, INPUT.mixing_tau); if (std::abs(INPUT.mixing_beta + 10.0) need_auto_set(); this->wf.init_wfc = INPUT.init_wfc; this->wf.mem_saver = INPUT.mem_saver; this->wf.out_wfc_pw = INPUT.out_wfc_pw; this->wf.out_wfc_r = INPUT.out_wfc_r; } 因此当调用 ESolver_KS::ESolver_KS() 时，除了父类中各函数会被初始化外，另有 wavefunc 类 wf、Charge_Extra 类 CE 被初始化并分配内存，此外还有 hsolver::HSolver 类 phsol、hamilt::Hamilt 类 p_hamilt、ModulePW::PW_Basis_K 类 pw_wfc、Charge_Mixing 类 p_chgmix 指针被创建。在执行构造函数过程中，有 pw_wfc、p_chgmix 被分配内存，因此调用其构造函数。 wavefunc 类数据成员 在头文件中初始化值 在构造函数中初始化值 allocate out_wfc_pw out_wfc_r 0 init_wfc, mem_saver R, Rmax Charge_Extra 类数据成员 在头文件中初始化值 在构造函数中初始化值 istep 0 pot_order, rho_extr dis_old1, dis_old2, dis_now nulltpr alpha,beta ⚙ 两类均基本没有数据成员在对象建立时被赋值。然而通过上面代码块第 23-26 行可以发现，wavefunc 类 wf 的数据成员直接可以被访问，直接导入（拷贝）Input 类对象 INPUT 的数据成员，即 wavefunc 类的数据成员处于直接暴露的状态，这违反了封装理念。更好一点的做法是为每个类建立 getter 和 setter 函数，通过此两者来访问和修改成员变量，但更多的封装理念此处不再赘述。 接下来我们对 ESolver_KS() 中的其他操作以及其具体结果进行介绍。 Constructor the ModulePW::PW_Basis_K_Big() ModulePW::PW_Basis_K_Big 类的构造函数进行过一次重载，此时调用的版本为重载版本。在重载版本中，完全为继承 PW_Basis 的构造函数对应版本，但内容简单： namespace ModulePW { class PW_Basis_Big: public PW_Basis { public: .... PW_Basis_Big(std::string device_, std::string precision_) : PW_Basis(device_, precision_) {} namespace ModulePW { .... PW_Basis::PW_Basis(std::string device_, std::string precision_) : device(std::move(device_)), precision(std::move(precision_)) { classname=\"PW_Basis\"; this->ft.set_device(this->device); this->ft.set_precision(this->precision); } void FFT::set_device(std::string device_) { this->device = std::move(device_); } void FFT::set_precision(std::string precision_) { this->precision = std::move(precision_); } Constructor the Charge_Mixing() 我们按照相同路数查看 Charge_Mixing 类的构造函数： Charge_Mixing::Charge_Mixing() { rstep = 0; dstep = rstep - 1; initp = false; initb = false; } 以及其所属类的指针 p_chgmix 的相关调用操作： p_chgmix = new Charge_Mixing(); p_chgmix->set_rhopw(this->pw_rho); p_chgmix->set_mixing(INPUT.mixing_mode, INPUT.mixing_beta, INPUT.mixing_ndim, INPUT.mixing_gg0, INPUT.mixing_tau); // using bandgap to auto set mixing_beta if (std::abs(INPUT.mixing_beta + 10.0) need_auto_set(); else if (INPUT.mixing_beta > 1.0 || INPUT.mixing_beta Charge_mixing::set_rhopw() 函数的操作十分简单，即从括号中形参复制到自己的成员变量 Charge_mixing::rhopw 中，其中形参类型被指定为 ModulePW::PW_Basis*。 void Charge_Mixing::set_rhopw(ModulePW::PW_Basis* rhopw_in) { this->rhopw = rhopw_in; } void Charge_Mixing::set_mixing(const std::string &mixing_mode_in, const double &mixing_beta_in, const int &mixing_ndim_in, const double &mixing_gg0_in, const bool &mixing_tau_in) { this->mixing_mode = mixing_mode_in; this->mixing_beta = mixing_beta_in; this->mixing_ndim = mixing_ndim_in; this->mixing_gg0 = mixing_gg0_in; //mohan add 2014-09-27 this->mixing_tau = mixing_tau_in; .... } 而因为在 module_io/input.cpp 中有 INPUT.mixing 初始化为-10，因此 if 判断中的满足意味着默认值未被修改，因而调用 Charge_mixing::need_auto_set()，将 Charge_mixing::autoset 置为 true。 void Charge_Mixing::need_auto_set() { this->autoset = true; } Trigger: ESolver_KS::Init() template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { ESolver_FP::Init(inp,ucell); ucell.cal_nelec(GlobalV::nelec); XC_Functional::set_xc_type(ucell.atoms[0].ncpp.xc_func); .... this->kv.set(this->symm, GlobalV::global_kpoint_card, GlobalV::NSPIN, ucell.G, ucell.latvec); .... if(GlobalV::BASIS_TYPE==\"pw\" || GlobalV::CALCULATION==\"get_wf\") { #ifdef __MPI this->pw_wfc->initmpi(GlobalV::NPROC_IN_POOL, GlobalV::RANK_IN_POOL, POOL_WORLD); #endif this->pw_wfc->initgrids(inp.ref_cell_factor * ucell.lat0, ucell.latvec, this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz); this->pw_wfc->initparameters(false, inp.ecutwfc, this->kv.nks, this->kv.kvec_d.data()); #ifdef __MPI if(INPUT.pw_seed > 0) { MPI_Allreduce(MPI_IN_PLACE, &this->pw_wfc->ggecut, 1, MPI_DOUBLE, MPI_MAX , MPI_COMM_WORLD); } #endif this->pw_wfc->setuptransform(); for (int ik = 0; ik kv.nks; ++ik) this->kv.ngk[ik] = this->pw_wfc->npwk[ik]; this->pw_wfc->collect_local_pw(); .... } GlobalC::Pgrid.init(this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz, this->pw_rho->nplane, this->pw_rho->nrxx, pw_big->nbz, pw_big->bz); this->sf.setup_structure_factor(&GlobalC::ucell, this->pw_rho); CE.Init_CE(GlobalC::ucell.nat); } 首先调用了两函数，以 UnitCell::cal_nelec() 计算体系中总电子数，并存储在 GlobalV::nelec，以及 XC_Functional::set_xc_type() 根据输入文件中设置参数，为三个泛函相关量（XC_Functional::func_id, XC_Functional::func_type 和 XC_Functional::use_libxc）进行赋值，见 source/module_hamilt_general/module_xc/xc_funtional.cpp: line 26（Link）。 变量 数据类型 描述 XC_Functional::func_id std::vector 首先将交换泛函压入，然后是关联泛函。预先通过宏对每种泛函和整数间进行对应，见 source/module_hamilt_general/module_xc/xc_funcs.h（Link） XC_Functional::func_type int LDA: 1; GGA: 2; meta-GGA: 3; hybrid GGA: 4; hybrid meta-GGA: 5 XC_Functional::use_libxc bool 因 Symmetry::analy_sys()功能尚未完全部署，暂时跳过。 波函数 k 点采样：K_Vectors::set() 在一般的第一性原理软件中，或对建模为周期性体系（认定其中包含平移对称性的体系）而言，平移对称性决定了\\mathbf{k}是量子数之一，因此为区分态，并且计算态，k 点采样对于准确计算体系的性质尤为重要（尽量准确计算占据态），但这一 k 点所对应\\mathbf{k}需要和原本用于展开波函数的平面波基其\\mathbf{G}加以区分：\\mathbf{G}（通过 ecut 决定）只能决定当前待求波函数的精度，但还并不能决定当前体系的性质能否计算准确。回顾 Bloch 定理，在 k 点\\mathbf{k}，第 n 个能级在实空间坐标表象下的波函数为： \\psi_{\\text{n}\\mathbf{k}}(\\mathbf{r})=e^{i\\mathbf{k}\\cdot\\mathbf{r}}u_{\\text{n}\\mathbf{k}}(\\mathbf{r}) 平面波基的\\mathbf{G}出现在 Bloch 调幅函数u_{\\text{n}\\mathbf{k}}(\\mathbf{r})中： u_{\\text{n}\\mathbf{k}}(\\mathbf{r})=\\sum_{\\mathbf{G}}c_\\mathbf{G}^{(\\text{n}\\mathbf{k})}e^{i\\mathbf{G}\\cdot\\mathbf{r}}。 老生常谈，平移对称性实际上是指\\psi_{\\text{n}\\mathbf{k}}(\\mathbf{r}+n\\mathbf{a})=\\psi_{\\text{n}\\mathbf{k}}(\\mathbf{r})，则\\psi_{\\text{n}\\mathbf{k}}(\\mathbf{r}+n\\mathbf{a})=e^{i\\mathbf{k}\\cdot(\\mathbf{r}+n\\mathbf{a})}u_{\\text{n}\\mathbf{k}}(\\mathbf{r}+n\\mathbf{a})。认定 Bloch 函数必有该性质，则实际上需要满足： 2N\\pi=n(\\mathbf{k}\\cdot\\mathbf{a}), 一维：2N\\pi/n|\\mathbf{a}|=|\\mathbf{k}| 因此不同 k 点的考虑实际是在考虑体系的不同平移对称性。当 k 点采样无穷多时，即等同于考虑体系（波函数）的所有平移对称性。 void K_Vectors::set(const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { .... this->nspin = nspin_in; if(this->nspin==4) this->nspin = 1;//zhengdy-soc .... bool read_succesfully = this->read_kpoints(k_file_name); #ifdef __MPI Parallel_Common::bcast_bool(read_succesfully); #endif if(!read_succesfully) {....} std::string skpt1=\"\"; std::string skpt2=\"\"; if(!berryphase::berry_phase_flag && ModuleSymmetry::Symmetry::symm_flag != -1) { bool match = true; this->ibz_kpoint(symm, ModuleSymmetry::Symmetry::symm_flag, skpt1, GlobalC::ucell, match); #ifdef __MPI Parallel_Common::bcast_bool(match); #endif if (!match) {....} if (ModuleSymmetry::Symmetry::symm_flag || is_mp) { this->update_use_ibz(); this->nks = this->nkstot = this->nkstot_ibz; } } this->set_both_kvec(reciprocal_vec, latvec, skpt2); if(GlobalV::MY_RANK==0) {....} int deg = 0; if(GlobalV::NSPIN == 1) deg = 2; else if(GlobalV::NSPIN == 2||GlobalV::NSPIN==4) deg = 1; else ModuleBase::WARNING_QUIT(\"K_Vectors::set\", \"Only available for nspin = 1 or 2 or 4\"); this->normalize_wk(deg); GlobalC::Pkpoints.kinfo(nkstot); #ifdef __MPI this->mpi_k(); #endif this->set_kup_and_kdw(); this->print_klists(GlobalV::ofs_running); } k 点生成：K_Vectors::read_kpoints()及变量赋值回溯复习 来到 K_Vectors::read_kpoints() 函数，对于前三条件判断，第一则为让非 rank0 processors 退出该函数， bool K_Vectors::read_kpoints(const std::string &fn) { ModuleBase::TITLE(\"K_Vectors\", \"read_kpoints\"); if (GlobalV::MY_RANK != 0) return 1; .... if(GlobalV::GAMMA_ONLY_LOCAL) { .... } else if (GlobalV::KSPACING[0] > 0.0) { .... 第二和三涉及 GlobalV 中相关参数，按照 Introduction to ABACUS: Path to PW calculation - Part 1 相同方法进行变量赋值回溯，举例对于 GlobalV::GAMMA_ONLY_LOCAL: 首先鼠标右键拉取菜单，选择“查找所有引用”， 仔细检查侧边栏 Vscode 给出引用查找结果 基于我们当前对 ABACUS 工作流的了解，单击左侧 input_conv.cpp 文件后，跳转到 input_conv.cpp 相关行（line 328）： 证明此参数可能也在 Input 类方法中被读取。切换到文件浏览器侧边栏后直接打开 input.cpp，查找 \"gamma_only_local\" 相关内容： 寻得有效赋值操作： 寻找何时有 “gamma_only == 1” 条件： 然而，并非只要将 gamma_only 关键词在 INPUT 文件中置为 true 即可，因为在 line 2350，实际上 pw 基不支持该参数，因此对于 esolver_type == esolver_ks_pw 的情况，gamma_only 为 false 而 gamma_only_local 也从未改变其默认值 false。 类似地我们回溯 GlobalV::kspacing[3]，发现在 input.cpp 中有： Full List of INPUT Keywords ‒ ABACUS documentation 图 1. 善用Ctrl+F 即如果指定了一个值，则 kspacing[1] 和 kspacing[2] 拥有和 kspacing[0] 相同值，若定义三个值，则三个值各不相同，通过 Input::read_kspacing() 实现。定义值后，将覆盖写入 KPT 文件，因此在之后的读取过程中读入的结果其实是刚刚写的结果。 从 examples 文件夹中，可以知道 KPT 文件可能具有的格式，以及在当前函数中会被读取到何变量中。 examples/scf/pw_Si2/INPUT 和 KPT: INPUT_PARAMETERS #Parameters (General) pseudo_dir ../../../tests/PP_ORB symmetry 1 #Parameters (Accuracy) basis_type pw ecutwfc 60 scf_thr 1e-8 scf_nmax 100 K_POINTS 0 Gamma 4 4 4 0 0 0 examples/band/pw_Al/INPUT1 和 KPT: INPUT_PARAMETERS #Parameters (General) pseudo_dir ../../../tests/PP_ORB calculation scf ntype 1 symmetry 0 #Parameters (Methos) basis_type pw ecutwfc 50 scf_thr 1.0e-8 // about iteration scf_nmax 100 smearing_method gauss smearing_sigma 0.01 #Parameters (File) out_chg 1 K_POINTS 0 Gamma 4 4 4 0 0 0 examples/band/pw_Al/INPUT2 和 KLINES（❗ 注意，此时 kpoint_file 参数被赋予 KLINES）: INPUT_PARAMETERS #Parameters (General) kpoint_file KLINES pseudo_dir ../../../tests/PP_ORB calculation nscf ntype 1 symmetry 0 #Parameters (Methos) ecutwfc 50 basis_type pw pw_diag_thr 1e-10 pw_diag_nmax 100 #Parameters (Accuracy) smearing_method gauss smearing_sigma 0.01 #Parameters (File) init_chg file out_band 1 K_POINTS 8 Line 0.0 0.0 0.0 20 0.5 -0.5 0.5 20 0.0 0.0 0.5 20 0.0 0.0 0.0 20 0.25 0.25 0.25 20 0.5 -0.5 0.5 1 0.25 0.25 0.25 20 0.0 0.0 0.5 1 相应地从 klist.cpp line 230（Link）开始，是读取 KPT 文件的相关行。在这里，我们并不逐行解读可读性强，容易理解的代码，而是将可能的情况汇总于下表： K_Vector 类中数据成员 KPT 文件中位置（行数） 取值 k_nkstot 2 0 >0, Depending on exact data kword 3 \"Gamma\" \"Monkhorst-Pack\" \"Cartesian\" \"Direct\" \"Line_Cartesian\" \"Line_Direct\"/“Line” is_mp true true false(default) false(default) false(default) false(default) k_type 0 1 nmp 4 Depending on exact data Depending on exact data koffset 4 Depending on exact data Depending on exact data k 点手动指定模式：[i]: 第 i-1 个 k 点的索引，其中 i 的取值范围由 nkstot 决定，在 KPT 文件中则从第 2 行读取。 kvec_c[i].x/y/z ≥4 Depending on exact data Depending on exact data kvec_d[i].x/y/z ≥4 K_Vectors::Monkhorst_Pack() generated K_Vectors::Monkhorst_Pack() generated Depending on exact data Depending on exact data wk[i] ≥4 K_Vectors::Monkhorst_Pack()generated K_Vectors::Monkhorst_Pack()generated Depending on exact data Depending on exact data 1.0 1.0 kc_done false(defalult) false(default) true true kd_done true true true true nkstot nmp[0]*nmp[1]*nmp[2] nmp[0]*nmp[1]*nmp[2] Depending on exact data Depending on exact data Depending on exact data Depending on exact data nk nkstot nkstot nkstot nkstot nkstot nkstot 备注 斜体变量实际为被 K_Vectors::Monkhorst_Pack() 函数赋值 \"Monkhorst-Pack\" 和 \"Gamma\" 方式对 k 空间采样： 图 2. klist.cpp line 486: K_Vectors::Monkhorst_Pack_formula(), k_type = 0 and 1 以这两种采样方式所给定的在 this->kvec_d 数组中存储顺序： 图 3. klist.cpp line 520: const int i = mpnx * mpny * (z - 1) + mpnx * (y - 1) + (x - 1) k 点归约、后处理与并行同步 归约：K_Vectors::ibz_kpoint() 在按照一定方法（Monkhorst-Pack、直接给定 k 点、Kpath）采样 k 点之后，需要根据对称性减少 k 点数量，使得计算量减少。对称操作可以使得 k vector 发生置换，或使得 k vector 不变。 void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... ModuleBase::Vector3 gb1(ucell.G.e11, ucell.G.e12, ucell.G.e13); ModuleBase::Vector3 gb2(ucell.G.e21, ucell.G.e22, ucell.G.e23); ModuleBase::Vector3 gb3(ucell.G.e31, ucell.G.e32, ucell.G.e33); ModuleBase::Vector3 gk1(gb1.x / nmp[0], gb1.y / nmp[0], gb1.z / nmp[0]); ModuleBase::Vector3 gk2(gb2.x / nmp[1], gb2.y / nmp[1], gb2.z / nmp[1]); ModuleBase::Vector3 gk3(gb3.x / nmp[2], gb3.y / nmp[2], gb3.z / nmp[2]); ModuleBase::Matrix3 gk(gk1.x, gk1.y, gk1.z, gk2.x, gk2.y, gk2.z, gk3.x, gk3.y, gk3.z); .... bool include_inv = false; std::vector kgmatrix(48 * 2); ModuleBase::Matrix3 inv(-1, 0, 0, 0, -1, 0, 0, 0, -1); ModuleBase::Matrix3 ind(1, 0, 0, 0, 1, 0, 0, 0, 1); .... int nrotkm; if (use_symm) {....} else if (is_mp) { nrotkm = 2; kgmatrix[0] = ind; kgmatrix[1] = inv; } ModuleBase::Matrix3* kkmatrix = new ModuleBase::Matrix3 [nrotkm]; symm.gmatrix_convert(kgmatrix.data(), kkmatrix, nrotkm, ucell.G, gk); .... void Symmetry::gmatrix_convert(const ModuleBase::Matrix3* sa, ModuleBase::Matrix3* sb, const int n, const ModuleBase::Matrix3 &a, const ModuleBase::Matrix3 &b)const { ModuleBase::Matrix3 ai = a.Inverse(); ModuleBase::Matrix3 bi = b.Inverse(); for (int i=0;i Symmetry::gmatrix_convert() 函数为对称操作在 3 维空间的矩阵表象进行变换，该函数可以写为如下形式： BA^{-1}O_iAB^{-1}=(AB^{-1})^{-1}O_i(AB^{-1}), i=1,2 O_1=\\begin{pmatrix} 1 &0 &0 \\\\ 0 &1 &0 \\\\ 0 &0 &1 \\end{pmatrix}, O_2=\\begin{pmatrix} -1 &0 &0 \\\\ 0 &-1 &0 \\\\ 0 &0 &-1 \\end{pmatrix} A=\\frac{\\text{lat}_0}{2\\pi}\\begin{pmatrix} b_{11}&b_{12}&b_{13}\\\\ b_{21}&b_{22}&b_{23}\\\\ b_{31}&b_{32}&b_{33} \\end{pmatrix}, B=\\frac{\\text{lat}_0}{2\\pi}\\begin{pmatrix} b_{11}/\\text{nk}_1&b_{12}/\\text{nk}_1&b_{13}/\\text{nk}_1\\\\ b_{21}/\\text{nk}_2&b_{22}/\\text{nk}_2&b_{23}/\\text{nk}_2\\\\ b_{31}/\\text{nk}_3&b_{32}/\\text{nk}_3&b_{33}/\\text{nk}_3 \\end{pmatrix}, AB^{-1}=\\begin{pmatrix} \\text{nk}_1&0&0\\\\ 0&\\text{nk}_2&0\\\\ 0&0&\\text{nk}_3\\\\ \\end{pmatrix} ，where b_{ij} is the j-th component of i-th canonically defined reciprocal vector. In principle \\mathbf{a}_i\\cdot\\mathbf{b}_j=2\\pi\\delta_{ij}, but the G (ucell.G) defined here is latvec.inverse().transpose(), where every element is rescaled by factor 1/lat0, therefore the multiplication between G and latvec cannot obtain 2\\pi but 1. Actually matrix A can relate to B directly via: TA=B, where T matrix is, \\begin{pmatrix} 1/\\text{nk}_1&0&0\\\\ 0&1/\\text{nk}_2&0\\\\ 0&0&1/\\text{nk}_3\\\\ \\end{pmatrix} if (!use_sym), kkmatrix[0]= (AB^{-1})^{-1}O_1(AB^{-1})= \\begin{pmatrix} 1/\\text{nk}_1&0&0\\\\ 0&1/\\text{nk}_2&0\\\\ 0&0&1/\\text{nk}_3\\\\ \\end{pmatrix}\\begin{pmatrix} 1 &0 &0 \\\\ 0 &1 &0 \\\\ 0 &0 &1 \\end{pmatrix}\\begin{pmatrix} \\text{nk}_1&0&0\\\\ 0&\\text{nk}_2&0\\\\ 0&0&\\text{nk}_3\\\\ \\end{pmatrix}\\\\ =\\begin{pmatrix} 1 &0 &0 \\\\ 0 &1 &0 \\\\ 0 &0 &1 \\end{pmatrix} if (!use_sym), kkmatrix[1]= (AB^{-1})^{-1}O_2(AB^{-1})= \\begin{pmatrix} 1/\\text{nk}_1&0&0\\\\ 0&1/\\text{nk}_2&0\\\\ 0&0&1/\\text{nk}_3\\\\ \\end{pmatrix}\\begin{pmatrix} -1 &0 &0 \\\\ 0 &-1 &0 \\\\ 0 &0 &-1 \\end{pmatrix}\\begin{pmatrix} \\text{nk}_1&0&0\\\\ 0&\\text{nk}_2&0\\\\ 0&0&\\text{nk}_3\\\\ \\end{pmatrix}\\\\ =\\begin{pmatrix} -1 &0 &0 \\\\ 0 &-1 &0 \\\\ 0 &0 &-1 \\end{pmatrix} 即实际上对于 is_mp 但 !use_symm 的情况，kgmatrix 和 kkmatrix 中内容相同。在当前情况，ucell.G=A，gk=B， ucell.G*gk.Inverse()=AB^{-1}, =A(TA)^{-1}=AA^{-1}T^{-1}=\\begin{pmatrix} \\text{nk}_1&0&0\\\\ 0&\\text{nk}_2&0\\\\ 0&0&\\text{nk}_3\\\\ \\end{pmatrix} gk*ucell.G.Inverse()=BA^{-1}, =TAA^{-1}=\\begin{pmatrix} 1/\\text{nk}_1&0&0\\\\ 0&1/\\text{nk}_2&0\\\\ 0&0&1/\\text{nk}_3\\\\ \\end{pmatrix} 对于当前所考虑的最简单情况，!use_sym，使得原本采样 k 点坐标（或矢量）由 reciprocal space（kvec_d: k vector in Direct coordinate）变化到 k-lattice space（kvec_d_k: k vector in Direct coordinate transformed in k lattice space）： void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... for (int i=0;i 图 4. 1-dimensional example 图 5. 2-dimensional example k 点归约通过 C++11 开始支持的匿名函数实现： void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... /// @brief PBC, wrap kvec_d into [-0.5, 0.5) auto restrict_kpt = [&symm](ModuleBase::Vector3 &kvec){ // in (-0.5, 0.5] kvec.x = fmod(kvec.x + 100.5-0.5*symm.epsilon, 1)-0.5+0.5*symm.epsilon; kvec.y = fmod(kvec.y + 100.5-0.5*symm.epsilon, 1)-0.5+0.5*symm.epsilon; kvec.z = fmod(kvec.z + 100.5-0.5*symm.epsilon, 1)-0.5+0.5*symm.epsilon; // in [0, 1) // kvec.x = fmod(kvec.x + 100 + symm.epsilon, 1) - symm.epsilon; // kvec.y = fmod(kvec.y + 100 + symm.epsilon, 1) - symm.epsilon; // kvec.z = fmod(kvec.z + 100 + symm.epsilon, 1) - symm.epsilon; if(std::abs(kvec.x) 之后遍历当前体系所具有的所有对称操作，记录新的 k vector（记为 kvec_rot_k）。可以预见，不管是在 k-lattice space 还是 reciprocal space，对称操作应当一致，即 k-lattice space vector 经对称操作后转换回到 reciprocal space 后，应当与直接在 reciprocal space 的 k vector 经历对称操作后结果（kvec_rot）严格相等： void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... for (int i = 0; i 之后匹配已经记录的 kvec_d（在变量 kvec_d_ibz 中，std::vector<> 容器），如果是新的则记录，如果是旧的则提高 k 点权重，用于后续计算需要 k 点平均的物理量。k 点归约部分的程序框图大致如下： 经过 k 点归约，下列变量数据成员的值被改变： 修改变量 意义 this->nkstot_ibz i:irreducible，即当前不可约布里渊区中 k 点数量，小于等于 this->nkstot this->kvec_d_ibz Direct 坐标下的 k 点坐标（归约后） this->wk_ibz 归约后 k 点坐标权重 this->ibz2bz 索引映射，从归约后 k 点索引到归约前。归约后存储在 this->kvec_d_ibz，而归约前存储在 this->kvec_d，可以通过 this->kvec_d[ibz2bz[index1]] 访问到归约前，内容应当相同，也可直接访问到 Cartesian：this->kvec_c[ibz2bz[index1]] 归约前，各 k 点权重均为\\frac{1}{\\text{nkstot}}，归约后则各不可约 k 点权重值需乘简并度： void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... for (int k=0; knkstot_ibz; ++k) { if ( symm.equal(kvec_rot.x, this->kvec_d_ibz[k].x) && symm.equal(kvec_rot.y, this->kvec_d_ibz[k].y) && symm.equal(kvec_rot.z, this->kvec_d_ibz[k].z)) { already_exist = true; this->wk_ibz[k] += weight; exist_number = k; break; } } 该函数的具体实现请自主阅读（Link）。 后处理：K_Vectors::update_use_ibz() 然而到达上层函数 K_Vectors::set(): line 105 后，以下量被更新： 被更新变量 具体值 this->nkstot this->nkstot_ibz this->kvec_d this->kvec_d_ibz this->wk this->wk_ibz this->kd_done true this->kc_done false ⚙ 如此一来 this->*_ibz 不应当为成员变量，而是应该在更新左列各量后销毁。 void K_Vectors::update_use_ibz( void ) { if (GlobalV::MY_RANK!=0) return; ModuleBase::TITLE(\"K_Vectors\",\"update_use_ibz\"); assert( nkstot_ibz > 0 ); this->nkstot = this->nkstot_ibz; ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running,\"nkstot now\",nkstot); this->kvec_d.resize(this->nkstot * nspin); for (int i = 0; i nkstot; ++i) { this->kvec_d[i] = this->kvec_d_ibz[i]; this->wk[i] = this->wk_ibz[i]; } this->kd_done = true; this->kc_done = false; return; } 可见该任务仍然只分配给 rank0 processor 去处理（之后在 K_Vectors::mpi_k() 函数进行广播）。之后同步 this->kvec_c 和 this->kvec_d。❗ 对于 kvec_d 已知而 kvec_d 未知的情况，对其进行了数值噪声的简单处理。而对于 kvec_c 已知而 kvec_d 为止的情况则并没有处理： void K_Vectors::set(const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { .... this->set_both_kvec(reciprocal_vec, latvec, skpt2); .... int deg = 0; if(GlobalV::NSPIN == 1) deg = 2; else if(GlobalV::NSPIN == 2||GlobalV::NSPIN==4) deg = 1; else .... .... void K_Vectors::set_both_kvec(const ModuleBase::Matrix3 &G, const ModuleBase::Matrix3 &R,std::string& skpt) { .... if (!kc_done && kd_done) { for (int i = 0;i 而对于更一般的，科学计算软件编写过程中需要注意的各种数值噪声、精度损失问题，见（文档缺失）。 分发与并行同步：K_Vectors::mpi_k() 生成、归约并进行过简单的 k 点后处理后，接下来对 k 点进行分发（记住 k 点的 MPI 并行在平面波基矢量下是比平面波并行和能带数并行更有效的并行方式，因为每个 k 点的 Kohn-Sham 方程求解基本都是独立的，所以并行效率较高）。 void K_Vectors::set(const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { .... this->normalize_wk(deg); GlobalC::Pkpoints.kinfo(nkstot); #ifdef __MPI this->mpi_k(); #endif 在调用 GlobalC::Pkpoints.kinfo(nkstot) 及 K_Vectors::mpi_k() 函数，以对当前已经读取和建立的相关数据成员在 processors 间进行广播之前，还经过了 this->wk 的重新归一化过程（函数 K_Vectors::normalize_wk()），由于只涉及具体数值而不涉及分发，因此将在下一节介绍。首先只关注分发。如前所述，由于 Parallel_Kpoints 类对象 PKpoints 是全局变量，因此可以直接调用其函数 Parallel_Kpoints::kinfo()。 void Parallel_Kpoints::kinfo(int &nkstot) { #ifdef __MPI Parallel_Common::bcast_int(nkstot); this->get_nks_pool(nkstot); this->get_startk_pool(nkstot); this->get_whichpool(nkstot); #endif return; } Parallel_Kpoints::kinfo() 函数完成三步骤的处理（由于已经完成过平面波的分发代码阅读，此处代码比较简单，故略过。Link）： （Parallel_Kpoints::get_nks_pool()）计算每个 processor/pool 所承担的 k 点数量。让每个 processor 都具有一份 nkstot 的拷贝，之后调用 Parallel_Kpoints::get_nks_pool() 进行计算。和平面波类似地，只不过此处 k point 并行方式为通过用户指定 KPAR 参数，之后以均分为基本原则，但对前 remain 个 processors 多分一个 k 点，即“getnks（of each）pool()”，分得 k 点数量记录在 Parallel_Kpoints::nks_pool 数组中，其中索引 runs over GlobalV::KPAR。 （Parallel_Kpoints::get_startk_pool()）计算每个 processor 对 k 点进行索引的连续编号，之后存储在 Parallel_Kpoints::startk_pool 中，索引仍然 runs over GlobalV::KPAR。 （Parallel_Kpoints::get_whichpool()）whichpool 是 Parallel_Kpoints 类内一个数据成员，其索引 runs over 所有 k 点。this->whichpool 提供了从 k 点可以找到对应 processor 的功能。 然后来到 K_Vectors::mpi_k() 函数。 #ifdef __MPI void K_Vectors::mpi_k(void) { .... Parallel_Common::bcast_bool(kc_done); Parallel_Common::bcast_bool(kd_done); Parallel_Common::bcast_int(nspin); Parallel_Common::bcast_int(nkstot); Parallel_Common::bcast_int(nmp, 3); Parallel_Common::bcast_double(koffset, 3); this->nks = GlobalC::Pkpoints.nks_pool[GlobalV::MY_POOL]; int nks_minimum = this->nks; Parallel_Reduce::gather_min_int_all( nks_minimum ); .... std::vector isk_aux(nkstot); std::vector wk_aux(nkstot); std::vector kvec_c_aux(nkstot*3); std::vector kvec_d_aux(nkstot*3); if (GlobalV::MY_RANK == 0) { for (int ik = 0;ik renew(this->nks * this->nspin); int k_index = 0; for (int i = 0;i 该函数第 12 行为每个 processor 分配了一定数量的 k 点，❗ 注意，此时每个 processor 的 K_Vectors::nks 的数量已经不同。之后在第 41 行，已经按照 this->nks*this->nspin 大小 resize 数组，而非原本的 this->nkstot*this->nspin。K_Vectors::mpi_k() 函数运行结束时，各 processor 已经拥有数量和内容不相同的 this->isk, this->wk, this->kvec_d 以及 this->kvec_c。即分配的 processor-特征变量是直接的 k 点坐标。 Unrestricted Kohn-Sham (UKS) case 贯穿刚刚的过程我们默认了只关心 RKS，即 Restricted Kohn-Sham scheme，对于非限制性情况（即不限制两自旋 channel 必须具有相同空间轨道）却丝毫未提及，仅在 K_Vectors::set() 函数的一开始见过对于 noncolinear 情况，设置 nspin 由 4 到 1。特别地，对于更加一般的情况，nspin=2 是最基本和常见的 scheme。 在归一化 this->wk 的过程中，对于不同数量的 spin-channel 已经具有不同的策略： void K_Vectors::set( const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { .... int deg = 0; if(GlobalV::NSPIN == 1) deg = 2; } else if(GlobalV::NSPIN == 2||GlobalV::NSPIN==4) deg = 1; .... this->normalize_wk(deg); void K_Vectors::normalize_wk(const int &degspin) { if(GlobalV::MY_RANK!=0) return; double sum = 0.0; for (int ik = 0;ik wk[ik]; .... for (int ik = 0;ik wk[ik] /= sum; for (int ik = 0;ik wk[ik] *= degspin; } 在一开始对 this->kvec_c、this->kvec_d、this->wk 等量就进行过 nspin 相关的内存空间分配： void K_Vectors::set(const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { //K_Vectors::set(): line 69 this->nspin = nspin_in; .... if(this->nspin==4) { this->nspin = 1;//zhengdy-soc } 导入 nspin 到 this->nspin 之后，在 K_Vectors::read_kpoints() 函数中对 this->kvec_c, this->kvec_d, this->wk, this->isk, this->ngk 共四个 std::vector> 类数据成员调用 std::vector::resize() 函数。而在先前的 k 点坐标导入中，无论是哪种方式，均只存储在第一个 spin channel 中，即前 nkstot 或前 nkstot_ibz 个元素中，直到 K_Vectors::set_kup_and_kdw() 函数，才对第二个 spin channel 进行设置（简单对第一个 spin channel 的 k vectors 进行复制）。 void K_Vectors::set_kup_and_kdw(void) { switch (nspin) { case 1: for (int ik = 0; ik isk[ik] = 0; break; case 2: for (int ik = 0; ik kvec_c[ik+nks] = kvec_c[ik]; this->kvec_d[ik+nks] = kvec_d[ik]; this->wk[ik+nks] = wk[ik]; this->isk[ik] = 0; this->isk[ik+nks] = 1; } this->nks *= 2; this->nkstot *= 2; break; case 4: for (int ik = 0; ik isk[ik] = 0; break; } } 发现实际上对于 nspin=2 的情况，this->kvec_c, kvec_d, wk 三个数据均 alpba 和 beta spin-channel 内容相同，但靠 this->isk 来区分是哪种自旋。⚙ 但其实已经不存在 nspin=4 的情况，因为在 K_Vectors::set() 中，nspin=1 和 nspin=4 效果相同。 跳过 Print_Info::setup_parameters() 的信息输出，下一篇内容将直接到平面波基波函数的初始化。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 4 下篇：Introduction to ABACUS: Path to PW calculation - Summary 1 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-04 23:18:07 "},"develop-sm1.html":{"url":"develop-sm1.html","title":"Introduction to ABACUS: Path to PW calculation - Summary 1","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Summary 1 作者：黄一珂，邮箱：huangyk@aisi.ac.cn；金祖鑫，邮箱：jinzx@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Summary 1 &#x1F3EE;写在前面 经过 Introduction to ABACUS: Path to PW calculation 的 Part1 到 5，我们已经阅读过上百行程序。在继续之前，有必要将已经解读过的内容再次就重点进行回顾，并凝练和一定程度的抽象。牢记本系列内容组织的两原则： 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 主题 1：dataflow 1. 全局变量 不仅在上篇（Part 5）的最后，在 k 点分发时我们看到了在 GlobalC 中声明为 extern 的 Parallel_Kpoints 类对象 Pkpoints，在很多地方会被直接调用的 UnitCell 类对象 ucell，以及实际上最一开始看到的 Input 类对象 INPUT，也被声明为 extern。 extern 标识变量的好处(1)是跨文件/跨模块可用，以至于可以尽量缩减每个函数的形参表体积，(2)维持变量的唯一性，若又有其他变量具有相同名字，则编译阶段无法通过。但缺点是 extern 变量可能被修改，修改后则所有用到该 extern 变量的地方均受影响。另外 extern 的使用不当可能会(1)破坏封装性，为函数、变量、类、模块带来深度耦合，为之后的开发工作带来困难，(2)带来异常大的程序运行内存开销——因为有些变量确实可以具有短于整个程序的生命周期。 另一方面，如果有 extern 变量的生命周期和整个程序相同，可能给开发者带来困难：判断其何时何阶段具有何值就更有难度。 2. 输入文件读取 综合前 5 篇介绍的内容，结合 ABACUS workflow 的赋值顺序，将有关的全局变量总结如下： 主题 2：分发存储 1. 格点分发 在 Part 4，我们解读过 ABACUS 关于实空间格点与倒空间格点的分发策略。我们需要重新确定所分发的产物是什么。 实际上，在实空间进行积分的量基本都和电荷密度\\rho有关，因此格点数量实际通过 ecutrho 来控制。同时考虑到 FFT 的维数问题，因此基本要求是实空间和倒空间格点数目完全一致（除去 gamma_only 情况），即 this->fftnx = this->nx; this->fftny = this->ny; this->fftnz = this->nz; 1.1 实空间格点（link） 实空间格点的分发策略分两步： xyz 三维实空间沿 z 轴切片 切片按照先按 processors 均分，若有余则再按顺序分配 实空间格点划分后在 PW_Basis 类中，如下成员变量被赋值： PW_Basis 类内数据成员 变量意义 this->numz 列表，每个 processor 所分得 xy 平面数量 this->nplane 当前 processor 所分得 xy 平面数量 this->startz 列表，每个 processor 分得 xy 平面后，所具有平面沿 z 方向的起始索引 this->startz_current 当前 processor 分得 xy 平面后，所具有平面沿 z 方向的起始索引 this->nrxx 当前 processor 分得实空间格点数量 因此实空间的格点分发对于每个 processor 来说，能够特征识别的仅仅是 this->nplane 和 this->startz_current，主要为以上两量具有特征，且真正进行运算时，可以根据 this->startz_current 来分配数据（作为结果地，this->nrxx 是 processor 具有的实空间格点数）。 可以预想，对于三维空间的数据，可以以 this->startz_current 为依据分配具有数据的格点给不同 processor，也可使用一个 processor，访问 this->startz 数组来实现三维空间格点数据在 processor 间的分发。 1.2 倒空间格点（link） 倒空间的格点分发策略分两步： 首先在 ecutrho 划定倒空间球壳（我们约定，以后简称“ecutrho/ecutwfc 球壳”）内沿 z 方向划分出不同数量的“棍子”，即每根“棍子”包含一定数量的相同(x,y)而不同 z 的倒空间格点 将“棍子”长度按照降序排列后，按照“当前所有 processors 中具有最小‘棍子’累计高度的，优先分配”为原则进行分发 倒空间格点划分后在 PW_Basis 类中，如下成员变量被赋值： PW_Basis 类内数据成员 变量意义 this->startnsz_per 每个包含“棍子”的 processor 其第一个 z-axis grid point 的编号，从 0 开始，跨 processor。 this->npw 当前 processor 分得平面波数量（亦即倒空间格点数量） this->npw_per 列表，每个 processor 分得平面波数量（亦即倒空间格点数量） this->nst 当前 processor 分得“棍子”数量 this->nst_per 列表，每个 processor 分得“棍子”数量 this->nstnz this->nstnz = this->nst * this->nz this->npwtot 平面波总数 this->fftixy2ip 从“棍子”translated (x,y)-pair 到 processor index 的映射 this->istot2ixy 从“棍子”索引到非折叠倒空间折合坐标的映射 this->ig2isz 从平面波的 processor 内索引，到其倒空间平移后 z 坐标的映射 this->is2fftixy 每个 processor 各有一份，建立从 procesor 内“棍子”索引到其折叠后倒空间 xy 平面折合坐标的映射 this->numg 列表，从当前 processor 从实空间 z 方向格点/xy 平面到所有 processors 的倒空间 sticks 的映射数量 this->numr 列表，当前 processor 从倒空间到所有 processors 所拥有 this->numz，即实空间 z 方向格点/xy 平面数量的映射数量 this->startg 列表，this->numg 的从当前 processor 到所有 processor 的映射的起始索引 this->startr 列表，this->numr 的从当前 processor 到所有 processor 的映射的起始索引 this->ig2igg 从归约前平面波索引到归约后模长列表的索引的映射 this->gg_uniq 列表，归约后平面波数量 由于倒空间格点的分发比较复杂，因此各个 processor 分得的格点，需要从 ecutrho 球壳中格点到 processor 进行 mapping，也需要方便地从 processor 中格点方便地知道其所对应（x,y,z）。 举例定义分发后的某倒空间格点为（ip, is, iz），其中 ip 为 index_processor，is 为 index_stick_processor，即在当前 processor 中“棍子”的索引，iz 为 index_z_stick，即在当前“棍子”中格点的索引（实际等价于 z 坐标的索引），则（&#x1F600; 以下建立两坐标系的双向 1-1 映射过程可以出成思考题）： （ip, is, iz）→（x, y, z）：ip 人为给定、this->is2fftixy 确定从（ip, is）到（x, y）映射，iz 则实际上可以直接换算——因为 ecutrho 球壳关于 z=0 平面上下对称。 （x, y, z）→（ip, is, iz）：this->fftixy2ip 确定 ip，在 ip 中得到 this->nst，再访问当前 processor 的 this->is2fftixy，核对（x, y），得到 is，然后转换 z 到 iz。 2. k 点分发（link） k 点的分发策略分三步： 按照用户给定方式生成 k 点：Gamma、Monkhorst-Pack、给定 k 点、k path 通过确定的对称性，对所生成的 k 点进行对称变换，对 k 点数量进行归约 k 点先按 processor 均分，若有余则再按顺序分配 k 点分发后在 K_Vectors 类中，主要有如下成员变量被赋值： PW_Basis 类内数据成员 变量意义 this->kvec_c 列表，当前 processor 分得 k 点的 Cartesian 坐标 this->kvec_d 列表，当前 processor 分得 k 点的 Direct 坐标 this->wk 列表，当前 processor 分得 k 点的权重 this->isk 列表，当前 processor 分得 k 点的 spin channel, 0: alpha, 1: beta this->nks 当前 processor 分得 k 点的数量 this->nkstot k 点总数 因此 k 点分发直接获得 k 点坐标和对应权重，以及 spin channel 的标识。 开发初步尝试：doxygen 注释和单元测试 1. 程序注释规范 1.1 现状介绍 诚然这个系列的文档是为让 ABACUS 新晋开发者更快熟悉 ABACUS 代码，清楚 ABACUS 中各个变量和功能可能声明、初始化和实现的位置，以及变量间的从属关系，但文档的发行速度和更新速度远慢于 ABACUS 新版本的开发。因为这一点，ABACUS 开发团队同时希望 ABACUS 的信息 self-contained，即在每个程序文件中都有足够详尽的关于当前文件内容的注释，以及其他可能需要的信息。 然而由于 ABACUS 的历史较长，ABACUS 的开发者也所属组织和单位众多，因此除了代码风格多样外，注释风格也十分多样。格式和缩写各异的注释使得代码整洁程度下降，因此代码主体的可读性降低，并且注释的可读性也难以保证。 目前在 ABACUS 中存在的代码注释风格按添加注释的位置分类主要包括两种：随行注释和 Section 注释。 然而，在头文件中添加 section 型注释可能会导致在 vscode 中讲注释显示在临近的第一个变量/函数上（如上图，会显示在 NPROC 上），而其他各变量和函数均保持未注释状态，此时在其他代码位置鼠标悬停时不会有注释显式。 1.2 基本注释原则 1.2.1 Doxygen 注释 ABACUS 现在推进 doxygen 格式的注释。Doxygen 注释在 vscode 中可以使用插件进行模板插入： Doxygen 函数注释样例： 1.2.2 若干注意事项 对于某个类中数据成员和成员函数的注释，请添加在相应的头文件中，避免在源文件中添加此类注释。对于程序代码的注释则没有要求，只需保证清晰明了。 （对于头文件中添加的函数注释）特别对于一些 void 类型函数，形参表中变量既有输入也有输出的，在 @param 字段注明“[in]”或者\"[out]\"作为标识 @brief 字段尽量保证描述清晰且语言简洁，更多的内容可以添加在 @details 字段 注意事项等可以添加在 @attention 字段 1.3 为了更平滑的开发和维护：扩展注释内容 1.3.1 模块封装化注释 封装、继承和多态是包括 C++ 在内的高级编程语言的核心理念。良好的封装有助于保护程序运行的稳定性，同时有利于开发工作的开展。然而，封装不仅仅是局部而言对某个类的封装，更应该将封装的理念应用于整体的程序设计。程序整体组织层面的封装，有利于在程序因一定需求需大幅改变结构时，能够稳定运行而不出错，同时能够实现各部分的独立、高效开发。 现阶段 ABACUS 缺乏模块层级的注释，即对于某个模块（module）究竟需要传入哪些参数/物理量/性质，传出哪些参数/物理量/性质，是尚未总结和落实到文档中的方面。 1.3.2 上游-下游函数注释 另一方面，除去 vscode 自身所包含的“查找所有引用”/“转到引用”的功能外，鼓励为函数添加注释时，添加 @note 字段，注明引用该函数的下游函数，即：考虑到通过 vscode“查看定义”，以及函数本身的调用方式可以方便查找到当前函数的上游函数，但在上游函数却较为困难获知被何下游函数调用。 注释下游函数有利于局部重构工作的开展。 2. 单元测试 大型程序包含数量众多的函数，对 C++ 等支持 OOP 的语言来说，也包含更多的类等。保障程序中各函数的顺利和正确执行，是保障程序整体能够运行的基础。对于数值计算软件来说，除去正常运行测试外，之后也应包括数值精度测试，这一理念的前提是开发者具有数值计算软件的编程常识，如避免小数位数丢失、DivideZeroError、相减精度丢失等数值错误，同时也将推动 ABACUS 在精度方面进行一定数量的小范围重构，符合 2023 Q2 推行的“测试驱动开发（Test Driven Development, TDD）”理念。 2.1 单元测试的设计原则 独立性：在设计和编写单元测试时，应当尽可能减少对其他部分函数的依赖，当作其他函数并未测试，因此可靠性不能保证。 高覆盖：对于程序流程控制出现分支的情况，应酌情对所有分支进行全面覆盖，以保证所有分支的函数和运算都可以正常执行。 自动：禁止出现 stdin 交互 快速：因为仅需要测试函数是否正常运行，是否可以得到预期结果，因此需要尽可能避免使用需要高时间复杂度的计算方式，而是使用尽可能简单（可以 unphysical）的数据，尽可能快地得出结果，可以考虑对预期结果进行硬编码。 2.2 对 private 变量的访问 由于当前 ABACUS 代码的封装并不完善，部分函数声明为 private 却仍然需要测试。另一方面，getter 和 setter 函数在原则上应当是从外部直接访问私有变量的唯一方式，但在使用之前也需要进行有效性测试。考虑到这两点，我们不得不尝试访问 private 或 protected 变量和成员函数。目前而言 ABACUS 中对 private 变量访问的方式主要有两种： #define private public，已知此种方式有一定情况不兼容，从而导致无法编译通过。 我们曾对访问 private 成员的方法进行过讨论，搜集到解决方案如下：https://github.com/deepmodeling/abacus-develop/issues/2666 C++ 委员会有关于几种访问私有成员的方式及其讨论：http://www.gotw.ca/gotw/076.htm 2.3 更多细节补充 ABACUS 的单元测试依靠 Googletest 框架实现。关于 Googletest 的安装、单元测试的运行、单元测试的注释规范等，见：ABACUS 测试者必知必会 。 为保证本地机器的工作不受影响，建议单元测试的编译和进行在 Bohrium 平台进行。 3. Fork and Pull request：在 ABACUS 上发布你的注释和单元测试，甚至更多！ 3.1 Fork 和 Pull request Fork 是便于进行多人协作开发的机制，其“叉子”体现在： 从待开发的软件仓库其软件的开发时间线创建时间线分支，即 Fork，到自己的仓库 在自己的仓库进行的任何改动将不会直接影响到原程序的时间线，但可以通过代码改动比较，来尽可能无冲突地将多人的改动进行合并 提交自己的改动，将自己 Fork 出的时间线和原有时间线进行合并的操作称为 Pull request (PR) 3.2 工作流示例 1 Fork ABACUS Github 仓库到自己的账号下 在自己的 ABACUS 仓库选择同步到 Github Desktop 在 Github Desktop 中选择自己的 ABACUS 仓库，之后选择在 Vscode 中打开 在 Vscode 上进行代码修改，每一次改动的保存都会同步被 Github Desktop 记录 重新编译、进行测试 在 Github Desktop 里选择左下角“Commit to develop”，然后“Push origin”将代码改动 push 到自己的 ABACUS 仓库 Github Desktop 中选择打开自己的仓库，再次审核代码改动后创建 pull request，待自动代码编译检查通过与代码人工审核 3.3 工作流示例2 Contributing to ABACUS ‒ ABACUS documentation 附：如何在飞书中平滑地分享文档 权限简介 在进行文档写作前，请确定自己账号所在的组织（如深势科技“DP”或北京科学智能研究院“AISI”）。一般而言对于创建的文档，非本人外的访问均需要文档作者进行分享，或在其他地方获得文档链接后，其阅读权限需要向作者发送权限申请。根据作者对文档的开放程度，可以分别赋予可阅读、可编辑、可管理权限，其权限自由度由低到高。 然而对于组织外，一般无文档阅读权限。 无限制访问 为了解决这一问题，可以在文档管理中按照如下方式设置： （电脑端） 打开文档，在文档右上角依次选择： （手机端） 系列链接 INPUT 读取：Introduction to ABACUS: Path to PW calculation - Part 1 STRU 读取：Introduction to ABACUS: Path to PW calculation - Part 2 赝势读取：Introduction to ABACUS: Path to PW calculation - Part 3 平面波并行与分发：Introduction to ABACUS: Path to PW calculation - Part 4 k 点并行与分发：Introduction to ABACUS: Path to PW calculation - Part 5 下篇：Introduction to ABACUS: Path to PW calculation - Part 6 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-04 23:29:29 "},"develop-path6.html":{"url":"develop-path6.html","title":"Introduction to ABACUS: Path to PW calculation - Part 6","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 6 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 6 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class 我们来到 ModuleESolver::ESolver_KS::Init()，在 source/module_esolver/esolver_ks.cpp: line105（link）： template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... if(GlobalV::BASIS_TYPE==\"pw\" || GlobalV::CALCULATION==\"get_wf\") { //Envelope function is calculated as lcao_in_pw //new plane wave basis #ifdef __MPI this->pw_wfc->initmpi(GlobalV::NPROC_IN_POOL, GlobalV::RANK_IN_POOL, POOL_WORLD); #endif this->pw_wfc->initgrids(inp.ref_cell_factor * ucell.lat0, ucell.latvec, this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz); this->pw_wfc->initparameters(false, inp.ecutwfc, this->kv.nks, this->kv.kvec_d.data()); #ifdef __MPI if(INPUT.pw_seed > 0) MPI_Allreduce(MPI_IN_PLACE, &this->pw_wfc->ggecut, 1, MPI_DOUBLE, MPI_MAX , MPI_COMM_WORLD); //qianrui add 2021-8-13 to make different kpar parameters can get the same results #endif this->pw_wfc->setuptransform(); for (int ik = 0; ik kv.nks; ++ik) this->kv.ngk[ik] = this->pw_wfc->npwk[ik]; this->pw_wfc->collect_local_pw(); this->print_wfcfft(inp, GlobalV::ofs_running); } PW_Basis_k::initgrids() ⚠ 注意，在 ESolver_KS 的构造函数中有 namespace ModuleESolver { template ESolver_KS::ESolver_KS() { .... pw_wfc = new ModulePW::PW_Basis_K_Big(GlobalV::device_flag, GlobalV::precision_flag); ModulePW::PW_Basis_K_Big* tmp = static_cast(pw_wfc); 因此对 pw_wfc 中成员函数的调用，和 pw_rho 类似地，此处会调用到其派生类 PW_Basis_K_Big 的对象 tmp 的成员函数。另一方面在 Introduction to ABACUS: Path to PW calculation - Part 4，我们对 PW_Basis_Big::initgrids() 在形参表中不包含 nx, ny 和 nz 的重载情况进行了介绍。当时使用 ecutrho，生成了 nx, ny, nz，bx，by，bz 及其组合，以及倒空间 fftnx, fftny 和 fftnz，然后分别将格点进行了实空间和倒空间的分发，为切片和“棍子”为分配基本单元，在 processors 间进行分发。 此处继续沿用依靠 Input::ecutrho 生成的 nx, ny 和 nz，调用包含 nx, ny 和 nz 在形参表中的 PW_Basis_K::initgrids() 函数（和 PW_Basis_Big 类不同，PW_Basis_K_Big 类并未重载 initgrids()）, template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... this->pw_wfc->initgrids(inp.ref_cell_factor * ucell.lat0, ucell.latvec, this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz); .... 以寻找适配于当前（格点数量增多后）nx, ny 和 nz 的新的 ecutwfc 球半径（PW_Basis_K::gridecut_lat）。 &#x1F914;思考时间 这样做的结果是什么？让 ecutwfc 等于 ecutrho 的操作正确吗？ 图 1. update cutoff value based on factorized nx, ny and nz nx, ny 和 nz 实空间格点数量增多的原因？→ 回顾 nx, ny 和 nz 的生成方式：在给定 ecutwfc 球半径后（通过 ecutrho），在可以分辨每个倒空间中点的情况下所确定出的最小格点数量。之后在给定的 ecutwfc 球中分别寻找可能达到的最大的 x/y/z 格点数，作为 nx, ny 和 nz，然后进行(2, 3, 5)-factorization，此处从 \\Delta l_i=\\frac{\\sqrt{\\text{ecut}}}{n_i^\\text{min}}\\le|\\mathbf{b}_i|→n_i^\\text{min}\\ge\\frac{\\sqrt{\\text{ecut}}}{|\\mathbf{b}_i|}→n_i↑, \\Delta l_i↓ 关系出发正向搜索，会使得 nx, ny 和 nz 增大。 void PW_Basis::initgrids( const double lat0_in, const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors const int nx_in, int ny_in, int nz_in ) { this->lat0 = lat0_in; this->tpiba = ModuleBase::TWO_PI / this->lat0; this->tpiba2 = this->tpiba*this->tpiba; this->latvec = latvec_in; this->omega = std::abs(latvec.Det()) * lat0 * lat0 * lat0; this->GT = latvec.Inverse(); this->G = GT.Transpose(); this->nx = nx_in; this->ny = ny_in; this->nz = nz_in; this->nxy = this->nx * this->ny; this->nxyz = this->nxy * this->nz; int *ibox = new int[3]; ibox[0] = int((this->nx-1)/2)+1; ibox[1] = int((this->ny-1)/2)+1; ibox[2] = int((this->nz-1)/2)+1; this->gridecut_lat = 1e20; int count = 0; for(int igz = -ibox[2]; igz poolnproc != this->poolrank) continue; /* distribute this task over all processors */ if(std::abs(igx) f; f.x = igx; f.y = igy; f.z = igz; double modulus = f * (this->GGT * f); /* if the surface vector has norm shorter than radius of present Bloch sphere, shrink the sphere */ if(modulus gridecut_lat) { this->gridecut_lat = modulus; } } } } #ifdef __MPI MPI_Allreduce(MPI_IN_PLACE, &this->gridecut_lat, 1, MPI_DOUBLE, MPI_MIN , this->pool_world); #endif this->gridecut_lat -= 1e-6; delete[] ibox; return; } 注意，在第 32 行，对该任务进行了分发，使用 MPI 函数 MPI_Allreduce() 以 MPI_MIN 对不同 processor 进行归并，得到其中最小的 this->gridecut_lat，之后共享给所有 processors。 PW_Basis_K::initparameters() 之后使用 PW_Basis_K::initparameters() 函数读取经过 k 点生成、归并、分发后读取的 kvec_c 与 kvec_d、nks 等参数。这三个两存储在 ESolver_FP 对象的 K_Vectors kv 数据成员中： template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... if(GlobalV::BASIS_TYPE==\"pw\" || GlobalV::CALCULATION==\"get_wf\") { .... this->pw_wfc->initparameters(false, inp.ecutwfc, this->kv.nks, this->kv.kvec_d.data()); .... 使得 pw_wfc 以下数值更新（initparameters()函数链接->link）： 属于 PW_Basis_k pw_wfc 的成员变量 取值 意义 this->nks ESolver_FP::K_Vectors::nks 当前 processor 所分得 k 点数量 this->kvec_c ESolver_FP::K_Vectors::kvec_c 采样的 k 点的 Cartesian 坐标 this->kvec_d ESolver_FP::K_Vectors::kvec_d 采样的 k 点的 Direct 坐标 this->gk_ecut (\\sqrt{\\text{this->ggecut}}-|\\mathbf{k}|)^2 min((sqrt(Input::ecutrho)-\\k\\max)^2, Input::ecutwfc) this->ggecut \\min(\\text{Input::ecutrho},(\\sqrt{\\text{Input::ecutwfc}}+|\\mathbf{k}|)^2) 由Input::ecutrho决定nx/ny/nz决定this->gridecut_lat，以及直接的Input::ecutwfc叠加k点后的最大平面波能量，两者其中小值 this->gamma_only false 仅 gamma 点 this->xprime true 是否 x 优先 FFT 变换 this->fftnx, this->fftny, this->fftnz, this->fftnxy, this->fftnxyz, this->nx, this->ny, this->nz, this->fftnx*this->fftny, this->fftnz*this->fftnxy, 倒空间格点数量 this->distribution_type 1 倒空间格点分发方式，默认 1 this->d_kvec_c ESolver_FP::K_Vectors::kvec_d.data() kvec_c 的指针 （for words in red）因此在 ABACUS 当前的实现中，只取更大的 ecutwfc 并不会带来波函数精度的提升，因为 ggecut 同时还受到 ecutrho 的限制：在所有采样的 k 点\\mathbf{k}中，不允许存在用于展开波函数的某平面波基其|\\mathbf{G+k}|超过电荷密度中用于展开的平面波的|\\mathbf{G}|。 之后跨 processors 对 this->ggecut 进行归并，所有 processors 均取跨 processors 中 this->ggecut 最高的那个值。 #ifdef __MPI if(INPUT.pw_seed > 0) MPI_Allreduce(MPI_IN_PLACE, &this->pw_wfc->ggecut, 1, MPI_DOUBLE, MPI_MAX , MPI_COMM_WORLD); //qianrui add 2021-8-13 to make different kpar parameters can get the same results #endif 格点分发 pw_wfc 和 pw_rho 格点分发的相同与不同：PW_Basis_K::setuptransform() 和 PW_Basis::setuptransform() 完全相同，或说 ESolver_KS::pw_wfc 和 ESolver_FP::pw_rho 完全相同地，此处按照实空间进行格点分发，以及平面波所对应的倒空间进行倒空间格点分发。仍然实际调用其派生类 *_Big::distrbute_r()，但 PW_Basis_K_Big 没有重载 initgrids() 函数。可以预见，如果 ecutwfc 取得足够大，则实际上波函数的倒空间分发和电荷密度的完全相同。另外和 ESolver_FP::pw_rho 所不同的是 PW_Basis_K::setuptransform() 多出来一个 PW_Basis_K::setupIndGk() 函数： void PW_Basis::setuptransform() { ModuleBase::timer::tick(this->classname, \"setuptransform\"); this->distribute_r(); this->distribute_g(); this->getstartgr(); this->ft.clear(); if(this->xprime) this->ft.initfft(this->nx,this->ny,this->nz,this->lix,this->rix,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); else this->ft.initfft(this->nx,this->ny,this->nz,this->liy,this->riy,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); this->ft.setupFFT(); ModuleBase::timer::tick(this->classname, \"setuptransform\"); } void PW_Basis_K::setuptransform() { ModuleBase::timer::tick(this->classname, \"setuptransform\"); this->distribute_r(); this->distribute_g(); this->getstartgr(); this->setupIndGk(); this->ft.clear(); if(this->xprime) this->ft.initfft(this->nx,this->ny,this->nz,this->lix,this->rix,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); else this->ft.initfft(this->nx,this->ny,this->nz,this->liy,this->riy,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); this->ft.setupFFT(); ModuleBase::timer::tick(this->classname, \"setuptransform\"); } PW_Basis_K::setupIndGk() PW_Basis_K::setupIndGk() 函数首先计算每个 k 点具有的平面波数量（因为有些 k 点的 k 向量加上平面波向量 G 之后可能会超出截断半径，因此不同 k 点的平面波数量可能会有小的差别），之后赋值给 this->npwk（实际上 this->npwk 是一维数组，具有 this->nks 的长度，而 this->nks 实际上是分发后 k 点数量，即实际上可能每个 processor 被分配到不止一个 k 点），并且在扫描当前 processor 所有的平面波时，同时计算跨 k 点的当前 processor 具有最大平面波数量，存储在 this->npwk_max 中。 在扫描平面波过程中所调用的 PW_Basis_K::cal_GplusK_cartesian() 函数则不外乎之前提到的实现在（ip, is, iz）到（x, y, z）之间的映射关系，此处反而是更加简单的情况：从 processor 所分配的某个平面波 ig，映射到其模长，实现如下： ModuleBase::Vector3 PW_Basis_K:: cal_GplusK_cartesian(const int ik, const int ig) const { int isz = this->ig2isz[ig]; int iz = isz % this->nz; int is = isz / this->nz; int ix = this->is2fftixy[is] / this->fftny; int iy = this->is2fftixy[is] % this->fftny; if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; ModuleBase::Vector3 f; f.x = ix; f.y = iy; f.z = iz; f = f * this->G; ModuleBase::Vector3 g_temp_ = this->kvec_c[ik] + f; return g_temp_; } 上述代码中 f=f*this->G 操作实现了平面波的坐标从 Direct 到 Cartesian 的转换。即 PW_Basis_K::cal_GplusK_cartesian() 函数实现从第 ik 个 k 点，第 ig 个平面波到其向量和的计算。当 ecutwfc 给定较小时，取平面波其对应倒空间矢量模长小于等于 ecutwfc 所对应矢量（但按照 ggecut 进行平面波的分发）： &#x1F914;思考时间 如果 ecutwfc != ggecut 会怎样？是否会有内存空间的浪费？ 平面波“棍子”分发时的能量比较： void PW_Basis::count_pw_st( int* st_length2D, // the number of planewaves that belong to the stick located on (x, y). int* st_bottom2D // the z-coordinate of the bottom of stick on (x, y). ) { .... int length = 0; // number of planewave on stick (x, y). for (int iz = iz_start; iz GGT * f); if (modulus ggecut || this->full_pw) { if (length == 0) st_bottom2D[index] = iz; // length == 0 means this point is the bottom of stick (x, y). ++this->npwtot; ++length; if(iy riy) this->riy = iy; if(iy > this->liy) this->liy = iy; if(ix rix) this->rix = ix; if(ix > this->lix) this->lix = ix; } } if (length > 0) { st_length2D[index] = length; ++this->nstot; } .... } processor 上平面波计数： void PW_Basis_K::setupIndGk() { .... this->npwk_max = 0; delete[] this->npwk; this->npwk = new int [this->nks]; for (int ik = 0; ik nks; ik++) { int ng = 0; for (int ig = 0; ig npw ; ig++) { const double gk2 = this->cal_GplusK_cartesian(ik, ig).norm2(); if (gk2 gk_ecut) ++ng; // this->gk_ecut may be equilvalent with ecutwfc } this->npwk[ik] = ng; .... if ( this->npwk_max npwk_max = ng; } .... 而作为回溯，this->npw 和 this->nks 分别在倒空间格点的分发阶段 PW_Basis::distribution_method1()（该函数 PW_Basis_K 直接从 PW_Basis 继承）和 PW_Basis_K::initparameters() 被赋值，赋值来源分别是 npw_per[this->poolrank]、st_length 和 ESolver_KS::K_Vectors::nks，后者来源于 K_Vectors::mpi_k() 函数。 接下来建立两映射表： //get igl2isz_k and igl2ig_k if(this->npwk_max igl2isz_k = new int [this->nks * this->npwk_max]; delete[] igl2ig_k; this->igl2ig_k = new int [this->nks * this->npwk_max]; for (int ik = 0; ik nks; ik++) { int igl = 0; for (int ig = 0; ig npw ; ig++) { const double gk2 = this->cal_GplusK_cartesian(ik, ig).norm2(); if (gk2 gk_ecut) { this->igl2isz_k[ik*npwk_max + igl] = this->ig2isz[ig]; this->igl2ig_k[ik*npwk_max + igl] = ig; ++igl; } } } .... return; } 由于此处的命名过于抽象，我们可以直接添加注释在头文件，之后提交 PR： class PW_Basis_K : public PW_Basis { public: .... /// @brief flattened, sparse 2d matrix whose row index runs over planewaves distributed on present processor and column index for kpoint (distributed on present processor, also), the matrix element value is PW_Basis::isz. isz is flattened index of (is, iz), where the is, is index of stick on present processor and iz is z index of FFT grid. \"Sparse\" means not every kpoint has as many as npwk_max planewaves, but the unflattened 2D matrix has dimension of npwk_max*nks, which means there will be empty elements (unreasonable isz value). igl is index of g-vector (equilvalent with planewave) local, the \"local\" means every kpoint. int *igl2isz_k=nullptr; .... /// @brief flattened, sparse 2d matrix established in the same way as this->igl2isz_k, mapping from (igl,ik) to ig, ig is index of planewave in present processor, for more info., see comment of this->igl2isz_k. int *igl2ig_k=nullptr; 而 this->igl2isz_k 这一矩阵的使用在紧接着的 PW_Basis_K::collect_local_pw() 中即将展现。 之后反向更新 ESolver_KS::K_Vectors::ngk 中值： template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... for (int ik = 0; ik kv.nks; ++ik) { this->kv.ngk[ik] = this->pw_wfc->npwk[ik]; } .... 后处理 PW_Basis_K::collect_local_pw() 展现了 this->igl2isz_k 如此抽象的 mapping 的使用方法（此处计算平面波的 Cartesian 坐标，即以 0 点为中心的截断半径内的平面波的坐标）： void PW_Basis_K::collect_local_pw() { if(this->npwk_max gk2 = new double[this->npwk_max * this->nks]; this->gcar = new ModuleBase::Vector3[this->npwk_max * this->nks]; .... ModuleBase::Vector3 f; for(int ik = 0 ; ik nks ; ++ik) { ModuleBase::Vector3 kv = this->kvec_d[ik]; for(int igl = 0 ; igl npwk[ik] ; ++igl) { int isz = this->igl2isz_k[ik * npwk_max + igl]; int iz = isz % this->nz; int is = isz / this->nz; int ixy = this->is2fftixy[is]; int ix = ixy / this->fftny; int iy = ixy % this->fftny; if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; f.x = ix; f.y = iy; f.z = iz; this->gk2[ik * npwk_max + igl] = (f+kv) * (this->GGT * (f+kv)); this->gcar[ik * npwk_max + igl] = f * this->G; } } .... this->d_gcar = reinterpret_cast(&this->gcar[0][0]); this->d_gk2 = this->gk2; .... } 的确，尽管我们以稀疏方式存储满足模长小于等于 Input::ecutwfc 的平面波的 isz，也不用担心访问到空元素：this->npwk 数组的存在，标定了究竟对于每一个存储在当前 processor 上的 k 点，有多少个平面波，且此时 this->npwk 里“平面波数量”已经是 ig 和 ik correlate 的结果：他们必须使得平面波模长小于等于 Input::ecutwfc。因此循环 k 点索引即可得到平面波数量，进而根据平面波数量可以获得局部平面波索引 igl，之后使用 igl 与 ik 访问刚刚建立的映射表 this->igl2isz_k，得到 isz，然后使用 isz 和 is、iz 的关系得到后两者，is 传入 this->is2fftixy 映射表，得到平面波的倒空间 Direct 坐标。 经过|\\mathbf{G+k}|以及坐标变换，得到 this->gk2 和 this->gcar，并且使用指针（this->d_gcar、this->d_gk2）指向两者。 至此，我们比起 ESolver_FP::pw_rho 的倒空间分发，多知道了和 k 点相关的众多属性：因波函数本身的平移对称性决定了其和 k 点的相关性，因而 k 点必然参与在内。 GlobalC::Parallel_Grid::init() template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... GlobalC::Pgrid.init(this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz, this->pw_rho->nplane, this->pw_rho->nrxx, pw_big->nbz, pw_big->bz); // mohan add 2010-07-22, update 2011-05-04 .... Parallel_Grid::init() 函数将 PW_Basis pw_rho 的实空间格点数据存储到 Parallel_Grid 类中，并且根据 KPAR 用户设置参数，使得\\mathbf{k}点的分发策略同时适用于实空间格点。 void Parallel_Grid::init(const int &ncx_in, const int &ncy_in, const int &ncz_in, const int &nczp_in, const int &nrxx_in, const int &nbz_in, const int &bz_in) { .... const int remain_pro = nprocgroup%GlobalV::KPAR; for(int i=0; inproc_in_pool[i]++; } this->numz = new int*[GlobalV::KPAR]; this->startz = new int*[GlobalV::KPAR]; this->whichpro = new int*[GlobalV::KPAR]; for(int ip=0; ipnumz[ip] = new int[nproc]; this->startz[ip] = new int[nproc]; this->whichpro[ip] = new int[this->ncz]; ModuleBase::GlobalFunc::ZEROS(this->numz[ip], nproc); ModuleBase::GlobalFunc::ZEROS(this->startz[ip], nproc); ModuleBase::GlobalFunc::ZEROS(this->whichpro[ip], this->ncz); } this->allocate = true; this->z_distribution(); .... } void Parallel_Grid::z_distribution(void) { assert(allocate); int* startp = new int[GlobalV::KPAR]; startp[0] = 0; for(int ipool=0; ipool0) startp[ipool] = startp[ipool-1] + nproc_in_pool[ipool-1]; for(int iz=0; iz=startz[ipool][nproc-1]) { whichpro[ipool][iz] = startp[ipool] + nproc-1; break; } else if(iz>=startz[ipool][proc] && iz PW_Basis_K::setupIndGk() 已经将分发后 k 点和平面波基函数（倒空间格点）相互耦合，最终获得的 processor-specific igl2isz_k 可以实现\\mathbf{k}和\\mathbf{G}的合并存储，即相当于实现了\\mathbf{k}和\\mathbf{G}的一并分发。 我们之前使用 pw_rho 的 PW_Basis::initgrids() 函数对用于电荷密度\\rho的实空间格点数量进行过初始化，也指定了分发策略。也为继承自 ESolver_FP 类的 ModulePW::PW_Basis_Big 类对象 pw_big 数据成员 bx, by, bz, nbx, nby 和 nbz： namespace ModuleESolver { class ESolver_FP : public ESolver { public: .... ModulePW::PW_Basis_Big* pw_big; /// ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); pw_big = static_cast(pw_rho); pw_big->setbxyz(INPUT.bx, INPUT.by, INPUT.bz); .... } Parallel_Grid::init() 调用 Parallel_Grid::z_distribution() 实现具体的分发过程，具体确定了以下三个列表的值： 变量 Dimension 意义 this->numz N(groups)*N(proc_in_group), N(groups)由 GlobalV::KPAR 决定，即该二维索引实际上是一维索引（rank of processor）的展开 存储每个组中每个 processor 所分得 xy 平面的个数。在 Parallel_Grid::z_distribution() 具体实现中，每次为一个 processor 分配一个 bz，即 big grid contained xyplanes，一共分配 nbz 个 xyplane this->startz N(groups)*N(proc_in_group) 每个组中每个 processor 分得的 xy 平面中最小 z 坐标 this->whichpro N(groups)*N(xyplane) 每个组所分得平面归属于哪个 processor ⚙ 在阅读 Parallel_Grid::init() 时还会发现另一个 Parallel_Grid::init_final_scf() 函数，其和 Parallel_Grid::init() 具有高度的相似性。 结构因子计算：ModuleESolver::ESolver_FP::Structure_Factor::setup_structure_factor() template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... // Calculate Structure factor this->sf.setup_structure_factor(&GlobalC::ucell, this->pw_rho); 固体物理中结构因子S(\\mathbf{G})以 atom type-by-atom type 定义为 S_\\alpha(\\mathbf{G})=\\sum_{\\mathbf{G}}{\\sum_{i}^{N_{\\alpha}}{e^{-i\\mathbf{G}\\cdot\\mathbf{\\tau}_{\\alpha,i}}}} 其中\\mathbf{G}为当前晶格所允许的倒空间矢量，即\\mathbf{G}=\\sum_{i}^3{m_i\\mathbf{b}_i}, m_i\\in Z, \\alpha为当前原子种类，i为当前盒子内\\alpha类型原子的索引，N_\\alpha为该种类原子数量。其会出现在任何涉及原子性质加和得到倒空间相应量的过程中： V(\\mathbf{G})=\\int{d\\mathbf{r} e^{i\\mathbf{G}\\cdot\\mathbf{r}} \\sum_{\\mathbf{T}}{ \\sum_{\\alpha}^{N}{ \\sum_{i}^{n^\\alpha} {V^{\\alpha}(\\mathbf{r}-\\mathbf{\\tau}_{\\alpha i}-\\mathbf{T})} } } } =\\sum_\\alpha{V^\\alpha(\\mathbf{G})S^\\alpha(\\mathbf{G})} void Structure_Factor::setup_structure_factor(UnitCell* Ucell, const ModulePW::PW_Basis* rho_basis) { .... const std::complex ci_tpi = ModuleBase::NEG_IMAG_UNIT * ModuleBase::TWO_PI; this->strucFac.create(Ucell->ntype, rho_basis->npw); // itype, iG-vector table .... bool usebspline; if(nbspline > 0) usebspline = true; else usebspline = false; 我们首先考虑不加 b 样条的情况： if(usebspline){....} else { for (int it=0; itntype; it++) /* runs over all atomtypes */ { const int na = Ucell->atoms[it].na; const ModuleBase::Vector3 * const tau = Ucell->atoms[it].tau; ....//parallelization with openmp is omitted in this line for (int ig=0; ignpw; ig++) /* runs over G-vectors */ { const ModuleBase::Vector3 gcar_ig = rho_basis->gcar[ig]; std::complex sum_phase = ModuleBase::ZERO; for (int ia=0; iastrucFac(it,ig) = sum_phase; } } } 注意，来自于形参表的 rho_basis->npw 决定了具体结构因子的倒空间波矢\\mathbf{G}具体取值（取值直接来自 rho_basis->gcar，实际即 pw_rho->gcar，由 INPUT.ecutrho 确定）。然后计算了e^{i\\mathbf{G}\\cdot\\mathbf{\\tau}_{\\alpha i}}在实空间格点上的 map： void Structure_Factor::setup_structure_factor(UnitCell* Ucell, const ModulePW::PW_Basis* rho_basis) { .... int i,j; //ng; this->eigts1.create(Ucell->nat, 2*rho_basis->nx + 1); this->eigts2.create(Ucell->nat, 2*rho_basis->ny + 1); this->eigts3.create(Ucell->nat, 2*rho_basis->nz + 1); .... ModuleBase::Vector3 gtau; int inat = 0; for (i = 0; i ntype; i++) { .... for (j = 0; j atoms[i].na;j++) { gtau = Ucell->G * Ucell->atoms[i].tau[j]; for (int n1 = -rho_basis->nx; n1 nx;n1++) { double arg = n1 * gtau.x; this->eigts1(inat, n1 + rho_basis->nx) = ModuleBase::libm::exp( ci_tpi*arg ); } for (int n2 = -rho_basis->ny; n2 ny;n2++) { double arg = n2 * gtau.y; this->eigts2(inat, n2 + rho_basis->ny) = ModuleBase::libm::exp( ci_tpi*arg ); } for (int n3 = -rho_basis->nz; n3 nz;n3++) { double arg = n3 * gtau.z; this->eigts3(inat, n3 + rho_basis->nz) = ModuleBase::libm::exp( ci_tpi*arg ); } inat++; } } this->z_eigts1 = this->eigts1.c; this->z_eigts2 = this->eigts2.c; this->z_eigts3 = this->eigts3.c; } 经过 Structure_Factor::setup_structure_factor() 函数，计算好的以[原子种类，G-vectors（从 pw_rho）]2D 数组存储结构因子被存储在 ESolver_KS::Structure_Factor::strucFac 中，属于 ESolver_KS 类（当前）对象 p_esolver 的 Structure_Factor 类对象为 sf。同理，还存储了 p_esolver->sf.eigts1, 2 和 3，以及 p_esolver->sf.z_eigts1, 2, 3。this->eigts1, 2, 3 按照如下方式取值： \\text{eigts}_1[i]=e^{i2\\pi(n_1\\mathbf{b}_1)\\cdot\\mathbf{\\tau}_i}, Ucell->G 所存储的是 G 矩阵，其中是倒空间 3 个基矢量，而n_1\\mathbf{b}_1\\equiv\\mathbf{G}_1，因此仍然有 \\text{eigts}_1[i]=e^{i\\mathbf{G}_1[i]\\cdot\\mathbf{\\tau}_i}。 即 this->eigts(i), i=1,2,3 中所存储的是由 INPUT.ecutrho 所确定的球形区域中每个倒空间格点对每个原子的结构因子，或相位项。 电荷外推初始化：Charge_Extra::Init_CE() template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... // Initialize charge extrapolation CE.Init_CE(GlobalC::ucell.nat); } 基本原理 在分子动力学（Molecular dynamics, MD）模拟，或 Born-Oppenheimer MD（BOMD）过程中，由于每步进行完整 SCF 成本较高，使用一定的电荷外推方法，用于构造 Hamiltonian 算符可以节约大部分时间。原本的电荷外推方法原理为： \\rho \\left( t+\\Delta t \\right) =\\rho \\left( t \\right) +\\alpha \\left[ \\rho \\left( t \\right) -\\rho \\left( t-\\Delta t \\right) \\right] +\\beta \\left[ \\rho \\left( t-\\Delta t \\right) -\\rho \\left( t-2\\Delta t \\right) \\right] 波函数其实也按照此方法进行外推，但需要注意波函数能级在 MD 过程中两步间可能发生交换，因此需要额外保证最小化\\min\\sum_{\\text{n}\\mathbf{k}}||\\Psi _{\\mathrm{n}\\mathbf{k}}\\left( t \\right) -\\Psi _{\\mathrm{n}\\mathbf{k}}\\left( t-\\Delta t \\right) ||。 \\alpha和\\beta的确定方法为使得\\sum_i^N{||\\mathbf{r}_{i}^{\\prime}-\\mathbf{r}_i\\left( t+dt \\right) ||^2}最小化，其中 \\mathbf{r}_{i}^{\\prime}\\equiv \\mathbf{r}_i\\left( t \\right) +\\alpha \\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-\\Delta t \\right) \\right] +\\beta \\left[ \\mathbf{r}_i\\left( t-\\Delta t \\right) -\\mathbf{r}_i\\left( t-2\\Delta t \\right) \\right] 。由此可有： \\alpha =\\frac{b_1a_{22}-b_2a_{12}}{\\det A}, \\beta =\\frac{b_2a_{11}-b_2a_{21}}{\\det A} A 矩阵的矩阵元a_{ij}定义为： \\begin{cases} a_{11}=\\sum_i^N{|\\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-\\Delta t \\right) |^2}\\\\ a_{12}=a_{21}=\\sum_i^N{\\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-\\Delta t \\right) \\right] \\cdot \\left[ \\mathbf{r}_i\\left( t-\\Delta t \\right) -\\mathbf{r}_i\\left( t-2\\Delta t \\right) \\right]}\\\\ a_{22}=\\sum_i^N{|\\mathbf{r}_i\\left( t-\\Delta t \\right) -\\mathbf{r}_i\\left( t-2\\Delta t \\right) |^2}\\\\ \\end{cases} B 矢量的定义为： \\begin{cases} b_1=-\\sum_i^N{\\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t+\\Delta t \\right) \\right] \\cdot \\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-\\Delta t \\right) \\right]}\\\\ b_2=-\\sum_i^N{\\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t+\\Delta t \\right) \\right] \\cdot \\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-2\\Delta t \\right) \\right]}\\\\ \\end{cases} 。1999 年，Dario Alfe 提出了新的电荷外推方式，将电荷分割为原子贡献部分和 delta 项： \\rho \\left( t \\right) =\\rho _{\\mathrm{at}}\\left( t \\right) +\\delta \\rho \\left( t \\right) 。采用相同的外推模式，但只外推\\delta\\rho(t)，\\rho_\\text{at}(t+\\Delta t)的值可以迅速在实空间求得： \\delta \\rho \\left( t+\\Delta t \\right) =\\delta \\rho \\left( t \\right) +\\alpha \\left[ \\delta \\rho \\left( t \\right) -\\delta \\rho \\left( t-\\Delta t \\right) \\right] +\\beta \\left[ \\delta \\rho \\left( t-\\Delta t \\right) -\\delta \\rho \\left( t-2\\Delta t \\right) \\right] ， \\rho \\left( t+\\Delta t \\right) =\\rho _{\\mathrm{at}}\\left( t+\\Delta t \\right) +\\delta \\rho \\left( t+\\Delta t \\right) 。另一种实现 BOMD 的方法为 CPMD，即通过给予电子相较于离子极小的质量，导致电子和离子的振动耦合尽可能小，从而使用经典的 MD 方法可以进行 BOMD。但由于计算机算力的更新迭代与应用场景更高的精度要求，目前 CPMD 已经逐渐退出历史舞台。 &#x1F914;思考时间 电荷外推的“旧”方法和 D. Alfe 提出的新方法根本区别在哪里？从物理图像层面考虑看看！ 代码细节 void Charge_Extra::Init_CE(const int& natom) { if(GlobalV::chg_extrap == \"none\") pot_order = 0; else if(GlobalV::chg_extrap == \"atomic\") pot_order = 1; else if(GlobalV::chg_extrap == \"first-order\") pot_order = 2; else if(GlobalV::chg_extrap == \"second-order\") pot_order = 3; else { ModuleBase::WARNING_QUIT(\"Charge_Extra\",\"charge extrapolation method is not available !\"); } if(pot_order == 3) { dis_old1 = new ModuleBase::Vector3[natom]; dis_old2 = new ModuleBase::Vector3[natom]; dis_now = new ModuleBase::Vector3[natom]; } alpha = 1.0; beta = 0.0; } 关于该类的其他函数请自行阅读。关于 GlobalV::chg_extrap： //input_conv.cpp GlobalV::chg_extrap = INPUT.chg_extrap; //input.cpp void Input::Default(void) { .... chg_extrap = \"atomic\"; // xiaohui modify 2015-02-01 .... } bool Input::Read(const std::string &fn) { .... while (ifs.good()) { .... else if (strcmp(\"chg_extrap\", word) == 0) // xiaohui modify 2015-02-01 { read_value(ifs, chg_extrap); // xiaohui modify 2015-02-01 } .... } .... } void Input::Default_2(void) { .... else if (calculation == \"get_pchg\") { .... chg_extrap = \"atomic\"; // xiaohui modify 2015-02-01 .... } else if (calculation == \"get_wf\") { .... chg_extrap = \"atomic\"; // xiaohui modify 2015-02-01 .... } .... } void Input::Check() { .... if (chg_extrap == \"dm\" && basis_type == \"pw\") // xiaohui add 2013-09-01, xiaohui modify 2015-02-01 { ModuleBase::WARNING_QUIT( \"Input\", \"wrong 'chg_extrap=dm' is only available for local orbitals.\"); // xiaohui modify 2015-02-01 } .... } 下篇我们将回到再上一层函数，ESolver_KS_PW::Init() 中去。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Summary 1 下篇：Introduction to ABACUS: Path to PW calculation - Part 7 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-05 10:49:50 "},"develop-path7.html":{"url":"develop-path7.html","title":"Introduction to ABACUS: Path to PW calculation - Part 7","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 7 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 7 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class 终于来到和原本 p_esolver 相同的类的成员函数 Init()： template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { ESolver_KS::Init(inp, ucell); // phsol == nullptr) { this->phsol = new hsolver::HSolverPW(this->pw_wfc, &this->wf); } // Initialize ElecState if (this->pelec == nullptr) { this->pelec = new elecstate::ElecStatePW(this->pw_wfc, &(this->chr), &(this->kv), this->pw_rho, this->pw_big); } // Initialize the charge density this->pelec->charge->allocate(GlobalV::NSPIN); this->pelec->omega = GlobalC::ucell.omega; // Initialize the potential if (this->pelec->pot == nullptr) { this->pelec->pot = new elecstate::Potential(this->pw_rho, &GlobalC::ucell, &(GlobalC::ppcell.vloc), &(this->sf), &(this->pelec->f_en.etxc), &(this->pelec->f_en.vtxc)); } this->Init_GlobalC(inp, ucell); if (GlobalV::ocp) this->pelec->fixed_weights(GlobalV::ocp_kb); } Initialization of HSolverPW object Constructor 首先来到按照注释划分的第一部分“Initialize HSolver”（line 6，HSolver 就是求解体系哈密顿量的求解器）： template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { ESolver_KS::Init(inp, ucell); // Initialize HSolver if (this->phsol == nullptr) { this->phsol = new hsolver::HSolverPW(this->pw_wfc, &this->wf); } 其实 phsol（此处命名逻辑为 p 代表 Pointer，hsol 为 HSolver 的缩写）并非是 ESolver_KS_PW 类中数据成员，而是在 ESolver_KS 中，这意味着 ESolver_KS 的派生类均有可能使用这一数据成员。稍加搜索，发现 ESolver_KS_LCAO::Init() 中也有类似操作： void ESolver_KS_LCAO::Init(Input& inp, UnitCell& ucell) { .... // init HSolver if (this->phsol == nullptr) { this->phsol = new hsolver::HSolverLCAO(this->LOWF.ParaV); this->phsol->method = GlobalV::KS_SOLVER; } 另一点可以预料的是，在基类 ESolver_KS 的声明中，phsol 起始被声明为基类 HSolver 类对象，而非直接地 HSolverPW 这一派生类对象，这一操作再次体现了 C++ 的多态编程思路。具体在当前 Init 函数中，phsol 被分配内存时调用的 HSolverPW 类构造函数，其形参表中，pw_wfc 是属于 PW_Basis_K（以及其派生类 PW_Basis_K_Big）类对象，继承自 ESolver_KS。wf 是 wavefunc 类对象，也继承自 ESolver_KS，这体现了仅对于 ESolver_KS 层级而言需要带有 k 点的平面波波函数，以及波函数的存储类，而再上一级 ESolver_FP 则不一定需要这两者。平行而言 ESolver_OF 也属于“FP”，但在 ESolver_FP 的派生类 ESolver_OF 中，丝毫没有关于平面波波函数的数据成员： 派生类 HSolverPW 的构造函数其结构十分简单： template HSolverPW::HSolverPW(ModulePW::PW_Basis_K* wfc_basis_in, wavefunc* pwf_in) { this->classname = \"HSolverPW\"; this->wfc_basis = wfc_basis_in; this->pwf = pwf_in; this->diag_ethr = GlobalV::PW_DIAG_THR; } ，即将 ESolver_KS::pw_wfc 复制进 HSolverPW 的数据成员 wfc_basis，ESolver_KS::wf 到 HSolverPW::pwf。 Initialization of ElecState object Constructor 接下来来到 ESolver_KS_PW::Init()“第二部分”中 ElecState 类对象的初始化。 template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { .... // init ElecState, if (this->pelec == nullptr) { this->pelec = new elecstate::ElecStatePW(this->pw_wfc, &(this->chr), &(this->kv), this->pw_rho, this->pw_big); } 和 phsol 同样地，这一次 pelec 是继承自 ESolver_FP 类（因此说明 FP 不仅 KS 派生类需要电荷这一物理量），但 pelec 实际被声明为基类 ElecState 的指针，在 ESolver_KS_PW::Init() 中被分配以其派生类 ElecStatePW 的内存空间（同样地也有 ElecStateLCAO 派生类等），因此调用派生类构造函数： template ElecStatePW::ElecStatePW(ModulePW::PW_Basis_K *wfc_basis_in, Charge* chg_in, K_Vectors *pkv_in, ModulePW::PW_Basis* rhopw_in, ModulePW::PW_Basis_Big* bigpw_in) : basis(wfc_basis_in) { this->classname = \"ElecStatePW\"; this->init_ks(chg_in, pkv_in, pkv_in->nks, rhopw_in, bigpw_in); } 在该构造函数的函数体外初始化了成员变量 basis 以 ESolver_KS::pw_wfc。除了设置 ElecStatePW::classname 这一数据成员的具体值外，调用 ElecState::init_ks() 函数（显然继承自基类）。 ElecState::init_ks() void ElecState::init_ks(Charge* chg_in, // pointer for class Charge const K_Vectors* klist_in, int nk_in, ModulePW::PW_Basis* rhopw_in, const ModulePW::PW_Basis_Big* bigpw_in) { this->charge = chg_in; this->charge->set_rhopw(rhopw_in); this->klist = klist_in; this->bigpw = bigpw_in; // init nelec_spin with nelec and nupdown this->init_nelec_spin(); // autoset and check GlobalV::NBANDS, nelec_spin is used when NSPIN==2 this->cal_nbands(); // initialize ekb and wg this->ekb.create(nk_in, GlobalV::NBANDS); this->wg.create(nk_in, GlobalV::NBANDS); } Link Charge* ElecState::charge to Charge ESolver_FP::chg ⚠ 注意在 ElecState/ElecStatePW 类中的数据成员 charge 是 Charge 类指针，被赋值为 ESolver_FP 类的 Charge 类对象，即使得 ElecState 类的 Charge 类指针指向 ESolver_FP 的 chr 数据成员。 namespace ModuleESolver { class ESolver_FP : public ESolver { public: .... elecstate::ElecState* pelec = nullptr; Charge chr; ModuleSymmetry::Symmetry symm; .... K_Vectors kv; 因此 this->charge = chg_in; this->charge->set_rhopw(rhopw_in); 的意义在于由 ElecState::init_ks() 作为被包含在 ESolver_FP（或说 ESolver）对象中的 Charge 类对象 chg 和 PW_Basis 类 pw_rho 的连接。（是否冗余？） 变量 ElecState::klist、ElecState::bigpw、ElecState::rhopw 传入的实参也类似，同样来自于 ESolver_FP。 void Charge::set_rhopw(ModulePW::PW_Basis* rhopw_in) { this->rhopw = rhopw_in; } &#x1F914;在变量命名过程中应当注意避免随意 context 用于展开电荷的 PW_Basis 类指针 包含 Big FFT grid 的用于电荷展开的 PW_Basis_Big 类指针 ElecState 数据成员 bigpw ElecState::init_ks() rhopw_in bigpw_in ESolver_KS_PW::Init() pw_rho pw_big ESolver_FP 数据成员 pw_rho pw_big Charge 数据成员 rhopw Calculate numbers of electrons in different spin channels ElecState::init_nelec_spin() 函数的调用为 this->nelec_spin 赋值，其中 GlobalV::nupdown 的意义已经在（Introduction to ABACUS: Path to PW calculation - Part 2 ）介绍，为 up 和 down spin 的差值： void ElecState::init_nelec_spin() { this->nelec_spin.resize(GlobalV::NSPIN); if (GlobalV::NSPIN == 2) { // in fact, when TWO_EFERMI(nupdown in INPUT is not 0.0), nelec_spin will be fixed. this->nelec_spin[0] = (GlobalV::nelec + GlobalV::nupdown) / 2.0; this->nelec_spin[1] = (GlobalV::nelec - GlobalV::nupdown) / 2.0; } } Get number of bands to solve: ElecState::cal_nbands() ElecState::cal_nbands() 函数的调用为 GlobalV::NBANDS（需要计算的能带数量）这一全局变量赋值或对通过 INPUT 文件中 nbands 关键词进行赋值的值进行合理性检查。对于未在 INPUT 文件中进行赋值的情况，则在此函数之前仍然保持值为 0，之后的赋值策略为： void ElecState::cal_nbands() { .... if (GlobalV::LSPINORB == 1) occupied_bands = static_cast(GlobalV::nelec); /* it can only be the case of uks, but if so, the following method for calculating NBANDS will make this variable meaningless cuz never used! */ if ((occupied_bands - std::floor(occupied_bands)) > 0.0) { occupied_bands = std::floor(occupied_bands) + 1.0; // mohan fix 2012-04-16 } .... ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, \"occupied bands\", occupied_bands); if (GlobalV::NBANDS == 0) { if (GlobalV::NSPIN == 1) { const int nbands1 = static_cast(occupied_bands) + 10; const int nbands2 = static_cast(1.2 * occupied_bands) + 1; GlobalV::NBANDS = std::max(nbands1, nbands2); if (GlobalV::BASIS_TYPE != \"pw\") GlobalV::NBANDS = std::min(GlobalV::NBANDS, GlobalV::NLOCAL); } else if (GlobalV::NSPIN == 4) { const int nbands3 = GlobalV::nelec + 20; const int nbands4 = static_cast(1.2 * GlobalV::nelec) + 1; GlobalV::NBANDS = std::max(nbands3, nbands4); if (GlobalV::BASIS_TYPE != \"pw\") GlobalV::NBANDS = std::min(GlobalV::NBANDS, GlobalV::NLOCAL); } else if (GlobalV::NSPIN == 2) { /* max() is because the keyword nupdown can either be positive or negative */ const double max_occ = std::max(this->nelec_spin[0], this->nelec_spin[1]); const int nbands3 = static_cast(max_occ) + 11; const int nbands4 = static_cast(1.2 * max_occ) + 1; GlobalV::NBANDS = std::max(nbands3, nbands4); if (GlobalV::BASIS_TYPE != \"pw\") GlobalV::NBANDS = std::min(GlobalV::NBANDS, GlobalV::NLOCAL); } ModuleBase::GlobalFunc::AUTO_SET(\"NBANDS\", GlobalV::NBANDS); } &#x1F914;思考时间 Is there any differences bewteen the ways to assign default values for number of bands to calculate in ABACUS and Quantum ESPRESSO? 回溯：GlobalV::nelec 的值从 ESolver_KS::Init() 调用时确定（具体调用 UnitCell::cal_nelec()，Introduction to ABACUS: Path to PW calculation - Part 5）。 //module_base/global_variable.cpp GlobalV::NBANDS = 0; //module_io/input.cpp INPUT.nbands = 0; //module_io/input.cpp::Read() else if (strcmp(\"nbands\", word) == 0) // number of atom bands { read_value(ifs, nbands); } //module_io/input_conv.cpp GlobalV::NBANDS = INPUT.nbands; 对于赋值的情况则需要对其合理性进行检查，一方面是对使用 smearing 时候的 nbands 数量（对于能级简并度较高的情况，SCF 过程中能级的变化将引起能量的变化剧烈，因此可以通过 smearing 方法弥散最高占据能级附近的电子布居，使得能量变化剧烈程度减少。smearing 的具体参照一方面可以由独立费米子体系所遵循 Fermi-Dirac 统计借鉴而来，或直接采用 Gauss 分布。控制 smearing 的参数取值越大，电子偏离“0 温”越严重，但可以加速电子迭代的收敛。实际计算时，一般对半导体或者绝缘体、或者有 gap 的系统，可以不取 smearing，或者 smearing 不起作用；如果对金属系统，可以适当取一点 smearing 加速收敛，但太大容易引起结果不准确）： void ElecState::cal_nbands() { .... if (GlobalV::NBANDS == occupied_bands) { if (Occupy::gauss()) { ModuleBase::WARNING_QUIT(\"ElecState::cal_nbands\", \"for smearing, num. of bands > num. of occupied bands\"); } } Occupy 是在 input_conv 被调用时所赋值的对象， //module_io/input_conv.cpp line 589 Occupy::decision(INPUT.occupations, INPUT.smearing_method, INPUT.smearing_sigma); 而 Occupy::gauss() 的功能仅仅为： class Occupy { public: .... static const bool& gauss(void) {return use_gaussian_broadening;} 剩余部分： void ElecState::cal_nbands() { .... if (GlobalV::NBANDS == 0) {....} else { if (GlobalV::NBANDS nelec_spin[0]) { ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, \"nelec_up\", this->nelec_spin[0]); ModuleBase::WARNING_QUIT(\"ElecState::cal_nbands\", \"Too few spin up bands!\"); } if (GlobalV::NBANDS nelec_spin[1]) { ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, \"nelec_down\", this->nelec_spin[1]); ModuleBase::WARNING_QUIT(\"ElecState::cal_nbands\", \"Too few spin down bands!\"); } } } Others this->pelec->charge->allocate(GlobalV::NSPIN); this->pelec->omega = GlobalC::ucell.omega; 第二行将当前晶胞体积赋值给 ElecState 指针中该成员变量，第一行则为 Charge* ElecState::charge 申请内存空间： void Charge::allocate(const int& nspin_in) { ModuleBase::TITLE(\"Charge\", \"allocate\"); this->nrxx = this->rhopw->nrxx; // number of distributed real space grid points this->nxyz = this->rhopw->nxyz; // total number of real space grid points this->ngmc = this->rhopw->npw; // number of distributed planewaves if (allocate_rho == true) { this->destroy(); allocate_rho = false; } assert(allocate_rho == false); this->nspin = nspin_in; ....// standard output omitted here rho = new double*[nspin]; rhog = new std::complex*[nspin]; rho_save = new double*[nspin]; rhog_save = new std::complex*[nspin]; if (elecstate::get_xc_func_type() == 3 || elecstate::get_xc_func_type() == 5) { kin_r = new double*[nspin]; kin_r_save = new double*[nspin]; } //spin-by-spin (sbs) for (int is = 0; is [ngmc]; // charge density in reciprocal space sbs rho_save[is] = new double[nrxx]; // backup of rho rhog_save[is] = new std::complex[ngmc]; // backup of rhog ....// initialize above four arrays of present spin with zeros if (elecstate::get_xc_func_type() == 3 || elecstate::get_xc_func_type() == 5) { kin_r[is] = new double[nrxx]; kin_r_save[is] = new double[nrxx]; ....// initialize above two arrays of present spin with zeros } } .... // memory record omitted this->rho_core = new double[nrxx]; // core charge in real space this->rhog_core = new std::complex[ngmc]; // reciprocal core charge ....// initialize above two arrays of present spin with zeros .... // memory record omitted this->allocate_rho = true; } Initialization of Potential template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { .... // Initialize the potential. if (this->pelec->pot == nullptr) { this->pelec->pot = new elecstate::Potential(this->pw_rho, &GlobalC::ucell, &(GlobalC::ppcell.vloc), &(this->sf), &(this->pelec->f_en.etxc), &(this->pelec->f_en.vtxc)); } 接下来将各与势能相关变量的内存地址拉取到 ElecStatePW* ESolver_KS_PW::pelec 的指针成员 Potential* pot 下（继承自基类 ElecState），Potential 类构造函数被调用，初始化 pot 指针： namespace elecstate { Potential::Potential(const ModulePW::PW_Basis* rho_basis_in, const UnitCell* ucell_in, const ModuleBase::matrix* vloc_in, Structure_Factor* structure_factors_in, double* etxc_in, double* vtxc_in): ucell_(ucell_in), vloc_(vloc_in), structure_factors_(structure_factors_in), etxc_(etxc_in), vtxc_(vtxc_in) { this->rho_basis_ = rho_basis_in; this->fixed_mode = true; this->dynamic_mode = true; // allocate memory for Potential. this->allocate(); } 在 Potential 构造函数的形参表中，我们发现了从未出现过的 ModuleBase::matrix* GlobalC::ppcell 变量，以及 fenergy ElecState::f_en 变量，这些变量以内存地址形式存入 ElecStatePW* ESolver_KS_PW::pelec 中。对于 Potential::allocate() 函数，则不出例外地为数组申请内存空间： void Potential::allocate() { ModuleBase::TITLE(\"Potential\", \"allocate\"); int nrxx = this->rho_basis_->nrxx; if (nrxx == 0) return; this->v_effective_fixed.resize(nrxx); this->v_effective.create(GlobalV::NSPIN, nrxx); .... // memory record omitted if (elecstate::get_xc_func_type() == 3 || elecstate::get_xc_func_type() == 5) { this->vofk_effective.create(GlobalV::NSPIN, nrxx); .... // memory record omitted } if (GlobalV::device_flag == \"gpu\") {....} else { if (GlobalV::precision_flag == \"single\") {....} else { this->d_v_effective = this->v_effective.c; this->d_vofk_effective = this->vofk_effective.c; } // There's no need to allocate memory for double precision pointers while in a CPU environment } } // module_elecstate/potentials/potential_new.h class Potential : public PotBase { ....//google-style indent? private: .... std::vector v_effective_fixed; // Potential 和其基类 PotBase 拥有漂亮的类注释文档（link）： Initialization of rest parts of GlobalC GlobalC 和 GlobalV 是两个特殊的类，如第一版开发者文档所提到，此两种类的收益为避免过大的形参表，但负向收益为带来对两类中全局变量意外覆盖读写的隐患，因此在 ABACUS 的未来版本中，会逐步弃用 GlobalC 和 GlobalV，转而使用对象：利用高度且合理的封装方式，每次传入对象，对象包含各自相关的数据成员和函数。但就当前而言，GlobalC 提供了一些全局类。此处剩余的一些全局类申请内存空间、被初始化。 template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { if (this->psi != nullptr) delete this->psi; this->psi = this->wf.allocate(this->kv.nks, this->kv.ngk.data(), this->pw_wfc->npwk_max); // init pseudopotential GlobalC::ppcell.init(GlobalC::ucell.ntype, &this->sf, this->pw_wfc); // initalize local pseudopotential GlobalC::ppcell.init_vloc(GlobalC::ppcell.vloc, this->pw_rho); // Initalize non local pseudopotential GlobalC::ppcell.init_vnl(GlobalC::ucell); GlobalC::ppcell.cal_effective_D(); // create GlobalC::ppcell.tab_at , for trial wave functions. this->wf.init_at_1(&this->sf); // Initial start wave functions this->wf.wfcinit(this->psi, this->pw_wfc); // denghui added 20221116 this->kspw_psi = GlobalV::device_flag == \"gpu\" || GlobalV::precision_flag == \"single\" ? new psi::Psi, Device>(this->psi[0]) : reinterpret_cast, Device>*>(this->psi); ....//memory record omitted here } &#x1F4DD;笔者的话 这里有一个有趣的东西是 kspw_psi（在求力部分还有 __kspw_psi）。有兴趣的读者可以自行查看对于 gpu 或者单精度情况，在调用的 psi 构造函数中发生了什么。 实际上，kspw_psi 支持了异构计算，而 psi，如 esolver_fp.h 声明中，实际上只为 psi::Psi, Device = psi::DEVICE_CPU>* 类指针。因此真正计算架构-dependent 的是 kspw_psi。ESolver_KS_PW 为支持异构计算，整个类为模板类。在 psi 被分配内存空间后，为 kspw_psi 赋予了其数据的可达性（accessibility），reinterpret_cast 或者复制内容。 Psi Psi 是 ABACUS 中一类特殊的数据结构，用于存储波函数（平面波基函数系数）信息。其包含如下数据成员： namespace psi { template class Psi { public: int npol = 1; .... private: T* psi = nullptr; // avoid using C++ STL AbacusDevice_t device = {}; // track the device type (CPU, GPU and SYCL are supported currented) Device* ctx = {}; // an context identifier for obtaining the device variable // dimensions int nk = 1; // number of k points int nbands = 1; // number of bands int nbasis = 1; // number of basis mutable int current_k = 0; // current k point mutable int current_b = 0; // current band index mutable int current_nbasis = 1; // current number of basis of current_k // current pointer for getting the psi mutable T* psi_current = nullptr; // psi_current = psi + psi_bias; mutable int psi_bias = 0; const int* ngk = nullptr; bool k_first = true; .... }; } Codes 我们首先阅读为 Psi 申请内存空间的代码 psi::Psi> *wavefunc::allocate(const int nks, const int *ngk, const int npwx_in) { /* parameter list: nks: number of kpoints distributed on present processor ngk: number of planewaves on kpoints respectively on present processor npwx_in: maximal number of planewaves across all kpoints distributed on present processor */ this->npwx = npwx_in; assert(npwx > 0); assert(nks > 0); // if use spin orbital, do not double nks but double allocate evc and wanf2. int prefactor = 1; if(GlobalV::NSPIN==4) prefactor = GlobalV::NPOL;//added by zhengdy-soc const int nks2 = nks; psi::Psi>* psi_out = nullptr; ....// non-pw cases are omitted else { psi_out = new psi::Psi>(nks2, GlobalV::NBANDS, npwx * GlobalV::NPOL, ngk); ....// standard output and memory record omitted } return psi_out; } 即 wavefunc::allocate() 函数核心功能为为不同基组类型按照不同方式分配内存空间，仍然需要调用 psi 自己的构造函数。psi 的构造函数的重载共有 6 个（以及 1 个默认构造函数）： template class Psi { public: // Constructor 1: basic Psi(); // Constructor 2: specify ngk only, should call resize() later Psi(const int* ngk_in); // Constructor 3: specify nk, nbands, nbasis, ngk, and do not need to call resize() later Psi(int nk_in, int nbd_in, int nbs_in, const int* ngk_in = nullptr); // Constructor 4: copy a new Psi which have several k-points and several bands from inputted psi_in Psi(const Psi& psi_in, const int nk_in, int nband_in = 0); // Constructor 5: a wrapper of a data pointer, used for Operator::hPsi() // in this case, fix_k can not be used Psi(T* psi_pointer, const Psi& psi_in, const int nk_in, int nband_in = 0); // Constructor 6: initialize a new psi from the given psi_in Psi(const Psi& psi_in); // Constructor 7: initialize a new psi from the given psi_in with a different class template // in this case, psi_in may have a different device type. template Psi(const Psi& psi_in); 此处我们调用的是\"Constructor 3\"： template Psi::Psi(int nk_in, int nbd_in, int nbs_in, const int* ngk_in) { this->ngk = ngk_in; this->current_b = 0; this->current_k = 0; this->npol = GlobalV::NPOL; this->device = device::get_device_type(this->ctx); this->resize(nk_in, nbd_in, nbs_in); // Currently only GPU's implementation is supported for device recording! ....//device recording omitted } template void Psi::resize(const int nks_in, const int nbands_in, const int nbasis_in) { assert(nks_in > 0 && nbands_in >= 0 && nbasis_in > 0); // This function will delete the psi array first(if psi exist), then malloc a new memory for it. resize_memory_op()(this->ctx, this->psi, nks_in * nbands_in * nbasis_in, \"no_record\"); this->nk = nks_in; this->nbands = nbands_in; this->nbasis = nbasis_in; this->current_nbasis = nbasis_in; this->psi_current = this->psi; // GlobalV::ofs_device //psi.h line 130 using resize_memory_op = psi::memory::resize_memory_op; //module_psi/kernels/memory_op.h namespace psi { namespace memory { template struct resize_memory_op { void operator()(const Device* dev, FPTYPE*& arr, const size_t size, const char* record_in = nullptr); }; //module_psi/kernels/memory_op.cpp namespace psi{ namespace memory{ template struct resize_memory_op { void operator()(const psi::DEVICE_CPU* dev, FPTYPE*& arr, const size_t size, const char* record_in) { if (arr != nullptr) free(arr); arr = (FPTYPE*) malloc(sizeof(FPTYPE) * size); std::string record_string; if(record_in != nullptr) record_string = record_in; else record_string = \"no_record\"; if(record_string != \"no_record\" ) { ModuleBase::Memory::record(record_string , sizeof(FPTYPE) * size); } } }; 因此 Psi 类对象最终使用 resize_memory_op() 来为 Psi::psi 数据成员进行内存申请，用于存储波函数信息/其同样是 3d-flatten，即申请的实际上是一级指针，规模为 [ikpoint][iband][ibasis]。 Feature: struct with overloaded \"()\", extends the way of defining functions Psi 申请内存时使用了在之前介绍的 ABACUS 代码中从未出现过的方式，即创建模板类结构体，之后在其中重载括号运算符，以调用函数的方式使用重载的括号。这种方式为 C++ 结构体所独有，是固定特性，对原本的函数实现方式实现了更大范围的拓展，结合 using 关键字，可以达到模板类实例化、封装、多态等效果。 并且 resize_memory_op()(this->ctx, this->psi, nks_in * nbands_in * nbasis_in, \"no_record\"); 实际可以写为 resize_memory_op(this->ctx, this->psi, nks_in * nbands_in * nbasis_in, \"no_record\"); 和原本的函数使用方法更加相似。类似的例子还有关于 Psi 类对象其他内存空间的操作： namespace psi { template class Psi { public: .... private: .... using set_memory_op = psi::memory::set_memory_op; using delete_memory_op = psi::memory::delete_memory_op; using resize_memory_op = psi::memory::resize_memory_op; using synchronize_memory_op = psi::memory::synchronize_memory_op; }; } // end of namespace psi template struct delete_memory_op { /// @brief free memory for multi-device /// \\param dev : the type of computing device /// \\param arr : the input array void operator()(const Device* dev, FPTYPE* arr); }; template struct delete_memory_op { void operator()(const psi::DEVICE_CPU* dev, FPTYPE* arr) { free(arr); } }; template struct set_memory_op { /// @brief memset for multi-device /// \\param dev : the type of computing device /// \\param var : the specified constant value /// \\param size : array size /// Output Parameters /// \\param arr : output array initialized by the input value void operator()(const Device* dev, FPTYPE* arr, const int var, const size_t size); }; template struct set_memory_op { void operator()(const psi::DEVICE_CPU* dev, FPTYPE* arr, const int var, const size_t size) { ModuleBase::OMP_PARALLEL([&](int num_thread, int thread_id) { int beg, len; ModuleBase::BLOCK_TASK_DIST_1D(num_thread, thread_id, size, (size_t)4096/sizeof(FPTYPE), beg, len); memset(arr + beg, var, sizeof(FPTYPE)*len); }); } }; template struct synchronize_memory_op { /// @brief memcpy for multi-device /// \\param dev_out : the type of computing device of arr_out /// \\param dev_in : the type of computing device of arr_in /// \\param arr_in : input array /// \\param size : array size /// Output Parameters /// \\param arr_out : output array initialized by the input array void operator()( const Device_out* dev_out, const Device_in* dev_in, FPTYPE* arr_out, const FPTYPE* arr_in, const size_t size); }; template struct synchronize_memory_op { void operator()( const psi::DEVICE_CPU* dev_out, const psi::DEVICE_CPU* dev_in, FPTYPE* arr_out, const FPTYPE* arr_in, const size_t size) { ModuleBase::OMP_PARALLEL([&](int num_thread, int thread_id) { int beg, len; ModuleBase::BLOCK_TASK_DIST_1D(num_thread, thread_id, size, (size_t)4096/sizeof(FPTYPE), beg, len); memcpy(arr_out + beg, arr_in + beg, sizeof(FPTYPE)*len); }); } }; 这种方式实现了模板函数的偏特化（partial specialization）需求（see cppreference），即首先实例化其中一个模板参数，之后再在其他地方实例化另一个。在更新的 C++20 版本中，使用 concepts（requires, see C++20）可以达到类似效果（see cppstories）。 在 ESolver_KS_PW()::init()的最后还有如下语句： this->kspw_psi = GlobalV::device_flag == \"gpu\" || GlobalV::precision_flag == \"single\" ? new psi::Psi, Device>(this->psi[0]) : reinterpret_cast, Device>*>(this->psi); 我们不考虑 GPU 和单精度的情况，因此以上等价于： this->kspw_psi = reinterpret_cast>*>(this->psi); pseudopot_cell_vnl Before init() 我们之前没有特别关注过这个被声明在 GlobalC 里的全局类（line 278），这里我们首先非常粗略回顾其顾名思义的非局域项的原理，之后在下一篇中对该类成员函数的一些细节进行详细说明（但仍然不会逐行逐句进行“翻译”）。该类的名字 pseudopot_cell_vnl 实际上是 pseudopotential_cell_V(potential)_nonlocal 的缩写。首先简单介绍 Kleinman-Bylander 方法（Phys. Rev. Lett. 48, 1425（1982））将 pseudopotential 分为完全非局域和局域部分： \\hat{V}^{\\mathrm{KB}}=\\sum_{l=0}^{l_{max}}{\\sum_{m=-l}^{+l}{\\sum_{i=1}{|\\chi _{lm,i}\\rangle V_{li}^{KB}\\langle \\chi _{lm,i}|}}}. Therefore the fully nonlocal part of pp. has projectors of different angular momentum, magnetic quantum number and basis functions. That is to say, this projector will project one state onto some basic states at such kind of resolution. The basis of projector, is constructed in this way: > \\chi _{lm,i}\\left( \\mathbf{r} \\right) =\\langle \\mathbf{r}|\\chi _{lm,i}\\rangle =R_{l,i}\\left( r \\right) Y_{lm}\\left( \\hat{\\mathbf{r}} \\right) > It is, similar with a hydrogen wavefunction that has radial part and angular part. The angular part, is represented by spherical harmonic function, and basis function, is only used for constructing radial part of the basis of projector \\hat{V}^{KB}. However, what is V^{KB}_{li} ? How is it calculated? V_{li}^{KB}=\\langle \\varphi _{li}|\\delta V_l|\\varphi _{li}\\rangle , where \\delta V_l=V_l(r)-V^{local}(r), from semilocal pp. V_l(r) (the one may directly read from portable pp. files like *.UPF), subtract the local part from it, leaving term \\delta V_l(r), is angular momentum-resoluted, while the local part is not. Imagine \\delta V_l(r) itself has its eigenspace and for each axis there is an eigenvalue. Any state can be expanded by eigenvectors \\{|v_{li}\\rangle\\} of \\delta V_l(r)-space. Thus, |\\varphi _{li}\\rangle =\\sum_k{c_{ik}|v_{lk}\\rangle}, > \\langle \\varphi _{li}|\\delta V_l|\\varphi _{li}\\rangle =\\langle \\varphi _{li}|\\sum_j{|v_{lj}\\rangle v_{lj}\\langle v_{lj}|}\\varphi _{li}\\rangle > \\ =\\sum{k^{\\prime}}{c{ik^{\\prime}}^{\\dagger}\\langle v{lk^{\\prime}}}|\\sum_j{|v{lj}\\rangle v{lj}\\langle v{lj}|}\\sumk{c{ik}|v{lk}\\rangle} \\ =\\sum{k^{\\prime}}{\\sumk{\\sum_j{c{ik^{\\prime}}^{\\dagger}c{ik}\\langle v{lk^{\\prime}}|v{lj}\\rangle v{lj}\\langle v{lj}|v{lk}\\rangle}}} \\ =\\sum{k^{\\prime}}{\\sum_k{\\sum_j{c{ik^{\\prime}}^{\\dagger}c{ik}\\delta {k^{\\prime}j}\\delta {kj}v{lj}}}} \\ =\\sumj{c{ij}^{\\dagger}c{ij}v{lj}}=\\sumj{c{ij}^{2}v{lj}} \\ =v{l1}\\left( c{i1}^{2} \\right) +v{l2}\\left( c{i2}^{2} \\right) +... > The result above is, norm of vector/state |\\varphi{li}\\rangle in eigen-space of operator \\delta Vl. > It is the same for any other kinds of scalar product, thus Schmidt orthogonalization in any arbitrary space has a more general form. For example, states {\\varphi{li}} is \\delta V_l-space-orthogonalized version of eigenstates of V_l(r), the semilocal pp employing KS eq.: > > |\\varphi {li}\\rangle =|\\psi {li}\\rangle -\\sum{i^{\\prime}=1}^{i-1}{|\\varphi {li^{\\prime}}\\rangle \\frac{\\langle \\varphi {li^{\\prime}}|\\delta V_l|\\psi {li^{\\prime}}\\rangle}{\\langle \\varphi {li^{\\prime}}|\\delta V_l|\\varphi {li^{\\prime}}\\rangle}} > > The term V^{local} is however, somewhat arbitrary, a sphericallly symmetrical charge distribution is directly given in this paper as: > > \\rho^{local}(r)=A\\exp[-(\\frac{\\sinh(abr)}{\\sinh(br)})^2] > > Parameters aand b are arbitrary. In paper ais optimized to 1.82/r_{core}$$, b is 1. 另一方面，自 ABACUS 开始运行时便调用其构造函数的 pseudopot_cell_vnl，有如下数据成员具有初始值： 变量 默认值 意义 备注 multi_proj false 是否使用多个投影子（projector） s_deeq, d_deeq, c_deeq_nc, z_deeq_nc nullptr s_nhtol, s_nhtolm, s_indv, s_tab nullptr c_vkb nullptr Kleinman-Bylander 完全非局域赝势 d_nhtol, d_nhtolm, d_indv, d_tab nullptr z_vkb nullptr Kleinman-Bylander 完全非局域赝势 wfcpw nullptr 平面波基波函数的指针 Init() 被赋值为 PW_Basis_K* ESolver_KS_PW::pw_wfc psf nullptr 结构因子指针 Init() 被赋值为 Structure_Factor* ESolver_KS_PW::sf 在下一篇中，我们将更加细致地探究这个类的其他被 Init_GlobalC() 函数所调用的成员函数。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 6 下篇：Introduction to ABACUS: Path to PW calculation - Part 8 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-05 11:01:13 "},"develop-path8.html":{"url":"develop-path8.html","title":"Introduction to ABACUS: Path to PW calculation - Part 8","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 8 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 8 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class Initialization of rest parts of GlobalC pseudopot_cell_vnl pseudopot_cell_vnl::init() init() 函数赋值以下变量，并为指针和数组进行初始化： 变量 意义 操作 wfcpw ESolver_KS_PW 对象中 PW_Basis_K 类指针 exact value psf ...对象中 Structure_Factor 类指针 exact value lmaxkb 跨原子种类的 projector 最大角动量 exact value nhm 原子种类的 projector 最大数量 zero nkb 所有原子的 projector 数量总和 zero indv 映射表，从[原子种类索引][projector 全局索引]到“原子种类内 projector 索引” zero nhtol 映射表，从[原子种类索引][projector 全局索引]到 projector 角量子数 l zero nhtolm 映射表，从[原子种类索引][projector 全局索引]到 projector 的(l,m)-pair: 0: s, 1/2/3: p, 4/5/6/7/8: d, ... zero nhtoj 映射表，从[原子种类索引][projector 全局索引]到 projector 总角量子数 zero deeq 赝势block 中数据（projector-projector），存储为[自旋 channel 索引][原子种类索引][projector1 索引][projector2 索引] zero deeq_nc Spin-orbit coupling case specific deeq zero z_deeq_nc double 指针，指向 deeq_nc d_deeq double 指针，指向 deeq exact value d_indv double 指针，指向 indv exact value d_nhtol double 指针，指向 nhtol exact value d_nhtolm double 指针，指向 nhtolm exact value dvan 赝势 projector 间，存储为[原子种类][projector1 全局索引][projector2 全局索引] zero dvan_so Spin-orbit coupling case specific dvan, 存储为[自旋 channel 索引][原子种类][projector1 全局索引][projector2 全局索引] zero becsum 存储为[自选channel索引][原子索引][(projectori,projectorj)-pair数量/2] zero lmaxq 2 * this->lmaxkb + 1; exact value vkb 倒空间V^{KB}值，即V_i(\\mathbf{G}_j)^{KB}, i\\inN(projector)，j\\inN(planewaves) zero GlobalV::NQX 球 Bessel 函数的 q-空间格点数量 exact value tab 插值表，表值\\frac{4\\pi}{\\sqrt{\\Omega}}\\int{r^2\\text{d}r\\beta_{\\alpha i}(r)j_l(qr)}, 存储为[原子种类][projector 索引][q索引] zero tab_at 原子波函数插值表 zero z_vkb double 指针，指向 vkb d_tab double 指针，指向 tab 因此部分函数冗长但功能简单，可读性强，因此不逐行解读，如需寻找代码细节，请自行阅读（link）。 pseudopot_cell_vnl::init_vloc() code template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { .... //================================= // initalize local pseudopotential //================================= GlobalC::ppcell.init_vloc(GlobalC::ppcell.vloc, this->pw_rho); ModuleBase::GlobalFunc::DONE(GlobalV::ofs_running, \"LOCAL POTENTIAL\"); //VL_in_pw.cpp void pseudopot_cell_vl::init_vloc(ModuleBase::matrix& vloc_in, const ModulePW::PW_Basis* rho_basis) { .... double *vloc1d = new double[rho_basis->ngg]; ModuleBase::GlobalFunc::ZEROS(vloc1d, rho_basis->ngg); this->allocate(rho_basis->ngg); for (int it = 0; it ngg); this->zp[it] = atom->ncpp.zv; if(numeric[it]==true) { this->vloc_of_g(atom->ncpp.msh, atom->ncpp.rab, atom->ncpp.r, atom->ncpp.vloc_at, this->zp[it], vloc1d, rho_basis); } else ModuleBase::WARNING_QUIT(\"init_vloc\",\"not available now.\"); if(it>=0 && it=0) ModuleBase::GlobalFunc::COPYARRAY(vloc1d, &vloc_in(it, 0), rho_basis->ngg); } delete[] vloc1d; this->print_vloc(rho_basis); } 回顾在 Part 3（Introduction to ABACUS: Path to PW calculation - Part 3）曾经读取过赝势到 UnitCell::atom.ncpp 数据成员中，pseudopot_cell_vl::init_vloc() 函数调用 pseudopot_cell_vl::vloc_of_g() 对实空间局域势进行傅里叶变换： V_{\\mathrm{loc}}\\left( \\mathbf{G} \\right) =\\mathscr{F} \\left[ V_{\\mathrm{loc}}\\left( \\mathbf{r} \\right) \\right] =\\mathscr{F} \\left[ V_{\\mathrm{loc}}\\left( \\mathbf{r} \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right] -\\frac{Ze^2}{r}\\mathscr{F} \\left[ \\mathrm{erf}\\left( r \\right) \\right] 后一项具有解析解， \\frac{Ze^2}{r}\\mathscr{F} \\left[ \\mathrm{erf}\\left( r \\right) \\right] =Ze^2\\frac{\\exp \\left[ -\\frac{|\\mathbf{G}|^2}{4} \\right]}{|\\mathbf{G}|^2} 前一项的傅里叶变换可以继续化简： \\mathscr{F} \\left[ V_{\\mathrm{loc}}\\left( \\mathbf{r} \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right] =\\frac{1}{\\Omega}\\int{\\mathrm{d}\\mathbf{r}e^{-i\\mathbf{G}\\cdot \\mathbf{r}}\\left[ V_{\\mathrm{loc}}\\left( \\mathbf{r} \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{1}{\\Omega}\\int{r^2\\mathrm{d}r\\int_0^{\\pi}{\\sin \\theta \\mathrm{d}\\theta}\\int_0^{2\\pi}{\\mathrm{d}\\phi}e^{-i|\\mathbf{G}||\\mathbf{r}|\\cos \\theta}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{2\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\int_0^{\\pi}{\\sin \\theta \\mathrm{d}\\theta}e^{-i|\\mathbf{G}|r\\cos \\theta}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{2\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\int_1^{-1}{\\mathrm{d}t}e^{-i|\\mathbf{G}|rt}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{2\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\frac{e^{i|\\mathbf{G}|r}-e^{-i|\\mathbf{G}|r}}{i|\\mathbf{G}|r}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{4\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\frac{\\sin \\left( |\\mathbf{G}|r \\right)}{|\\mathbf{G}|r}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} 最后得到： V_{\\mathrm{loc}}\\left( \\mathbf{G} \\right) =\\frac{4\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\frac{\\sin \\left( |\\mathbf{G}|r \\right)}{|\\mathbf{G}|r}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]}-Ze^2\\frac{\\exp \\left[ -\\frac{|\\mathbf{G}|^2}{4} \\right]}{|\\mathbf{G}|^2} &#x1F914;思考时间 Write a piece of code to calculate the term above! Compare with the version in ABACUS source code, what are your pros and what are your cons? If you are confident enough with your codes in aspect of well-documenting, clean-formatting and even efficiency and accurancy, why not pull a request to replace the present one? Do it! Relevant topic: a glimpse of Ewald summation 数值计算过程中需要考虑更多的技术问题，对于函数积分的可收敛性是其中一个重要的方面。erf(x)和 erfc(x)分别定义为： \\mathrm{erf}\\left( x \\right) \\equiv \\int_0^x{\\exp \\left[ -t^2 \\right] \\mathrm{d}t} \\mathrm{erfc}\\left( x \\right) \\equiv 1-\\mathrm{erf}\\left( x \\right) 就实际应用场景而言，原子势能就是其中之一。为避免V(r)=-\\frac{Ze^2}{r}的傅里叶变换可能存在的积分发散，使用 erf(x)来 rescale 它，得到： V^\\text{loc}(r)\\equiv V(r)\\text{erf}(r) V^\\text{nloc}(r)\\equiv V(r)\\text{erfc}(r) 进而让V^\\text{nloc}(r)在倒空间进行加和，V^\\text{loc}(r)在实空间进行加和。 &#x1F914; 思考时间 The following reading materials are generated by OpenAI GPT-4, read it and try to understand the use of erf(x) function Ewald summation is a method used to compute long-range electrostatic interactions in periodic systems. It's especially important in simulations of crystalline solids and other periodic systems because the straightforward summation of pairwise Coulomb interactions converges very slowly due to the long-range nature of the interaction. Here's a brief outline with the essential mathematical details: The Problem In a periodic system, the electrostatic energy U due to a set of charged particles can be written as: U=\\frac{1}{2}\\sum_{ij, \\mathbf{T}}{\\frac{q_iq_j}{|\\mathbf{\\tau}_i-\\mathbf{\\tau}_j+\\mathbf{T}|}} Where: q_i and q_j are the charges of particles i and j. \\mathbf{\\tau}_i and \\mathbf{\\tau}_j are their positions. \\mathbf{T} represents a lattice vector of the periodic system. The summation over \\mathbf{T} includes all periodic replicas of the system. Ewald's Idea Ewald summation splits the Coulomb interaction into two parts: Short-range, real-space sum: This converges quickly in real space. Long-range, reciprocal-space sum: This converges quickly in Fourier (reciprocal) space. The Split To achieve this, Ewald introduced a splitting function \\text{erf}(r)/r (complementary error function) such that: > \\frac{1}{r}=\\frac{\\text{erf}(\\alpha r)}{r}+\\frac{\\text{erfc}(\\alpha r)}{r} > \\text{erf} is the error function. \\alpha is a free parameter that can be chosen to optimize convergence. The first term on the right-hand side is short-ranged and is treated in real space. The second term is treated in reciprocal space. The Two Parts Real-Space Sum: U_\\text{real}=\\frac{1}{2}\\sum_{ij, \\mathbf{T}}{q_iq_j\\frac{\\text{erf}(\\alpha|\\mathbf{\\tau}_i-\\mathbf{\\tau}_j+\\mathbf{T}|)}{|\\mathbf{\\tau}_i-\\mathbf{\\tau}_j+\\mathbf{T}|}} (Only nearby terms are summed, as this converges quickly in real space.) Reciprocal-Space Sum: U_\\text{recip}=\\frac{1}{2\\pi\\Omega}\\sum_{\\mathbf{G}\\neq0}{\\frac{\\exp[-\\frac{G^2}{4\\alpha^2}]}{G^2}|\\sum_{i}{q_i\\exp[i\\mathbf{G}\\cdot\\mathbf{r}_i]}|^2} Where \\mathbf{G} are the reciprocal lattice vectors and \\Omega is the volume of the unit cell. An additional self-energy term and surface term are added to correct for the self-interaction and surface effects. Conclusion The Ewald summation provides a more efficient way to compute the electrostatic interactions in a periodic system. By treating short-range interactions in real space and long-range interactions in reciprocal space, both parts converge much faster than the naive pairwise sum. &#x1F914;思考时间 More specifically the Ewald summation technique, there are many derivatives of it, for the Ewald summation takes a large part of computation time in classical Molecular dyanmics simulation. Further reading: PME (Particle Mesh Ewald summation), SPME (Smoothed Particle Mesh Ewald summation). Nonlocal pseudopotential initialization template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { .... //====================================== // Initalize non local pseudopotential //====================================== GlobalC::ppcell.init_vnl(GlobalC::ucell); ModuleBase::GlobalFunc::DONE(GlobalV::ofs_running, \"NON-LOCAL POTENTIAL\"); GlobalC::ppcell.cal_effective_D(); pseudopot_cell_vnl::init_vnl() 在上篇（Introduction to ABACUS: Path to PW calculation - Part 7 ）和 init() 函数中（link）已经阐明各变量的意义，init_vnl()则对非局域赝势相关变量（nhtol, nhtolm, nhtoj, indv, dvan/dvan_so, tab 等）进行了实际的赋值操作，使其符合表（link）中描述。考虑到篇幅限制和实际需求，此处 SOC 相关部分略过，但保留链接可供自行查看：link pseudopot_cell_vnl::cal_effective_D() 先前实际上已经对D_{ij}的出现位置进行过介绍（Introduction to ABACUS: Path to PW calculation - Part 3 ），此处 cal_effective_D() 则实现的是从 dvan（[原子种类][global index of projectori][global index of projectorj]）到 deeq（[ispin][global index of atom][index of projectori][index of projectorj]）的数据拷贝。 void pseudopot_cell_vnl::cal_effective_D(void) { ModuleBase::TITLE(\"pseudopot_cell_vnl\", \"cal_effective_D\"); for (int iat = 0; iat deeq(is, iat, ih, jh) = this->dvan(it, ih, jh); this->deeq(is, iat, jh, ih) = this->dvan(it, ih, jh); if(ih != jh && std::fabs(this->deeq(is, iat, ih, jh))>0.0) { this->multi_proj = true; } } } } } } if (GlobalV::device_flag == \"gpu\") {....} else { if (GlobalV::precision_flag == \"single\") {....} } } 亦即对于 nspin≤2 的情况，一开始的 projector 其配置完全相同，而对于 nspin=4 的情况，ispin=0 和 3 的数值和 nspin≤2 的 ispin=0 和 1 相同，而 ispin=1 和 2 则在此处被初始化为 std::complex(0.,0.)。 到这里，GlobalC::pseudopot_cell_vnl ppcell 中大部分数据成员的值均从 UnitCell::atoms::ncpp 中获得，即实现了如下数据传输方式： 即赝势数据从 upf 文件经 UnitCell::atom.ncpp 解析，上传至 GlobalC 中，详细其对应类为 GlobalC::pseudopot_cell_vnl，具体实例化对象为 ppcell。这一操作类似于 Input::INPUT 解析 INPUT 文件，上传至 GlobalV，唯一的区别是 GlobalV 直接以散装变量方式存储。 &#x1F527;重构信息 回顾当前 ABACUS 版本中从外部读入数据的传递模式： STRU 文件的读取，使用的为 UnitCell 中方法，UnitCell 中存储，并且 UnitCell 本身也属于 GlobalC，为全局变量。 KPT 文件的读取，使用 K_Vectors 类中方法，但 K_Vectors 对象被声明在 ESolver_FP 中，并非 GlobalC。 INPUT 文件的读取，使用 Input 类中方法，Input 被声明为 extern，其成员函数 Input::input_conv() 将大部分变量传到 GlobalV，少部分直接传到具体的类数据成员中。 &#x1F616; somewhat in mess wavefunc wf_atomic::init_at_1() template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { .... //================================================== // create GlobalC::ppcell.tab_at , for trial wave functions. //================================================== this->wf.init_at_1(&this->sf); 回忆 wavefunc 实际为 ESolver_KS 中数据成员，因 ESolver_FP 还包括 ESolver_OF 即 orbital-free dft 方法，此种方法不需要显式的波函数，而 init_GlobalC 是 ESolver_KS_PW 类成员函数，因此其中所有\"this->\"都为当前类对象的指针。init_at_1() 由 wavefunc 类继承自 wf_atomic，此函数归一化了原子的 pswfc（\\tilde{\\phi}^\\alpha_{i}(r)，即赝波函数，pseudo wavefunction），之后对其求 tab_at(it, ic, iq) = \\frac{4\\pi}{\\sqrt{\\Omega}}\\int_{0}^{r_\\text{cut}}{j_l(qr)\\tilde{\\phi}^\\alpha_{i}(r)r^2dr} 。注意如 Part 3 所提到，实际读取的 pswfc 已经乘以 r。 wavefunc::wfcinit() template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { .... //================================ // Initial start wave functions //================================ this->wf.wfcinit(this->psi, this->pw_wfc); void wavefunc::wfcinit(psi::Psi> *psi_in, ModulePW::PW_Basis_K *wfc_basis) { .... if (GlobalV::BASIS_TYPE == \"pw\") { if (this->irindex != nullptr) delete[] this->irindex; this->irindex = new int[wfc_basis->fftnxy]; wfc_basis->getfftixy2is(this->irindex); } .... } ASE philosophy: the so-called dynamics 我们通过 ESolver 初始化工作流，之后使用 Relax_Driver 类对象运行工作流。 void Driver::driver_run() { .... if(GlobalV::CALCULATION == \"md\") { Run_MD::md_line(GlobalC::ucell, p_esolver, INPUT.mdp); } else // scf; cell relaxation; nscf; etc { Relax_Driver rl_driver; rl_driver.relax_driver(p_esolver); } 这是我们首次提到这个类，检查发现 Relax_Driver 并非直接显式包含在当前 driver_run.cpp 中，而是位于 #include \"module_hamilt_pw/hamilt_pwdft/global.h\" ，可以发现 #include \"module_relax/relax_driver.h\" 。一窥 Relax_Driver 类的数据成员： class Relax_Driver { public: Relax_Driver(){}; ~Relax_Driver(){}; void relax_driver(ModuleESolver::ESolver *p_esolver); private: // mohan add 2021-01-28 // mohan moved this variable from electrons.h to relax_driver.h int istep = 0; double etot = 0; // new relaxation method Relax rl; // old relaxation method Relax_old rl_old; }; 因为我们只考虑 PW-SCF 计算任务，因此 Relax 和 Relax_old 类成员我们可暂且不去关心。Relax_Driver 类构造函数直接在当前头文件中定义为空，因此只剩下 Relax_Driver::relax_driver() 成员函数： void Relax_Driver::relax_driver(ModuleESolver::ESolver *p_esolver) { ....//omit output and timer if (GlobalV::CALCULATION == \"relax\" || GlobalV::CALCULATION == \"cell-relax\") {....} this->istep = 1; ....//omit force and stree step defnition bool stop = false; while (istep Run(istep - 1, GlobalC::ucell); ....//omit timer if (GlobalV::CALCULATION == \"scf\" || GlobalV::CALCULATION == \"relax\" || GlobalV::CALCULATION == \"cell-relax\") { this->etot = p_esolver->cal_Energy(); ....// omit, calculate and gather all parts of total ionic forces ....// omit, calculate and gather all parts of stress if (GlobalV::CALCULATION == \"relax\" || GlobalV::CALCULATION == \"cell-relax\") {....} } } ....//omit timer ++istep; } ....//omit output and timer } 通过检查 ESolver 各派生类和基类之间的继承关系，ESolver_KS::Run() 为此时实际调用的函数。 ESolver::Run()/ESolver_KS::Run() template void ESolver_KS::Run(const int istep, UnitCell& ucell) { ....//omit totally irelevant lines else { ....//omit timer this->beforescf(istep); //Something else to do before the iter loop ....//omit record and output bool firstscf = true; this->conv_elec = false; this->niter = this->maxniter; for (int iter = 1; iter maxniter; ++iter) { writehead(GlobalV::ofs_running, istep, iter); #ifdef __MPI auto iterstart = MPI_Wtime(); ....//omit non-mpi case #endif double diag_ethr = this->phsol->set_diagethr(istep, iter, drho); eachiterinit(istep, iter); this->hamilt2density(istep, iter, diag_ethr); if(GlobalV::MY_STOGROUP == 0) { drho = p_chgmix->get_drho(pelec->charge, GlobalV::nelec); double hsolver_error = 0.0; if (firstscf) { firstscf = false; hsolver_error = this->phsol->cal_hsolerror(); if (hsolver_error > drho) { diag_ethr = this->phsol->reset_diagethr(GlobalV::ofs_running, hsolver_error, drho); this->hamilt2density(istep, iter, diag_ethr); drho = p_chgmix->get_drho(pelec->charge, GlobalV::nelec); hsolver_error = this->phsol->cal_hsolerror(); } } this->conv_elec = (drho scf_thr); // If drho conv_elec) { if (drho pelec->cal_bandgap(); bandgap_for_autoset = this->pelec->bandgap; } else { this->pelec->cal_bandgap_updw(); bandgap_for_autoset = std::min(this->pelec->bandgap_up, this->pelec->bandgap_dw); } p_chgmix->auto_set(bandgap_for_autoset, GlobalC::ucell); } p_chgmix->mix_rho(iter, pelec->charge); } } #ifdef __MPI MPI_Bcast(&drho, 1, MPI_DOUBLE , 0, PARAPW_WORLD); MPI_Bcast(&this->conv_elec, 1, MPI_DOUBLE , 0, PARAPW_WORLD); MPI_Bcast(pelec->charge->rho[0], this->pw_rho->nrxx, MPI_DOUBLE, 0, PARAPW_WORLD); #endif updatepot(istep, iter); eachiterfinish(iter); #ifdef __MPI double duration = (double)(MPI_Wtime() - iterstart); ....//omit non-mpi case #endif printiter(iter, drho, duration, diag_ethr); if (this->conv_elec) { this->niter = iter; bool stop = this->do_after_converge(iter); if(stop) break; } } afterscf(istep); ....//omit timer } }; 下一篇我们将基于 ESolver_KS::Run() 正式步入 ABACUS 的主要工作部分，并暂时将 Relax_Driver::relax_driver() 函数提级为一级标题。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 7 下篇：Introduction to ABACUS: Path to PW calculation - Part 9 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-05 11:07:43 "},"abacus-news.html":{"url":"abacus-news.html","title":"ABACUS 新闻稿整理","keywords":"","body":"ABACUS 新闻稿整理 整理人：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 标题 链接 日期 当Hackathon遇上ABACUS \\ ABACUS@Hackathon作品合集大揭秘 网页链接 2023/09/24 ABACUS计算催化实践@Notebook，快速上手催化理论计算 网页链接 2023/09/20 DP+ABACUS还能干这个：钙钛矿氧化物通用力场UniPero 网页链接 2023/09/16 ABACUS@Notebooks \\ 边学边练，随时随地运行的 DFT 软件使用教程 网页链接 2023/09/07 ABACUS新进展：基于数值原子轨道基的meta-GGA密度泛函的实现 网页链接 2023/09/06 ABACUS开发者大会 \\ 聚焦国产密度泛函理论开源软件的进步与挑战 网页链接 2023/08/01 ABACUS 3.3 发布：自动化测试工作流赋能高效研发，为代码质量保驾护航 网页链接 2023/07/13 LibRI：携手 DeepModeling 社区，助力超越常规 DFT 方法的高阶方法计算 网页链接 2023/05/26 ABACUS 3.2 发布：支持 Hefei-NAMD 接口，全面提升代码稳定性和易用性 网页链接 2023/04/01 ABACUS 还能干这个？探索准一维材料碳纳米管中的无序超均匀性 网页链接 2023/03/07 ABACUS 3.1 发布，支持平面波基组下的 GPU 高效计算，发布固液界面计算新功能 网页链接 2023/01/01 探索 AI+DFT 最前线，「原子算筹」ABACUS 3.0 重磅发布！ 网页链接 2022/10/02 探索 AI+DFT 最前线，「原子算筹」ABACUS 3.0 重磅发布！ 网页链接 2022/10/01 ABACUS 3.0：共建 AI 辅助的新一代电子结构算法平台 网页链接 2022/10/01 ABACUS 新进展：用混合随机密度泛函理论方法模拟极端高温物质电子性质 网页链接 2022/09/20 以合作促发展：共建国产密度泛函理论开源软件 ABACUS 网页链接 2022/09/14 ABACUS 新进展：能带反折叠（band unfolding）方法及相关应用 网页链接 2022/07/22 v2.3 来了！ABACUS 小步快跑，重大升级，更快更稳更好用！ 网页链接 2022/07/01 ABACUS 新进展：用密度泛函理论模拟千原子以上半导体电极表面反应 网页链接 2022/06/21 DeePKS+ABACUS：构建高精度第一性原理计算与机器学习势函数的桥梁 网页链接 2022/06/13 ABACUS 2.2 版本介绍 网页链接 2022/04/08 涓流汇沧海，积篑成丘山：一位科学家与 ABACUS 的十五年 网页链接 2021/09/28 ABACUS ：携手 DeepModeling，做源自中国、开源开放的 DFT 软件 网页链接 2021/09/22 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-02 10:29:19 "},"abacus-contribute.html":{"url":"abacus-contribute.html","title":"如何贡献 ABACUS 使用教程","keywords":"","body":"如何贡献ABACUS使用教程 一、明确教程格式 第一行，写作者姓名，单位，联系方式（例如Github ID或者邮箱），如果不愿意透露作者信息，也可以不写 第一部分“介绍”：本文档教程要展示的例子、要教授的内容有哪些，相关知识可以给一些参考文献。 第二部分“准备”：介绍输入文件需要哪些，最好是能够提供输入文件的下载（例如网上github仓库），或者直接贴上输入文件 第三部分“流程”：最好通过图文结合的方式，一步步的介绍每一步的命令，能得到什么结果。 第四部分“结语”：对这个功能使用需要注意的地方，或者可以应用的场景都可以给与相关介绍 二、投稿 写好教程，检查无误后，AISI内部直接把稿件发给陈默涵老师（邮箱mohanchen@pku.edu.cn），或者向DeepModeling社区（deepmodeling@deepmodeling.com）投稿，审核通过后会加入到“ABACUS使用教程汇总” Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-04 10:08:19 "}}