{"./":{"url":"./","title":"ABACUS 使用教程","keywords":"","body":"ABACUS使用教程 一、介绍 ABACUS（Atomic-orbtial Based Ab-initio Computation at UStc，中文名原子算筹）是国产开源密度泛函理论软件，相关介绍 ABACUS 的新闻可在ABACUS 新闻稿整理查看，以下是一些常用地址： ABACUS 在 DeepModeling 社区中的 GitHub 仓库地址为： https://github.com/deepmodeling/abacus-develop ABACUS 的 Gitee 镜像仓库地址为： https://gitee.com/deepmodeling/abacus-develop ABACUS 网站访问： http://abacus.ustc.edu.cn/ 文档（包括安装方法、输入输出参数介绍、功能介绍、算例介绍、开发者须知等）： https://abacus.deepmodeling.com/en/latest/ 本教程系列旨在帮助新手用户入门了解 ABACUS 的使用。秉着开源软件的理念，本文档是由开源社区的老师同学们贡献所成。如果你也想贡献一份文档，我们十分欢迎，请参考如何贡献ABACUS使用教程。 本教程中标有 Logo的部分可以直接在Bohrium Notebook上打开。 在Bohrium Notebook上快速学习，见快速开始 ABACUS｜自洽 能带 态密度 结构优化；在Bohrium平台上运行大任务，见教程。 二、ABACUS基本操作教程 ABACUS的编译介绍 官方编译教程 GCC 编译 ABACUS 教程 Intel oneAPI 编译 ABACUS 教程 编译 Nvidia GPU 版本的 ABACUS 在超算环境编译 ABACUS 的建议 ABACUS 在曙光 DCU 集群上的编译与使用 ABACUS toolchain 脚本集 (md文档待整理) ABACUS 编译教程系列之一：基于Intel编译器（B站视频） ABACUS 编译教程系列之二：基于CUDA（B站视频） ABACUS 编译教程系列之三：docker的使用（B站视频） ABACUS建模介绍 准备晶胞和原子位置等信息的文件STRU：如何转换STRU的格式 准备赝势： 模守恒赝势生成方法简介 数值原子轨道基组生成教程： 数值原子轨道（一）：ABACUS 中的数值原子轨道命名和使用方法 数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道 数值原子轨道（三）：产生高精度数值原子轨道 Kohn-Sham密度泛函理论 电子自洽迭代 带自旋的体系计算：ABACUS磁性材料计算使用教程 +U计算：ABACUS使用DFT+U计算教程 |基础版 结构优化：ABACUS 使用教程｜结构优化 ABACUS 的平面波计算与收敛性测试 分子动力学：ABACUS 分子动力学使用教程 DeePKS方法 DeePKS基础篇 DeePKS案例篇 + 增强采样 ABACUS 隐式溶剂模型使用教程 随机波函数密度泛函理论：ABACUS 随机波函数DFT方法使用教程 无轨道密度泛函理论：ABACUS 无轨道密度泛函理论方法使用教程 采用ABACUS进行表面计算 静电势和功函数 偶极修正 表面能计算 表面缺陷能和吸附能计算 外加电场 补偿电荷 分析结果 能带计算 ABACUS+Atomkit 计算态密度和能带 PDOS计算 ABACUS里怎样做DOS和PDOS计算 和其他软件对接 ABACUS+Phonopy 计算声子谱 ABACUS+ShengBTE 计算晶格热导率 ABACUS+Phono3py 计算晶格热导率 ABACUS+DPGEN 使用教程 ABACUS+LibRI 做杂化泛函计算教程 ABACUS+Candela 使用教程 ABACUS+USPEX 接口教程 ABACUS+Hefei NAMD 使用教程 ABACUS+Wannier90 使用教程 ABACUS+pyatb 能带反折叠计算 ABACUS+DeepH 建立碳材料的哈密顿量模型 ABACUS+ASE接口使用技巧 ABACUS+ASE 做过渡态计算 ATST-Tools: ASE-ABACUS过渡态计算工作流套件与算例 支持NEB，Dimer，AutoNEB等过渡态方法。 ABACUS-ASE做NEB计算 （简单算例） ABACUS+ASE 遗传算法 （暂缺，待更新） 三、使用经验 ABACUS 答疑手册 ABACUS 收敛性问题解决手册 有VASP使用背景的用户上手ABACUS教程：ABACUS新人使用的一些注意事项 四、开发者文档 ABACUS 开源项目 C++ 代码规范 ABACUS 中使用格式化工具 clang-format ABACUS 注释规范：Doxygen 入门 (c++) ABACUS 的 Github 仓库 Issues 处理流程 ABACUS 线上文档输入参数撰写规范 ABACUS 代码存放规范 ABACUS 全局数据结构和代码行数检测 ABACUS 中的测试（一）：测试的重要性 ABACUS 中的测试（二）：测试工具 gtest Introduction to ABACUS: Path to PW calculation - Part 1 Introduction to ABACUS: Path to PW calculation - Part 2 Introduction to ABACUS: Path to PW calculation - Part 3 Introduction to ABACUS: Path to PW calculation - Part 4 Introduction to ABACUS: Path to PW calculation - Part 5 Introduction to ABACUS: Path to PW calculation - Summary 1 Introduction to ABACUS: Path to PW calculation - Part 6 Introduction to ABACUS: Path to PW calculation - Part 7 Introduction to ABACUS: Path to PW calculation - Part 8 Introduction to ABACUS: Path to PW calculation - Part 9 Introduction to ABACUS: Path to PW calculation - Part 10 Introduction to ABACUS: Path to PW calculation - Part 11 Introduction to ABACUS: Path to PW calculation - Summary Final 如何在 ABACUS 中新增一个输入参数（截至 v3.5.3） C++ 程序设计的一些想法 五、算法文档 最大局域化 Wannier 函数方法简介 电荷密度混合算法介绍 在 ABACUS 中进行差分测试 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-04-22 20:26:37 "},"abacus-gcc.html":{"url":"abacus-gcc.html","title":"GCC 编译 ABACUS 教程","keywords":"","body":"GCC 编译 ABACUS 教程 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/19 一、介绍：关于 ABACUS ABACUS（原子算筹）软件同时支持两种基矢量，一种是平面波（Plane wave，PW） 基组，一种是 LCAO (Linear combination of atomic orbitals)或者称 NAO(Numerical atomic orbitals)基组。因为两种基组运行依赖的软件库不完全相同，所以我们分开介绍。 实际上，LCAO 基组依赖的软件库比 PW 基组更多，因此如果用户只使用 PW 基组，并不需要将所有依赖的数学库全都下载安装好。 下面介绍，两种基组分别都依赖那些数学库： PW 基组依赖以下 3 个 数学库： BLAS：BLAS（Basic Linear Algebra Subprograms）是一组基本的线性代数库，用于高效执行常见的基础线性代数运算，如矩阵乘法和向量操作。 LAPACK：LAPACK（Linear Algebra Package）是一个开源的数值线性代数库，用于解决线性代数问题，包括矩阵分解、方程组求解和特征值计算等。 FFTW3：FFTW3（Fastest Fourier Transform in the West 3）是一个高性能、开源的快速傅里叶变换（FFT）库，用于高效计算各种傅里叶变换和逆变换。 LCAO 基组依赖以下 6 个 软件库： BLAS LAPACK FFTW3 ScaLAPACK：ScaLAPACK（Scalable LAPACK）是一种并行计算库，构建在 LAPACK 之上，用于解决大规模线性代数问题，特别适用于分布式和并行计算环境。 CEREAL：CEREAL 是一个 C++ 序列化库，用于将 C++ 对象转换为可存储或传输的数据格式，以及将其反序列化回对象。 ELPA：ELPA（Eigenvalue SoLvers for Petaflop-Applications）是一个用于高性能计算的开源库，旨在解决大规模高性能计算中的特征值问题，特别是密集矩阵的特征值问题。（用户编译安装 abacus 的时候大多在这里出现问题） ELPA仅用于 LCAO基组求解特征值与特征矩阵的过程，如果由于机器等原因导致 ELPA 难以安装，可以暂不安装ELPA，在编译 abacus 的时候添加-DUSE_ELPA=0即可绕过ELPA安装困难的问题。 在ABACUS中，LCAO基组求解特征值与特征矩阵提供了两种方法，一种是调用ELPA进行求解（默认选项），一种是调用ScaLAPACK进行求解。 如果使用-DUSE_ELPA=0编译选项，请参考使用文档配置ks_solver为scalapack_gvx，调用ScaLAPACK进行求解。（http://abacus.deepmodeling.com/en/stable/advanced/input_files/input-main.html#ks-solver） 二、检查当前服务器基础环境： 1. 查看当前系统版本： root@bohrium-11852-1041346:~# lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 20.04.5 LTS Release: 20.04 Codename: focal 2. 检查当前 GCC 编译器版本： root@bohrium-11852-1041346:~# g++ --version g++ (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0 Copyright (C) 2019 Free Software Foundation, Inc. 3. 检查当前环境是否有 git root@bohrium-11852-1041346:~# git --version git version 2.25.1 三、安装 仅支持 PW 基组的 ABACUS 对于仅支持 PW 基组的 ABACUS，我们同时支持两种版本的编译：串行版本和并行版本。 编译这两个版本的主要区别在于是否需要安装 MPI library。 1. 编译串行版本 1.1 安装依赖库。 sudo apt update sudo apt install -y libopenblas-openmp-dev sudo apt install -y liblapack-dev sudo apt install -y libfftw3-dev 1.2 从仓库克隆代码到本地，并进入目录。 git clone https://github.com/deepmodeling/abacus-develop.git cd abacus-develop/ 1.3 开始编译并安装 abacus。 cmake -B build -DENABLE_MPI=OFF cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus_pw_serial 可执行文件。 abacus_pw_serial 就是串行版本的支持平面波基组的 ABACUS。 2. 编译并行版本 2.1 安装依赖库。（同串行，如果已经安装，则不用重复操作） sudo apt update sudo apt install -y libopenblas-openmp-dev sudo apt install -y liblapack-dev sudo apt install -y libfftw3-dev 2.2 安装 MPI library。这里选择更为常用的 open MPI。 sudo apt install -y libopenmpi-dev 2.3 从仓库克隆代码到本地，并进入目录。 git clone https://github.com/deepmodeling/abacus-develop.git cd abacus-develop/ 2.4 开始编译并安装 abacus。 cmake -B build -DENABLE_LCAO=OFF cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus_pw 可执行文件。 abacus_pw 就是并行版本的支持平面波基组的 ABACUS。 四、安装 支持两种基组的 ABACUS 对于同时支持两种基组的 ABACUS，仅可以编译并行版本。并无串行版本。 在本文最初就提到支持 LCAO 基组的 ABACUS 所依赖软件库的更多。 1. 安装 PW 基组依赖的软件库。（同上，如果已经安装，则不用重复操作） sudo apt update sudo apt install -y libopenblas-openmp-dev sudo apt install -y liblapack-dev sudo apt install -y libfftw3-dev 2. 安装 MPI library。这里选择更为常用的 open MPI。（同上，如果已经安装，则不用重复操作） sudo apt install -y libopenmpi-dev 3. 安装 LCAO 基组依赖的 ScaLAPACK 和 CEREAL 软件库。 sudo apt install -y libscalapack-mpi-dev sudo apt install -y libcereal-dev 4. 安装 ELPA 软件库。（一般这里容易出问题） 如果你的系统是 Ubuntu 22.04，那么你可以以很简单的方式成功安装 ELPA： sudo apt install -y libelpa-dev 如果你的系统不是 Ubuntu 22.04，很可惜，你需要稍微辛苦一点来安装 ELPA。但别急，这也并不难！ 手动编译安装 ELPA 可以分为以下几步： 下载并进入 ELPA 目录： wget https://elpa.mpcdf.mpg.de/software/tarball-archive/Releases/2021.05.002/elpa-2021.05.002.tar.gz tar xzf elpa-2021.05.002.tar.gz cd elpa-2021.05.002 mkdir build && cd build configure ../configure --enable-openmp CFLAGS=\"-O3 -march=native -funsafe-loop-optimizations -funsafe-math-optimizations -ftree-vect-loop-version -ftree-vectorize\" FCFLAGS=\"-O2 -mavx\" --disable-avx512 编译安装 make -j`nproc` make install ln -s /usr/local/include/elpa_openmp-2021.05.002/elpa /usr/local/include/ 注意：ln -s /usr/local/include/elpa_openmp-2021.05.002/elpa /usr/local/include/ 是非常重要的！（很多用户是这里出的问题！） 5. 开始编译并安装 abacus。 cmake -B build cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus 可执行文件。 abacus 就是完整版的 ABACUS，它同时支持两种基矢量，而且还是并行版本！ Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-04 12:04:49 "},"abacus-intel.html":{"url":"abacus-intel.html","title":"Intel oneAPI 编译 ABACUS 教程","keywords":"","body":"Intel oneAPI 编译 ABACUS 教程 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/21 一、前言 非特殊情况，linux 系统会默认安装 GCC（GNU Compiler Collection）编译器套件。因此如果你的机器默认没有 Intel® oneAPI Toolkits，那么建议，你可以直接看上一篇文章：GCC 编译 ABACUS 教程 。 如果您的机器恰好有 Intel® oneAPI Toolkits，那么您也可以使用它来编译 ABACUS。 二、关于 Intel® oneAPI Toolkits Intel® oneAPI Toolkits 分为很多个版本的 Toolkit，这里解释下 Intel® oneAPI Base Toolkit 和 Intel® oneAPI HPC Toolkit 的区别。 简单来说：Intel® oneAPI HPC Toolkit 包含 Intel® oneAPI Base Toolkit。 Intel® oneAPI Base Toolkit 中包含：Intel® oneAPI Math Kernel Library（简称为 MKL），这个软件库里面包含了大量常用的数学库，包括 ABACUS 依赖的 BLAS、LAPACK、FFTW3 和 ScaLAPACK 4 个软件库。 因此使用 Intel oneAPI 来编译 ABACUS，可以省去逐个去安装数学库的过程！ Intel® oneAPI HPC Toolkit 相比于 Intel® oneAPI Base Toolkit 多了一些必要的 Intel 的编译器以及 Intel® MPI Library（ABACUS 想要编译并行版本必须的关键库）。 总结一下，使用 Intel oneAPI 编译 ABACUS，必须确保你的机器中包含 Intel® oneAPI HPC Toolkit。 关于 Intel® oneAPI Toolkits 更详细的信息：https://www.intel.com/content/www/us/en/developer/tools/oneapi/toolkits.html#hpc-kit 三、编译 安装 开启 Intel® oneAPI Toolkits： source /opt/intel/oneapi/setvars.sh ELPA仅用于 LCAO基组求解特征值与特征矩阵的过程，如果由于机器等原因导致 ELPA 难以安装，可以暂不安装ELPA，在编译 abacus 的时候添加-DUSE_ELPA=0即可绕过ELPA安装困难的问题。 在ABACUS中，LCAO基组求解特征值与特征矩阵提供了两种方法，一种是调用ELPA进行求解（默认选项），一种是调用ScaLAPACK进行求解。 如果使用-DUSE_ELPA=0编译选项，请参考使用文档配置ks_solver为scalapack_gvx，调用ScaLAPACK进行求解。（http://abacus.deepmodeling.com/en/stable/advanced/input_files/input-main.html#ks-solver） 1. 安装 仅支持 PW 基组的 ABACUS 对于仅支持 PW 基组的 ABACUS，我们同时支持两种版本的编译：串行版本和并行版本。 ABACUS 的 PW 基组只依赖：BLAS、LAPACK、FFTW3 三个数学库，而这三个数学库都已经被 Intel® oneAPI Base Toolkit 中包含：Intel® oneAPI Math Kernel Library（简称为 MKL）所包含，因此我们不需要再安装其他的软件库！ 1.1 编译串行版本 CXX=icpx cmake -B build -DENABLE_MPI=OFF cd build && make -j`nproc` 注意，这里必须指定CXX=icpx，不然系统会使用默认的 CXX 编译器。同时这里的 CXX 也不要指定 icpc，icpc 是 Intel® C++ Compiler Classic，会带来一些报错。 可以看到在当前目录下，已经编译成功了 abacus_pw_serial 可执行文件。 abacus_pw_serial 就是串行版本的支持平面波基组的 ABACUS。 1.2 编译并行版本 CXX=icpx cmake -B build -DENABLE_LCAO=OFF cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus_pw 可执行文件。 abacus_pw 就是并行版本的支持平面波基组的 ABACUS。 2. 安装 支持两种基组的 ABACUS 对于同时支持两种基组的 ABACUS，仅可以编译并行版本。并无串行版本。 完整版的 ABACUS 需要依赖更多的软件库：BLAS、LAPACK、FFTW3、ScaLAPACK、CEREAL、ELPA共 6 个。 而前四个数学库（BLAS、LAPACK、FFTW3、ScaLAPACK）都已经被 Intel MKL 所包含，因此我们只需再额外安装CEREAL、ELPA即可。 2.1 安装 CEREAL sudo apt install -y libcereal-dev 2.2 安装 ELPA 如果你的系统是 Ubuntu 22.04，那么你可以以很简单的方式成功安装 ELPA。 sudo apt install -y libelpa-dev 如果你的系统不是 Ubuntu 22.04，很可惜，你需要稍微辛苦一点来安装 ELPA。但别急，这也并不难！ 注意；这里手动编译安装 ELPA 的方法与在 GCC 下编译不太一样，因为要保证 ELPA 和 ABACUS 都是基于 Intel oneAPI 来编译的！ 手动编译安装 ELPA 可以分为以下几步： 下载并进入 ELPA 目录： wget https://elpa.mpcdf.mpg.de/software/tarball-archive/Releases/2021.05.002/elpa-2021.05.002.tar.gz tar xzf elpa-2021.05.002.tar.gz cd elpa-2021.05.002 mkdir build && cd build configure CC=mpiicc CXX=mpiicpc FC=mpiifort ../configure --enable-openmp FCFLAGS=\"-qmkl=cluster\" 编译安装 make -j`nproc` make install ln -s /usr/local/include/elpa_openmp-2021.05.002/elpa /usr/local/include/ 注意：ln -s /usr/local/include/elpa_openmp-2021.05.002/elpa /usr/local/include/ 是非常重要的！（很多用户是这里出的问题！） 2.3 编译安装 ABACUS CXX=icpx cmake -B build cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus 可执行文件。 abacus 就是完整版的 ABACUS，它同时支持两种基矢量，而且还是并行版本！ Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-04 12:04:49 "},"abacus-gpu.html":{"url":"abacus-gpu.html","title":"编译 Nvidia GPU 版本的 ABACUS","keywords":"","body":"编译 Nvidia GPU 版本的 ABACUS 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024/03/15 一、介绍 本教程旨在介绍 ABACUS 在支持 NVIDIA GPU 的服务器上的编译与使用。 当前 ABACUS 支持的 GPU 并行计算 INPUT 文件中 device 参数需设置为 gpu。 目前 GPU 版本的 ABACUS 仅支持 PW 基组的计算，因此 INPUT 文件中 basis_type 参数仅能设置为 pw。 详细请看官方文档：https://abacus.deepmodeling.com/en/latest/advanced/acceleration/cuda.html LCAO 基组的 GPU 计算版本近期会发布。 NVIDIA GPU & CUDA NVIDIA GPU (Graphics Processing Unit) 是由一种专门设计来处理图形和并行计算任务的电子芯片。自从 NVIDIA 推出其首款 GPU 以来，它们已经从仅仅处理视频游戏图形的设备发展成为能处理各种高性能计算和深度学习任务的强大工具。 CUDA（Compute Unified Device Architecture），是显卡厂商 NVIDIA 推出的运算平台。 CUDA 是一种由 NVIDIA 推出的通用并行计算架构，该架构使 NVIDAI GPU 能够解决复杂的计算问题。 为了使 ABACUS 的部分功能支持 NVIDIA GPU，ABACUS 开发团队针对 NVIDIA GPU 写了大量的 CUDA 代码，使其在 NVIDIA GPU 上有较高的运行效率。相比于 CPU 版本的计算任务，有极高的效率提升！ 新闻稿：https://mp.weixin.qq.com/s/D8gcQb0bikMdgizLsbvCfQ 二、检查环境 检查当前环境是否有 NVIDIA GPU nvidia-smi 命令帮助检测你的服务器是否有 NVIDIA GPU 设备。 nvcc --version 命令帮助你检测你的服务器软件环境中是否包含 cuda toolkit 更详细的内容查看：https://abacus.deepmodeling.com/en/latest/advanced/acceleration/cuda.html#required-hardware-software 三、编译 如果您已经尝试过使用 GCC 编译 ABACUS 教程 或者 Intel oneAPI 编译 ABACUS 教程，那么编译支持在 NVIDIA GPU 上运行的 ABACUS 十分简单。 在保证可以正常编译 CPU 版本的 ABACUS 的环境下，使用： cmake -B build -DUSE_CUDA=1 # for GCC cd build && make -j`nproc` # or CXX=icpx cmake -B build -DUSE_CUDA=1 # for Intel oneAPI cd build && make -j`nproc` 这样编译出来的 abacus 可执行文件就是支持 NVIDIA GPU 运行的 ABACUS。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-03-15 15:08:11 "},"abacus-hpc.html":{"url":"abacus-hpc.html","title":"在超算环境编译 ABACUS 的建议","keywords":"","body":"在超算环境编译 ABACUS 的建议 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/26 由于不同超算环境提供的软件包版本各不相同，因此我们没办法提供给您确切的安装方法。 但是，我们将在本篇文档中介绍一些在超算环境中编译安装 ABACUS 的注意事项和相关知识。 如果在具体编译操作过程中遇到了任何问题，请随时联系我们。 一、关于 ABACUS 首先，再次简单介绍一下 ABACUS。ABACUS（原子算筹）软件同时支持两种基矢量，一种是平面波（Plane wave，PW） 基组，一种是 LCAO (Linear combination of atomic orbitals) 或者称 NAO (Numerical atomic orbitals) 基组。 用户可以编译 仅支持 PW 基组的 ABACUS 或者 同时支持两种基组的 ABACUS。同时，针对 PW 基组的 ABACUS，用户还可以选择编译串行版本或并行版本。但因为这个文档的主题是如何在超算环境中编译 ABACUS（应该没有人在超算上跑串行的 ABACUS 吧），我们接下来只会介绍并行版本的编译方法。如果想要在普通的服务器上安装串行版本的 PW 基组的 ABACUS，可以参考 GCC 编译 ABACUS 教程 · GitBook 和 Intel oneAPI 编译 ABACUS 教程 · GitBook。 二、超算平台的简单介绍： 1. 关于 Modules 一般情况下，大多数超算平台是通过 Environment Modules 来管理基础软件库的。 如何使用 Modules？这里提供一些参考的教程：软件模块使用方法 - 上海交大超算平台用户手册 Documentation 2. 超算上编译 ABACUS 的基本路线 在超算平台上编译 ABACUS，同样也有两种选择： 一种是 基于 GCC（the GNU Compiler Collection）编译 一种是 基于 Intel oneAPI 或者 Intel Parallel Studio 编译 不得不说，使用 Intel oneAPI 将会简单很多！因此，如果你所使用的超算平台正好有 Intel oneAPI ，那么请毫不犹豫的使用它！ 2.1 ABACUS 依赖的软件库 C/C++ 编译器：由于 ABACUS 是由 C++ 语言编写的软件，所以一定需要 C++ 编译器。 Fortran 编译器：Fortran 编译器并不直接用于编译 ABACUS 软件，而是需要用其编译 ABACUS 所依赖的数学库：BLAS、LAPACK、ScaLAPACK 和 ELPA。（这四个软件都是使用 Fortran 语言写的，因此需要依赖 Fortran 编译器） MPI 库：如果要编译并行版本的 ABACUS，那么 MPI Library 是必须的。同时也需要注意，如果你选择自己编译 ScaLAPACK 和 ELPA，那么 MPI Library 也是必须的。 数学库： BLAS：BLAS（Basic Linear Algebra Subprograms）是一组基本的线性代数库，用于高效执行常见的基础线性代数运算，如矩阵乘法和向量操作。 LAPACK：LAPACK（Linear Algebra Package）是一个开源的数值线性代数库，用于解决线性代数问题，包括矩阵分解、方程组求解和特征值计算等。 FFTW3：FFTW3（Fastest Fourier Transform in the West 3）是一个高性能、开源的快速傅里叶变换（FFT）库，用于高效计算各种傅里叶变换和逆变换。 ScaLAPACK：ScaLAPACK（Scalable LAPACK）是一种并行计算库，构建在 LAPACK 之上，用于解决大规模线性代数问题，特别适用于分布式和并行计算环境。 ELPA：ELPA（Eigenvalue SoLvers for Petaflop-Applications）是一个用于高性能计算的开源库，旨在解决大规模高性能计算中的特征值问题，特别是密集矩阵的特征值问题。（用户编译安装 abacus 的时候大多在这里出现问题） CEREAL：CEREAL 是一个 C++ 序列化库，用于将 C++ 对象转换为可存储或传输的数据格式，以及将其反序列化回对象。 如果你只编译 仅支持 PW 基组的 ABACUS，那么你不需要安装 ScaLAPACK、ELPA 和 CEREAL。他们是 LCAO 基组才依赖的软件库。 2.2 基于 Intel oneAPI 编译 ABACUS 首先在此介绍一下 Intel oneAPI 和 Intel Parallel Studio 的区别。用户可能在超算平台上同时看到 Intel oneAPI 和 Intel Parallel Studio。这是因为 Intel Parallel Studio 是 oneAPI 的前身，或者说 Intel Parallel Studio 是 oneAPI 的子集。Intel Parallel Studio 在 2020 年已经停止维护，而 Intel oneAPI 却是在 2019 年 11 月正式提出。因此我们可以将 Intel oneAPI 看作是 新版的 Parallel Studio 或加强版。 Intel oneAPI（Intel® oneAPI Toolkits）同时包含 C/C++ 编译器、 Fortran 编译器 和 Intel MPI Library。因此如果加载了 Intel oneAPI 环境，也就不用再次加载其他的 MPI Library。除此之外，Intel oneAPI 还包含了 Intel® oneAPI Math Kernel Library（简称为 MKL），这个软件库里面包含了大量常用的数学库，包括 ABACUS 依赖的 BLAS、LAPACK、FFTW3 和 ScaLAPACK 4 个软件库。 因此，如果你只编译 支持 PW 基组的 ABACUS，那么 Intel oneAPI 就已经可以解决所有的依赖问题。 如果你要编译 同时支持两种基组的 ABACUS，那么还需要手动编译安装 ELPA 和 CEREAL，安装完成后，可以参考官方文档中的 ABACUS-Installation-Options 编译 ABACUS。 注意： 在使用 Intel oneAPI 编译 ABACUS 的时候，并不意味着软件环境中不需要 GCC。 refer：How the Compiler Uses GCC Intel compilers 需要使用 GCC 中的头文件和库。因此同时也需要加载 GCC。 2.3 基于 GCC 编译 ABACUS GCC（the GNU Compiler Collection）它同时包含 C/C++ 编译器和 Fortran 编译器，但其不包含 MPI Library。因此我们还需要额外的 MPI 库（Open MPI 或者 MPICH）。 由于这是基于 GCC 编译 ABACUS，如果用户所使用的超算环境中没有提供 BLAS、LAPACK、FFTW3、ScaLAPACK、ELPA 和 CEREAL 的 modules，那么这些数学库都需要用户一个个手动编译安装。 在安装完成后，可以参考官方文档中的 ABACUS-Installation-Options 编译 ABACUS。 三、拓展教程 1. ABACUS 高级编译选择： Easy Installation ‒ ABACUS documentation Advanced Installation Options ‒ ABACUS documentation 2. 超算平台使用教程推荐： 上海交大超算平台用户手册 中国科大超算中心用户使用手册 北大超算手册 超算小站 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-26 19:08:07 "},"abacus-dcu.html":{"url":"abacus-dcu.html","title":"ABACUS 在曙光 DCU 集群上的编译与使用","keywords":"","body":"ABACUS 在曙光 DCU 集群上的编译与使用 作者：贾志炜，邮箱：jiazhiwei@stu.pku.edu.cn 审核：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 最后更新时间：2023/07/07 一、介绍 本教程旨在介绍 ABACUS 在 曙光 DCU 计算平台 上的编译与使用。 1. DCU DCU (Deep Computing Unit) 是一款面向人工智能、科学计算的高性能全功能 GPGPU (General-Purpose computing on Graphics Processing Units) 加速卡。 中科海光基于 DCU 硬件提供完整的软件工具链，以 DTK(DCU toolkit)为基础软件层为开发者提供运行、编译、调试和性能分析等功能，并提供多种深度优化的计算加速库。DCU 加速卡支持 ROCm/Hip 并行架构。 曙光计算集群采用 CPU 和 DCU 加速卡（Deep Computing Unit）相结合的异构融合计算体系结构。 2. ABACUS 的异构并行计算 INPUT 文件中 device 参数需设置为 gpu。 目前 GPU/DCU 版本的 ABACUS 仅支持 PW 基组的计算，因此 INPUT 文件中 basis_type 参数仅能设置为 pw。 二、准备 1. 曙光计算平台 用户需要在平台上申请异构计算资源： https://ac.sugon.com/doc/1.0.6/30000/general-handbook/platform/source.html 2. E-shell 曙光计算平台采用 E-shell 来对管理节点进行操作。 可使用网页版或 E-Shell Client。 不可直接运行任务，而是使用 Slurm 调度系统。 采用 modules 工具 来管理环境变量与系统依赖项。许多依赖如编译器版本等可以通过 modules 来处理。 3. slurm Slurm 工作调度工具是面向 Linux 和 Unix 及类似内核的免费和开源工作调度程序，可以方便用户进行作业的提交、管理、监测。 sinfo: 查看系统资源。 squeue: 查看当前作业状态。 salloc: 分配节点的作业提交，用 salloc 申请的节点会在当前终端退出时释放掉。用于程序测试以及中小型任务的提交。 sbatch: 批处理模式的作业提交，需要编写 slurm 作业提交脚本。在 E-shell 的默认目录存有 slurm 脚本模板。在下面的流程中也会介绍提交 ABACUS 任务的脚本案例。 srun: 交互式提交作业命令，有屏幕输出，但容易受网络波动影响，断网或关闭窗口会导致作业中断。 三、流程 1. 配置超算环境 module avail # 列出已有环境 module list # 查看当前已加载环境 module load # 加载环境 module unload # 卸载环境 昆山节点 module purge 1) compiler/devtoolset/7.3.1 2) compiler/rocm/dtk-22.10 3) compiler/cmake/3.17.2 4) mpi/hpcx/2.6.0/gcc-7.3.1 乌镇节点 1) compiler/devtoolset/7.3.1 2) compiler/dtk/23.04 3) compiler/cmake/3.23.1 4) mpi/hpcx/gcc-7.3.1 对于使用其他 DCU 节点（合肥、哈尔滨、西安）的用户，如果 module 中没有找到类似的环境，欢迎在 ABACUS 仓库 提出 issue，我们将尽力协助解决。 2. 编译 ABACUS 依赖软件包 目前按照 DCU 版本已验证的编译方法，有三个数学库需要自行编译。 若曙光平台网络连接不畅，请在软件官网选择合适的软件包，再用曙光平台的 E-File 传送至节点。 FFTW: https://fftw.org/pub/fftw/fftw-3.3.10.tar.gz OpenBLAS: https://github.com/xianyi/OpenBLAS/releases/download/v0.3.21/OpenBLAS-0.3.21.tar.gz ScaLAPACK: https://github.com/Reference-ScaLAPACK/scalapack/archive/refs/tags/v2.2.0.tar.gz 2.1 编译 FFTW tar -zxvf fftw-3.3.10.tar.gz mkdir build ./configure --prefix=/work/home/your_username/fftw-3.3.10/build cd ~/fftw-3.3.10/build make make install FFTW 需要编译单精度版本和双精度版本： cd ~/fftw-3.3.10/build ./configure --prefix=/work/home/your_username/fftw-3.3.10/build --enable-float make make install 2.2 编译 OpenBLAS tar -zxvf OpenBLAS-0.3.23.tar.gz cd OpenBLAS-0.3.23 make USE_OPENMP=1 NO_AVX512=1 FC=\"gfortran -fPIC\" CC=\"gcc -fPIC\" -j8 mkdir build make PREFIX=/work/home/your_username/OpenBLAS-0.3.21/build install 2.3 编译 ScaLAPACK cp SLmake.inc.example SLmake.inc 复制包中提供的 SLmake.inc.example 作为基准，并对 SLmake.inc 的内容作出一部分修改: FC = mpif90 -fPIC CC = mpicc -fPIC BLASLIB = LAPACKLIB = -L/work/home/your_username/OpenBLAS-0.3.21/build/lib -lopenblas make 3. 编译 DCU 版本的 ABACUS git clone https://gitee.com/deepmodeling/abacus-develop # main分支 cd abacus-develop mkdir build cd build CMake 配置： 指定编译器为 clang，关闭 OpenMP、LCAO 计算模块，设定三个数学库的位置，设定 USE_ROCM=ON。 CC=clang CXX=clang++ cmake -B build -DUSE_OPENMP=OFF -DENABLE_LCAO=OFF \\ -DFFTW3_DIR=/work/home/your_username/fftw-3.3.10/build/ \\ -DLAPACK_DIR=/work/home/your_username/OpenBLAS-0.3.21/build/lib \\ -DSCALAPACK_DIR=/work/home/your_username/scalapack-2.2.0/ \\ -DUSE_ROCM=ON Make 编译：make 部分建议不要并行编译。 make 4. 提交任务 salloc（中小型任务与交互性程序测试） salloc -p [队列名] -N 1 -n 32 --gres=dcu:4 ... load text ... salloc: Waiting for resource configuration salloc: Nodes node_num are ready for job # 分配计算节点，可用ssh直接连接 ssh node_num ...交互式进行计算任务 sbatch（大型任务与批量提交） 写一个作业提交脚本，可以参考以下结构： #!/bin/bash #SBATCH --job-name=ABACUS_GPU #SBATCH --partition=kshdnormal #SBATCH --nodes=1 #SBATCH --output=output.log #SBATCH --ntasks-per-node=32 #SBATCH --mail-user=username@email #SBATCH --gres=dcu:4 #dcu个数 #SBATCH --time=01:00:00 #SBATCH --error=error.log #以上的SBATCH信息会由slurm识别 abacus=/work/home/your_username/abacus-develop/build/abacus_pw #设置环境 module purge module load compiler/devtoolset/7.3.1 module load compiler/rocm/dtk-22.10 module load compiler/cmake/3.17.2 module load mpi/hpcx/2.11.0/gcc-7.3.1 #运行脚本 cd your_task_path mpirun -np 4 $abacus sbatch abacus_dcu.slurm 作业已提交，可在“作业管理”中查看。 四、结语 DCU 可以提高 ABACUS 计算性能，也充分利用了 ROCm 并行框架，使得 ABACUS 异构计算能应用在更多的平台上。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-04 10:08:19 "},"abacus-question.html":{"url":"abacus-question.html","title":"ABACUS 答疑手册","keywords":"","body":"ABACUS 答疑手册 作者：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024/04/05 一、背景 本文档适用于想用 ABACUS（原子算筹）来做电子结构计算的科研工作者。 PW：Plane Wave，指平面波 NAO：Numerical Atomic Orbitals，指数值原子轨道 LCAO：Linear Combination of Atomic Orbitals，指局域轨道，在 ABACUS 里面也指数值原子轨道 基于过去几年来积累的用户问题，接下来本文档将尽量以问答的形式来替使用 ABACUS 的用户答疑解惑，例如： 问：ABACUS 和 ABAQUS 是什么关系？ 答：ABAQUS 是一款知名的多物理场有限元仿真分析软件，ABACUS 的英文单词翻译是算盘，ABACUS 作为一款国产密度泛函理论软件，中文名是原子算筹。 问：使用 ABACUS 需要收费吗？ 答：从软件的角度来讲不收费，因为是开源软件，但跑该软件的机器得自己准备，机器要交电费。 问：ABACUS 的开发过程是怎样的，什么人可以成为开发者？ 答：ABACUS 的代码开发记录完全公开，所有代码的修改都在 https://github.com/deepmodeling/abacus-develop 网页上可以查到，ABACUS 为所有感兴趣的参与者都保留了成为开发者的可能性，每个人都有可能称为开发者。 二、ABACUS 使用建议 1. 编译 1.1 从哪里可以下载到 ABACUS 的代码？ 答：如果可以接 github，可以登录 https://github.com/deepmodeling/abacus-develop，建议下载最新版本使用，因为软件一直在更新，总体而言新版本的 bugs 会更少。 如果网络不方便登录 github，还可以登录国内网站 https://gitee.com/deepmodeling/abacus-develop.git 下载。 1.2 怎么安装 ABACUS？ 答：可以参考官方文档 https://abacus.deepmodeling.com/en/latest/quick_start/easy_install.html 也可以登录网址 https://mcresearch.gitee.io/abacus-user-guide/，上面有一些针对不同编译器的中文编译教程。 另外，注意“安装 ABACUS”这句话其实有歧义，ABACUS 有很多不同的安装选项，比如是否只安装支持平面波的功能，还是也要安装支持数值原子轨道的功能，是否要使用 LIBXC 等等不同选项，可根据自己的需要来安装具体的代码模块。 1.3 如何在曙光的 DCU 上编译 ABACUS？ 答：可参考文档 https://mcresearch.gitee.io/abacus-user-guide/abacus-dcu.html 2. 计算前准备 2.1 PW 计算需要准备的文件？ 答：INPUT 文件控制输入参数，STRU 文件包含晶胞、原子信息和赝势；KPT 文件包含布里渊区 k 点信息。这三个文件默认是放在一个文件夹内的。但是 INPUT 文件里其实可以控制结构文件所在地址，以及 KPT 文件所在地址。 2.2 KPT 文件什么时候不适用？ 答：第一，在使用 DPGEN 的时候，强烈建议设置 kspacing 这个参数，而不是在 KPT 文件里设置 k 点的个数，这是为了做不同大小体系密度泛函计算的时候，使得计算的精度尽量持平，从而得到不同结构里精度相当的总能量和受力，这对于 DPMD 的训练很重要。第二，LCAO 可以在 INPUT 使用 gamma_only（设为 1），那么 KPT 文件不起作用，所有计算只用到 Gamma（0，0，0）这个 k 点，这种情况下体系有更快速的特殊算法，效率更高，计算内存的消耗也更小。 2.3 LCAO 基组相比于 PW 基组需要额外准备的文件？ 答：数值原子轨道文件，下载地址为 https://abacus.ustc.edu.cn/pseudo/list.htm。注意轨道文件要和对应的赝势相匹配。 关于数值原子轨道的背景知识，可以参考文档： https://mcresearch.gitee.io/abacus-user-guide/abacus-nac1.html https://mcresearch.gitee.io/abacus-user-guide/abacus-nac2.html https://mcresearch.gitee.io/abacus-user-guide/abacus-nac3.html 2.4 能量截断值收敛性测试是必须要做的吗？ 答：是的，除非你或者别人之前已经做过了，得到了推荐的能量截断值。否则，一般来讲一个给定的赝势（模守恒或者超软赝势），你需要从低到高逐步增加能量截断值来判断总能量已经收敛。 2.5 关于长度单位 答：没有注意到单位的转换是初学者容易犯的错之一。长度单位 Angstroms（埃）和 Bohr 的转换关系需要了解（1 埃=1.8897259886 Bohr，反过来 1 Borh=0.529177249 Angstroms，转换时候尽可能多地取有效数字，会让原子坐标更准确），不同软件的长度单位可能有取得不同的情况，涉及到晶格矢量、原子位置，以及坐标系转换（Direct 和 Cartesian 的区别，前者是晶格坐标系，后者单位才是长度单位），如果原子位置或者晶胞设错了，不同软件计算结果就会不同。一个小技巧判断不同软件的晶格结构和原子坐标是否一样：可以看不同软件算出来的 Ewald 能量（周期性边界条件下算离子-离子库伦排斥能的快速算法），如果 Ewald 能量能对上（精确到小数点后 10 位以上），那么说明两个软件的原子坐标和晶格矢量设置都是一样的。 2.6 关于能量单位 答：涉及到能量单位的有多处。首先是平面波的能量截断值，VASP 经常用的是 eV，QE 和 ABACUS 用的是 Ry，这两者有转换关系（1 Ry=13.605703976 eV），所以用 VASP 习惯的用户需要把对应的 eV 转换成 Ry 再使用 ABACUS。其次是 smearing 的参数选择，例如 0.015，其单位是 Ry 或者 eV 也对结果有较大影响。 3. 基矢量 3.1 ABACUS 支持的基矢量有几种？ 答：分成 PW（平面波）和 LCAO（具体来讲是 Numerical atomic orbitals，NAO，即数值原子轨道）两种，目前 ABACUS 都支持，像是 VASP 和 QE 只支持 PW，SIESTA 和 OpenMP 支持 LCAO。还有一种叫 lcao_in_pw，就是把 NAO 展开成平面波进行计算，但一般只用于测试目的。 3.2 怎么选择是采用 PW 还是用 LCAO 基矢量来做计算？ 答：如果是较小原子数的固体体系，建议可以采用 PW 效率较高。如果是体系原子数较大（例如大于 50 个原子），建议可以用 LCAO 试试，效率会更高。此外，当使用 LCAO 做计算时，可以先用 PW 这组相对完备的基组来测试赝势带来的能量收敛性。 3.3 如果感觉 LCAO 的效率慢，可能的原因是否和基矢量有关系? 答：ABACUS 里采用的 LCAO 的局域轨道长度一般在 6-10 au 之间，轨道的截断越长，往往计算精度越高，但计算量和内存消耗也会显著的更大。如果要提高速度，可以在尽可能不影响精度（需要自己测试）的前提下，减小数值原子轨道的半径，这样可以大幅度提升计算效率以及降低内存占用量。 3.4 ABACUS 中 LCAO 的 Ecut 是做什么用的？ 答：LCAO 和 PW 一样，都会有一个 Ecut，在使用 LCAO 的时候，增加 Ecut 只会增加局域势格点积分部分的精度（赝势的局域部分 + 交换关联势 +Hartree 势），并不增加数值原子轨道基矢量的完备性，所以原先用于 PW 的收敛性测试方法是不能这样直接用于 LCAO 的。如果要增加 LCAO 的基矢量使得基矢量更完备，需要从例如 DZP 增加到 TZDP，而不是增加 Ecut。 3.5 LCAO 算小分子和固体有什么要注意的？ 答：使用局域轨道的话，会有 BSSE（Basis set superposition error），对于小分子体系，BSSE 带来的误差会较为严重，使得对于一些分子体系，有必要采用更完备的基矢量（或者更长的局域轨道）或者 BSSE 修正。而对于固体系统，一般来讲每个原子会有若干近邻原子，这些近邻原子上的局域轨道会使得在描述每个原子的电子结构时基矢量总体更完备，所以可以相对选择更短的局域轨道。 3.6 如果算出来 SZ 结果比 DZP 好，是否可以用 SZ 结果？ 答：采用 LCAO 时，SZ（single zeta 轨道）的结果一般来讲都不收敛，一般不可以用来发表文章。一般至少是 DZP 及以上才认为基矢量较为准确，是学界可以认可的 NAO 精度。 4. 赝势 4.1 PAW 是不是赝势？ 答：准确来说不是，是一种描述电子-离子相互作用的方法。 4.2 为什么不同软件算出来的统一体系的总能量差距可能会巨大？ 答：因为同样的元素，其不同的赝势（或 PAW 势）允许总能量有一个常数的偏移，因为都对库伦势进行了人为的修改。所以，我们一般在分析结果的时候也不用总能量这个数值，而是用总能量之间的差别，例如 bcc 相比于 fcc 更稳定这种结论，不同赝势哪怕总能量不对齐，其算出来的 bcc 和 fcc 之间的能量差也应该是对齐的。另外一件事情就是画态密度（Density of States，DOS）的时候，我们习惯把费米面取成 0 点，也是因为总能量是可以有一个常数的偏移的。 4.3 赝势为什么和交换关联泛函有关？ 答：因为赝势生成过程中解的是一维的 Kohn-Sham 方程，这个过程也用到了泛函，所以不同泛函生成的赝势就不同。 4.4 赝势改变了，什么参数需要重新测试？ 答：因为电子和离子的描述方式变了，所以需要重新测试能量截断值 Ecut 的收敛性，即增加 Ecut，看总能量变化，例如从 90 Ry 变到 100 Ry，如果总能量变化小于 1 meV/atom，则认为可以收敛。 4.5 别人文献看到的某元素的能量截断值，是否可以直接拿过来使用？ 答：一般来说是不可以，例如用了 VASP 的 PAW 势，就难以直接拿到模守恒赝势里使用。 5. 电子自洽迭代过程 5.1 为什么 ABACUS 的 SCF 计算比 VASP 慢很多？ 答：首先，先检查 Ecut 是否一样（注意 ABACS 的单位是 Ry，VASP 是 eV，要换算），一般来讲 VASP 用 PAW 方法所需的 Ecut 比 ABACUS 的模守恒赝势要低，目前来讲这部分参数 VASP 占优，你并不能降低 ABACUS 的 Ecut 来和 VASP 的 Ecut 持平。第二，检查你所计算的元素的电子数，往往电子数不同，计算效率会有很大差别。例如 Ga 的模守恒赝势可能有 13 个电子，但 VASP 的 Ga 的 PAW 势可能只有 3 个电子，那么 VASP 的计算效率会快很多也是可以预期的。 5.2 电子自洽迭代里的展宽技术是用来做什么的？ 答：电子自洽迭代过程中使用的展宽（一般称为 Smearing）是一种数值技术，它用于提高计算中的收敛稳定性和速度，尤其是在处理金属和其他导体体系时非常有用。展宽通常采用几种不同的办法来实施，例如费米-狄拉克展宽（Fermi-Dirac smearing）、高斯展宽（Gaussian smearing）、Methfessel-Paxton 展宽等，它们代表不同的电子占据数分布方法。 5.3 电子自洽迭代收敛结果和 smearing 相关吗？ 答：对于没有带隙的金属体系是相关的，采用 smearing 会在体系总能量里额外引入一个电子熵项。一般来讲 smearing_sigma 取得越大越容易收敛，但是要注意的是，smearing_sigma 取大了，总能量结果也愈发不准确。因此在迭代接近收敛时，通常需要逐步减少展宽值，以得到更加准确的接近零温的结果。对于半导体来讲，一般较小的 smearing 参数不影响总能量结果。 5.4 只要体系不收敛，就可以调整 smearing 吗？ 答：在项目里对一系列相关体系进行密度泛函理论计算，如果需要用到这些体系的总能量相对值，但发现有体系不收敛，我可以针对不同体系调整不同的 smearing 参数吗？一般不可以，因为 smearing 可能会改变总能量的数值。 5.5 电荷密度混合是用来做什么的？ 答：在电子自洽迭代过程中，需要不断更新电荷密度，直到输入的电荷密度和由此计算得到的输出电荷密度之间的差异足够小，即达到自洽。混合的具体方法有很多种，比如简单的线性混合、Broyden 混合、Pulay 混合（也称为 DIIS，Direct Inversion in the Iterative Subspace）等。这些方法通过考虑前几次迭代的电荷密度和/或电荷密度差异，来改进当前迭代的电荷密度估计。 5.6 总能量收敛、受力和应力是否收敛了？ 答：一般来讲，总能量在 SCF 中收敛到几乎不变时，受力和应力不一定完全收敛。如果是对受力或者压力敏感的计算，建议也测试一下相应受力和应力是否收敛（即继续降低 scf_thr 数值，设置更严格收敛阈值）。 6. 原子位置和晶胞结构优化(弛豫) 6.1 原子位置和晶胞结构优化有什么需要注意的？ 答：首先要注意的就是，原子位置和晶胞结构优化较慢，很耗机时，动辄就是几十上百个进程跑一两天。所以，如果不是很有把握了解你要算的体系，或者不是特别熟练密度泛函理论计算，建议动手算之前找导师聊一聊这样做的可行性，这样做一方面也是可以少走科研上的弯路，另外一方面也能有效的帮助导师节省机时费。 6.2 原子位置和晶胞结构优化有什么技巧？ 答：首先，就是要小心一些参数不要设多了，例如不要包含太多费米面上方非占据的轨道，如果体系没有磁矩，没有必要打开自旋极化计算（nspin=2）。其次，如果你能预估偏离最终的构型较大，那你可以先采用低精度的方法达到一个接近最终构型的一个临时构型。例如，没有必要用 181818 的 k 点（虽然你认为这样才能完全收敛总能量）来做优化，你可以先选一个 999 的 k 点 mesh 来做。第三，如果你是做的一系列相关结构的原子位置和晶胞结构优化，可以想办法构造一些更好的初猜结构，除非考虑亚稳态的存在，否则一开始猜测的结构越接近，所需要的优化步数就越少。第四，BFGS 算法一般适用于偏离稳定结构较小的情况，而 cg 一般用于偏离稳定结构较大的情况。 6.3 做结构优化很多步都不收敛，怎么办？ 答：首先，检查每一步的 SCF 是否收敛，如果不收敛，先让 SCF 能收敛，再做结构优化。其次，如果能不用 cell-relax 而只用 relax，建议尽量先用 relax，把晶胞内的原子位置先固定住了，最后再做 cell-realx，这样效率更高。原因是如果把 cell 的自由度和原子的自由度一起考虑做 relax，往往效率较低。 6.4 采用 LCAO 和 PW，结构优化收敛上有什么区别？ 答：PW 基组更完备，一般结构优化可以收敛到 0.001 eV/Angstroms。而 LCAO 由于基矢量不够完备，存在诸如 egg box effect 的误差，所以求力能收敛到的精度一般要差一些，通常 0.04 eV/Angstroms 以下是可以接受的，也有不少文章采用这个精度来发表结果，是被认可的。 7. 并行 7.1 MPI 并行和 OpenMP 并行的区别是什么？什么叫进程，什么叫线程？ 答：MPI 进程和 OpenMP 线程的差别，前者内存是不共享的，后者内存是共享的。 7.2 是不是进程或者线程越多，计算就越快？ 答：举个例子，用 7au 的 DZP 轨道算 512 个 Fe 原子的体系，K 点 111，以下是运行时间（OMP 代表线程数，MPI 代表进程数）：1 OMP x 32 MPI = 262s 每电子步；1 OMP x 64 MPI = 581s 每电子步；1 OMP x 128 MPI = 654s 每电子步；1 OMP x 256 MPI = 765s 每电子步。可以看到进程越多，计算反而越慢，这是因为进程间的通讯量随着进程数增多变大了。所以，并不是用的计算资源越多，计算就会越快，建议做计算前先评估好并行效率。 7.3 K 点并行（也就是 KPAR 这个参数），要怎么理解它的使用？ 答：对 PW 来说，不同 K 点的 Kohn-Sham 方程求解（即寻找特征值和特征向量）是比较独立的，因此如果给定了总的进程数，我们可以想办法把不同 K 点的方程求解尽可能并行，KPAR 代表我们要将 K 点分成几组，因此原则上 KPAR 越大效率应该越高。如果 KPAR 设成 1，那么程序执行时是用平面波来并行，在某些时候，平面波并行效率也挺高，因此看不出 K 点并行的优势。对 LCAO 来说，KPAR 并行的优势不大，因此目前 ABACUS 不支持 LCAO 的 K 点并行功能。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-04-05 17:37:42 "},"abacus-conv.html":{"url":"abacus-conv.html","title":"ABACUS 收敛性问题解决手册","keywords":"","body":"ABACUS 收敛性问题解决手册 作者：周巍青，邮箱：zhouwq@aisi.ac.cn 单位：北京科学智能研究院（AISI） 最后更新日期：2024/2/22 如果遇到手册中无法解决的收敛性问题，欢迎给 ABACUS 提出 Issues，我们将持续更新这个文档 可选参数 mixing_type 描述：混合电荷密度所使用的方法 可选：broyden，pulay，plain 默认值：broyden 说明：没有特殊理由，不建议更改这个参数 mixing_ndim 描述：DIIS 混合计算混合系数时会保存的历史电荷密度数目 可选：int 默认值：8 说明：一般而言，这个值越大，收敛性越好，但是代价是内存消耗线性增加，8 一般是够用的。 mixing_beta 描述：电荷密度的混合系数，1.0 时表示全部用输出电荷，0.0 时表示全部用输入电荷 可选：double 默认值：0.8（nspin=1）；0.4（nspin=2|4） 说明：一般而言，这个值越大，收敛越快，但是 SCF 跑飞不收敛的风险也越大；这个值越小，收敛越慢，但是收敛会更稳定，不收敛的情况会减少。 mixing_gg0 描述：电荷密度混合时所做的 kerker 预处理的强度。Kerker 预处理会显著降低一些低频长程的电荷波动，对于金属性体系的收敛帮助极大。 可选：double 默认值：1.0 说明：默认 1.0 代表 ABACUS 默认打开 kerker 预处理，你可以手动设置成 0.0 将其关闭。一般而言，绝缘体/分子/原子体系中 kerker 预处理的效果不明显，甚至有负优化，可以关闭。 mixing_gg0_min 描述：电荷密度的混合系数，所做的 kerker 预处理中，小于这一$|q|$的电荷分量不再进一步衰减 可选：double 默认值：0.1 说明：没有特殊理由，不建议更改这个参数 mixing_beta_mag 描述：磁密度的混合系数，只在 nspin=2|4 时才会启用 可选：double 默认值：4*mixing_beta，但是最大不超过 1.6 说明：与电荷密度的混合类似，这个值越大，收敛越快，但是 SCF 跑飞不收敛的风险也越大；这个值越小，收敛越慢，但是收敛会更稳定，不收敛的情况会减少。 mixing_gg0_mag 描述：磁密度的混合时所做的 kerker 预处理的强度 可选：double 默认值：0.0 说明：默认 0.0 代表 ABACUS 默认关闭对磁密度的 kerker 预处理，你可以手动设置成非零将其打开。一般而言，对于磁密度的 Kerker 预处理物理意义并不明确，不建议打开。 mixing_angle 描述：使用J. Phys. Soc. Jpn. 82 (2013) 114706中所描述的角度混合来更新电荷密度，只在非共线计算，即 nspin=4 时才可以启用 可选：double 默认值：0.0 说明：默认 0.0 代表 ABACUS 默认不使用这个方法，还是默认优先使用传统的 DIIS 混合。你可以手动设置成非零将其打开。这一方法可以解决非共线计算中磁矩收敛困难、收敛到错误磁态的问题。 mixing_tau 描述：是否混合动能密度，只在 metaGGA 计算中才能使用 可选：bool 默认值：false 说明：ABACUS 默认不混合动能密度。但是打开一般会提升收敛性。 mixing_dmr 描述：使用混合电荷密度的系数，同样混合密度矩阵。打开这一参数的前提必须同时设置 mixing_restart 可选：bool 默认值：false 说明：ABACUS 默认不混合密度矩阵。如果你在进行需要密度矩阵构建算符的计算，例如 DFT+U/EXX/DeePKS，你可以试图打开 mixing_dmr。经过我们大量的 DFT+U 算例测试，mixing_dmr 配合一个合适的 mixing_restart 会显著地提升 ABACUS 计算的收敛性。 mixing_restart 描述：在第 mixing_restart 步 SCF 清空 mixing 的历史，直接使用上一步的输出作为这一步的输入，一般与 mixing_dmr 配合使用 可选：int 默认值：0 说明：ABACUS 默认不进行 restart，一个不适合的 mixing_restart 设置可能导致计算收敛不了。 如果收敛困难怎么办 非磁计算（nspin=1） 非磁实际上可调的自由度不多，所有体系都可以遵循的原则如下： 尝试调小 mixing_beta 尝试调大 mixing_ndim 分情况，你可以进一步有如下特殊的操作： 原子分子体系 原子分子的电荷高度局域，Kerker 预处理一般都难以实际取得正优化，你可以选择关闭 Kerkerk 预处理，mixing_gg0=0.0。 半导体/绝缘体 虽然绝缘体部分电子态也很局域，但是 Kerker 预处理一般是安全的，即使负优化也不会很严重，但是你仍可以选择关闭 Kerkerk 预处理，mixing_gg0=0.0。 金属 调节不同的 mixing_gg0、mixing_gg0_min。 metaGGA 计算 打开 mixing_tau=true。一般会解决 metaGGA 收敛困难，以及 EDIFF 慢于 DRHO 的问题。 检查初始构型 一般而言，你不会在非磁计算遇到收敛性问题。如果真的遇到了，有很大概率初始构型太差，你可以调整构型，或者用先用宽松的收敛判据做几步弛豫计算，让体系构型更合理之后再调小 scf_thr。 共线磁性计算（nspin=2） 磁性计算中所有体系都可以遵循的原则如下： 尝试调小 mixing_beta，并等比例调小 mixing_beta_mag 尝试调大 mixing_ndim 分情况，你可以进一步有如下特殊的操作： 原子分子体系 孤立体系的磁性计算如果出现无法收敛，那大概率是出现一种极端的情况，即某一自旋全部来自某一轨道，不会叠加态。这种情况一旦出现，默认参数无法收敛。这时，请保证电荷密度和磁密度的混合系数完全一致： mixing_beta 0.4 mixing_beta_mag 0.4 mixing_gg0 0.0 mixing_gg0_mag 0.0 相信这个设置之后，问题就会解决。 半导体/绝缘体 与非磁建议一致。 金属 与非磁建议一致。 metaGGA 计算 打开 mixing_tau=true。一般会解决 metaGGA 收敛困难，以及 EDIFF 慢于 DRHO 的问题。 DFT+U 计算 如果你的 DFT+U 计算无法收敛，我们推荐你做如下设置： mixing_restart 10 mixing_dmr 1 mixing_restart=10 代表 SCF 的计算会在第 10 步直接用第 9 步的输出电荷开启一个新的 SCF，在那之后 DFT+U 的计算同时也会混合密度矩阵。在大多数情况下，10 是一个安全有效的设置，但请务必记住 mixing_restart 的设置是危险的，设置之后，你可能会遇到： 本来不设置这 2 个参数还可以收敛，只是收敛的不快，设置之后完全不能收敛了。 答：那是因为 mixing_restart 的位置选取不合适，在 mixing_restart 前一步的输出密度很差，用其做初始密度使得计算直接跑飞。这个时候，我们建议你观察不开 mixing_restart 时候，drho 的收敛曲线，找一个距离基态近一些的位置做 mixing_restart（例如 drho）。 本来不能收敛，设置这 2 个参数之后，仍然不能收敛 答：大概率是 mixing_restart 的晚了，此时 SCF 已经跑飞，结合 drho 的收敛曲线，适当提前 mixing_restart 的位置。 弛豫计算 在弛豫计算中可以分多步做 relax，会使用上一步的 SCF 的磁矩做下一步优化的初始磁矩。这样对于弛豫计算的收敛性帮助巨大。 非共线磁性计算（nspin=4） 在使用传统的 DIIS 计算时，即 mixing_angle=0.0，参数建议与共线磁性一致。但是如果尝试之后，仍难以收敛，或收敛到错误的磁态，那么我们建议你进行如下的设置： mixing_angle 1.0 我们实现了J. Phys. Soc. Jpn. 82 (2013) 114706中的新方法，这个方法寻找非共线基态的能力大大强于传统的 DIIS 混合。相信会对你有帮助。 其他 FAQ 我可以在 STRU 中不设置初始磁矩，就设置成 0 吗？ 答：可以。当 STRU 中所有元素的初始磁矩都是 0 的时候，我们会自动为体系中的所有原子都赋予大小为 1 a.u.的原子磁矩。但是我们仍建议你设置它，因为一个好的初始磁矩对于计算的收敛速度和正确性都有巨大的帮助。 我可以在计算中设置 NUPDOWN 来帮助收敛吗？ 答：可以。一个合理的 NUPDOWN 设置一般会使得计算收敛地比较稳定。但是这么做的前提是，一定要对所做的体系很可靠的先验知识。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-02-22 12:50:47 "},"abacus-upf.html":{"url":"abacus-upf.html","title":"模守恒赝势生成方法简介","keywords":"","body":"模守恒赝势生成方法简介 作者：陈涛，邮箱：chentao@stu.pku.edu.cn；刘千锐，邮箱：terry_liu@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/30 一、介绍 UPF（unified PP format）是一种类似 XML 格式的文件格式，用于存储赝势及其相关参数。该格式由 Quantum ESPRESSO（QE）团队开发，并已成为许多量子计算软件包的标准格式之一。 ABACUS（截至 v3.2.3）的 Kohn-Sham 密度泛函理论计算主要支持 UPF 格式的模守恒赝势，在使用 ABACUS 过程中，一般可以直接使用网上已经生成好的赝势，常见的下载位置： ABACUS 官网 SG15-ONCV，参考文献：Optimization algorithm for the generation of ONCV pseudopotentials Quantum ESPRESSO 官网中的模守恒赝势 pseudo-dojo 官网（psp8 格式，需要转换） PWmat 官网 但是，在实际计算中，可能这些赝势并不符合当前的需求，这时候就需要自己生成模守恒赝势。可以通过其他格式赝势转换或者利用赝势软件生成两种方式来获得赝势。 注：ABACUS 的无轨道密度泛函理论计算（Orbital-Free Density Functional Theory，简称 OFDFT）需要用到一种特殊的局域势（不包含非局域势），一般采用 BLPS 局域赝势文件而非上文提到的 UPF 文件，如果做 OFDFT 计算的，可以阅读介绍 OFDFT 计算的文档，或者登录 Emily A. Carter 教授主页寻找相关的信息。 二、从其他格式赝势转换 1. 使用 QE upflib 中的 upfconv 进行转换 其支持将 UPF v.1 格式、vdb/van 格式（Vanderbilt US pseudopotential）、cpi/fhi 格式（FHI/abinit）转化成 UPF v.2 格式 path_to_QE/upflib/upfconv.x -u *.upf/UPF/vdb/van/cpi/fhi 注：这里的 path_to_QE 代表下载的 Quantum Espresso 的软件包地址。 注：文件夹 upflib 在 QE 5.x 和 6.x 版本名称为 upftools，在QE 7.x 版本为 upflib。 2. psp8 格式转换 psp8 格式是 ONCVPSP 软件生成的一种赝势格式，在 Abinit 官网（pseudo-dojo）中，其使用的就是 psp8 的格式，目前没有直接将 psp8 格式的赝势直接转换成 UPF 格式的脚本，但可以将 psp8 中输入文件部分摘抄下来，用 ONCVPSP 软件重新生成 UPF 格式的赝势（具体生成见下面 ONCVPSP 的讲解）。 可供参考的批量处理脚本：https://github.com/pipidog/ONCVPSP 三、赝势的生成 下面介绍三个可以生成 UPF 模守恒赝势的软件，分别是 ONCVPSP，Opium，和 ld1.x 1 ONCVPSP 1.1 介绍 ONCVPSP（Optimized Norm-Conservinng Vanderbilt PSeudoPotential）是由 D.R. Hamann 等人提出的优化版模守恒赝势，其有更高的精度与效率。ONCVPSP 依赖 Libxc，支持多种交换关联泛函。 参考文献：Optimized norm-conserving Vanderbilt pseudopotentials。 1.2 安装 1.2.1 安装 Libxc Libxc 网址：Libxc - a library of exchange-correlation functionals for density-functional theory 推荐下载 libxc-4.3.4 然后执行如下命令： cd libxc-4.3.4 ./configure --prefix='PATH/TO/LIBXC' CC=icc FC=ifort make make install 命令执行完毕后即可在 PATH/TO/LIBXC 目录下看到 bin,include 和 lib 三个目录，代表安装成功 1.2.2 安装 oncvpsp 推荐下载 oncvpsp-4.0.1 然后执行 cd oncvpsp-4.0.1，进入文件夹 这时需要修改 make.inc 文件 修改 F77 = ifort, F90 = ifort, CC = icc FFLAGS 删去 -ffast-math LIBS 改为 -qmkl=\"sequential\" LIBS+ 和 FFLAGS 中的地址改为自己的 PATH/TO/LIBXC 具体如下： # System-dependent makefile options for ONCVPSP # This must be carefully edited before executing \"make\" in src # # Copyright （c） 1989-2019 by D. R. Hamann, Mat-Sim Research LLC and Rutgers # University ##### Edit the following lines to correspond to your compilers #### F77 = ifort F90 = ifort CC = icc FCCPP = cpp FLINKER = $（F90） #FCCPPFLAGS = -ansi -DLIBXC_VERSION=301 #Use this for versions 400 ##### Edit the following optimization flags for your system #### FFLAGS = -O3 -funroll-loops CFLAGS = -O3 ##### Edit the following LAPACK and BLAS library paths for your system #### LIBS = -qmkl=\"sequential\" ##### Edit the following for to use libxc if available ##### OBJS_LIBXC = exc_libxc_stub.o # oncvpsp is compatible with libxc # To build oncvpsp with libxc, uncomment the e following lines and edit # the paths to point to your libxc library and include directories # make clean in src before rebuilding after changing this LIBS += -L/PATH/TO/LIBXC/lib -lxcf90 -lxc FFLAGS += -I/PATH/TO/LIBXC/include #LIBS += -L/home/drh/abinit/fallbacks/exports/lib -lxcf90 -lxc #FFLAGS += -I/home/drh/abinit/fallbacks/exports/include OBJS_LIBXC = functionals.o exc_libxc.o 然后执行如下命令： make # 如果make -j报错，可以忽略再make，即可编译成功 安装测试完成后，即可在 src 目录下看到 oncvpsp.x 可以在 ~/.bashrc 中增加如下命令将 oncvpsp.x 加入环境变量，方便直接调用： export PATH=$PATH:/PATH/TO/ONCVPSP/src 1.3 输入文件 输入文件的准备可以参考 PATH_TO_ONCVPSP/doc/32_Ge_annotated.dat，或者参考已知 ONCV 的赝势里面的 部分来写。 这里以铝（Al）为例，输入文件 Al.dat: # ATOM AND REFERENCE CONFIGURATION # atsym, z, nc, nv, iexc psfile Al 13 1 4 4 upf # # n, l, f （nc+nv lines） 1 0 2 2 0 2 2 1 6 3 0 2 3 1 1 # # PSEUDOPOTENTIAL AND OPTIMIZATION # lmax 1 # # l, rc, ep, ncon, nbas, qcut （lmax+1 lines, l's must be in order） 0 1.29163 0 5 8 10.3003 1 2.40653 0 5 8 7.02214 # # LOCAL POTENTIAL # lloc, lpopt, rc（5）, dvloc0 4 5 0.932267 0 # # VANDERBILT-KLEINMAN-BYLANDER PROJECTORs # l, nproj, debl （lmax+1 lines, l's in order） 0 2 0 1 2 0 # # MODEL CORE CHARGE # icmod, fcfact 0 0 # # LOG DERIVATIVE ANALYSIS # epsh1, epsh2, depsh -5.0 3.0 0.02 # # OUTPUT GRID # rlmax, drl 6.0 0.01 # # TEST CONFIGURATIONS # ncnf 0 # nvcnf # n l f 一些可以调整的参数如下： nc：c = core，芯电子层数 nv：v = valence，价电子层数，调整 nc 和 nv 可以改变赝势的价电子数 iexc：生成赝势所用的交换关联泛函，详情可参考 ONCVPSP-4.0.1 目录下 doc 内的 pwscf_exc.txt 文件，常用的如下 iexc==3 .or. iexc==-001009, 'functional=\"PZ\"' iexc==4 .or. iexc==-101130, 'functional=\"PBE\"' psfile：赝势格式，有 upf 和 psp8 两种。ABACUS 支持 upf 的格式 rc: rc 中较小的为赝势的截断半径。在温度较高或密度较大的温稠密体系，通常需要调整赝势的截断半径，推荐小于 0.7 倍维格纳半径，单位为 Bohr；每个 l 对应一个 rc，其中最小的为赝势的截断半径 rc（5）：rc 都要大于等于 rc（5）。例如 Al 的 l=0 的 rc 为 1.29163 Bohr，l=1 的 rc 为 2.40653 Bohr，rc（5） 为 0.932267 Bohr，因此该赝势的截断半径为 1.29163 Bohr。 qcut：通过调整（+-0.1），直到推荐 ECUT 达到最小 dvloc0：通过调整（+-0.5），直到消除赝势的 GHOST 态（可参考文献 Phys. Rev. B 41, 12264 (1990)） 1.4 生成赝势 执行命令： oncvpsp.x Al.out sed -n '//,//p' Al.out > Al.UPF 生成完赝势需要查看 Al.out 文件，确定没有 GHOST 态（可参考文献 Phys. Rev. B 41, 12264 (1990)）： Testing for highly-localized positive-energy ghosts l \\/rc E Basis Diag. E Cutoff 1 0.974041 120.256772 338.98 WARNING - GHOST（+） 如上，出现 WARNING - GHOST 说明有 GHOST，需要调整 dvloc0 （+-0.5）直到消除 GHOST 态 sed 命令是为了从 Al.out 文件中截取赝势文件到 Al.UPF 中 如果同时要画出类似 Phys. Rev. B 88, 085117 (2013) 的图，需要准备输入文件 Al.dat 并执行命令： sh PATH_TO_ONCVPSP/scripts/run.sh Al 可以画出如下的图： 图 1. 局域势函数与非局域势不同轨道角动量对应的半局域径向势函数 图 2. S赝波函数与全电子波函数对比 图 3. S的双投影波函数 图 4. 不同能级波函数在截断半径处log导数对比，其影响散射性质的计算 图 5. 不同轨道角动量对应的截断能 1.5 优化赝势 依次调节不同 l 对应的 qcut（+-0.1），检查对应 ECUT（l） 变化情况，直到 ECUT（l） 达到最小 参考的脚本： !/bin/bash qcut=17 dq=0.1 #遍历l=0的qcut从17到25，间隔为0.1，输出其对应的ECUT while [ `echo \"$qcut test.dat qcut$qcut.out grep -A 5 \"Energy error\" qcut$qcut.out > _tmp.txt E1=`sed -n \"6p\" _tmp.txt | awk '{print $3}'` E2=`sed -n \"13p\" _tmp.txt | awk '{print $3}'` E3=`sed -n \"20p\" _tmp.txt | awk '{print $3}'` E4=`sed -n \"27p\" _tmp.txt | awk '{print $3}'` # echo $qcut $E1 $E2 $E3 $E4 if [ `echo \"$E1>$E2\" | bc` == '1' ] ;then Emax1=$E1 else Emax1=$E2 fi if [ `echo \"$E3>$E4\" | bc` == '1' ];then Emax2=$E3 else Emax2=$E4 fi echo $qcut $Emax1 $Emax2 qcut=`echo \"$qcut+$dq\" | bc` done 不同的 l 都会有对应的能量截断值 ECUT(l)。一般 rc(l) 越小，对应的 ECUT(l) 越大，赝势也就越精确。由于 DFT 计算中的截断能 ECUT 是由赝势中较大的那个 ECUT(l) 决定，如果不同 l 的 ECUT(l) 相差很大，可以适当减小较小的 ECUT（l） 对应 l 的截断半径 rc，使得不同 l 对应的 ECUT(l) 更接近，这样并不会增加赝势计算的 ECUT，却可以提升精度。 这样调完之后如果有 GHOST 态，需要调整 dvloc0 （+-0.5）直到消除 GHOST 态，这个赝势才可使用 2. Opium Opium 软件包可以生成 RRKJ、TM 或 Kerker 径向波函数的赝势，官网有 LDA、GGA 赝势库（但是某些输入文件已经不匹配最新的 4.1 版本，需要稍作修改） 下载 Opium 之后利用 configure 安装： ./configure make 输入文件可以参考官网 LDA、GGA 赝势库，也可以参考 PATH_TO_OPIUM/tests，这里以铝（Al）为例，输入文件 al.param: [Atom] Al 6 100 2.00 -13.0 # reference configuration 200 2.00 -1.4 # reference configuration 210 6.00 -0.4 # reference configuration 300 2.00 -0.1 # reference configuration 310 0.95 -13.0 # reference configuration 320 -1.0 -0.0 # 这条能带是非束缚态，需要将占据数调成负数，官网给错了 [Pseudo] 3 1.85 1.85 1.97 opt [Optinfo] 7.07 10 # rc[a.u.] qc[sqrt（Ry）] Nb 7.07 10 7.07 10 [Configs] 3 # number of valence configurations # 300 2.00 -13.0 # nlm occ eigen（- means auto-generate） 310 1.00 -6.0 320 0.00 -6.0 # 300 1.00 -13.0 310 2.00 -6.0 320 0.00 -6.0 # 300 2.00 -13.0 310 0.00 -6.0 320 0.00 -6.0 [XC] gga [Relativity] srl 这里的参数可以参考官网手册 之后执行 opium al log all #输出在log文件里，依次执行全电子计算、计算赝势、计算非局域势、可移植性测试 opium al log upf #生成al.upf的输出文件 upfconv.x -u al.upf #利用QE的upflib将UPFv.1转化成UPFv.2格式 3. ld1.x QE 的 atomic 模块中的 ld1.x 支持生成赝势。其不仅可以生成模守恒赝势、还支持超软赝势、PAW 方法，支持全相对论、标量（非）相对论赝势（rel, non-rel/sca-rel），其径向波函数支持 TM（更稳定）与 RRKJ 两种方法，支持交换关联近似 7 类 LDA（ pz）,GGA（pbe, pbesol, revpbe, bp, wc, pw91。 下载好 QE 软件后，可以直接安装： ./configure make ld1 3.1 pslibrary 赝势库 推荐 ld1.x 生成其自带的 pslibrary 赝势库，下载好 pslibrary.1.0.0.tar.gz，解压，进入文件夹，修改 QE_path 文件，指定 QE 的路径。然后打开 make_ps 文件，解锁相应赝势： # These two files generate PAW and US PPs for all elements. These are # high accuracy - high kinetic energy cut-off PPs. # . ../paw_ps_high.job #默认打开的 . ../us_ps_high.job # # These two files generate additional PAW and US PPs for some elements. # These are less accurate PP than the previous one but require # lower kinetic energy cut-off or have less projectors or less semicore # states. # . ../paw_ps_low.job . ../us_ps_low.job # Uncomment the following line to generate the old pslibrary 0.3.1 PPs. # 打开下面的注释，可以解锁其余赝势 # #. ../paw_ps_collection.job #可以打开注释 #. ../us_ps_collection.job #可以打开注释 # Uncomment the following line to generate the NC-PPs. Be very careful # these PPs are completely untested. # 虽然可以生成，但其也提示该赝势的准确性并不能保证 # #. ../nc_ps_collection.job #可以打开注释 下面运行 ./make_all_ps 就能看到在一个个生成赝势库里的赝势： Making Ac.pz-spfn-kjpaw_psl.1.0.0.in ... Done Making Ac.pz-spfn-rrkjus_psl.1.0.0.in ... Done Making Ag.pz-n-kjpaw_psl.1.0.0.in ... Done Making Ag.pz-n-rrkjus_psl.1.0.0.in ... Done Making Ag.pz-spn-kjpaw_psl.1.0.0.in ... Done Making Ag.pz-spn-rrkjus_psl.1.0.0.in ... Done Making Al.pz-n-kjpaw_psl.1.0.0.in ... Done Making Al.pz-n-rrkjus_psl.1.0.0.in ... Done Making Al.pz-nl-kjpaw_psl.1.0.0.in ... Done Making Al.pz-nl-rrkjus_psl.1.0.0.in ... Done 如果不想生成所有的元素的赝势，则可以修改 make_ps 的 element，例如： element='C Si Ge' 3.2 生成自己的赝势 参数的详细解释见 PATH_TO_QE/atomic/Doc/INPUT_LD1.html 或线上的文档（不是最新的，建议前者），输入文件可以参考 pslibrary 赝势库的例子。 这里就简单给个 Al（铝）的例子，准备输入文件 al.in： &input title='Al', zed=13.0, rel=1, config='[Ne] 3s2 3p1 3d-2.0 4f-2.0', iswitch=3, dft='PBE' / &inputp pseudotype=2, file_pseudopw='Al.pbe-n-nc.UPF', #输入赝势 lloc=2, nlcc=.true., tm=.true. / 3 3S 1 0 2.00 0.00 2.60 2.60 0.0 3P 2 1 1.00 0.00 2.60 2.60 0.0 3D 3 2 0.00 0.10 2.60 2.60 0.0 运行 ld1.x 即可生成 Al.pbe-n-nc.UPF 模守恒赝势。 四、结尾 ABACUS 使用的是模守恒赝势，基于模守恒赝势还可以产生数值原子轨道，进行基于数值原子轨道的高效率密度泛函理论计算。有些情况下，网上提供的赝势不能满足需求，这个时候赝势的生成需要对赝势理论有比较深入的了解之后，才能调整好相关参数，生成质量较好的赝势。此外，生成之后，应该经过较为充分的测试，才能保证赝势的可移植性和正确性。如果大家有任何问题，欢迎发 email 至文档开头的邮箱。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-20 16:24:10 "},"abacus-nac1.html":{"url":"abacus-nac1.html","title":"数值原子轨道（一）：ABACUS 中的数值原子轨道命名和使用方法","keywords":"","body":"数值原子轨道（一）：ABACUS 中的数值原子轨道命名和使用方法 作者：梁馨元，邮箱：2201111875@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/07/18 一、数值原子轨道的背景知识 1. 数值原子轨道 对电子结构的求解可以在不同的表象下进行，电子的波函数以及势函数也可以在不同基矢量下表示，常用的有平面波和局域轨道等。LCAO（Linear Combination of Atomic Orbitals）方法就是通过局域的原子轨道来求解量子力学问题。其中局域轨道的选取方式有多种，例如高斯轨道（Gaussian type Orbitals，GTOs 或 Gaussians）、数值原子轨道（Numerical Atomic Orbitals）、万尼尔函数（Wannier Functions）等。 2. 数值原子轨道作为基矢量的优点 数值原子轨道作为基矢量有几个优点：第一，基矢量个数相比于一些常用的基矢量（例如平面波和实空间网格）大幅度降低；第二，数值原子轨道是局域的，空间上可以严格截断，采用数值原子轨道来构建体系的哈密顿量的效率可以达到线性标度的时间复杂度。 3. 构造数值原子轨道基组的几种方案 构造精度高、可系统提升数量、可移植性好的原子轨道基组颇有挑战，因此也有多种方案被提出。例如，Junquera 等人提出在一维薛定谔方程中加入不同形式的约束势场，从而求解出具有严格截断的数值原子轨道[1]。Ozaki 在 OpenMX 软件中采用变分的方法来优化局域轨道的形状，从而得出一组最优的数值原子轨道[2]。Volker 等人提出在一个大的局域轨道基组中挑选最合适的局域轨道组成不同等级的基组轨道，该方案用于全电子密度泛函理论软件 FHI-aims 中[3]。Chen 等人提出利用前人提出的溢出函数（Spillage function）[4-5]来构造可系统提高数量的数值原子轨道，其中每个轨道都由一组球贝塞尔函数作为基矢量展开，该轨道被用在 ABACUS（原子算筹）软件中[6]。 二、数值原子轨道的命名方法 1. 数值原子轨道的组成 数值原子轨道（Numerical Atomic Orbitals，简称 NAO）是目前在 ABACUS 程序中支持的一种基矢量。从数学形式上来看，数值原子轨道可以分解为径向函数 flζ 和球谐函数 Ylm 的乘积。 \\phi_{l m \\zeta}(\\mathbf{r})=f_{l \\zeta}(r) Y_{l m}(\\hat{r}), 其中 l 是角量子数，m 是磁量子数，ζ 代表了每个角量子数上对应的多个径向轨道，实际计算中通常采用多于 1 个轨道来增加基矢量的完备性。 2. 数值原子轨道的命名方法 数值原子轨道有一套常用的命名方案用来表示选取的基组大小，早期该命名方案在 SIESTA 软件中被采用[7][8][9][10]，后来在 OpenMX、FHI-aims 和 ABACUS 中也采取这套命名方案。具体来说是，对于每个被电子占据的角量子数 l，若采用 1 条径向轨道，则称该基组为 Single-ζ 轨道，简称 SZ 轨道基组。若采用 2 条径向轨道，则称该基组为 Double-ζ 轨道，简称 DZ 轨道基组。 目前，在许多赝势结合数值原子轨道的程序里，通常会在 DZ 轨道的基础上引入 1 条极化（polar）的径向轨道，即角量子数更高的轨道，来组成 DZP（Double-ζ valence orbitals plus SZ polarization） 轨道基组。此外，还有基组数量更大的 TZDP（Triple-ζ valence orbitals plus DZ polarization） 轨道等。 3. 数值原子轨道基组的个数 数值原子轨道基组的具体个数除了取决于轨道类别（比如 SZ、DZP、TZDP）外，也取决于元素种类、所选取的赝势。 轨道类别：比如对于 O 元素的赝势而言，一般将两个 1s 电子作为核内电子，在构造赝势的时候只考虑它的外层 6 个价电子部分 2s、2p 轨道，则该 O 赝势下的电子的极化轨道为 d 轨道。故它的 SZ（Single-ζ）轨道包含 1 组 s 轨道、1 组 p 轨道，共 1*1+1*3=4 个轨道；DZP 轨道包含 2 组 s 轨道、2 组 p 轨道、1 组 d 轨道，共包含 2*1+2*3+1*5=13 个轨道；TZDP 轨道包含 3 组 s 轨道、3 组 p 轨道、2 组 d 轨道，共包含 3*1+3*3+2*5=22 个轨道。 元素种类：比如同为 DZP 轨道，对于 H 元素（1 个价电子）即为 2 组 s 轨道、1 组 p 轨道（p 轨道也是 H 的极化轨道），共包含 2*1+1*3=5 个轨道。对于 O 元素即为 2 组 s 轨道、2 组 p 轨道、1 组 d 轨道，共包含 2*1+2*3+1*5=13 个轨道。 赝势：比如对于 Fe 元素而言，同为 DZP 轨道。若选取的赝势为，[Ne]3s^23p^64s^23d^6，即[Ne]=1s^22s^22p^6部分为芯电子，3s^23p^64s^23d^6部分为 16 个价电子，则 DZP 轨道包含 2*2 套 s 轨道（3s 和 4s）、2 套 p 轨道（3p）、2 套 d 轨道（3d）、1 套 f 轨道（极化轨道），即每个原子的 DZP 数值原子轨道个数为 2*2*1+2*3+2*5+1*7=27 个轨道。若选取的赝势为[Ar]4s^23d^6，则 DZP 轨道包含 2 套 s 轨道、2 套 d 轨道、1 套 p 轨道，共 2*1+2*5+1*3=15 个轨道。 三、ABACUS 中数值原子轨道的使用方法 1. ABACUS 中的数值原子轨道文件 ABACUS 提供了已经生成好的数值原子轨道库打包文件供下载（官网下载链接），对于绝大多数计算任务，这些数值原子轨道是经过精度和可靠性验证，可以直接使用的。这些轨道文件的开头提供了关于该轨道的重要信息。以 O_gga_7au_100Ry_2s2p1d.orb 轨道文件为例，首先文件名包含的信息有：氧元素（o），GGA 泛函（gga），数值原子轨道截断半径（7au，即 7 Bohr），推荐能量截断值（100 Ry），数值原子轨道个数（2s2p1d，2 个 s 的径向轨道，2 个 p 的径向轨道，1 个 d 的径向轨道）。值得注意的三个点是： ABACUS 里用到的模守恒赝势和轨道是需要匹配的。因为不同的赝势可能有不同的价电子，而数值原子轨道是用来描述这些价电子的，如果赝势的价电子多，则相应的默认数值原子轨道基组数量也会增多。 推荐用户直接使用轨道文件包含的能量截断值做计算。ABACUS 里的数值原子轨道在生成时，是尽量的去匹配平面波输出的波函数，从而优化得到的。而平面波计算是有一个能量截断值的，因此为了尽可能的保证 LCAO 的精度，我们建议直接使用推荐的能量截断值，而不需要真正做计算的时候做体系能量随着能量截断值变化的收敛性测试。当你在 LCAO 计算时改变能量截断值时候，其实只是改变了平面波的个数，这些平面波是用来做一些数值计算的，本质上并没有改变基矢量的个数，而基矢量的个数增加是靠改变基组大小，例如 DZP 到 TZDP 来实现的。 特殊情况可以自己生成数值原子轨道。如果用户有自己特殊的赝势，或者对目前提供的原子轨道的参数或者个数感觉不满意，例如对于导带的描述能力较差，也可以自己生成数值原子轨道，具体生成的方法可以参考这个系列文档的第二和第三篇。 打开以上提到的氧的数值原子轨道文件，文件的开头如下： --------------------------------------------------------------------------- Element O Energy Cutoff(Ry) 100 Radius Cutoff(a.u.) 7 Lmax 2 Number of Sorbital--> 2 Number of Porbital--> 2 Number of Dorbital--> 1 --------------------------------------------------------------------------- SUMMARY END 这里包括元素种类（Element），生成轨道时指定的截断能量值（Energy Cutoff）、截断半径（Radius Cutoff），最大角量子数（Lmax）及各角量子数轨道的个数（Number of * orbital，*为 S、P、D 等轨道角动量）。根据这些信息可以知道该轨道的类别，比如该举例文件即包含 O 的 DZP 轨道。 上述 ABACUS 提供的数值原子轨道文件中，在取名中即包含文件开头的重要信息，包括各角量子数的轨道个数。由这些轨道的文件名即可判断轨道类型。 轨道文件中包含的后续内容为不同类型、不同角量子数（L）的多个径向数值原子轨道（即不同 N）的具体数据，目前轨道是存在均匀格点上的，之后有可能也会支持非均匀格点。 2. 如何选择数值原子轨道文件 用户需要根据精度要求，选择数值原子轨道合适的截断能量值、截断半径及轨道类型。截断能量值、截断半径越大，轨道类型提升（SZ、DZP、TZDP），精度越高，结果更接近平面波。注意对于不同元素，要达到同样的精度，以上数值设置并不一定相同。 3. 如何修改数值原子轨道文件的设置，获得低精度轨道类型文件 在 ABACUS 中生成数值原子轨道文件时，可以设置同时生成多种精度的轨道文件，即设置 SIAB_INPUT 文件中的参数 Save Orbitals，详见篇目（三）。 如果已有一份数值原子轨道文件，但希望直接用此文件进行低精度计算，比如希望使用 DZP 轨道文件进行 SZ 计算。可以修改文件开头的信息实现，具体是 Lmax 及各角量子数轨道个数，将这些参数调整到低精度计算对应的数值。文件的后续内容不需要做更改。 比如对于 O 元素而言，DZP 轨道文件参数如 3.1 所示，若要进行 SZ 基矢量的计算，则将 Lmax 设置为 1，Number of Sorbital/Porbital/Dorbital=1/1/0 即可。 四、参考文献 [1] J. Junquera, Ó. Paz, D. Sánchez-Portal, and E. Artacho, Numerical Atomic Orbitals for Linear-Scaling Calculations, Phys. Rev. B, 64, 235111 (2001). [2] T. Ozaki, Variationally Optimized Atomic Orbitals for Large-Scale Electronic Structures, Phys. Rev. B, 67, 155108 (2003). [3] V. Blum, R. Gehrke, F. Hanke, P. Havu, V. Havu, X. Ren, K. Reuter, and M. Scheffler, Ab Initio Molecular Simulations with Numeric Atom-Centered Orbitals, Comput. Phys. Commun., 180, 2175 (2009). [4] M. Chen, G.-C. Guo, and L. He, Systematically Improvable Optimized Atomic Basis Sets for Ab Initio Calculations, J. Phys.: Condens. Matter, 22, 445501 (2010). [5] M. Chen, G.-C. Guo, and L. He, Electronic Structure Interpolation via Atomic Orbitals, J. Phys.: Condens. Matter, 23, 325501 (2011). [6] Liu Xiao-Hui et al., Introduction to first-principles simulation package ABACUS based on systematically improvable atomic orbitals, Acta Phys. Sin., 64, 187104 (2015). [7] Sánchez‐Portal D, Ordejon P, Artacho E, et al. Density‐functional method for very large systems with LCAO basis sets, J. International Journal of Quantum Chemistry, 65, 453-461 (1997). [8] Artacho E, Sánchez‐Portal D, Ordejón P, et al. Linear‐scaling ab‐initio calculations for large and complex systems, J. Physica Status Solidi (b), 215, 809-817 (1999). [9] Junquera J, Paz Ó, Sánchez-Portal D, et al. Numerical atomic orbitals for linear-scaling calculations, J. Physical Review B, 64, 235111 (2001). [10] Soler J M, Artacho E, Gale J D, et al. The SIESTA method for ab initio order-N materials simulation, J. Phys.: Condens. Matter, 14, 2475 (2002). Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-28 16:22:24 "},"abacus-nac2.html":{"url":"abacus-nac2.html","title":"数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道","keywords":"","body":"数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/15 在Bohrium Notebook上快速学习： 一、ABACUS 中的数值原子轨道背景知识 1. 数值原子轨道 ABACUS 中的三维数值原子轨道[1]：可以分解为径向部分与角向球谐函数的乘积，即 \\phi_\\mu(\\mathbf{r})=f_{\\mu, l}(\\mathbf{r}) Y_{l m}(\\hat{r}), 其中 \\mu=\\{\\alpha,i,\\xi,l,m\\}，\\alpha是原子种类的指标，i是每个原子种类对应的原子个数的指标，\\xi是角动量l对应的径向函数的个数，m是磁量子数。 径向部分函数：第 \\mu个轨道的径向部分函数可以写为球贝塞尔函数的线性组合(可参考文献[1]) f_{\\mu l}(\\mathbf{r})= \\begin{cases}\\sum_q c_{\\mu q} j_l(q r), & r 其中 j_l(q r)是波矢为q的球贝塞尔函数，r_c是径向部分的截断半径，满足关系j_l(q r_c)=0。q的个数由能量截断值决定（以下会介绍）。在实际计算里，通过用户指定每种元素的数值原子轨道截断半径和能量截断值来确定需要用到多少个球贝塞尔函数。组合系数 c_{\\mu q}是可优化的量，决定了数值原子轨道的形状。 2. 参考体系 参考系统：在ABACUS中构造某个元素对应的数值原子轨道的最普遍方式是为每个元素选取一组参考体系做平面波计算（可以是单k点也可以是多k点），得到这些参考体系的电子波函数，然后通过最小化自定义的一个溢出函数（下面会介绍）来优化c_{\\mu q}系数。换句话说，我们需要选定一组参考系统，生成数值原子轨道基组，并期望它们有良好的迁移性，以便可以在更一般的情况下使用。 Dimer（二聚体）：我们发现二聚体是较为合适的参考系统。具体来说，推荐选择的是若干个不同键长的二聚体（dimer），有时也可选择三聚体（trimer）或四聚体。对同一个元素，我们通常选择几个键长不同的二聚体（例如5-6个），这些键长覆盖二聚体稳定键长附近能量区间，通常可以取与最稳定能量差别为1-2个eV的能量曲线上的点。 周期性体系：数值原子轨道还有一些特殊用途，例如能带插值。面对这种场景，可以选择一系列带多个k点的周期性体系，此时参考态中的每个原子构型就对应了不同k点指标和不同能带指标的波函数，这些波函数会被用于最小化溢出函数来生成数值原子轨道，可以参考文献[2]。 3. 溢出函数 溢出函数（英文为spillage）：由给定参考体系的多个电子波函数与生成的数值原子轨道之间的差别来定义。换个角度理解，溢出函数的大小反映的是由一组“精确”波函数所张成的希尔伯特空间与局域轨道所张成的空间的差别。溢出函数定义如下： \\mathcal{S}=\\frac{1}{N_n} \\sum_{n=1}^{N_n}\\left\\langle\\Psi_n|1-\\hat{P}| \\Psi_n\\right\\rangle, 其中\\Psi_n表示平面波基组下的本征态，N_n是选定的参考电子态的个数，\\hat{P}是由所有原子轨道张成的投影子 \\hat{P}=\\sum_{\\mu v}\\left|\\phi_\\mu\\right\\rangle S_{\\mu v}^{-1}\\left\\langle\\phi_v\\right| \\text, 其中S_{\\mu v}=\\left\\langle\\phi_\\mu \\mid \\phi_v\\right\\rangle是局域轨道\\phi_\\mu与\\phi_v之间的重叠矩阵，投影子用到了重叠矩阵的逆。 轨道正交：事实上，如果我们有了给定的数值原子轨道，我们可以在此基础上再次定义新的溢出函数来得到一组新的数值原子轨道，这也是为什么该算法可以系统性的增加数值原子轨道的原因。定义的方式也比较直接，可以将|\\Psi_n\\rangle和已有原子轨道形成的投影子\\hat{P}正交，公式为 |\\Psi_n^{new}\\rangle=（1-\\hat{P}）|\\Psi_n\\rangle, 这个公式里，左边的波函数经过正交已经不包含原子轨道的成分，这样可以再次作为新的参考体系波函数生成新的数值原子轨道，以上算法已经被实现在SIAB这个程序里。 最小化溢出函数：优化原子轨道时，最终溢出函数值定义为选定的几个二聚体的平均溢出函数值。溢出函数可以用来评估获得的原子轨道基组的质量，溢出函数越小，则原子轨道所张成的空间越接近于参考态波函数。在ABACUS中，通过最小化溢出函数的方式来优化c_{\\mu q}，该系数决定了原子轨道的径向函数的形状。这种方法的好处在于 轨道形状可调：可以由球贝塞尔函数基组的线性组合自动生成，而不需要任何先决条件，因此原则上可获得完全优化的原子轨道。 基组数量可调：可以用统一的方式系统的增加轨道数量，包括增加径向轨道的数量（multi-ζ）和增加更高角动量的轨道（极化轨道）两种方式。为此，我们可以首先生成具有给定角动量的轨道，然后更高级的轨道可以使用相同的程序生成，但是此时只需最小化剩余的希尔伯特空间中的溢出函数，该空间与所有先前生成的原子轨道所张成的空间正交。 参考系统可调：通过选择参考系统及对应能级，可以提高原子轨道基组在不同环境的可迁移性。例如，对于涉及到激发态能级的计算，往往需要在生成数值原子轨道的时候，考虑这组轨道对于非占据态能级的拟合能力，这个时候可以在生成参考体系的时候加入一定数量的非占据能级。 4. 模拟退火算法SA（Simulated Annealing） 我们首先介绍模拟退火法Simulated Annealing（SA）来最小化溢出函数[1]，从而优化球贝塞尔函数的系数c_{\\mu q}。在模拟退火算法中我们用的是Metropolis的算法，需要设置一个初始温度，并且指定温度下降的方式。代码部分我们之后会介绍，这里先简要介绍一下算法。 初始系数：如果没有特别指定，一开始的系数c_{\\mu q}是随机产生的， 每一步SA会更新其中一个系数，当溢出函数被改变的数值在允许接收的范围内时，参数c_{\\mu q}会被更新。 优化过程：当要优化的所有轨道的所有参数c_{\\mu q}都被更新过一次之后，我们称为一步优化。 我们发现大约在每个温度行走500 ~ 1000步就已经足够产生好的原子轨道。最开始的温度我们一般取为1.0e-5，事实上我们发现即便初始温度取得更小，最后的结果也是不错的。 在每一步优化之后，我们将温度乘上一个比率，来达到降温的目的从而得到新的温度，这个参数我们一般取为0.5~0.8，最后的温度一般降到1.0e-9~1.0e-12。接收的概率可以控制在0.2~0.4范围内。 能量截断值：这里的能量截断值实际上是能量截断值，我们知道每个平面波 e^{i\\mathbf{q}\\cdot\\mathbf{r}}都对应一个二阶求导后的动能q^2/2。同样的，每个球贝塞尔函数 j_l(q r)也有一个对应的动能是 q^2/2。在平面波计算里我们通过能量截断值来控制平面波的数量，从而控制计算精度。在生成数值原子轨道的时候，我们也通过能量截断值来控制球贝塞尔函数的个数，从而控制生成的数值原子轨道的精度。 对于ABACUS的平面波计算和产生球贝塞尔函数 j_l(q r)个数的计算，我们建议采用同样的能量截断值，该截断值取得越高，基矢量个数越多同时基组也越完备。对于采用赝势的平面波计算，15~30个球贝塞尔函数已经足够得到质量比较高的数值原子轨道。 数值原子轨道的二阶可导：除了以上操作之外，还有一个需要注意到的地方。为了使数值原子轨道的动能积分是良定义的，需要使原子轨道的二阶导数连续。这可以通过将原子轨道的径向部分乘以一个平滑函数g(r)来实现 g(r)=1-\\exp \\left[-\\frac{\\left(r-r_{\\mathrm{c}}\\right)^2}{2 \\sigma^2}\\right], 该径向轨道会在数值原子轨道的截断值以内起作用，使其在截断值处2阶连续，超过阶段半径之后就严格截断。在我们的测试中，我们发现参数\\sigma对轨道的质量影响不大，所以我们一般固定\\sigma为常数0.1。 数值原子轨道动能和再次使用模拟退火算法：如果仅仅最小化溢出函数值，原子轨道的径向部分经常会出现震荡，原因是震荡有时候有利于溢出函数的值尽可能的低，但震荡厉害的函数往往动能高，可移植性较差。因此，为了去除这些实际上非物理的震荡，在算法中我们还定义了原子轨道的动能： T_{\\mu}=\\sum_{q} c_{\\mu q}^{2} q^{2} / 2+\\kappa, 并再次通过模拟退火算法最小化原子轨道的动能，其中\\kappa则是模拟退火的一个惩罚函数： \\kappa=\\left\\{\\begin{array}{ll} 0, & \\mathcal{S} / \\mathcal{S}_{0}-1\\Delta \\end{array}\\right., 这里\\mathcal{S}\\_{0}是在优化动能之前所得到的数值原子轨道算出来的溢出函数的值，而\\mathcal{S}则是当前在参数c_{\\mu q}下面的溢出函数的值。我们发现参数取\\Delta=0.002~0.005足够使得原子轨道平滑了。轨道动能也是通过同样的模拟退火算法得到，经过动能优化之后，轨道的形状会变平滑，同时溢出函数的值也会相比没有动能优化的轨道会有一点点增加，但是对精度的影响是很小的。 优化动能用的模拟退火算法几乎和优化溢出函数一样，除了一点点参数的区别。 目标函数选择的是所有轨道中最大的动能，而不是像溢出函数一样取平均值。对于每个轨道来说，温度是不一样的，因为每个轨道会有一个不同的动能，在这步动能优化中，我们发现结果对初始的温度不敏感，但最终达到的温度必须取得足够小。实际中我们发现只需要100~200步，动能就可以下降得很快。 所以一般来说优化动能的步数就取得比优化溢出函数要少。 二、ABACUS中产生数值原子轨道的具体流程 注：本文档介绍的是模拟退火算法SA，不适用于基于Pytorch的PyTorch-Gradient方法，关于这两个算法，可以参考本数值原子轨道中文文档系列的第三篇文档。 1. 平面波计算 简化计算量：前文我们提到的溢出函数公式，如果把投影子\\hat{P}带进公式，则可以发现我们不需要在计算溢出函数的时候显示的包含任何基矢量（例如平面波）的操作。实际上，我们只需要先算好数值原子轨道|\\phi_\\mu\\rangle和电子波函数|\\Psi_i\\rangle的重叠矩阵（Overlap Matrix）\\langle \\Psi_i|\\phi_\\mu\\rangle并存下来，以及数值原子轨道之间的重叠矩阵\\langle \\phi_\\mu|\\phi_\\nu\\rangle存下来就可以算溢出函数了。更进一步，我们意识到数值原子轨道|\\phi_\\mu\\rangle的径向部分在程序里是写成了球贝塞尔函数的线性组合，根据线性叠加的原理，我们只需要计算球贝塞尔函数和电子波函数的内积，以及球贝塞尔函数之间的内积，并把这些结果存下来，就可以优化系数c_{\\mu q}了！注意这里指标i遍历体系的所有电子态，包括所有的k点以及能带对应的电子波函数。 换句话说，只需要存储线性代数里的内积结果而不是每个波函数在基矢量下的展开系数就可以优化我们想要的系数，因此数值原子轨道的优化过程可以极大提速！ 采用ABACUS做平面波计算： 因此，第一步我们先调用ABACUS主程序，计算出以上overlap矩阵，首先需要准备INPUT文件如下： INPUT_PARAMETERS suffix H pseudo_dir /home/liuyu/github/abacus-develop/tests/PP_ORB wannier_card INPUTw calculation scf ks_solver dav nspin 1 lmaxmax 1 symmetry 0 nbands 10 ecutwfc 100 scf_thr 1.0e-7 scf_nmax 1000 smearing_method gauss smearing_sigma 0.01 mixing_type pulay mixing_beta 0.4 mixing_ndim 8 printe 1 bessel_nao_ecut 100 // same as ecutwfc bessel_nao_rcut 6 // rcut 如上所示，该INPUT与平常的平面波计算相比，只有3个参数（已标红）需要注意： wannier_card：指定wannier相关参数的输入文件名INPUTw bessel_nao_ecut：球贝塞尔函数的截断能，根据公式\\sqrt{E_{cut}} \\times r_{cut} / \\pi来决定求贝塞尔函数的数量 bessel_nao_rcut：数值原子轨道的截断半径r_{cut} 此外，我们还需要准备输入文件 INPUTw 如下（将来计划会把 INPUTw 文件去掉，把参数加入 INPUT 里）： WANNIER_PARAMETERS out_spillage 2 // output overlap spillage_outdir OUT.H // could be the same as OUT.${suffix} 通过 ABACUS 做平面波基矢量计算可以计算出： 1）电子波函数|\\Psi_i\\rangle和球贝塞尔函数 j_l(q r)之间的 overlap\\langle \\Psi_i|j_l(q r)\\rangle； 2）球贝塞尔函数之间的 overlap\\langle j_{l_2}(q_2 r)|j_{l_1}(q_1 r)\\rangle； 3）电子波函数|\\Psi_i\\rangle之间的 overlap\\langle \\Psi_i|\\Psi_i\\rangle。 这些输出将存在文件 OUT.${suffix}/orb_matrix.0.dat 中，而这个文件将被读入进行数值原子轨道的生成。 2. 编译 SIAB SIAB 的全称是 Systematically Improvable Atomic orbital Basis generator based on spillage formula，目前是包含在 ABACUS 软件里的一个独立程序，可用来读入以上 ABACUS 产生的数据文件并且生成数值原子轨道，具体编译方法如下： 拉取 deepmodeling/abacus-develop 仓库（github 和 gitee 二选一即可，国内建议用 gitee） # github仓库 $ git clone -b develop https://github.com/deepmodeling/abacus-develop.git # gitee仓库 $ git clone -b develop https://gitee.com/deepmodeling/abacus-develop.git 编译 SIAB 模拟退火（SA）方法生成数值原子轨道的代码在 SIAB 文件夹里，采用 C++ 编写，目前 Makefile 仅支持 intel 编译器。 SIAB 程序有串行（make s）和并行（make p）两种版本，一般情况下串行版本即可满足使用需求。 $ cd abacus-develop/tools/SIAB/SimulatedAnnealing/source $ make clean $ make s 编译成功后，在目录 abacus-develop/tools/SIAB/SimulatedAnnealing/source 下可以看到生成数值原子轨道的可执行程序 SIA_s.exe，这里 s 代表编译串行版(serial)。此外，对于并行版本，SIAB 还可以结合 MPI 编译并行版，通过命令 make p 指令得到 SIA_p.exe 可执行程序，这里 p 代表 parallel，但注意并行版只对某些特定算法进行并行，之后对代码进行一个更好整理之后我们会给出并行版的教程。 3. 运行例子 进入 tests_s 目录，可以看到 H-6-0.6.15.dat 文件，这是用来生成数值原子轨道所需要准备的输入文件，从 ABACUS 的平面波自洽迭代计算后获得，现在该文件已经改名为 OUT.${suffix}/orb_matrix.0.dat。 此外，还有一个输入文件 INPUT 如下： 1 // bool: calculate the spillage. 1/0 0 // bool: restart or not. 1/0 1 // bool: output the file. 1/0 1 // integer: number of structures. H-6-0.6.15.dat // Each structure's file name occupies one line 1 // integer: number of k points (for parallel version) 1 // integer: number of pools (for parallel version) 15 // can be ignored now 2 // The way to calculate spillage, 2 means averaged spillage 1.0e-8 // real: start temperature for minimizing spillage 0.5 // real: cooling rate for the temperature in minimizing spillage 2 // integer: number of temperatures (spillage) 500 // integer: number of steps per temperature (spillage) 1.0e-2 // real: starting temperature for the kinetic energy 0.8 // real: cooling rate for temperature in minimizing kinetic energy 1 // integer: number of temperatures (kinetic) 100 // integer: number of steps per temperature (kinetic) 0.05 // real: delta kappa for kinetic energy 49 // integer: selectly output information every n steps 100 // integer: change accept rate every n steps, can be ignored now 0.4 // real: acceptance rate (high), can be ignored now 0.2 // real: acceptance rate (low), can be ignored now 50 // real: max allowed kinetic energy (Rydberg) 0.01 // real: 'dr' for the 1d r grid to compute kinetic energy 1 // integer: 1: Kin 2: Ecut, can be ignored now 1 // bool: to control the number of bands 1 // int, the start band index(>0). 1 // int, the end band index( 2 // Number of levels. # label / na / skip / lmax / each L / 01 2 new 1 1 1 01 2 new 1 1 1 01 2 new 1 1 1 0.01 //dr(a.u.) of uniform mesh. Attention!!dr will affect kinetic energy minmized largely. -6 //xmin 1 //zed, chosen as valence charge. 0.01 //dx 6.0 //xmax 0 // print out the C4, this section can be ignored now 2 ./FILE/Si-S.ORBITAL 0 ./FILE/Si-P.ORBITAL 1 0 // for tests, can be ignored now 14.0 // rcut, only useful for test program 0.01 // dr, for simpson integral 2 // test eigenvalue index 2 // lmax C4：代表 4 个重要参数：\\alpha,\\xi,l,nq，\\alpha是原子种类的指标，\\xi是角动量l对应的径向函数的个数，nq 是对应的球贝塞尔函数的个数。 该输入文件包含 SIAB 程序需要读取的一系列参数，基本上重要参数的说明都有列上去，一些可忽略的参数可以先不用设置，之后我们会推出更详细的关于此输入文件的说明文档。 准备好该输入文件后，可以通过如下命令执行 SIAB 程序： $ ~/abacus-develop/tools/SIAB/SimulatedAnnealing/source/SIA_s.exe 运行完毕后，可以得到一系列输出文件，其中 ORBITAL_1U.dat 则是我们需要的数值原子轨道文件。我们可以通过文件的前几行获取关键信息：这是 H 原子的轨道文件，平面波截断能为 100 Ry，截断半径为 6 Bohr，最大角动量为 1，角动量 s 和 p 的径向函数的个数都为 2，即 2 条 s 轨道和 6 条 p 轨道，共 8 条轨道。为了体现这些关键信息，在使用轨道的时候我们建议重命名该文件为 H_gga_100Ry_6au_2s2p.orb。 --------------------------------------------------------------------------- Element H Energy Cutoff(Ry) 100 Radius Cutoff(a.u.) 6 Lmax 1 Number of Sorbital--> 2 Number of Porbital--> 2 --------------------------------------------------------------------------- SUMMARY END 三、ABACUS 中数值原子轨道的生成脚本 我们需要采用平面波计算不同键长的二聚体，并且存在不同层级的轨道，因此也可以通过一个脚本来实现自动化整个流程：abacus-develop/tools/SIAB/Generate_Orbital_AllInOne.sh。该脚本需要读入一个输入文件 ORBITAL_INPUT 如下： #1.exe_dir #-------------------------------------------------------------------------------- EXE_mpi mpirun -np 4 EXE_pw /home/liuyu/github/abacus-develop/build/abacus EXE_orbital /home/liuyu/github/abacus-develop/tools/SIAB/SimulatedAnnealing/source/SIA_s.exe #-------------------------------------------------------------------------------- #( In this part, the direction of the two used exe is provided ) #2.electronic calculatation #-------------------------------------------------------------------------------- targets 14_Si_60 # element ref_bands 4 6 # reference bands nbands 8 12 # num of bands for calculate Ecut 60 # cutoff energy (in Ry) Rcut 6 7 # cutoff radius (in a.u.) Pseudo_dir /home/liuyu/github/abacus-develop/tests/PP_ORB Pseudo Si_ONCV_PBE-1.0.upf smearing_sigma 0.01 # energy range for gauss smearing (in Ry) #-------------------------------------------------------------------------------- #( In this part , some parameters of calculating are given ) #3.structure information #-------------------------------------------------------------------------------- #the Bond Length list for each STRU BLSTRU1 1.8 2.0 BLSTRU2 2.4 # if skip the orbital optimization for each STRU (1:skip, 0:not skip). SkipSTRU 0 0 # set the objective structure list to fit for orbital optimization ListSTRU dimer trimer #-------------------------------------------------------------------------------- #(In this part, it gives us the bond length of the reference system(in angstrom) ) #4.orbital calculatation #-------------------------------------------------------------------------------- maxL 2 # the max angular momentum Level 2 3 # num of levels to generate orbitals( 该输入文件主要分为 5 个部分： 1. exe_dir EXE_mpi：MPI 并行计算命令，这里我们采用的是 4 核 MPI 并行进行 dimer（或者 trimer）的平面波计算。 EXE_pw：ABACUS 可执行程序的绝对路径。 EXE_orbital：数值原子轨道生成程序 SIA_s.exe 的绝对路径。 2. electronic calculatation targets：可以任取，一般格式是${原子序数}_${元素名}_${截断能}。 ref_bands：参考体系的能带数，取值为电子总数的一半。注意这里有多个取值，原因是我们选择了多组参考构型，既有 dimer，也有 trimer。 nbands：平面波计算中的实际能带数，必须大于 ref_bands，以保证包含非占据态。同理，由于多组参考构型，nbands 也有多个取值。 Ecut：平面波截断能，单位为 Ry。 Rcut：数值原子轨道的截断半径，单位为 Bohr。这里的多个取值表明，采用相同的一套参数，生成多个不同截断半径的数值原子轨道文件，根据第一部分的基础知识，截断半径会极大地影响数值原子轨道的质量，因此该参数可以帮助我们一次性生成多个不同截断半径的数值原子轨道文件。 Pseudo_dir：平面波计算采用的赝势文件所在文件夹的绝对路径。 Pseudo：平面波计算采用的赝势文件名。 smearing_sigma：平面波计算采用 Gaussian smearing 的展宽，单位为 Ry，一般取 0.01 即可。 3. structure information BLSTRU1：第一组参考构型的键长，单位为埃。如上所示，第一组参考构型包含两个构型，键长分别为 1.8 和 2.0 埃。 BLSTRU2：第二组参考构型的键长，单位为埃。如上所示，第二组参考构型包含一个构型，键长为 2.4 埃。 以此类推，可以存在 BLSTRU3、BLSTRU4 等等。 SkipSTRU：是否跳过该组参考构型的优化，一般而言，都取为 0 即可。 ListSTRU：指定 BLSTRU1、BLSTRU2 等等参考体系的具体构型，这里说明 BLSTRU1 是 dimer，BLSTRU2 是 trimer。如果取值缺省（第一个不可缺省），则默认为 dimer。 4. orbital calculatation maxL：最大角动量。 Level1：根据上文可知，轨道可以分为多个层级，这里 level1 是 SZ 层级，最大角动量为 1，角动量 s 和 p 的径向函数的个数为 1 和 1，即 1 条 s 轨道和 3 条 p 轨道。 Level2：同上，这里 level2 的最大角动量为 2，角动量 s，p 和 d 的径向函数的个数为 1，1 和 1，即 1 条 s 轨道，3 条 p 轨道和 5 条 d 轨道。level1 和 level2 合在一起，是 DZP 层级。 Level3：同 Level2。 Level：BLSTRU1 和 BLSTRU2 分别负责一部分轨道的生成，Level 的 2 个取值对应的是 BLSTRU1 和 BLSTRU2 的 endlevel，即 BLSTRU1 用于 level1 和 level2 轨道的生成，BLSTRU2 用于 level3 轨道的生成。 5. Metropolis parameters 如注释所说，这部分参数实际上大多数情况下不需要改变。 Start_tem_S：优化 Spillage 的初始温度，更高的初始温度可以搜索更大的温度范围。 Start_tem_K：优化动能的初始温度，更高的初始温度可以搜索更大的温度范围。 Step_S：优化 Spillage 的步数。 Step_K：优化动能的步数。 Delta_kappa：模拟退火的惩罚函数\\kappa所用的参数\\Delta。 准备好以上输入文件后，通过以下命令即可开始生成轨道： $ ~/abacus-develop/tools/SIAB/Generate_Orbital_AllInOne.sh ORBITAL_INPUT 四、ABACUS 中数值原子轨道的测试流程 在生成轨道之后，为了保证基于数值原子轨道基组的第一性原理计算拥有与平面波基组相当的精度，我们需要针对该元素的一些常见的晶体结构做一些验证性计算。 以 Al 元素为例，我们可以选择 simple cubic（sc），body center cubic（bcc），face center cubic（fcc）和 hexagonal close-packed（hcp）这 4 种常见的晶体结构，采用平面波（Plane wave）基组和数值原子轨道基组计算这些晶体结构的平衡晶格常数、体弹性模量等基态性质，评估两种基组之间的误差随着截断半径、最大角动量以及轨道数量的收敛趋势，选择合适的数值原子轨道文件。例如以下就是用 ABACUS 的平面波和数值原子轨道 DZP 计算的铝的四种体相材料的体积-能量曲线，来自文献[1]。从图中可以看到，DZP 轨道描述不同体相的铝的相对能量还是精度较高的。细心的读者会发现纵坐标给出的是绝对能量，因为两种基矢量采用了相同的赝势，但左图给出的能量更低，这是因为平面波更加完备，所以根据 Honhenberg-Kohn 定理，体系总能量的密度泛函可以在更完备的基矢量下得到更好的收敛，即总能量更低。一般来说，平面波得到的总能量比 DZP 轨道小一些，大概在 0.1-0.2 eV/atom，是比较合理的。如果采用了同样的赝势，但两种基矢量给出的能量差别远远大于这个数值，则要检查一下是不是数值原子轨道产生出了问题。最后，大家有任何问题，欢迎写邮件到文档开头邮箱。 五、参考文献 [1] M. Chen, G.-C. Guo, and L. He, Systematically Improvable Optimized Atomic Basis Sets for Ab Initio Calculations, J. Phys.: Condens. Matter 22, 445501 (2010). [2] M. Chen, G.-C. Guo, and L. He, Electronic Structure Interpolation via Atomic Orbitals, J. Phys.: Condens. Matter 23, 325501 (2011). Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-nac3.html":{"url":"abacus-nac3.html","title":"数值原子轨道（三）：产生高精度数值原子轨道","keywords":"","body":"数值原子轨道（三）：产生高精度数值原子轨道 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：林霈泽，邮箱：linpeize@sslab.org.cn 最后更新时间：2023/06/20 在Bohrium Notebook上快速学习： 一、PTG（PyTorch Gradient）方法 这篇文档是数值原子轨道系列的第三篇文档，除了第二篇文档提到的模拟退火算法之外，还可以使用 Pytorch 中的自动微分算法来最小化溢出函数。首先定义损失函数如下，并可以证明它与溢出函数是等价的： \\Delta \\mathrm{PSI} \\stackrel{\\text { def }}{=} \\frac{1}{N_n} \\sum_{n=1}^{N_m} \\|\\left|\\Psi_n\\right\\rangle-\\left|\\tilde{\\Psi}_n\\right\\rangle \\|^2, 其中 \\left|\\tilde{\\Psi}_n\\right\\rangle \\stackrel{\\text { def }}{=} \\hat{P}\\left|\\Psi_n\\right\\rangle, 且\\hat{P}是由所有原子轨道张成的投影子，即\\hat{P}=\\sum_{\\mu v}\\left|\\phi_\\mu\\right\\rangle S_{\\mu v}^{-1}\\left\\langle\\phi_v\\right| \\text {}。由 \\hat{P}^2=\\hat{P}及 \\left\\langle\\Psi_n|\\Psi_n\\right\\rangle=\\delta_{mn}可知，此处的损失函数\\Delta \\mathrm{PSI}与溢出函数是等价的。 二、PTG_dpsi（PyTorch Gradient with dpsi）方法 为了增加局域轨道做电子结构计算时的精度，损失函数的定义还可以被拓展，即在其中加入波函数的梯度，将总的损失函数定义为： \\Delta \\mathrm{PSI} \\stackrel{\\text { def }}{=} \\frac{1}{N_n} \\sum_{n=1}^{N_m} [\\|\\left|\\Psi_n\\right\\rangle-\\left|\\tilde{\\Psi}_n\\right\\rangle \\|^2+\\|\\left|\\nabla\\Psi_n\\right\\rangle-\\left|\\nabla\\tilde{\\Psi}_n\\right\\rangle \\|^2]. 由于投影波函数\\left|\\tilde{\\Psi}_{n}\\right\\rangle是数值原子轨道的线性组合： \\left|\\tilde{\\Psi}_{n}\\right\\rangle=\\sum_{\\mu} a_{\\mu n}\\left|\\phi_{\\mu}\\right\\rangle, 其中系数的表达式为 a_{\\mu n}=\\sum_{\\nu} S_{\\mu \\nu}^{-1}\\left\\langle\\phi_{\\nu} \\mid \\Psi_{n}\\right\\rangle. 那么投影波函数的梯度可以表示为数值原子轨道梯度的线性组合： \\left|\\nabla \\tilde{\\Psi}_{n}\\right\\rangle=\\sum_{\\mu} a_{\\mu n}\\left|\\nabla \\phi_{\\mu}\\right\\rangle. 因此，损失函数的梯度项可以转化为： \\begin{array}{l} \\|\\left|\\nabla \\Psi_{n}\\right\\rangle-\\left|\\nabla \\tilde{\\Psi}_{n}\\right\\rangle \\|^{2} \\\\ =\\left\\langle\\nabla \\Psi_{n} \\mid \\nabla \\Psi_{n}\\right\\rangle-\\sum_{\\mu} a_{\\mu n}\\left\\langle\\nabla \\Psi_{n} \\mid \\nabla \\phi_{\\mu}\\right\\rangle \\\\ -\\sum_{\\nu} a_{v n}^{*}\\left\\langle\\nabla \\phi_{v} \\mid \\nabla \\Psi_{n}\\right\\rangle+\\sum_{\\mu \\nu} a_{\\mu n} a_{v n}^{*}\\left\\langle\\nabla \\phi_{v} \\mid \\nabla \\phi_{\\mu}\\right\\rangle. \\end{array} 根据经验，使用这个算法生成的双重-ζ + 极化(DZP)基组，精度与模拟退火法或 PTG 法生成的三重-ζ + 双极化(TZDP)甚至四倍-ζ + 三重极化(QZTP)基组相当。 在平面波计算中，除了数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道 提到的 overlap 输出文件 OUT.${suffix}/orb_matrix.0.dat 之外，overlap 输出文件 OUT.${suffix}/orb_matrix.1.dat 同样会作为生成轨道的输入文件之一，该文件保存与波函数梯度相关的如下 overlap 项： 1）电子波函数梯度|\\nabla \\Psi_i\\rangle和局域轨道梯度|\\nabla \\phi_\\mu\\rangle的 overlap，也就是电子波函数梯度|\\nabla \\Psi_i\\rangle以及球贝塞尔函数梯度\\nabla j_l(q r)之间的 overlap\\langle \\nabla \\Psi_i|\\nabla j_l(q r)\\rangle； 2）球贝塞尔函数梯度\\nabla j_l(q r)之间的 overlap\\langle \\nabla j_{l_2}(q_2 r)|\\nabla j_{l_1}(q_1 r)\\rangle； 3）电子波函数梯度|\\nabla \\Psi_i\\rangle之间的 overlap\\langle \\nabla \\Psi_i|\\nabla \\Psi_i\\rangle。 三、安装 Pytorch PTG 和 PTG_dpsi 方法采用 python 语言，无需编译，但是依赖 pytorch 包，下面介绍利用 conda 安装 pytorch 的方法： # 确定conda版本 $ conda -V conda 4.8.3 # 确定python3版本 $ python3 -V Python 3.5.2 # 创建python环境 $ conda create -n pytorch python=3.5 # 激活环境（每次使用pytorch需要激活该环境） $ source activate pytorch # 安装pytorch $ conda install pytorch torchvision torchaudio cpuonly -c pytorch # 安装依赖库 $ pip3 install --user scipy numpy $ pip3 install --user torch_optimizer # 退出python环境（使用完毕后） $ source deactivate 四、产生高精度数值原子轨道流程 首先下载 PTG_dpsi 仓库 # github仓库 git clone -b main https://github.com/abacusmodeling/ABACUS-orbitals 接着准备输入文件 SIAB_INPUT #-------------------------------------------------------------------------------- #1. CMD & ENV EXE_mpi mpirun -np 4 EXE_pw /home/liuyu/github/abacus-develop/build/abacus EXE_opt /home/liuyu/github/ABACUS-orbitals/SIAB/opt_orb_pytorch_dpsi/main.py #-------------------------------------------------------------------------------- #2. Electronic calculatation element Si # Element Name Ecut 100 # in Ry Rcut 6 7 # in Bohr Pseudo_dir /home/liuyu/github/abacus-develop/tests/PP_ORB Pseudo_name Si_ONCV_PBE-1.0.upf sigma 0.01 # energy range for gauss smearing (in Ry) #-------------------------------------------------------------------------------- #3. Reference structure related parameters for PW calculation #For the built-in structure types (including 'dimer', 'trimer' and 'tetramer'): #STRU Name #STRU Type #nbands #MaxL #nspin #Bond Length list STRU1 dimer 8 2 1 1.8 2.0 2.3 2.8 3.8 STRU2 trimer 10 2 1 1.9 2.1 2.6 #-------------------------------------------------------------------------------- #4. SIAB calculatation max_steps 200 # Orbital configure and reference target for each level #LevelIndex #Ref STRU Name #Ref Bands #InputOrb #OrbitalConf Level1 STRU1 4 none 1s1p Level2 STRU1 4 fix 2s2p1d Level3 STRU2 6 fix 3s3p2d #-------------------------------------------------------------------------------- #5. Save Orbitals #Index #LevelNum #OrbitalType Save1 Level1 SZ Save2 Level2 DZP Save3 Level3 TZDP 该输入文件同样包含 5 个部分： 1. CMD & ENV EXE_mpi：MPI 并行计算命令，这里我们采用的是 4 核 MPI 并行进行 dimer（或者 trimer）的平面波计算。 EXE_pw：ABACUS 可执行程序的绝对路径。 EXE_opt：数值原子轨道生成程序 PTG_dpsi 的绝对路径。 2. Electronic calculatation element：元素名。 Ecut：平面波截断能，单位为 Ry。 Rcut：数值原子轨道的截断半径，单位为 Bohr。这里的多个取值表明，采用相同的一套参数，生成多个不同截断半径的数值原子轨道文件，根据第一部分的基础知识，截断半径会极大地影响数值原子轨道的质量，因此该参数可以帮助我们一次性生成多个不同截断半径的数值原子轨道文件。 Pseudo_dir：平面波计算采用的赝势文件所在文件夹的绝对路径。 Pseudo：平面波计算采用的赝势文件名。 sigma：平面波计算采用 Gaussian smearing 的展宽，单位为 Ry，一般取 0.01 即可。 3. Reference structure related parameters for PW calculation STRU Name：参考构型组别 STRU1、STRU2、STRU3...... STRU Type：参考体系构型，一般可取 dimer，trimer，tetramer。 nbands：平面波计算中的实际能带数，必须保证包含非占据态。 MaxL：最大角动量。 nspin：自旋量子数。 Bond Length list：键长取值列表，单位为埃。以 STRU1 为例，这一组共有 5 个不同键长的 dimer 作为生成轨道的参考构型。 4. SIAB calculatation max_steps：优化步数 LevelIndex：轨道分层的 index，取 Level1、Level2、Level3...... Ref STRU Name：该层级的轨道采用哪一组参考构型生成。以上面的输入参数为例，Level1 和 Level2 的轨道采用 STRU1 组别的 dimer 参考构型生成，Level3 的轨道采用 STRU2 组别的 trimerr 参考构型生成。 Ref Bands：拟合参考体系的能带数，若输入“auto”则自动拟合所有基态。 InputOrb：是否在已有的轨道基础上生成新轨道，一般 Level1 设为 none，即没有旧轨道；Level2 一般以 Level1 生成的轨道为基础继续生成轨道，Level3 往后同理。 OrbitalConf：轨道的具体配置，这里 Level1 是 SZ 层级，Level2 是 DZP 层级，Level3 是 TZDP 层级，实际上还可以继续设置更高层级的轨道。 5. Save Orbitals Index：取值 Save1、Save2、Save3...... LevelNum：将特定 Level 的轨道保存到一个轨道文件中。以上面的输入参数为例，分别将 Level1、Level2、Level3 对应的轨道保存到单独的轨道文件中。 OrbitalType：即保存的轨道文件中，该轨道基组所属的层级。以上面的输入参数为例，分别为 SZ、DZP、TDZP。 准备好输入参数文件 SIAB_INPUT 后，运行如下命令即可开始生成轨道： $ python3 ~/github/ABACUS-orbitals/SIAB/SIAB.py SIAB_INPUT 程序正常结束后，轨道会分别保存在 Orbital_Si_SZ、Orbital_Si_DZP、Orbital_Si_TZDP 中，并自动命名成标准格式（如 Si_gga_6au_100Ry_2s2p1d.orb）。 五、参考文献 [1] Peize Lin, Xinguo Ren and Lixin He, Strategy for constructing compact numerical atomic orbital basis sets by incorporating the gradients of reference wavefunctions, Phys. Rev. B 103, 235131 (2021). Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-pw.html":{"url":"abacus-pw.html","title":"ABACUS 的平面波计算与收敛性测试","keywords":"","body":"ABACUS 的平面波计算与收敛性测试 作者：谢炘玥，邮箱：xyxie@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024/04/09 一、背景介绍 ABACUS(原子算筹)作为一款国产的电子结构软件，可用于对材料进行密度泛函理论（Density Functional Theory，简称 DFT）的第一性原理（first-principles）计算，其主要核心功能之一是电子自洽迭代计算(Self Consistent Field，简称SCF)，在给定材料微观层面的晶胞和原子位置的条件下，我们可以通过 SCF 流程的计算获得电子结构的总能量、能级、电子波函数、电子密度等关键信息，这些信息可用于进一步计算得出材料体系的其它性质。然而，对于初学者来说，初次运行 ABACUS 难免不熟悉输入参数，容易出错，要熟练掌握好 SCF 计算要领也颇具难度。因此，本文将主要针对初学者，详细介绍（1）如何采用ABACUS设置合理的输入参数完成一个SCF 计算，以及（2）如何对体系做收敛性测试，以便确定所有计算参数。这里收敛性测试包括在平面波（Plane Wave，简称 pw）基矢量下面对 ecut（电子动能截断值）进行测试，以及对布里渊区的 k 点个数进行测试来确定这些参数。 对密度泛函理论计算不太了解的读者，我们想先介绍密度泛函理论的三个特点。第一，只要给定原子坐标和种类，密度泛函理论就可以用于预测该体系的许多物理和力学等性质。第二，对于不同的原子坐标排列方式以及不同元素种类，密度泛函理论软件提供了一系列参数用于调节计算的精度和效率，只有将参数设定在某一些正确的范围之内，得到的结果才有意义。反之，如果参数过于粗糙，则得到的结果可能也不收敛，因此不具有价值。第三，密度泛函理论计算是一种虽然较为流行的但也相对昂贵的科学计算方法。笔记本电脑只能跑得动几个原子的小体系计算，真正数十个原子乃至更大的体系需要借助超算进行长时间的计算（几个小时甚至几天），而选择不同的参数可能会对最终运行时间有较大的影响。因此，基于以上三点认识，有必要更加细致地掌握密度泛函理论计算的具体参数，下面我们予以介绍。 二、输入文件简介 图 1. 电子自洽迭代计算流程。 图1：控制 SCF 的主要输入文件有三个。KPT 和 STRU 文件分别存储了布里渊区的信息和晶体结构的信息。此外 INPUT 文件主要存储了 5 部分信息，对应于下一章的小节序号，可以对应查看。n_0(\\vec{r})表示体系运行开始时的初猜电荷密度，\\widehat{H}表示电子系统的哈密顿量，\\varphi_{nk}(\\vec{r})表示波函数，其中n代表不同的能级，k代表体系的第一布里渊区里不同的采样点。\\varepsilon_{nk}表示特征值，N_{k}代表k点的个数，N_{occ}表示被电子占据的能级个数，f(\\varepsilon_{nk})表示电子的费米-狄拉克分布函数，n(\\vec{r})表示由波函数算出来的电荷密度，n_i(\\vec{r})表示迭代过程中第i步的电荷密度而n_{i+1}(\\vec{r})表示第i+1步的电荷密度。mixing\\_beta表示混合新电荷密度的比例（取值范围为 0~1）。ABACUS 支持平面波和数值原子轨道双基组，如果使用平面波基矢量，则数值原子轨道信息可以在 STRU 里不提供。 使用 ABACUS 中进行密度泛函理论或者第一性原理分子动力学计算时，一般需要 STRU、KPT、INPUT 三个最基本的文件作为 ABACUS 的基本输入文件。STRU 文件提供元素、晶格、原子的基本结构信息；KPT 文件提供周期性边界条件下布里渊区采样的网格设置。INPUT 文件主要提供计算所需的各种设置参数，在图1里我们分成了五部分且将在下面详细介绍。 三、STRU 和 KPT 文件简单介绍 1. STRU 文件 STRU 文件提供元素种类、原子质量（SCF 中不会用到）、赝势文件（如果做密度泛函理论计算）、数值原子轨道（如果采用该基组做计算）、晶格矢量、原子位置、原子位置是否可移动等基本结构相关的信息。其中，晶格是晶体中原子有序排列的具体形式，我们可以选取一组晶格矢量来描述晶格。晶格确定后，原子的相对位置也可以通过选取不同坐标系（例如 Cartesian 直角坐标系或者 Direct 晶格坐标系）确定下来。 例如，以下是一个金刚石硅的结构文件（8 个硅原子，周期性边界条件） ATOMIC_SPECIES Si 28.085 Si_ONCV_PBE-1.0.upf NUMERICAL_ORBITAL Si_gga_8au_60Ry_2s2p1d.orb LATTICE_CONSTANT 1.8897261258369282 LATTICE_VECTORS 5.4307000000 0.0000000000 0.0000000000 0.0000000000 5.4307000000 0.0000000000 0.0000000000 0.0000000000 5.4307000000 ATOMIC_POSITIONS Direct Si 0.0000000000 8 0.0000000000 0.0000000000 0.0000000000 1 1 1 mag 0.0 0.0000000000 0.5000000000 0.5000000000 1 1 1 mag 0.0 0.5000000000 0.0000000000 0.5000000000 1 1 1 mag 0.0 0.5000000000 0.5000000000 0.0000000000 1 1 1 mag 0.0 0.7500000000 0.7500000000 0.2500000000 1 1 1 mag 0.0 0.7500000000 0.2500000000 0.7500000000 1 1 1 mag 0.0 0.2500000000 0.7500000000 0.7500000000 1 1 1 mag 0.0 0.2500000000 0.2500000000 0.2500000000 1 1 1 mag 0.0 第 2 行 \"元素 原子质量 赝势\" 中的 \"原子质量\" 在进行 DFT 计算时不可以省略不写，哪怕在 SCF 中不会用到。那么什么时候会用到呢？比如在进行分子动力学（Molecular Dynamics，简称 MD，在 INPUT 的 calculation 参数里设置）计算时，涉及运动的积分方程时用的是牛顿的第二定律F=ma，此时会使用原子的质量。另外注意，此行需要提供所使用的 \"赝势\" 文件名称。 第 5 行提供 LCAO 基组所需的 \"某种元素的数值原子轨道\" 文件名称，而如果采用 pw 基组计算，不需要写第 4~5 行内容。 第 8 行代表晶格整体缩放的一个长度，注意1 Angstrom=1.8897261258369282 bohr，这里写 1.8 开头的小数意味着接下来的 LATTICE_VECTORS 部分可以写以 Angstrom 为单位的晶格。 第 11~13 行表示x,y,z方向分别对应的三条晶格矢量。 第 16 行 \"Direct\" 表示给出原子位置的方法是分数坐标（或者称为晶格坐标），常用的还有Cartesian(笛卡尔坐标方法)，就是直角坐标系下的坐标。 第 17 行是元素种类的名称。 第 18 行设置原子初始磁矩，如果 INPUT 里的 nspin 参数设为 1，则不考虑磁性，这个参数不起作用。 第 19 行表示体系的硅原子个数。 第 20~27 行给出所有 8 个硅原子的坐标；前三个数是坐标，之后的(1 1 1)三个数代表允许该原子在对应的x,y,z对应方向上移动，相反，(0 0 0)表示不允许在对应的方向上移动；同样，当考虑磁性计算的时候，\"mag 0.0\" 指定每个原子的初始磁矩，若设置此参数，则第 18 行的值将被覆盖。 关于赝势，还值得多提一些。平面波基组计算涉及采用描述电子和离子吸引作用的赝势，例如模守恒赝势或者超软赝势。需要注意的是，如果赝势换了，则相应的 ecut 能量截断值也需要重新测试收敛性。而基于局域原子轨道(Linear Combination of Atomic Orbitals，简称 LCAO)基组的计算则涉及赝势和数值原子轨道（Numerical Atomic Orbitals，简称 NAO），需要使用者准备好相应文件。这里提到的赝势是一种描述核外电子和离子之间相互作用的近似方法，数值原子轨道是通过数值方法构建的描述电子波函数和电子密度等性质的基函数。需要注意的是，LCAO 计算所采用的数值原子轨道要和对应的赝势匹配，即数值原子轨道是从给定赝势生成出来的，赝势如果改变了，相应的数值原子轨道也要重新生成，才能保证较好的精度。一般来说数值原子轨道的截断半径越长或轨道越多，则基矢量越完备，计算精度越高，但同时计算量也越大。 2. KPT 文件 KPT 文件提供周期性边界条件下布里渊区k点采样的网格设置 K_POINTS 0 Gamma k k k 0 0 0 第 2 行表示k点的总数，如果设置成 \"0\" 代表k点是自动生成的 如果第二行是 0，则第 3 行 \"Gamma\" (Γ-centered Monkhorst-Pack method)是选择以 Gamma 点为中心的 Monkhorst-Pack 方法划分布里渊区网格，此外还可以使用 \"mp\" 方法，即最常用的 Monkhorst-Pack 方法。 第 4 行的前三个整数代表网格沿着每个方向划分成几份，后三个数代表网格的平移量，0 0 0 即代表不平移。 计算立方形晶格时，k点各方向应取相同个数。在本次计算中，我们会将k的各方向从 2 取到 8，测试不同k点下体系能量的收敛情况。 在后文我们将介绍如何进行k点的收敛性测试，当选定一个k点后，若体系在某方向扩胞n次，该方向k点个数大致可以缩小到原来的\\frac{1}{n}。对于 N 原子以上的立方大体系，可通过在 INPUT 文件中设置参数 gamma_only 取 1，即只使用 Gamma 点计算，这个时候计算所需内存会显著下降，计算效率也会有提升。 此外，k点还有所谓的 line mode，或者离散的k点模式，若有兴趣的读者可以查看 KPT 的介绍文档（http://abacus.deepmodeling.com/en/latest/advanced/input_files/kpt.html）。 四、INPUT 文件关键输入参数 我们以金刚石结构硅原子体系（8 个原子）作为示例，进行电子自洽迭代计算(Self Consistent Field，SCF)。接下来让我们需要准备一个 INPUT 文件，我们把一些计算的关键参数分成如下 5 个部分。 1. 基本参数 suffix：suffix 是用户可以自定义的后缀，运行 ABACUS 可执行程序之后，输入文件所在的文件夹里会生成一个包含大部分运行信息的 OUT.suffix 文件夹。例如，在这个例子里我们可设为 \"Si\"，运行后就会产生一个 OUT.Si 文件夹。 calculation：设置本次计算类型，例如本次文档主要展示 \"scf\"(自洽电子结构计算)。scf((Self Consistent Field)、relax、cell-relax、md(Molecular Dynamics)是较常用的四类计算。 scf(自洽电子结构计算)是一种用于求解电子基态电子密度的自洽迭代计算方法，通过迭代来持续更新体系的电子密度，以达到收敛条件。通过电子自洽迭代，计算是否达到收敛由参数 scf_thr 决定。 relax(结构弛豫计算)是通过调整体系中原子的位置来达到系统最稳定的状态的计算方法，每一次 relax 中都包含若干步的 scf 计算。在 relax 中，需要设置参数 force_thr_ev (eV/Angstrom)，代表所有原子中最大受力的收敛阈值。而 relax 计算的收敛需要每一步离子迭代时 scf 中的 scf_thr 都满足，以及最后多步离子迭代后 force_thr_ev 也满足。 cell-relax(结构弛豫计算)与 relax 不同的是，其晶胞参数，比如晶格常数、晶格形状也会发生变化。除 force_thr_ev 外，还需要设置参数 stress_thr(kbar)，是晶胞感受到的应力的阈值。 md(分子动力学)基于牛顿力学原理，通过数值积分模拟粒子的运动轨迹，根据原子间的势能计算相互作用力，因此势函数的选择比较关键，在 ABACUS 里可以选择 DFT 来计算相互作用力，也可以选择 DP 势函数。 symmetry：是否考虑对称性，有如下三个选项 -1 不进行对称性分析 0 仅考虑时间反演对称性 1 进行对称性分析 如果打开对称性（设置为 1），布里渊区k点可以根据对称性进行简化处理，若体系有对称性，则可以减少所需计算的k点。因为每个k点都会进行一次 Kohn-Sham 方程的求解，对称性分析后若 k 点减少则将提升计算效率。本次计算中开启对称性分析，设置 \"1\"，关于对称性分析的测试还在进一步完善，如果计算结果奇怪，建议设置成 \"0\"之后再进行计算，比较结果是否一致。 pseudo_dir：计算中需要使用赝势来近似离子和电子相互作用势能，为计算提供赝势文件。pseudo_dir指定 STRU 文件中赝势文件所在的目录。本次计算将赝势和轨道文件都与 INPUT、STRU、KPT 文件放在一起，因此填入 \".\"，表示处在当前文件夹中。 ABACUS 支持的赝势文件——Si_ONCV_PBE-1.0.upf \"ONCV\"代表模守恒赝势的种类，\"PBE\"是采用的交换关联泛函。 orbital_dir：本次计算将采取 pw（平面波轨道）基组（后文 basis_type 中设置）。若采用 LCAO 基组进行计算，则需要提供作为基组的轨道文件，在 STRU 文件中指定轨道文件所在的目录。若选用 pw 基组，则不需要轨道文件，不需要填写此参数。常用的轨道有：DZP（Double-ζ valence orbitals plus SZ polarization，两条径向轨道和一条杂化轨道）,TZDP（Triple-ζ valence orbitals plus DZ polarization，三条径向轨道和两条杂化轨道）。 ABACUS 支持的轨道文件——Si_gga_7au_100Ry_2s2p1d.orb： \"gga\"代表 GGA 泛函；\"7au\"是轨道半径，半径越大，计算结果会更准确，但花费时间也更久；\"100Ry\"是推荐的 ecutwfc 值；\"2s2p1d\"表明采用了 DZP 轨道，轨道数目越多，即基矢量更完备，计算也会更准确。 basis_type：计算的基组（指描述电子波函数的基函数），在 ABACUS 中常用的有两种： pw：平面波基组（由于基矢量更完备，pw 计算将更准确，同时计算时间也更长） LCAO：局域原子轨道基组（没有 pw 准确，但效率高） ecutwfc：平面波函数的能量截止（单位：Ry），在平面波基组里是很重要的一个参数，其大小决定着作为基矢的平面波函数的个数多少，而基矢的多少，也决定了计算精度的高低。 在本次计算选用的 LCAO 基组中，一般选取轨道文件上推荐的值，设置 \"100\" Ry 即可。 本次计算中选择 pw 基组。如前所述，pw 中不会用到轨道文件。 我们目前填写好的基本参数如下： #Parameters (1.General) suffix Si calculation scf symmetry 1 pseudo_dir . orbital_dir . basis_type pw ecutwfc 100 2. SCF 迭代参数 scf_nmax：针对每个离子构型，scf 电子迭代的最大次数为 scf_nmax，可设为\"50\"或\"100\" 次。半导体和绝缘体是较容易收敛的体系，一般 20 步 scf 以内即可达到收敛，对于金属体系或者费米面较为复杂的体系，有可能 50 步仍未收敛。注意，如果做 relax, cell-relax, 或者 md 的时候发现有某些 scf 迭代次数达到最大时仍未达到收敛条件，建议先把计算停下来弄清楚原因后再继续算，有可能是因为离子构型或者k点等参数的设置不合理引起的。 scf_thr：代表两个相邻电子迭代步之间的电荷密度误差，也是 SCF 计算中判断是否收敛、完成计算的标准，对于 LCAO，一般设置为 \"1e-7\"，可认为精度足够。对于 pw，建议设置 1e-8 或 1e-9 的精度。 #Parameters (2. SCF iterations) scf_nmax 100 scf_thr 1e-8 3. 求解 Kohn-Sham 方程 nbands：计算的 Kohn-Sham 轨道数目，在本次计算中无磁性，参数 nspin 取 1（默认值），程序目前采取 0.5*max(1.2*occupied_bands, occupied_bands + 10) 计算 nbands。 对于 Si，价电子数为 4，每个能级填充可以填充自旋向上和向下 2 个电子，金刚石结构中共有 8 个原子，则nbands=max(1.282，8*2+10)=26。 ks_solver：在不同基组中展开哈密顿矩阵的对角化方法，对于 pw，可以选择 cg(Conjugate Gradient，默认方法)，bpcg(还不是太稳定、测试中)，dav(Davidson 算法)；对于 LCAO，可以选择 genelpa(默认值)，scalapack_gvx(Scalable Linear Algebra PACKage)。如果选用 LCAO 基组，ks_solver 可设置为\"genelpa\"。 #Parameters (3. Solve KS equation) nbands 26 ks_solver cg 4. 展宽技术 smearing_method：对于金属体系或者费米面附近较复杂的体系，电子自洽迭代方法往往不容易收敛，这个时候可以选择给电子提供一个光滑的占据函数，用来调节程序计算电荷密度和总电子数时候的电子占据函数，这对于费米面附近的电子态尤为重要。我们这里称为 \"smearing method\"，或者称为展宽方法。具体来说，对于金属体系可以选择 mp(methfessel-paxton)，mp2(2-nd methfessel-paxton) ，也可以使用 gauss(也可以写作 gaussian)。因为我们计算金刚石 Si 具有半导体性质，所以 smearing 方法基本不起作用，默认可以选择 gauss。此外，非导体计算可以选择 fixed，半导体和非导体也可以选择 fd(Fermi-Dirac)方法。 smearing_sigma：给定展宽方法的能量范围（单位：Ry），默认是 0.015 Ry，我们按照通常情况给定 \"0.01\"。 #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.01 5. 电荷密度混合 mixing_type：进行新旧电荷密度混合时选用的方法，可选 \"plain\"(简单电荷密度混合方法，如图 1 所示)、\"pulay\"、\"broyden\"），默认选择 \"broyden\"算法。 mixing_beta：新旧电荷密度混合时，新电荷的比例，不同系统取值不同。能带大于 1 eV 的体系，设为 0.7；能带小于 1 eV 的金属和过渡金属，设为 0.2。这个参数越大，收敛得越快，但不收敛的风险也会变大，不过取值大小并不会改变基态能量的结果。对于 Si，因为其能带隙为 1.12 eV，本计算中设置此参数为 \"0.7\"。 mixing_gg0：电子迭代过程中，可能出现混合电荷密度不收敛的情况，此时可以通过一种叫 Kerker Mixing 的方法来加快收敛。这个参数代表 Kerker 方法中调整电荷密度的尺度，本计算中设置此参数为 \"0\"。 #Parameters (5.Mixing) mixing_type broyden mixing_beta 0.7 mixing_gg0 0 到此，我们完成了对主要计算参数的设置，此时集成了以上主要参数的 INPUT 文件如下： #Parameters (1.General) suffix Si calculation scf symmetry 1 pseudo_dir . orbital_dir . basis_type pw ecutwfc 100 #Parameters (2. SCF iterations) scf_nmax 100 scf_thr 1e-8 #Parameters (3. Solve KS equation) nbands 26 ks_solver cg #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.01 #Parameters (5.Mixing) mixing_type broyden mixing_beta 0.7 mixing_gg0 0 五、收敛性测试 1. Ecut 收敛（只对平面波有效） 平面波（pw）作为一种可以用于描述周期性边界条件下的电子波函数和电荷密度基矢量，它们都是正交的，且可以通过一个 ecutwfc 参数来控制基矢量的个数，ecut 其实代表了每一个平面波所对应的动能，如果 ecut 取得越大，则基矢量可以描述震荡得越剧烈的物理量（例如氧原子的 2p 轨道），那么计算结果就会越精确，但同时所带来的机时成本消耗也越大。因此我们采用 pw 基组做真正计算前，需要对 ecut 进行测试来获得一个足够准确且效率也高的取值。 保持前文用于计算的基组为\"pw\"，进行 ecut 的收敛性测试，ecut 取值范围为：20~100 Ry。这个例子在 4 进程下启动 MPI 进行并行计算，一般推荐总核数(=线程数*进程数)取 2 的 n 次方或者 n 倍。一个较为粗糙、但基本不会造成计算资源浪费的选取 n 值原则是：体系有多少个原子，不要用超过这个原子个数太多的总核数进行并行计算。例如，体系如果有 16 个原子，不要用远大于 16 的总核数进行计算，一般取 16 的总核数或者更少就够了，具体需要测试。 mpirun -n 4 abacus 计算完成后，建议用脚本提取 ecut 数值下OUT.Si文件夹里running_scf.log文件中收敛的系统总能量，计算单原子能量并绘制其随着 ecut 的变化曲线。如图2，可以看见随 ecut 增大，系统总能量趋于收敛。在 ecut=60 Ry 时，认为总能量收敛(与 ecut=50 Ry 的能量差小于 1 meV/atom)。 图 2. 体系里平均单个Si原子能量(in eV/atom)随ecut (in Ry)变化。 2. k 点收敛 对具有周期性的体系进行计算时，DFT 计算实际会对第一布里渊区中不同离散化k点的单独进行计算（例如每个k点都会单独求解一次依赖于该k点的 Kohn-Sham 方程），并将计算结果进行积分。k点越多，则需要求的离散积分就越多，也将越近似连续积分的结果，但计算资源也会增加。因此，pw 和 LCAO 都有必要对 \"需要多少k点\" 进行测试并得出合适的k点选取方案。 金刚石Si的k点测试结果。同样在4进程下进行并行计算。 mpirun -n 4 abacus 计算完成后，提取各 K 点下OUT.Si文件夹里running_scf.log文件中收敛的系统总能量和计算时间，绘制这两个参数随 K 点的变化曲线。此处，N_k表示各方向上的k点取值个数，\"Energy-N_k\" 图中采用单原子的能量。 分析图3和图4可知，在N_k=6时，结果已收敛，能量不会再发生较大的变化(与N_k=5的能量差小于 1 meV/atom)，而此时花费时间 132 秒，相比于更大的N_k点较低。因此选择 6×6×6 的k点可以同时获得准确的结果和高的计算效率。 图 3. 体系里平均单个Si原子能量(in eV/atom)随K点变化。 图 4. 计算时间随K点变化。 提取出每个计算中实际使用到k点个数，如表一所示，实际使用k点数相比总k点数有较明显的简化。如前所述，INPUT 文件中我们设置了参数 symmetry 取 \"1\"，因此在实际计算中利用了晶胞结构中的对称性，即倒易空间的积分没有使用所有的k点计算，而是巧妙的利用了对称性得到其它k点的信息，简化了布里渊区中的计算工作量。这也解释了图4中明明总k点数不同，计算时间却十分接近的原因。 表一、N_k点数，总k点数，实际使用k点数： N_k 2 3 4 5 6 7 8 总k点个数 8 27 64 125 216 343 512 实际计算k点数（开了对称性） 4 4 10 10 20 20 35 以上就是本教程的内容，希望对学习密度泛函理论计算的初学者有所帮助。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-04-10 09:55:27 "},"abacus-md.html":{"url":"abacus-md.html","title":"ABACUS 分子动力学使用教程","keywords":"","body":"ABACUS 分子动力学使用教程 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/14 在Bohrium Notebook上快速学习： 一、分子动力学方法简介 分子动力学（Molecular Dynamics，简称 MD）：一种模拟原子体系随时间运动的方法，被广泛的用来研究与原子运动路径相关的一些基本过程，如相变、扩散、化学反应等等。本教程旨在介绍 ABACUS 中的分子动力学功能，分子动力学模拟重要的一件事情是如何选取精度和效率的平衡，其中精度高低主要取决于势函数的准确程度，而效率主要受限于求出每个原子的能量和受力的计算量。 经典分子动力学（Classical MD，简称 CMD）：通过构建描述原子间相互作用的势函数，获得每个原子的受力（受力等于能量对原子位置的导数），再通过积分运动方程来获得每个原子的下一时刻位置，从而获得随时间演化的粒子位置和速度。当系统处在一定的密度、温度和压强等物理条件限制下，可以结合统计物理的方法计算物质的性质。具体来说，采取某个系综后，对粒子位置和速度采样，之后统计出体系的热力学宏观性质。 从头算分子动力学（ab initio molecular dynamics，简称 AIMD）：也称为第一性原理的分子动力学方法（first-principles molecular dynamics，简称 FPMD），该方法采用的是第一性原理方法（例如密度泛函理论）来计算体系的势能面，因此计算量相比于经典分子动力学方法要昂贵很多。 ABACUS 的分子动力学功能：支持第一性原理分子动力学 FPMD 方法，也支持经典的 Lennard-Jones（LJ 对势）的分子动力学模拟。此外，ABACUS 还支持深度势能分子动力学（Deep Potential Molecular Dynamics，简称 DPMD）方法，此时需要编译 DeePMD-kit 软件包并在编译原子算筹软件时进行动态库的链接。 二、文档和算例下载地址 ABACUS 里关于分子动力学方法的线上文档地址为：http://abacus.deepmodeling.com/en/latest/advanced/md.html ABACUS 里关于分子动力学参数的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#molecular-dynamics ABACUS 的 MD 算例下载地址为（国内 gitee）： https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/md 可以采用的下载命令是： git clone https://gitee.com/mcresearch/abacus-user-guide.git 之后进入 /abacus-user-guide/examples/md 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/md 注：算例仓库里面包含 1_AIMD，2_LJMD（采用 Lennard-Jones 经典势做 MD），3_DPMD（采用深度势能方法做 MD）和 4_FIRE（采用 FIRE 算法做结构优化）四个目录。 注：以上算例要在 ABACUS v3.2.1 版本及以上可以运行成功，并且我们强烈建议下载使用 ABACUS 最新版本！ 1. 第一性原理分子动力学（AIMD） 进入 1_AIMD 目录，该目录提供了 8 个输入文件，使用的时候将 INPUT_* 复制为 INPUT 即可（INPUT_* 代表从 INPUT_0 到 INPUT_7 共 8 个不同的 INPUT 文件，对应 8 种不同的 MD 算法）。该算例采用 8 原子的金刚石结构 Si，晶格结构放在 STRU 文件里，布里渊区的 k 点采样放在 KPT 文件里。 8 个 INPUT 文件对应的 MD 方法如下： INPUT_0：采用 NVE 微正则系综 INPUT_1：采用 NVT 正则系综 INPUT_2：采用 Langevin 热库 INPUT_3：采用 Anderson 热库，NVT 系综 INPUT_4：采用 MSST 方法 INPUT_5：采用 Berendsen 热库，NVT 系综 INPUT_6：采用 rescaling 方法，NVT 系综 INPUT_7：采用 rescale_v 方法，NVT 系综 以 INPUT_0 为例： INPUT_PARAMETERS #Parameters (1.General) suffix Si_nve calculation md nbands 20 symmetry 0 pseudo_dir ../../../tests/PP_ORB orbital_dir ../../../tests/PP_ORB #Parameters (2.Iteration) ecutwfc 30 scf_thr 1e-5 scf_nmax 100 #Parameters (3.Basis) basis_type lcao ks_solver genelpa gamma_only 1 #Parameters (4.Smearing) smearing_method gaussian smearing_sigma 0.001 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 chg_extrap second-order #Parameters (6.MD) md_type nve md_nstep 10 md_dt 1 md_tfirst 300 这些参数在 ABACUS 线上文档中均有说明，在这里再进行简单概述： calculation：设置 ABACUS 计算类型，做分子动力学模拟请设置为 md。 esolver_type：给定原子位置进行系统能量的计算，默认 Kohn-Sham 密度泛函理论（ksdft），还可以设置 LJ 势（lj）或者深度势能（dp）。理论上来说，所有的 esolver_type 都可以用于 MD 计算。 chg_extrap：电荷外插法，在 relax 和 md 计算中可用于优化电荷密度初始化，加速电子迭代收敛，MD 中可以设置为 second-order。 md_type：MD 算法种类，默认是正则系统 nvt，这里的例子选择的是 nve，即 NVE 微正则系综。 md_nstep：MD 模拟的总步数。 md_dt：MD 计算每一步的时间步长（单位是 fs），与 md_nstep 共同决定 MD 总时长。 md_tfirst：MD 系统的初始温度（单位是 K）。 2. Lennard-Jones 势函数 进入 2_LJMD 目录，ABACUS 软件包中提供了一个采用 Lennard-Jones（LJ）经典势函数进行 MD 模拟的算例，该算例采用 LJ 对势作为能量求解器来做经典分子动力学，初始结构是边长 20 埃的正方体盒子中的 256 个无序 He 原子。 2.1 LJ 对势 LJ 对势的解析形式如下：u^{ij}表示原子 i 与原子 j 之间的相互作用能，r^{ij}表示这两个原子之间的距离，\\epsilon，\\sigma和r_{cut}则是 LJ 势需要的 3 个参数。LJ 势只考虑截断半径r_{cut}内的近邻原子 j 对中心原子 i 的能量贡献。 \\begin{array}{c} u^{i j}=4 \\varepsilon\\left[\\left(\\frac{\\sigma}{r_{i j}}\\right)^{12}-\\left(\\frac{\\sigma}{r_{i j}}\\right)^{6}\\right] \\\\ \\boldsymbol{F}_{i}=-\\nabla_{i} U=\\sum_{j} 4 \\varepsilon\\left[12\\left(\\frac{\\sigma}{r_{i j}}\\right)^{12}-6\\left(\\frac{\\sigma}{r_{i j}}\\right)^{6}\\right] \\frac{\\boldsymbol{r}_{i}-\\boldsymbol{r}_{j}}{r_{i j}^{2}} H\\left(r_{c u t}-r_{i j}\\right) \\end{array} \\\\ H(x)=\\left\\{\\begin{array}{l} 0\\ \\ \\ \\ (x0) \\end{array}\\right.\\\\ 2.2 STRU LJMD 是经典分子动力学，不需要提供 KPT，赝势和轨道文件，STRU 的前面几部分如下： ATOMIC_SPECIES He 4.0026 LATTICE_CONSTANT 1.889727 LATTICE_VECTORS 20 0 0 0 20 0 0 0 20 ATOMIC_POSITIONS Cartesian He #label 0 #magnetism 256 #number of atoms ATOMIC_SPECIES：不需要提供赝势信息 NUMERICAL_ORBITAL：不需要添加轨道信息 2.3 INPUT INPUT 文件中的参数也需要做少量修改： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md pseudo_dir ../../PP_ORB #Parameters (esolver) esolver_type lj lj_rcut 8.5 lj_epsilon 0.01032 lj_sigma 3.405 cal_force 1 cal_stress 1 #Parameters (MD) md_nstep 5 md_type nve md_dt 1 md_tfirst 300 init_vel 1 esolver_type：指定为 lj 就可以做 Lennard-Jones 经典势函数。 lj_rcut：LJ 对势的参数，即截断半径r_{cut}。 lj_epsilon：LJ 对势的参数，即\\epsilon。 lj_sigma：LJ 对势的参数，即\\sigma。 init_vel：读取 STRU 中的原子速度信息，原子单位制。 3. 深度势能（Deep Potential） ABACUS 软件包中提供了一个 DPMD 的算例，进入 3_DPMD 目录。该算例采用 DP 模型（DeePMD-kit 产生的深度势能模型）作为能量求解器来做基于机器学习的分子动力学，初始结构是 864 个无序铝原子。 3.1 DP 模型 DeePMD-kit 是一种基于机器学习的分子动力学模拟方法，该方法是通过使用第一性原理计算数据对深度神经网络模型进行训练，从而得到通用的多体势能模型（DP 模型）。 3.2 编译方式 ABACUS 采用 DP 模型做 MD 计算需要编译与 DeePMD-kit 的接口，cmake 以及 makefile 编译方式可以参考 ABACUS 线上文档。 3.3 INPUT 文件设置 DPMD 是经典分子动力学，不需要提供 KPT，赝势和轨道文件 INPUT 文件中的参数需要做少量修改： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md esolver_type dp pot_file ../../PP_ORB/Al-SCAN.pb cal_force 1 cal_stress 1 md_nstep 3 md_type msst md_dt 1 md_tfirst 200 md_dumpfreq 1 md_restartfreq 1 msst_qmass 200 msst_vel 0.028 msst_vis 0.3 init_vel 1 esolver_type：设置为 dp pot_file：DP 模型文件路径 md_dumpfreq：MD 输出文件 MD_dump 中原子以及晶胞信息的输出频率 md_restartfreq：结构文件 STRU_MD_${istep} 的输出频率，MD 续算文件 Restart_md.dat 的更新频率 3.4 STRU 文件的设置 首先，我们可以通过如下命令确定 DP 势文件中是否存在关键字“type_map”： $ strings Al-SCAN.pb | grep type_map {\"model\": {\"type_map\": [\"Al\"], \"descriptor\": {\"type\": \"se_e2_a\", \"sel\": [150], \"rcut_smth\": 0.5, \"rcut\": 6.0, \"neuron\": [25, 50, 100], \"resnet_dt\": false, \"axis_neuron\": 16, \"seed\": 1, \"activation_function\": \"tanh\", \"type_one_side\": false, \"precision\": \"default\", \"trainable\": true, \"exclude_types\": [], \"set_davg_zero\": false}, \"fitting_net\": {\"neuron\": [240, 240, 240], \"resnet_dt\": true, \"seed\": 1, \"type\": \"ener\", \"numb_fparam\": 0, \"numb_aparam\": 0, \"activation_function\": \"tanh\", \"precision\": \"default\", \"trainable\": true, \"rcond\": 0.001, \"atom_ener\": []}, \"data_stat_nbatch\": 10, \"data_stat_protect\": 0.01}, \"learning_rate\": {\"type\": \"exp\", \"decay_steps\": 5000, \"start_lr\": 0.001, \"stop_lr\": 3.51e-08, \"scale_by_worker\": \"linear\"}, \"loss\": {\"type\": \"ener\", \"start_pref_e\": 0.02, \"limit_pref_e\": 1, \"start_pref_f\": 1000, \"limit_pref_f\": 1, \"start_pref_v\": 0, \"limit_pref_v\": 0, \"start_pref_ae\": 0.0, \"limit_pref_ae\": 0.0, \"start_pref_pf\": 0.0, \"limit_pref_pf\": 0.0, \"enable_atom_ener_coeff\": false}, \"training\": {\"training_data\": {\"systems\": [\"../deepmd_data/\"], \"batch_size\": \"auto\", \"set_prefix\": \"set\", \"auto_prob\": \"prob_sys_size\", \"sys_probs\": null}, \"validation_data\": {\"systems\": [\"../deepmd_validation\"], \"batch_size\": 1, \"numb_btch\": 3, \"set_prefix\": \"set\", \"auto_prob\": \"prob_sys_size\", \"sys_probs\": null}, \"numb_steps\": 1000000, \"seed\": 10, \"disp_file\": \"lcurve.out\", \"disp_freq\": 100, \"save_freq\": 1000, \"save_ckpt\": \"model.ckpt\", \"disp_training\": true, \"time_training\": true, \"profiling\": false, \"profiling_file\": \"timeline.json\", \"enable_profiler\": false, \"tensorboard\": false, \"tensorboard_log_dir\": \"log\", \"tensorboard_freq\": 1}} 如果存在关键字 type_map，那么 ABACUS 会自动匹配 STRU 和 DP 势文件中的原子种类顺序。 否则，STRU 中的原子种类以及顺序必须与 DP 势文件中的原子种类以及顺序一致。 例如，如果我们用 Al-Cu-Mg 三元合金的 DP 势文件来跑 Al-Mg 二元合金的 MD，那么 STRU 应该如下所示： ATOMIC_SPECIES Al 26.982 Cu 63.546 Mg 24.305 LATTICE_CONSTANT 1.889727000000 LATTICE_VECTORS 4.0 0.0 0.0 0.0 4.0 0.0 0.0 0.0 4.0 ATOMIC_POSITIONS Cartesian Al 0 2 0.0 0.0 0.0 0.5 0.5 0.0 Cu 0 0 Mg 0 2 0.5 0.0 0.5 0.0 0.5 0.5 注：在这个例子中，即使 Cu 原子的数量为 0，也必须在 STRU 中给出 Cu 原子相关信息。 三、MD 输出和续算功能 1. MD 输出文件 ABACUS 的 MD 模拟会产生 3 类输出文件：结构文件 STRU_MD_${istep}，续算文件 Restart_md.dat，信息文件 MD_dump。 1.1 结构文件 STRU_MD_${istep} 参数 md_restartfreq 控制 OUT.${suffix}/STRU/文件夹中结构文件STRU_MD_${istep}的输出频率，该文件格式与输入结构文件 STRU 相同，主要用于 MD 续算。这里 istep 代表离子步，从 0 开始计数。 1.2 续算文件 Restart_md.dat 参数 md_restartfreq 控制 OUT.${suffix}/Restart_md.dat 的更新频率，用于 MD 续算。 1.3 信息文件 MD_dump 参数 md_dumpfreq 控制 OUT.${suffix}/MD_dump 文件的追加输出频率，该文件输出每 md_dumpfreq 步的 MD 信息，包括 MD 步数，晶格常数，晶格矢量，晶格维里，原子编号，原子位置，原子受力，原子速度。其中，晶格维里，原子受力，原子速度可以通过输入参数 dump_virial，dump_force，dump_vel 控制是否输出。 MDSTEP: 0 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 123.045275146001 -3.807535058112 -13.541439282961 -3.807535058112 124.421300186299 24.047959743672 -13.541439282961 24.047959743672 125.016024430342 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 0.000000000000 0.000000000000 0.000000000000 -0.885362725233 0.500467424348 0.150239620206 -0.003506076235 0.000412570794 0.000094403053 1 Si 1.300822817264 1.376389287977 1.354798867769 0.885362725233 -0.500467424348 -0.150239620206 0.003506076235 -0.000412570794 -0.000094403053 MDSTEP: 1 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 123.051574098220 -2.465332696362 -10.608474638302 -2.465332696362 123.587154919736 16.307187552709 -10.608474638302 16.307187552709 123.960669810770 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.389827754452 2.701629481339 2.699621723525 -0.602062173578 0.391990779819 0.096323485153 -0.010548689866 0.004659227844 0.001267888485 1 Si 1.308600113700 1.373562332082 1.353979669688 0.602062173578 -0.391990779819 -0.096323485153 0.010548689866 -0.004659227844 -0.001267888485 MDSTEP: 2 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 122.953007762375 -0.240072876170 -4.211946086929 -0.240072876170 122.930693852071 3.378536464243 -4.211946086929 3.378536464243 122.992607262385 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.376757913710 2.708010452044 2.701308224779 -0.124946902346 0.155367961328 0.009378252255 -0.012739769308 0.006644009927 0.001613591879 1 Si 1.321669954442 1.367181361377 1.352293168434 0.124946902346 -0.155367961328 -0.009378252255 0.012739769308 -0.006644009927 -0.001613591879 MDSTEP: 3 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 122.881221914392 1.206247195689 2.345023988024 1.206247195689 123.110079832453 -8.436042066928 2.345023988024 -8.436042066928 123.123976300784 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.364727401370 2.714719749381 2.702800880457 0.310711926370 -0.086233730382 -0.043760493686 -0.009222308089 0.005510922784 0.001122226311 1 Si 1.333700466782 1.360472064040 1.350800512757 -0.310711926370 0.086233730382 0.043760493686 0.009222308089 -0.005510922784 -0.001122226311 2 MD 续算功能 如果 ABACUS 运行达到指定的 MD 步数，或者计算中断，可以通过 MD 续算功能继续之前的 MD 计算。 以上一个 INPUT 文件为例： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md pseudo_dir ../../PP_ORB esolver_type dp pot_file ../../PP_ORB/Al-SCAN.pb cal_force 1 cal_stress 1 md_nstep 3 md_type msst md_dt 1 md_tfirst 200 md_dumpfreq 1 md_restartfreq 1 md_restart 1 msst_qmass 200 msst_vel 0.028 msst_vis 0.3 init_vel 1 md_restart：控制续算的开关，在 MD 续算时将这个参数设为 1，其他参数不变。当 md_restart 设为 1，ABACUS 会读取${read_file_dir}/Restart_md.dat文件，从中获取当前MD步数istep以及续算所需的其他参数如恒温器以及恒压器的信息，根据istep从OUT.${suffix}/STRU/ 文件夹中读取相应的结构文件 STRU_MD_${istep}，之后就可以进行 MD 续算了。 四、MD 后处理 目前主流的可视化软件如 VESTA、VMD、OVITO 并不支持 ABACUS 的文件格式，因此我们需要通过一些后处理软件实现 ABACUS 的 STRU、MD_dump 文件与常用文件格式的转化。我们比较推荐的后处理软件有： 1 ASE 官网：https://wiki.fysik.dtu.dk/ase/ 用法参考 ABACUS 线上文档：http://abacus.deepmodeling.com/en/latest/advanced/interface/ase.html 2 dpdata github 网址：https://github.com/deepmodeling/dpdata gitee 网址：https://gitee.com/deepmodeling/dpdata 3 案例 现在我们用 LJMD 算例来演示如何采用dpdata+OVITO的方式在 MD 计算完成后制作分子动力学轨迹动画。 3.1 MD 计算 下载案例文件 $ git clone https://gitee.com/mcresearch/abacus-user-guide 进入 LJMD 文件夹 $ cd abacus-user-guide/examples/md/2_LJMD 修改 INPUT 参数，把 md_nstep 改为 100 INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md pseudo_dir ../../PP_ORB #Parameters (esolver) esolver_type lj lj_rcut 8.5 lj_epsilon 0.01032 lj_sigma 3.405 cal_force 1 cal_stress 1 #Parameters (MD) md_nstep 100 md_type nve md_dt 1 md_tfirst 300 init_vel 1 运行 abacus $ abacus 3.2 dpdata 转化格式 安装 dpdata $ git clone https://github.com/deepmodeling/dpdata.git dpdata $ cd dpdata $ pip install . 运行 dpdata，将 MD_dump 文件转化为 GROMACS 的 gro 格式的文件 data.gro $ python3 >>> import dpdata >>> data = dpdata.LabeledSystem(\"./\", fmt=\"abacus/md\") >>> data.to_gro(\"data.gro\") 3.3 OVITO 制作动画 打开 OVITO，点击左上角 load file，选择上一步的 data.gro 文件 右上角 rendering settings 点击 Render active viewport 即可保存动画文件 五、特殊的 MD 方法 1. Fast Inertial Relaxation Engine ABACUS 中实现了一种特殊的基于 MD 的 Fast Inertial Relaxation Engine (FIRE)结构优化方法，该算法比共轭梯度法的标准实现快得多，具有额外的速度修改和自适应时间步长，具有优异的优化效率。 以上面提供的 4_FIRE 算例为例，我们可以介绍一下所需的参数如下： INPUT_PARAMETERS #Parameters (1.General) suffix Si_fire calculation md nbands 6 symmetry 0 pseudo_dir ../../PP_ORB orbital_dir ../../PP_ORB #Parameters (2.Iteration) ecutwfc 30 scf_thr 1e-8 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method gaussian smearing_sigma 0.001 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 chg_extrap second-order #Parameters (6.MD) md_type fire md_nstep 100 md_dt 1 md_tfirst 300 force_thr_ev 0.001 calculation：FIRE 算法是基于 MD 方法的，因此需要将 calculation 设为 md md_type：采用 FIRE 算法，需要设为 fire md_tfirst：MD 需要离子速度，因此需要通过设置初始温度来随机生成离子速度，或者在 STRU 文件中手动设置初始速度 force_thr_ev：离子受力的收敛阈值，当离子受力的每个分量均小于该阈值或者 MD 运行至最大步数时，MD 终止 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-sol.html":{"url":"abacus-sol.html","title":"ABACUS 隐式溶剂模型使用教程","keywords":"","body":"ABACUS 隐式溶剂模型使用教程 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn；孙梦琳，邮箱：sunmenglin@stu.pku.edu.cn 审核：许审镇，邮箱：xushenzhen@pku.edu.cn；陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/01 一、介绍 近年来，电化学表面反应，例如一些电催化系统，无论是在工业界还是科学研究领域，都受到了广泛的关注。而对于一个真实电极表面反应体系，往往需要考虑许多复杂的情况，例如电极与电解液之间的固液界面，在材料模拟中经常遇到和使用。在这种系统的第一性原理计算中应该考虑溶剂化效应，以便获得准确的性质预测。 溶剂化是指溶质和溶剂之间的相互作用，使溶质在溶液中稳定。这种相互作用的强度和性质影响体系的许多特性。在计算化学中，溶剂模型(Solvation model) 是描述溶剂化行为的一种计算方法。 隐式溶剂化模型(Implicit solvation model)是一种处理溶剂化效应的成熟方法，在有限系统和周期系统中得到了广泛的应用。这种方法将溶剂视为连续介质，而不是单独的“显式”溶剂分子，这意味着嵌入隐式溶剂中的溶质以及溶剂自由度的平均值将隐含在溶剂浴的性质中。与“显式”方法相比，这种隐式溶剂化模型可以以低得多的计算成本提供定性正确的结果，特别适用于大型复杂系统。 ABACUS 中实现的隐式溶剂化模型采用了 Mathew、Sundararaman、Letchworth-Waver、Arias 和 Hennig 在 2014 年开发的方法[1]。 二、文档和算例 ABACUS 里关于隐式溶剂模型的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/scf/advanced.html#implicit-solvation-model ABACUS 里关于隐式溶剂模型参数的线上文档地址为：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#implicit-solvation-model ABACUS 的隐式溶剂模型算例下载地址为（gitee）： https://gitee.com/deepmodeling/abacus-develop/tree/develop/examples/implicit_solvation_model/Pt-slab 可以采用的下载命令是： git clone https://gitee.com/deepmodeling/abacus-develop.git 之后进入 /abacus-develop/examples/``implicit_solvation_model/Pt-slab 目录 或者采用 Github 仓库地址： https://github.com/deepmodeling/abacus-develop/tree/develop/examples/implicit_solvation_model/Pt-slab 三、输入参数 INPUT_PARAMETERS #Parameters (1.General) suffix H2 calculation scf ntype 1 nbands 2 symmetry 0 pseudo_dir ./ #Parameters (2.Iteration) ecutwfc 60 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (Solvation Model) imp_sol 1 eb_k 80 tau 0.000010798 sigma_k 0.6 nc_k 0.00037 以算例提供的 INPUT 文件为例，使用隐式溶剂模型方法只需添加如下参数即可： imp_sol：类型是 Bool，指定隐式溶剂模型的开(1)或者关(0)，默认值为 0 eb_k：类型是 Real，溶剂的相对介电常数，水为 80 tau：类型是 Real，有效表面张力参数，用于描述未被静电项捕获的溶质和溶剂之间的空化、分散和排斥相互作用，单位是$Ry/Bohr^2$，默认值为 1.0798e-05 sigma_k：类型是 Real，由溶质的电子结构隐含地确定的扩散腔的宽度（溶质电子密度与 nc_k 的比值，无量纲），默认值为 0.6 nc_k：类型是 Real，介电腔形成时的电子密度值，单位是$Bohr^{-3}$，默认值为 0.00037 注意，eb_k 可根据需要设置为模拟溶剂分子的相对介电常数参数，默认值 80 为水分子情况。tau，sigma_k，nc_k 的默认值均由在水溶液情况下与实验结果拟合得到，如需考虑其他溶剂，可自行测试拟合。 四、预期结果 如图所示，一个氢分子位于超胞中，模拟其处于溶液环境时的状态。将 imp_sol 设为 1，其他参数使用默认值，表示溶剂为水。 在输出文件 OUT.ABACUS/running_scf.log 中，E_sol_el 和 E_sol_cav 分别表示静电作用和空腔作用引起的能量修正。如案例所示，E_sol_el 代表溶质和溶剂分子之间的静电感应作用，贡献的能量修正一般为负值。E_sol_cav 代表溶质分子在溶剂中产生空腔所引起的能量修正，一般为正值。 体系溶剂化能的计算：打开隐式溶剂模型（imp_sol = 1)时体系总能量(结构优化之后)与真空情况（imp_sol = 0)体系总能量（结构优化之后）之差。 五、参考文献 [1] J. Chem. Phys. 140, 084106 (2014), https://doi.org/10.1063/1.4865107 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-02 10:20:41 "},"abacus-sdft.html":{"url":"abacus-sdft.html","title":"ABACUS 随机波函数DFT方法使用教程","keywords":"","body":"ABACUS 随机波函数 DFT 方法使用教程 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/07/11 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍 ABACUS 中随机波函数密度泛函理论（Stochastic Density Functional Theory，以下简称 SDFT）计算功能。目前 ABACUS 使用 SDFT 主要聚焦在高温高压物质的模拟，特别是温稠密物质（Warm Dense Matter，简称 WDM）。在进行温稠密物质计算时（温度高达数十到上千 eV， 1 eV=11604.5 K），传统的 Kohn-Sham 密度泛函理论（KSDFT）需要用到极大数量的占据态电子波函数导致计算困难，而 SDFT 使用随机波函数轨道，可以有效地避开对角化哈密顿矩阵这个问题，应用于高温计算。关于 ABACUS 中实现 SDFT 算法的细节可以参考 Qianrui Liu and Mohan Chen*, \"Plane-wave-based stochastic-deterministic density functional theory for extended systems,\" Phys. Rev. B, 106, 125132 (2022)。本教程中将会展示如何在 ABACUS 计算中使用 SDFT 功能，此外还会介绍混合随机波函数密度泛函理论方法使用（mixed stochastic-deterministic DFT，简称 MDFT），即在 SDFT 计算中，混入一部分的低能 Kohn-Sham 轨道，从而加速结果收敛。 二、软件和算例准备 ABACUS 的软件包（3.2.0 版本）中提供了一个 SDFT 的算例，可以从 Gitee 上下载。可以在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载后解压，之后进入/abacus-user-guide/examples/stochastic 文件夹。算例中有三个文件夹，pw_Si2、pw_md_Al 和 186_PW_SDOS_10D10S。 三、采用 SDFT 进行电子自洽迭代计算 pw_Si2文件夹：这是一个电子温度为 0.6 Ry（约 8.16 eV）的 2 个原子的金刚石结构硅（Si）的电子自洽迭代（Self Consistent Field，简称 SCF）算例，包含布里渊区 K 点的 KPT 文件和包含原子位置的 STRU 文件与传统的 KSDFT 计算并无区别，主要的不同在于输入文件 INPUT，注意目前 SDFT 仅支持 smearing_method 为 fd。INPUT 文件如下： INPUT_PARAMETERS #Parameters (General) calculation scf esolver_type sdft pseudo_dir ../../PP_ORB nbands 4 nbands_sto 64 nche_sto 100 method_sto 1 #Parameters (Accuracy) ecutwfc 50 scf_nmax 20 symmetry 1 #Parameters (Smearing) smearing_method fd smearing_sigma 0.6 以上参数在 ABACUS 的线上文档中均有详细说明，这里再进行简单概述： calculation设置为 scf，代表进行电子自洽迭代计算（self-consistent field）。 esolver_type是选择系统总能量求解方法的，默认为 ksdft（Kohn-Sham density functiona theory），这里需要设置为 sdft 才会使用 SDFT 或者 MDFT 进行计算。 nbands是使用的 Kohn-Sham 轨道的数目（也叫 determinstic orbitals，是通过严格对角化矩阵计算出来的）。如果 nbands 设置为 0，且 nbands_sto（随机轨道数目，这里设成 64）不为 0，则会进行 SDFT 计算；如果 nbands>0，且 nbands_sto>0，则会进行混合 KS 电子轨道和随机轨道（stochastic orbitals）的 MDFT 计算。注意：一般 nbands 设置为能量低于费米能级对应的能带数，计算效率会比较高。 nbands_sto是使用随机波函数（stochastic orbitals）轨道数目，原则上取得越大则随机误差越小，但计算效率也会相应降低。 判断随机波函数个数是否足够的一个经验法则是：测试能量误差。实际计算中，一般可以采用10 个左右不同的随机数种子（可以参考 seed_sto 参数设置随机数种子，下面有介绍）生成的相同数目的随机波函数轨道进行 SDFT 计算，得到系统能量并求得相应误差，增加随机波函数轨道数目直到控制能量误差小于万分之一即可。 当 nbands_sto 设为 0 时， 程序会自动转成 KSDFT 进行计算（ABACUS 3.2.2 版本以后）。 nche_sto是将电子体系的哈密顿量进行切比雪夫展开的阶数，这个数取得越大则用到的切比雪夫展开阶数越多，相应的计算精度也会越高但效率会降低。大致关系为与温度成反比，温度越高，阶数可以取得越小；ecut（正比关系）越大，阶数越大；推荐使用的 nche_sto 的大小是使得输出文件 running_scf.log 中的 Chebyshev Precision 小于 1e-8。 method_sto是进行 SDFT 计算使用的方法：1 代表消耗内存较少但稍慢的方法，2 代表更快但需要更大内存的方法，默认是 2。 此外还有如下参数可能会用到： seed_sto：生成随机轨道的随机种子。默认是 0，代表随时间随机生成；若要控制使用相同的随机种子，可以设置一个大于 1 的整数。 bndpar：将所有并行的进程分成 bndpar 个组，计算所用随机轨道将平均分布在每个组中，可以提高并行效率，默认为 1。值得注意的是，这个参数并不是越大越好，并且不如 K 点并行（kpar参数）有效，实际计算中应该优先使用 K 点并行，然后测试不同大小的 bndpar，确定最佳的 bndpar。 平面波能量截断值 ecut 的测试：由于随机误差的出现，SDFT 的 ecut 的测试与传统的 KSDFT 稍有区别，但是原理是类似的。在确定好 nbands_sto 后，就可以测试 ecut 了。与测试 nbands_sto 类似，在不同的 ecut，需要采用 10 个左右不同的随机种子生成的相同数目的随机波函数轨道进行 SDFT 计算，然后取平均能量。由于温稠密物质能量一般都比较高，因此只要控制相邻二个 ecut（相差为 10 Ry）对应的平均能量差小于一定标准即可（例如万分之一）。 注 1：在这个例子里我们提供的赝势是 Si.pz-vbc.UPF 文件，这个文件包含 4 个硅的价电子。事实上，当温度特别高的时候，一般的赝势可能会面临可移植性差的问题，例如高温会使得内壳层电离。这个时候，要选择合理的赝势进行计算，甚至可能需要自己造一个新的赝势，目前 ABACUS 3.2.0 支持的是模守恒的赝势。 注 2：ABACUS 的 SDFT 和 MDFT 支持多个 k 点采样，因此可以在 KPT 文件里设置不同的 k 点个数，在某些性质的计算里，要注意计算性质随着 k 点的收敛。 四、采用 SDFT 进行分子动力学模拟 pw_md_Al 文件夹：这是一个电子温度为 7.35 Ry（约 100 eV）、包含 16 个铝（Al）原子的结构，我们对其进行分子动力学（Molecular Dynamics，简称 MD）的模拟。INPUT 文件如下： INPUT_PARAMETERS #Parameters (General) calculation md esolver_type sdft pseudo_dir ../../PP_ORB nbands 0 nbands_sto 64 nche_sto 20 method_sto 2 #Parameters (Accuracy) ecutwfc 50 scf_nmax 20 scf_thr 1e-6 symmetry 1 #Parameters (Smearing) smearing_method fd smearing_sigma 7.34986072 #Parameters (MD) md_tfirst 1160400 md_dt 0.2 md_nstep 10 注意要进行分子动力学模拟，calculation 参数需设置为 md。esolver_type 需设置为 sdft，才能进行 SDFT 的计算。这里 nbands 设置为 0，nbands_sto 设置为 64，代表仅仅使用随机轨道而没有 KS 轨道的 SDFT 计算。 五、采用 SDFT 计算态密度 186_PW_SDOS_10D10S 文件夹：采用 SDFT 还可以计算给定体系的态密度（Density of States，简称 DOS）。例如，186_PW_SDOS_10D10S 是一个 1 个 Si 原子的算例，电子温度约为0.6 Ry（约 8.16 eV）。如下所示： INPUT_PARAMETERS #Parameters (1.General) suffix autotest calculation scf esolver_type sdft method_sto 2 nbands 10 nbands_sto 10 nche_sto 120 emax_sto 0 emin_sto 0 seed_sto 20000 pseudo_dir ../../PP_ORB symmetry 1 kpar 1 bndpar 2 #Parameters (2.Iteration) ecutwfc 20 scf_thr 1e-6 scf_nmax 20 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method fd smearing_sigma 0.6 #Parameters (5.Mixing) mixing_type broyden mixing_beta 0.4 out_dos 1 dos_emin_ev -20 dos_emax_ev 100 dos_edelta_ev 0.1 dos_sigma 4 dos_nche 240 npart_sto 2 以上参数在 ABACUS 的线上文档中均有说明，这里再进行简单概述： out_dos：需要设置为 1，才能输出能态密度。 dos_emin_ev：能态密度的能量最小范围，单位 eV。 dos_emax_ev：能态密度的能量最大范围，单位 eV。 dos_edelta_ev：控制输出DOS时的能量间隔，单位 eV。 dos_sigma：能态密度的高斯展宽的因子，单位 eV。 dos_nche：计算能态密度时切比雪夫展开阶数，默认为 100。 npart_sto：当使用 method_sto＝2 运行例如 DOS 的 SDFT 后处理时，将控制使用内存大小为正常的 1/npart_sto，防止内存不够导致无法计算，默认为 1。 注：态密度的输出文件是 OUT 文件夹下的 DOS1_smearing.dat。 六、结尾 总体来讲，随机波函数密度泛函理论方法（SDFT 或者 MDFT）的使用与 KSDFT 并无太大的区别，直接运行 ABACUS 程序即可，但是对一些关键参数的选取会影响精度和效率（例如 nbands, nbands_sto, nche_sto, method_sto, kpar, bnd_par）。对于极端高温计算（>10 eV），使用 SDFT 可以大大提高计算速度，是比普通的 KSDFT 更好的选择。如果大家使用有问题，欢迎写信联系（见上）。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-ofdft.html":{"url":"abacus-ofdft.html","title":"ABACUS 无轨道密度泛函理论方法使用教程","keywords":"","body":"ABACUS 无轨道密度泛函理论方法使用教程 作者：孙亮，邮箱：l.sun@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/07/19 在Bohrium Notebook上快速学习： 一、无轨道密度泛函理论背景知识 无轨道密度泛函理论(Orbital free density functional theory, OFDFT)是一种第一性原理模拟方法，相比于 Kohn Sham DFT (KSDFT)，它的优势之一在于O(N\\ln N)的算法复杂度，这使得 OFDFT 可以用于上万原子甚至更大体系的电子基态计算，或者大体系、长时间的第一性原理分子动力学等。 目前，OFDFT 已被应用于简单金属、合金、半导体、小分子、温稠密物质等体系。 1. 无轨道密度泛函理论 在 OFDFT 的框架下，体系的总能量泛函可以写为 E_{\\rm{OF}}[\\rho] = T_{\\rm{s}}[\\rho] + E_{\\rm{ext}}[\\rho] + E_{\\rm{H}}[\\rho] + E_{\\rm{xc}}[\\rho] + E_{\\rm{II}}. 依次为无相互作用动能T_{\\rm{s}}[\\rho]，电子-离子相互作用能E_{\\rm{ext}}[\\rho]，电子-电子相互作用能E_{\\rm{H}}[\\rho]，交换关联能E_{\\rm{xc}}[\\rho]，离子-离子相互作用能E_{\\rm{II}}，其中\\rho为电荷密度。 为了在粒子数守恒的条件下求解其极小值，利用拉格朗日乘子法，定义 L=E_{OF}[\\rho]-\\mu(\\int{\\rho(r)dr}-N), 可以证明，这里的乘子\\mu就是无相互作用体系中最高占据态的能量，即化学势。为了保证密度处处为正，一般对\\sqrt\\rho进行优化，因此求L对\\sqrt\\rho的导数，为了方便，定义\\phi(r) = \\sqrt {\\rho(r)}，则有 \\frac{\\delta L}{\\delta \\phi}=\\frac{ \\delta E_{OF}[ \\rho ] }{ \\delta \\phi }-2\\mu\\phi=0 \\rightarrow V(r)\\phi(r)=\\mu\\phi(r). \\ \\ \\ \\ \\ \\ \\ \\ (*) 其中V(r)=\\frac{ \\delta E_{OF}[ \\rho ] }{ \\delta \\rho(r) }为势能。这就是 OFDFT 求解的方程，一般用共轭梯度（CG）法、截断牛顿（TN）法或 L-BFGS 等优化算法求解。目前 ABACUS 中实现了 TN 法和两种 CG 法（Polak-Ribire 形式和 Hager-Zhang 形式），默认采用 TN 法。 ABACUS 基于平面波基矢量，实现了上述流程，可以进行基于 OFDFT 的自洽计算，分子动力学计算，以及结构弛豫。 2. 动能泛函 OFDFT 的精度高度依赖于动能泛函（kinetic energy density functional, 简称 KEDF）的精度，目前 ABACUS 中实现了 Thomas-Fermi (TF) [1], von Weizsäcker (vW) [2], TFλvW [3], Wang-Teter (WT) [4], Luo-Karasiev-Trickey (LKT) [5]共五种动能泛函。 下面我们对这些泛函做简单介绍，并且介绍在 ABACUS 的 INPUT 文件中如何设置相关的参数。 2.1 Thomas-Fermi KEDF 设置 INPUT 文件中的 of_kinetic tf 参数 T_{\\rm{TF}}=\\frac{3}{10}(3\\pi^2)^{2/3}\\int{\\rho^{5/3}(r)dr}, 对均匀电子气精确成立，可用于极高温体系，比如处于温稠密状态的金属。 可通过 of_tf_weight 调整其权重，默认为 1。 2.2 von Weizsäcker KEDF 设置 of_kinetic vw T_{\\rm{vW}}=-\\frac{1}{2}\\int{\\sqrt{\\rho(r)} \\nabla^2 \\sqrt{\\rho(r)}dr}, 对单电子、双电子体系（只有一条轨道）严格成立，一般不单独使用。 可通过 of_vw_weight 调整其权重，默认为 1。 2.3 TFλvW KEDF 设置 of_kinetic tf+ T=T_\\text{TF}+\\lambda T_\\text{vW}, 当\\lambda=\\frac{1}{9}时就是TF KEDF的二阶梯度展开，一般\\lambda=\\frac{1}{5}时表现最好。 参数\\lambda可通过of_vw_weight设置，默认为1。 2.4 Wang-Teter KEDF 设置of_kinetic wt T_{\\rm{WT}} = \\frac{3}{10}(3\\pi^2)^{2/3} \\iint{\\rho ^{\\alpha}(r)W(r - r'){\\rho ^{\\beta}}(r') drdr'} + T_{\\rm{vW}} + T_{\\rm{TF}}, 基于 Lindhard 响应函数推导，在简单金属 Li、Mg、Al 中有着不错的表现。是 ABACUS 默认采用的 KEDF。 参数\\alpha,\\beta可通过 of_wt_alpha 和 of_wt_beta 设置，默认值均为\\frac{5}{6}。 2.5 Luo-Karasiev-Trickey KEDF 设置 of_kinetic lkt T_{\\rm{LKT}}= \\int{\\tau_{\\rm{TF}}\\frac{1}{\\cosh as}dr} + T_{\\rm{vW}}, s=\\frac{1}{2(3\\pi^2)^{1/3}}\\frac{|\\nabla\\rho|}{\\rho^{4/3}}. 可用于简单金属和半导体，计算效率较高，但在简单金属中精度低于 WT KEDF。 参数 a 可通过 of_lkt_a 设置，默认值为 1.3。 3. 局域赝势 由于 OFDFT 中舍弃了单电子轨道，无法采用常用的非局域赝势，如模守恒赝势，而必须采用局域赝势。 目前 ABACUS 支持 BLPS (bulk-derived local pseudopotential)。 下载地址： https://github.com/EACcodes/local-pseudopotentials实空间赝势：ABINIT, ABACUS； 倒空间赝势：PROFESS。赝势生成(需要和 ABINIT 7.0.5 结合)：https://github.com/EACcodes/BLPSGenerator覆盖 Li, Mg, Al, Si, P, Ga, As, In, Sb 九种元素 使用 BLPS 时，需要在 ABACUS 里调整的参数有： INPUT 中：pseudo_rcut 16 STRU 中：赝势种类设置为 blps，比如 Al 26.98 al.lda.lps blps 二、ABACUS 中进行 OFDFT 计算的具体流程 1. 自洽计算 1.1 示例 下面是输入文件的示例： INPUT 文件记录 OFDFT 计算所需主要参数 INPUT_PARAMETERS #Parameters (1.General) suffix example calculation scf esolver_type ofdft symmetry 1 pseudo_dir ../../PP_ORB/ pseudo_rcut 16 nspin 1 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 50 #Parameters (3.Basis) basis_type pw #OFDFT of_kinetic wt of_method tn STRU 文件记录元素种类、质量、赝势，晶格矢量，原子坐标等信息 ATOMIC_SPECIES Al 26.98 al.lda.lps blps LATTICE_CONSTANT 7.50241114482312 // add lattice constant LATTICE_VECTORS 0.000000000000 0.500000000000 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 0.500000000000 0.000000000000 ATOMIC_POSITIONS Direct Al 0 1 0.000000000000 0.000000000000 0.000000000000 1 1 1 KPT 文件（因为 OFDFT 没有电子波函数，所以不需要布里渊区的多个 k 点，Gamma 点就可以） K_POINTS 0 Gamma 1 1 1 0 0 0 如上所示，与 KSDFT 的自洽计算相比，OFDFT 自洽计算的输入文件有以下几个区别： INPUT 不需要设置 smearing 和 charge mixing 相关参数，如果设置了也没有关系，这些参数不会影响 OFDFT 计算； 将 esolver_type 设置为 ofdft； 将 pseudo_rcut 设置为 16，以适配 BLPS 赝势。 STRU 将赝势种类设置为 blps。 做完以上调整后，即可使用默认参数进行 OFDFT 的自洽计算。 下面列举一些其它的重要参数： of_kinetic：用于选择动能泛函，可选项有 tf, vw, tf+, wt, lkt，默认值为 wt，具体介绍见 1.2 节； of_method：用于选择优化方法，可选项有 tn, cg1, cg2，分别对应截断牛顿法和两种 CG 法（Polak-Ribire 形式和 Hager-Zhang 形式），默认为 tn。一般而言，效率上 tn > cg2 > cg1； of_full_pw：做快速傅里叶变换（FFT）时，是否使用全部的平面波，默认为 True。建议打开，可以保证计算的稳定性和精度； of_full_pw_dim：控制 FFT 维数的奇偶性，可选项有 0, 1, 2，分别表示可奇可偶，保证为奇数，保证为偶数，默认为 0。FFT 维数为偶数时，可能导致微小的误差，但一般来说可以忽略。需要注意的是，如果打开了 nbspline，则需要设置 of_full_pw_dim 1，否则会导致计算不稳定。 1.2 注意事项 目前 ABACUS 的 OFDFT 模块并不是十分完善，使用时请注意以下几个注意事项： 目前 OFDFT 不支持 gamma only，因此使用 OFDFT 功能时请关闭 gamma_only； 目前 OFDFT 只支持自旋简并，即 nspin 1 的计算； 如果使用 PBE 泛函，建议用 dft_functional XC_GGA_X_PBE+XC_GGA_C_PBE 调用 Libxc 中的 PBE，否则可能导致计算不稳定。 2. 分子动力学与结构弛豫 ABACUS 中支持使用 OFDFT 作为能量、力和应力的求解器，进行分子动力学模拟与结构弛豫。 与使用 KSDFT 进行分子动力学或结构弛豫相比，使用 OFDFT 时，不需要对 MD，relax，或 cell-relax 相关参数进行修改，只需要按照 2.1 中的方式，将能量、力和应力的求解器替换为 OFDFT。 下面是几个实际的 INPUT 例子： 2.1 分子动力学（MD） INPUT_PARAMETERS #Parameters (1.General) suffix test calculation md esolver_type ofdft pseudo_dir ../../PP_ORB pseudo_rcut 16 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #OFDFT of_kinetic wt of_method tn of_full_pw_dim 1 #Parameters (3.Basis) basis_type pw md_restart 0 md_type nvt md_nstep 2 md_dt 0.25 md_tfirst 58022.52706 md_dumpfreq 10 md_tfreq 1.08 md_tchain 1 nbspline 10 2.2 原子结构弛豫（relax） INPUT_PARAMETERS #Parameters (1.General) suffix test calculation relax esolver_type ofdft pseudo_dir ../../PP_ORB pseudo_rcut 16 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #OFDFT of_kinetic wt of_method tn #Parameters (3.Basis) basis_type pw relax_nmax 50 2.3 晶格弛豫（cell-relax） INPUT_PARAMETERS #Parameters (1.General) suffix test calculation cell-relax esolver_type ofdft pseudo_dir ../../PP_ORB pseudo_rcut 16 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #OFDFT of_kinetic wt of_method tn #Parameters (3.Basis) basis_type pw relax_nmax 50 三、参考文献 [1] Fermi E. Statistical method to determine some properties of atoms[J]. Rend. Accad. Naz. Lincei, 1927, 6(602-607): 5. [2] Weizsäcker C F. Zur theorie der kernmassen[J]. Zeitschrift für Physik, 1935, 96(7-8): 431-458. [3] Berk A. Lower-bound energy functionals and their application to diatomic systems[J]. Physical Review A, 1983, 28(4): 1908. [4] Wang L W, Teter M P. Kinetic-energy functional of the electron density[J]. Physical Review B, 1992, 45(23): 13196. [5] Luo K, Karasiev V V, Trickey S B. A simple generalized gradient approximation for the noninteracting kinetic energy density functional[J]. Physical Review B, 2018, 98(4): 041111. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-surface1.html":{"url":"abacus-surface1.html","title":"采用 ABACUS 进行表面计算（一）：静电势和功函数","keywords":"","body":"采用 ABACUS 进行表面计算（一）：静电势和功函数 作者：孙亮，邮箱：l.sun@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/01 一、背景 静电势（electrostatic potential），也叫电势，是指将单位电荷从参考点移动到场内某一点所做的功。 在密度泛函理论的框架下，静电势V_{static}定义为 V_{static} = V_{H}+V_{ext}+V_{efield}+V_{dipole}+... 其中V_{H} = \\int{\\frac{\\rho(r')}{|r-r'|}dr'}为电子产生的静电势，V_{ext}为离子势（赝势的局域部分），V_{field}为外加电场项，V_{dipole}为偶极修正项，输出静电势和输出局域势的差别在于有没有输出交换关联势。 在处理表面等体系时，静电势可用于计算功函数等物理量，并进一步用于催化活性、化学反应机理以及电子输运性质等性质的计算与分析。 ABACUS 提供了直接输出静电势的接口，并提供了对其进行后处理的 python 脚本。 二、ABACUS 中计算静电势具体流程 此功能在平面波基组、原子轨道基组下的 Kohn-Sham DFT（KSDFT），以及随机波函数密度泛函理论和无轨道密度泛函理论中均适用。接下来，我们以平面波基组下的 KSDFT 为例介绍其使用方法，如果需要使用其它的能量求解器，只需要设置 INPUT 文件里的 esolver_type、basis_type 更换能量求解器并设置相应求解器的参数即可。 1. 计算实例 1.1 输出静电势 下面是输入文件的示例： INPUT 文件记录计算所需主要参数，为了输出静电势，只需要设置 out_pot 2 即可（设置 out_pot 1 时，会输出总的局域势，2 相比于 1 少输出了交换关联势，具体可以参考线上文档 https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#out-pot）。 INPUT_PARAMETERS #Parameters (1.General) suffix example calculation scf ntype 1 nbands 40 symmetry 1 pseudo_dir . #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.0074 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.7 out_pot 2 STRU 文件记录元素种类、质量、赝势，晶格矢量，原子坐标等信息 ATOMIC_SPECIES Al 13 Al_ONCV_PBE-1.0.upf LATTICE_CONSTANT 7.6513590200098225 // add lattice constant LATTICE_VECTORS 0.707106781187 0.000000000000 0.000000000000 0.000000000000 0.707106781187 0.000000000000 0.000000000000 0.000000000000 5.000000000000 ATOMIC_POSITIONS Direct Al 0.0 5 0.000000000000 0.000000000000 0.000000000000 1 1 1 0.500000000000 0.500000000000 0.100000000000 1 1 1 0.000000000000 0.000000000000 0.200000000000 1 1 1 0.500000000000 0.500000000000 0.300000000000 1 1 1 0.000000000000 0.000000000000 0.400000000000 1 1 1 KPT 文件 K_POINTS 0 Gamma 20 20 1 0 0 0 如上所示，为了输出静电势，只需要在 INPUT 中设置 out_pot`` ``2，计算完成后即可在 OUTOUT.${suffix} 文件夹下找到下面的 ElecStaticPot.cube 文件。 ElecStaticPot.cube 文件（记录了实空间格点上的静电势，单位是 A.U.，下面的文档中，我们在括号中加入了注释。此文件可以直接在 VESTA 中可视化） Cubefile created from ABACUS SCF calculation. The inner loop is z index, followed by y index, x index in turn. 1 (nspin) 5（总原子数） 0.0 0.0 0.0（原点坐标） 27（沿x轴格点数nx） 0.200383 0.000000 0.000000（晶格矢量a1的1/nx，in Bohr。即晶格常数a*a1/nx） 27（沿y轴格点数ny） 0.000000 0.200383 0.000000（晶格矢量a2的1/ny，in Bohr） 192（沿z轴格点数nz） 0.000000 0.000000 0.199254（晶格矢量a3的1/nz，in Bohr） 13（第一个原子的原子序数） 11（赝势中的价电子数） 0.000000 0.000000 0.000000（该原子位置的笛卡尔坐标，in Bohr） 13 11 2.705164 2.705164 3.825680 13 11 0.000000 0.000000 7.651359 13 11 2.705164 2.705164 11.477039 13 11 0.000000 0.000000 15.302718 （空间格点上的数据，z坐标变化最快，接下来依次是y, x，一般为6个数据一行，每走完z的一次循环换一行） -1.808618025e+01 -1.683249579e+01 -1.326226499e+01 -8.726520963e+00 -4.859516723e+00 -2.648153424e+00 -1.754646057e+00 -1.082969997e+00 -7.712730497e-01 -5.301070017e-01 -1.865686936e-01 1.178808012e-03 1.531960521e-01 2.434659807e-01 3.236379649e-01 3.580121711e-01 3.871087692e-01 4.067752520e-01 4.191236489e-01 4.303464392e-01 4.269139054e-01 4.072584618e-01 4.012863417e-01 3.694437712e-01 3.419696568e-01 2.751686292e-01 1.986707660e-01 7.265002162e-02 -9.800789596e-02 -3.699329212e-01 ... 5.605648983e-01 5.596641131e-01 5.601221783e-01 5.558024312e-01 5.582286739e-01 5.509517334e-01 5.484144631e-01 5.474458329e-01 5.413456797e-01 5.310960172e-01 5.220139261e-01 5.057932112e-01 4.893954664e-01 4.661977108e-01 4.379332539e-01 3.906110446e-01 3.390039472e-01 2.575599458e-01 1.632711220e-01 1.092880266e-02 -1.657977733e-01 -5.027618535e-01 -7.758727829e-01 -1.023213291e+00 -1.643162715e+00 -2.406825325e+00 -4.139043775e+00 -7.343485448e+00 -1.119104878e+01 -1.435478802e+01 1.2 后处理 为了方便计算沿着 z 方向的平均静电势，我们在 tools/average_pot 下提供了 python 后处理脚本 aveElecStatPot.py，在存放 ElecStaticPot.cube 的文件夹下运行 python path_to_abacus/tools/average_pot 即可在此文件夹中得到存放了平均静电势的 ElecStaticPot_AVE 文件，如下所示。 ElecStaticPot_AVE 文件（存放了沿 z 方向的平均静电势，单位是 A.U.。此文件的前 11 行与 ElecStaticPot.cube 相同，之后的第一列数为沿着 z 轴的格点指标，第二列数为平均静电势） Average electrostatic potential along z axis 1 (nspin) 5 0.0 0.0 0.0 27 0.200383 0.000000 0.000000 27 0.000000 0.200383 0.000000 192 0.000000 0.000000 0.199254 13 11 0.000000 0.000000 0.000000 13 11 2.705164 2.705164 3.825680 13 11 0.000000 0.000000 7.651359 13 11 2.705164 2.705164 11.477039 13 11 0.000000 0.000000 15.302718 iz average 0 -1.021155030e+00 1 -9.476023401e-01 2 -7.542571394e-01 3 -5.200099451e-01 ... 189 -5.039597208e-01 190 -7.447469356e-01 191 -9.431350596e-01 可视化后如图所示： 1.3 功函数 功函数（work function），又称逸出功，描述把电子从固体内部移到真空中所需的最小能量。 在 DFT 计算中，它可以定义为V_{vaccum} - E_F，其中V_{vaccum}为真空静电势，可以在 ElecStaticPot_AVE 中读到，E_F为体系费米能，可以用 grep EFERMI OUT.${suffix}/running_scf.log 命令从 OUT.${suffix}/running_scf.log 文件中提取出来。 对于上面的例子，V_{vaccum} = 0.563\\ \\rm{Ry}，E_F=3.3293551883\\ \\rm{eV}\\approx0.245\\ \\rm{Ry}，因此功函数为V_{vaccum} - E_F = 0.318\\ \\rm{Ry}。 如果大家使用有问题，欢迎写信联系（见上）。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-09 12:03:12 "},"abacus-surface2.html":{"url":"abacus-surface2.html","title":"采用 ABACUS 进行表面计算（二）：偶极修正","keywords":"","body":"采用 ABACUS 进行表面计算（二）：偶极修正 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/08/28 一、偶极修正介绍（Dipole Correction） 偶极矩（Dipole Moment）是一个矢量，由正、负电荷中心距离和其所带电量乘积得到，方向规定为正电中心指向负电中心，采用原子建模表面时，往往表面会产生偶极矩。 ABACUS 在 xyz 三个方向都采用周期性边界条件（Periodic Boundary Conditions），当使用密度泛函理论（Density Functional Theory，简称 DFT）进行表面体系的电子结构计算时常采用超胞（Supercell）近似，这时所研究的体系在真空方向会出现两个表面。当两个表面不对称时（例如在某表面进行吸附原子计算），这两个表面的电荷密度分布就会不同，这个时候两个表面的偶极密度不同且表面附近的静电势（Electrostatic Potential）会呈现不同的值。然而，周期性边界条件的存在会强制使得静电势也要满足周期性边界条件，这个时候周期性边界条件的存在相当于制造了一个非物理的人造电场（Artificial Electric Field）。 通常情况下，降低这个人造电场的方法是加大真空层的厚度，使得相邻的超胞之间没有相互作用，但这往往要大幅增加密度泛函理论的计算量。因此，为了消除周期性边界条件对表面偶极矩带来的影响，我们可以采用偶极修正（Dipole Correction）的方法，通过引入另外一个外电场来抵消这个人造电场，但注意引入的外电场需要存在于真空中（其位置是程序输入参数的一部分）才不至于影响所要研究的表面体系。经过修正后，人造电场将被抵消，真空电势则维持不变。 ABACUS 中实现了偶极修正功能[1]，可以有效的加速静电势收敛，避免超胞的真空取得太长，从而可以降低计算量。该修正功能主要体现在 Hartree 项的处理上，并且存在相应的原子受力的修正，可以用于平面波（Plane-Wave）基组和数值原子轨道（Numerical Atomic Orbitals）基组计算，但注意该功能只能用于带真空层的表面体系。 二、文档与算例 ABACUS 里关于偶极修正的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/scf/advanced.html#dipole-correction ABACUS 里关于偶极修正参数的线上文档地址为：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#electric-field-and-dipole-correction ABACUS 的偶极修正算例下载地址为（gitee）： https://gitee.com/MCresearch/abacus-user-guide/tree/master/examples/dipole_correction/H2O 可以采用的下载命令是： git clone https://gitee.com/MCresearch/abacus-user-guide 之后进入 /abacus-user-guide/examples/``dipole_correction/H2O/ 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/dipole_correction/H2O 三、偶极修正输入参数介绍 INPUT_PARAMETERS #Parameters (1.General) suffix H2O calculation scf nbands 6 symmetry 0 pseudo_dir ../../PP_ORB #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method fixed #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.7 #Parameters (6.Dipole correction) efield_flag 1 dip_cor_flag 1 efield_pos_max 0.0 efield_pos_dec 0.1 efield_amp 0.00 #Parameters (7.Output) out_pot 2 以算例提供的 INPUT 文件为例，使用偶极修正方法只需添加如下参数即可： efield_flag：类型是 Bool，指定外加电场的开(1)或者关(0)，默认值为 0，注意应用偶极修正功能时，efield_flag 必须设为 true dip_cor_flag：类型是 Bool，指定偶极修正的开(1)或者关(0)，默认值为 0 efield_dir：类型是 Int，外加电场方向，可取 0，1，2 分别表示 x，y，z 方向，默认值为 2 efield_pos_max：类型是 Real，锯齿状电势最大值所在分数坐标，范围[0,1)，默认值为 0.5 efield_pos_dec：类型是 Real，锯齿状电势从最大值到最小值的长度（同样以分数坐标为度量），默认值为 0.1，范围[0,1)。以图1为例，0.5 是最大值，0.6 是最小值，那么 0.5 ~ 0.6 的区域必须放置在没有原子的真空层中 图 1. 锯齿状势场分布图 efield_amp：类型是 Real，电场强度，默认值为 0，单位为 a.u.，其中 1 a.u. = 51.4220632*10^10 V/m。在偶极修正时需要设为 0，不为 0 则说明同时添加了外加电场和偶极修正 四、预期结果 如图2所示，一个水分子位于超胞（尺寸为 3\\times3\\times18 Å^3）的中部（即位于9 Å），那么按照上一部分的说明，锯齿应该放在没有原子的真空处，因此我们将电势的最大值所在的位置设为 efield_pos_max 设为 0.0，之后设置电势从最大值到最小值的长度，即将 efield_pos_dec 设为 0.1（在这个例子是 1.8 Å），如此锯齿即位于 0.0~0.1 的区域。 为了验证结果的正确性，我们可以画出静电势沿 Z 轴（c 方向）的变化如图3所示。在水分子上方（9-18 Å）和下方（0-9 Å）的真空层中，静电势在很长一段区间保持常数不变，出现了两个平台，这说明我们的偶极修正功能使用无误。静电势计算和作图方法请参考静电势和功函数计算文档。 图 2. 一个水分子位于超胞中，红色代表氧原子，白色代表氢原子 图 3. 静电势沿超胞Z轴变化图 五、参考文献 [1] Phys. Rev. B 59, 12301 (1999), https://doi.org/10.1103/PhysRevB.59.12301 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-20 16:41:21 "},"abacus-surface3.html":{"url":"abacus-surface3.html","title":"采用 ABACUS 进行表面计算（三）：表面能计算","keywords":"","body":"采用 ABACUS 进行表面计算（三）：表面能计算 作者：孙亮，邮箱：l.sun@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/12 一、背景 将某一固体沿着某一晶面方向切开会形成相应的表面，许多化学反应都是依托在一些特定的表面系统上展开的。因此，计算表面能也是第一性原理计算经常会遇见的。 表面能（surface energy）定义为单位面积内表面体系与相应的体材料（bulk systems）能量之差，或者建立某特定表面需要做的功。不同表面的原子排布会对应不同大小的表面能，从能量的观点来看，表面能越低的表面体系越稳定，在现实世界里就越有可能稳定存在。 另外，需要注意的是，当沿着固体的某一晶面切开形成表面时，这个表面不一定是稳定结构。由于表面原子所经历的周围环境相比于体材料有所变化，所以往往表面原子会重新排布，只是排布的幅度有大有小。所以，一般来说，需要对表面进行结构优化计算，达到能量最低的稳定态。有一些常见的表面重构，已经被实验所证实，例如硅的表面重构。 密度泛函理论（Density Functional Theory，简称 DFT）也常用来计算材料体系的表面能，但如果使用的是周期性边界条件，往往构造的原子体系会有两个表面，以及一段真空。注意真空的长度一般不能太小（一般大于 10 埃），要长到能量达到收敛。另外，如果表面是有极化的，可以采用 dipole correction 功能进行修正，这样真空往往可以取短一些。另外一方面，构成表面体系的原子层数一般来讲不少于 3-5 层，有时候需要检验更多层以达到收敛，达到收敛时体系最靠近中间的层一般和体材料的原子性质较为接近，这个可以作为表面厚度是否足够的判据之一，另外一个判据就是随着层数的增加，所得到的表面能的值是否已经收敛。 用 DFT 计算材料体系的表面能时，需要进行两次自洽迭代（self-consistent field，简称 scf）计算，一次用于计算体材料体系中每原子的能量E_{0}，一次用于计算表面体系的总能量E_{slab}，最终表面能\\sigma定义为 \\sigma = \\frac{E_{\\rm{slab}} - NE_{0}}{2A} 其中N为表面体系包含的原子数，A为表面面积，分母上的 2 来自于如果计算中采用了周期性边界条件，即表面体系实际有上下两个表面。计算表面能时，需要计算E_{0}和E_{\\rm{slab}}两个能量。ABACUS 软件中，我们可以采用平面波基组、原子轨道基组下的 Kohn-Sham DFT（KSDFT），以及随机波函数密度泛函理论和无轨道密度泛函理论来计算它们。 二、ABACUS 计算表面能具体流程 接下来，我们以平面波基组下的 KSDFT 为例介绍其计算方法，如果需要使用其它的能量求解器，只需要设置 INPUT 文件里的 esolver_type、basis_type 更换能量求解器并设置相应求解器的参数即可。 以下是几个构造表面结构的注意点： 由于 ABACUS 在实空间的并行策略是将格点沿 z 轴分层，关于并行我们有两个建议：第一，为了使得 MPI 并行时负载平衡，建议沿 x 方向设置真空，即让表面的法线沿着 x 轴，避免有些核分不到原子，影响计算效率；第二，如果并行的核数较多，建议沿 z 方向设置真空，即让表面的法线沿着 z 轴，因为每个核至少要分到一些 z 方向的格点，选取长边会使得可以并行的核数更多。 真空层厚度一般设置在 10 埃以上，具体需要调整真空层厚度做收敛性测试； 表面结构（slab）需要用内部的原子模拟体材料，因此其厚度也要做收敛性测试。 1. 铝面心立方晶体(100)表面能计算 算例链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_energy/Al_fcc100 1.1 计算体材料能量 这一步用晶格弛豫方法找到面心立方晶体 fcc Al 的平衡构型以及平衡能量。 链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_energy/Al_fcc100/0_bulk 运行完算例后，用 grep FINAL_ETOT_IS OUT.example/running_cell-relax.log 得到总能量为 -1883.225 eV，由于原胞内只有一个原子，因此E_{0}=-1883.225\\ \\rm{eV}。 从 OUT.example/STRU_ION_D 文件中可以读到平衡晶格常数为a_0=7.586\\ \\rm{Bohr}，它将用于表面构型的构造。 注意，如果是带有磁性的原子，计算体材料的时候也要加上磁性的计算，例如在 INPUT 文件里设置 nspin=2。 1.2 计算表面体系能量 这一步我们搭建表面体系并计算其总能量。 链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_energy/Al_fcc100/1_surface_5layers https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_energy/Al_fcc100/2_surface_7layers 实际计算时，需要对表面构型的原子层数做收敛性测试，作为例子，我们提供了 5 层和 7 层的算例，其构型如下所示： 计算总能量时，可以根据实际需要选择是否做结构优化，这里为了结果更准确，同时兼顾效率，我们固定了内部原子，对表面上的原子结构进行了优化。 对于 5 层构型，用 grep FINAL_ETOT_IS OUT.example/running_relax.log 得到总能量为 -9415.005 eV，因此E_{\\rm{slab}}=-9415.005\\ \\rm{eV}。 对于 7 层构型，总能量E_{slab}=-13181.372\\ \\rm{eV}。 1.3 计算表面能 对于上述构型，表面面积A=(a_0 / \\sqrt{2})^2 = 8.057\\ \\rm{Å}^2。 对于 5 层构型，表面构型原子数N=5，因此表面能\\sigma = \\frac{E_{\\rm{slab}} - NE_{0}}{2A} = 0.070\\ \\rm{eV/Å^2} = 1113\\ \\rm{mJ/m}^2。 对于 7 层构型，表面构型原子数N=7，因此表面能\\sigma = \\frac{E_{\\rm{slab}} - NE_{0}}{2A} = 0.075\\ \\rm{eV/Å^2} = 1196\\ \\rm{mJ/m}^2。 可以看到 7 层的构型相比于 5 层算出的表面能还差别较大，所以需要增加层数一直到表面能收敛。 2. 硅金刚石结构(100)表面能计算 这里金刚石结构我们又名为 CD（Cubid Diamond）结构 算例链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_energy/Si_CD100 2.1 计算体材料能量 这一步我们用晶格弛豫方法找到 CD Si 的平衡构型以及平衡能量。 链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_energy/Si_CD100/0_bulk 运行完算例后，用命令 grep FINAL_ETOT_IS OUT.example/running_cell-relax.log 得到体系总能量为 -214.516 eV，由于原胞内有两个原子，因此E_{0}=-107.258\\ \\rm{eV}。 从 OUT.example/STRU_ION_D 文件中可以读到平衡晶格常数为a_0=10.351\\ \\rm{Bohr}，它将用于表面构型的构造。 2.2 计算表面体系能量 这一步我们搭建表面体系并计算其总能量。 链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_energy/Si_CD100/1_surface 我们搭建了一个 9 层的表面构型，如下图所示： 计算总能量时，可以根据实际需要选择是否做结构优化，这个例子里，为了计算省时，我们没有做结构优化。 用 grep FINAL_ETOT_IS OUT.example/running_scf.log 得到总能量为 -961.337 eV，因此E_{\\rm{slab}}=-961.337\\ \\rm{eV}。 2.3 计算表面能 对于上述构型，表面面积A=(a_0 / \\sqrt{2})^2 = 15.015\\ \\rm{Å}^2，表面构型原子数N=9，因此表面能\\sigma = \\frac{E_{\\rm{slab}} - NE_{0}}{2A} = 0.133\\ \\rm{eV/Å^2} = 2126\\ \\rm{mJ/m}^2。 与实验值 2131\\ \\rm{mJ/m}^2[1]非常接近，但略大于另一个实验值1361\\ \\rm{mJ/m}^2[2]。 注：以上为表面能计算示例，若有问题欢迎邮件联系（见上）。 三、参考文献 [1] Eaglesham D J, White A E, Feldman L C, et al. Equilibrium shape of Si[J]. Physical Review Letters, 1993, 70(11): 1643. [2] Messmer C, Bilello J C. The surface energy of Si, GaAs, and GaP[J]. Journal of Applied Physics, 1981, 52(7): 4623-4629. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-12 23:15:47 "},"abacus-surface4.html":{"url":"abacus-surface4.html","title":"采用 ABACUS 进行表面计算（四）：表面缺陷能和吸附能计算","keywords":"","body":"采用 ABACUS 进行表面计算（四）：表面缺陷能和吸附能计算 作者：孙亮，邮箱：l.sun@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/09 一、背景 在研究表面的稳定性时，我们经常关注表面上形成空穴、或者表面上吸附其它分子的难易程度，这两种现象可以分别用表面缺陷能和表面吸附能描述。 表面缺陷能（surface vacancy energy）定义为在表面上形成原子的空穴所需能量，缺陷能越低，则该表面越容易形成缺陷。 表面吸附能（surface adsorption energy）定义为原子、离子或分子（吸附物，adsorbate）附着在固体表面（吸附剂，adsorbent）的吸附过程中，二者结合时的能量下降，它描述了吸附剂对吸附物的吸附能力，吸附能越低，则吸附能力越强。 由于缺陷间或吸附物间的相互作用，上述两种物理量都与缺陷或吸附物在表面的覆盖率（coverage）\\theta有关，其定义为\\theta = N_{\\rm{v/a}}/N_{\\rm{surface}}，即缺陷数或吸附物数与表面原子数之比。覆盖率越低，则缺陷间或吸附物间相互作用越弱，计算时所需的超胞也越大，实际计算中，可根据需求选择合适的覆盖率。本文档中，为了节省计算量，采取较大的覆盖率\\theta=0.25。 下面我们分别介绍这两个物理量的计算方法，并展示如何使用 ABACUS 计算。 ABACUS 中，我们可以采用平面波基组、原子轨道基组下的 Kohn-Sham DFT（KSDFT）和无轨道密度泛函理论等电子结构计算方法来计算所需的能量，也可以调用 DeePMD 势函数。接下来，我们以平面波基组下的 KSDFT 为例介绍其计算方法，如果需要使用其它的能量求解器，只需要设置 INPUT 文件里的 esolver_type、basis_type 更换能量求解器并设置相应求解器的参数即可。 二、ABACUS 计算表面缺陷能具体流程 表面缺陷能E_{\\rm{vac}}可定义为 E_{\\rm{vac}} = E_{\\rm{slab/vac}} + E_{\\rm{bulk}} - E_{\\rm{slab}} 其中E_{\\rm{slab/vac}}为带缺陷表面构型的总能量，E_{\\rm{bulk}}为体材料中每原子的能量，E_{\\rm{slab}}为无缺陷表面构型的总能量，注意计算E_{\\rm{slab/vac}}所需构型比E_{\\rm{slab}}少一个原子，即缺陷。 因此为了计算某种表面的缺陷能，我们需要进行三次自洽迭代（scf）计算，分别得到上述三个能量。 注意下面的例子中，为了提升效率，我们采用了较低的能量截断值（20 Ry）以及较少的 k 点（gamma 点），实际计算中，需要对二者做收敛性测试。 如果计算体系有磁性原子，要注意体材料的时候是否要加上磁性的计算。 计算实例：钼体心立方 110 表面缺陷能 链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_vacancy_adsorption/0_vacancy/Mo 1.1 计算体材料能量 这一步我们用晶格弛豫方法找到体心立方（bcc） Mo 的晶格常数以及平衡能量。 运行算例后，用 grep FINAL_ETOT_IS OUT.example/running_cell-relax.log 得到总能量为 -1861.827 eV，由于原胞内只有一个原子，因此E_{\\rm{bulk}}=-1861.827\\ \\rm{eV}。 从 OUT.example/STRU_ION_D 文件中可以读到平衡晶格常数为a_0=5.924\\ \\rm{Bohr}，它将用于表面构型的构造。 1.2 计算表面体系能量 这一步我们参考文献[1]，搭建了一个 7 层的 Mo bcc(110)表面体系，每层包含 4 个原子，如下图所示： 计算其总能量时，可以根据实际需要选择是否做结构优化，这里为了效率更高，我们没有做结构优化。 用 grep FINAL_ETOT_IS OUT.example/running_scf.log 得到总能量为 -52129.480 eV，因此E_{\\rm{slab}}=-52129.480\\ \\rm{eV}。 1.3 计算带缺陷的表面体系能量 第三步我们搭建带缺陷的表面体系，方法是从表面上移除一个原子，如下图所示，移除了表面中心的原子： 此算例同样没有做结构优化。 用 grep FINAL_ETOT_IS OUT.example/running_scf.log 得到总能量为 -50265.933 eV，因此E_{\\rm{slab/vac}}=-50265.933\\ \\rm{eV}。 1.4 计算缺陷能 对于上述构型，最终的缺陷能E_{\\rm{vac}} = E_{\\rm{slab/vac}} + E_{\\rm{bulk}} - E_{\\rm{slab}} = 1.720\\ \\rm{eV}。 三、ABACUS 计算表面吸附能具体流程 表面吸附能E_{\\rm{ads}}可定义为 E_{\\rm{ads}} = E_{\\rm{adsorbate/adsorbent}} - E_{\\rm{adsorbent}} - E_{\\rm{adsorbate}} + \\Delta \\rm{ZPE} 其中E_{\\rm{adsorbate/adsorbent}}为吸附物与吸附剂结合后的总能量，E_{\\rm{adsorbent}}为吸附剂体系的总能量，E_{\\rm{adsorbate}}为吸附剂体系的总能量，\\Delta \\rm{ZPE}为零点能，注意计算E_{\\rm{adsorbate/adsorbent}}所需构型的原子数为E_{\\rm{adsorbent}}与E_{\\rm{adsorbate}}之和。 因此为了计算吸附能，我们需要进行三次自洽迭代（scf）计算，分别得到上述三个能量。 计算实例：Li 原子在 Mo bcc(110)表面的吸附能 链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_vacancy_adsorption/1_adsorption/Li-Mobcc110 1.1 计算 Li 原子能量 这一步我们计算孤立 Li 原子的能量，方法是将一个 Li 原子放在一个足够大的原胞中，以排除 Li 原子间的相互作用。比如本例子中 Li 原子间距为 20\\ \\rm{Å}。 用 grep FINAL_ETOT_IS OUT.example/running_cell-relax.log 得到总能量为 -183.156 eV，由于原胞内有两个原子，因此E_{\\rm{adsorbent}}=-183.156\\ \\rm{eV}。 1.2 计算 Mo bcc(110)体系总能量 上文已经计算过E_{\\rm{slab}}=-52129.480\\ \\rm{eV}，因此这里E_{\\rm{adsorbate}}=-52129.480\\ \\rm{eV}。 1.3 计算吸附体系总能量 这一步我们参考文献[1]搭建了以 long bridge 形式吸附了 Li 原子的 Mo bcc(110)表面体系，其中 Li 到 Mo 表面的距离为 2.229\\ \\rm{Å}，如下图所示，绿色的原子为 Li 原子。 这里我们没有做结构优化，但在实际计算中，Li 原子到 Mo 表面的距离应该通过结构优化得到。 用 grep FINAL_ETOT_IS OUT.example/running_scf.log 得到总能量为 -52315.069 eV，因此E_{\\rm{adsorbate/adsorbent}}=-52315.069\\ \\rm{eV}。 1.4 计算吸附能 对于上述构型，吸附能E_{\\rm{ads}} = E_{\\rm{adsorbate/adsorbent}} - E_{\\rm{adsorbent}} - E_{\\rm{adsorbate}} = -2.433\\ \\rm{eV}。（此处忽略了零点能） 四、参考文献 [1] Chen M, Roszell J, Scoullos E V, et al. Effect of temperature on the desorption of lithium from molybdenum (110) surfaces: Implications for fusion reactor first wall materials[J]. The Journal of Physical Chemistry B, 2016, 120(26): 6110-6119. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-14 11:02:06 "},"abacus-surface5.html":{"url":"abacus-surface5.html","title":"采用 ABACUS 进行表面计算（五）：外加电场","keywords":"","body":"采用 ABACUS 进行表面计算（五）：外加电场 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/08/28 一、介绍 电场是电荷及变化磁场周围空间里存在的一种特殊物质。这种物质与通常的实物不同，它虽然不是由分子原子所构成的，但它却是客观存在的特殊物质，具有通常物质所具有的力和能量等客观属性。许多材料在外加电场作用下会表现出不同寻常的性质，例如：铁电体在外加电场的作用下会产生电极化，也可以通过施加的电场来控制磁性和自发极化，因此在信息储存和传输中有广泛应用；二维材料（如石墨烯）在外加电场下表现出不同的电子性质和可控制的物理性质，这种特性使其具有在电子学领域的广泛应用前景。在电子结构计算中，周期性边界条件下对体系施加电场较为容易，而施加磁场则困难很多。 因此，外加电场是密度泛函理论（Density Functional Theory，简称 DFT）软件中可以被实现且重要的功能。ABACUS 中实现了在表面体系中外加恒定电场的功能[1]。注意，在 ABACUS 中，外加电场功能存在相应的原子受力的修正，可以用于平面波（Plane-Wave）基组和数值原子轨道（Numerical Atomic Orbitals）基组计算，但注意该功能只能用于带真空层的表面体系。 本教程中将会展示如何在 ABACUS 计算中使用加电场功能，为使得这个教程较为有趣，我们举一个半金属二维材料 nanoribbon（见图 1）加电场产生半金属的例子来讲解如何给体系添加电场，该 DFT 的计算工作曾发在 2006 年的 Nature 杂志上，具体可参考文献[2]。在这个教程里，我们使用的是数值原子轨道基矢量（Numerical Atomic Orbitals），碳和氢的轨道半径都是 8 a.u.，但实际上也可以使用平面波基矢量，只是前者效率更高所以在这里采用。我们还会使用到电子的自洽场（self-consistent field，简称 SCF）计算，非自洽计算（non-self-consistent field，简称 NSCF），自旋非极化和极化计算等概念。在不考虑自旋时（即设置 nspin=1 时），计算出的能带图中没有带隙，为金属；考虑自旋之后，带隙打开，成为半导体；在自旋极化基础上，外加恒定电场之后，其中一个自旋表现为半导体，另一个自旋则为金属。 图 1. Nanoribbon结构图，黑框代表超胞大小，有真空。超胞里包含32个碳原子（棕色），超胞里接触真空的2个碳原子（每个表面一个碳原子）被2个氢原子（白色）饱和。 二、软件和算例准备 ABACUS 里关于外加电场的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/scf/advanced.html#external-electric-field ABACUS 里关于外加电场参数的线上文档地址为：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#electric-field-and-dipole-correction ABACUS 的外加电场算例下载地址为（gitee）： https://gitee.com/MCresearch/abacus-user-guide/tree/master/examples/electric_field/ 可以采用的下载命令是： git clone https://gitee.com/MCresearch/abacus-user-guide 下载后解压，之后进入 /abacus-user-guide/examples/``electric_field 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide 三、采用加电场进行二维材料的能带计算 该算例中含有六个文件夹，解释如下： 1_unspin_scf：做非自旋极化（INPUT 文件中的 nspin 设为 1）的自洽场迭代 SCF 计算（INPUT 文件中的 calculation 设为 scf），输出自洽迭代之后的电子密度（将 INPUT 中的 out_chg 设为 1），注意二维材料的 KPT 文件，因为超胞大小是 102.459512146645 Å^3，所以对应的布里渊区 k 点取的是 1101，因为实空间周期长度小的方向对应的布里渊区大，所以需要取更多 k 点得到收敛结果。 2_unspin_band： 采用非自洽计算 NSCF（INPUT 文件中的 calculation 设为 nscf），读入上一个步骤输出的电荷密度（INPUT 文件中的 init_chg 设为 file），从而可以读入体系的基态电荷密度进行能带计算。 3_spin_scf：同 1_unspin_scf 的计算，只是把 nspin 设为 2。 4_spin_band：同 2_unspin_band 的计算，只是把 nspin 设为 2。 5_spin_elec_scf：同 3_spin_scf 的计算，只是又外加了电场的参数。 6_spin_elec_band：同 4_spin_band 的计算，只是又外加了电场的参数。 以下是算例 5 的输入文件（包含电场参数）： INPUT_PARAMETERS #Parameters (General) suffix nanoribbon calculation scf nbands 70 nspin 2 pseudo_dir ../../PP_ORB orbital_dir ../../PP_ORB #Parameters (Basis) basis_type lcao #Parameters (Accuracy) ecutwfc 100 scf_thr 1e-6 scf_nmax 200 #Parameters (Smearing) smearing_method gaussian smearing_sigma 0.001 #Parameters (Charge mixing) mixing_type pulay mixing_beta 0.1 mixing_ndim 20 mixing_gg0 1.5 #Parameters (Efield) efield_flag 1 efield_dir 2 efield_amp 0.0019440124 efield_pos_max 0.95 efield_pos_dec 0.10 以算例提供的 INPUT 文件为例，使用外加电场功能只需添加如下参数即可： efield_flag：类型是 Bool，指定外加电场的开(1)或者关(0)，默认值为 0 efield_dir：类型是 Int，外加电场方向，可取 0，1，2 分别表示 x，y，z 方向，默认值为 2 efield_pos_max：类型是 Real，锯齿状电势最大值所在分数坐标，范围[0,1)，默认值为 0.5 efield_pos_dec：类型是 Real，锯齿状电势从最大值到最小值的长度（同样以分数坐标为度量），默认值为 0.1，范围[0,1)。以图2为例，0.5 是最大值，0.6 是最小值，那么 0.5 ~ 0.6 的区域必须放置在没有原子的真空层中，注意这个例子设置的是 0.95 到 0.10 为电场区间。 图 2. 锯齿状势场分布图 efield_amp：类型是 Real，电场强度，默认值为 0，单位为 a.u.，其中 1 a.u. = 51.4220632*10^10 V/m 以上参数的使用方法在采用 ABACUS 进行表面计算（二）：偶极修正中有更详细的说明。 四、预期计算结果 运行完算例 2_unspin_band 后会通过非自洽计算得到体系非自旋极化能带图，横坐标是对二维材料布里渊区取 k 点，从 Gamma 点（坐标为 0 0 0）取到\\pi点（坐标为 0 0.5 0），取了 100 个 k 点算出来的能带图；纵坐标是能级，将费米面设置为 0，取了费米面附近 2 eV 的能量区间画出能带。以下两张图是同样取法。 运行完算例 4_spin_band 后会得到非自洽计算得到的自旋极化能带图（图 3）。 运行完算例 6_spin_elec_band 后会得到自旋极化加电场的能带图（图 4），注意这里所加的电场为 0.1 V/Å，由输入文件 INPUT 中的 efield_amp 设置，但 efield_amp 的单位是 a.u.，需要换算。 图 3. 采用PBE交换关联泛函和非自旋极化得到的二维nanoribbon的能带图，可以看出费米面附近CBM（Conduction Band Minimum）和VBM（Valence Band Maximum）重合，无带隙。 图 4. 采用PBE交换关联泛函和自旋极化得到的二维nanoribbon的能带图。蓝色和红色代表自旋极化方向不同时对应的两副能带图像，可以看出不加电场时，两个自旋方向的能带图几乎一样，都有带隙。 图 5. 采用PBE交换关联泛函和自旋极化，再给体系加上0.1 V/Å的电场得到的二维nanoribbon的能带图。蓝色和红色代表自旋极化方向不同时对应的两副能带图像，可以看出加了能带之后，其中一个自旋方向的能带图出现费米面附近的交叠，呈现金属性质，另外一个自旋方向的能带图依旧保持在费米面处的能隙。 五、参考文献 [1] Phys. Rev. B 59, 12301 (1999), https://doi.org/10.1103/PhysRevB.59.12301 [2] Nature 444, 347–349 (2006), https://doi.org/10.1038/nature05180 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-20 16:44:22 "},"abacus-surface6.html":{"url":"abacus-surface6.html","title":"采用 ABACUS 进行表面计算（六）：补偿电荷","keywords":"","body":"采用 ABACUS 进行表面计算（六）：补偿电荷 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/08/28 一、介绍 现实中的化学反应多数时候发生在恒定电势条件下，而传统的 DFT 计算软件则是基于恒定电荷的条件。若要在计算模拟中保持恒定电势，在电化学表面反应建模时就需要调整晶胞中的电子数。在开源密度泛函理论软件 ABACUS 里，模拟体系时使用的是周期性边界条件，因此需要添加额外的算法保持模拟过程中同时保证超胞的电中性。其中的一种方案就是当从系统中添加/提取额外的电子时，需要在表面模型的真空区域中实现补偿电荷的分布。 目前 ABACUS 软件中实现了补偿电荷功能[1]，与增减电子数相对应的补偿电荷会以带电平板的形式（不考虑平板厚度）予以补偿进而保持电中性，并且存在相应的原子受力的修正，可以用于平面波（Plane-Wave）基组和数值原子轨道（Numerical Atomic Orbitals）基组计算，但注意目前该功能只能用于带真空层的表面体系。我们以下的例子以一个水分子为例，如图 1 所示。 图 1. 一个水分子位于超胞中，红色代表氧原子，白色代表氢原子 二、文档与算例 ABACUS 里关于补偿电荷的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/scf/advanced.html#compensating-charge ABACUS 里关于补偿电荷参数的线上文档地址为：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#gate-field-compensating-charge ABACUS 的补偿电荷算例下载地址为（gitee）： https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/compensating_charge/H2O 可以采用的下载命令是： git clone https://gitee.com/mcresearch/abacus-user-guide 之后进入 /abacus-develop/``examples/compensating_charge/H2O 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/compensating_charge/H2O 三、偶极修正与补偿电荷结合的表面计算 在采用 ABACUS 进行表面计算（二）：偶极修正文档中，我们给出了水分子层计算中应用偶极修正之后的结果。在此基础上，我们可以进一步应用补偿电荷功能。如图 1 所示，我们采用了完全相同的一个水分子在周期性晶胞的结构，只有 INPUT 文件中添加了补偿电荷相关参数。 INPUT_PARAMETERS #Parameters (1.General) suffix H2O calculation scf nbands 8 symmetry 0 pseudo_dir ../../PP_ORB #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.001 #Parameters (5.Mixing) mixing_type broyden mixing_beta 0.1 #Parameters (6.Dipole correction) efield_flag 1 dip_cor_flag 1 efield_pos_max 0.0 efield_pos_dec 0.1 efield_amp 0.0 #Parameters (7.Compensating charge) gate_flag 1 zgate 0.7 nelec 9 #Parameters (8.Output) out_pot 2 以算例提供的 INPUT 文件为例，使用补偿电荷功能只需添加如下参数即可： gate_flag：类型是 Bool，指定补偿电荷功能的开(1)或者关(0)，默认值为 0 efield_dir：类型是 Int，指定与带电平板垂直的方向，可取 0，1，2 分别表示 x，y，z 方向，默认值为 2 zgate：类型是 Real，指定带电平板（位于真空中）在晶胞中的位置（分数坐标），范围[0,1)，默认值为 0.5 nelec：类型是 Real，设定的体系总电子数，这里是 9 个电子（氧原子因为赝势有 6 个电子，每个氢原子有 1 个电子，总共 8 个电子），即原体系多加了 1 个电子，那么为了保持电中性，带电平板会带 1 个正电荷 block：类型是 Bool，添加势垒以防止电子溢出的功能（可选），1 代表开，0 代表关，默认值为 0 block_down：类型是 Real，势垒的起点（分数坐标），默认是 0.45 block_up：类型是 Real，势垒的终点（分数坐标），默认是 0.55 block_height：类型是 Real，势垒高度，单位是里德堡（Rydberg），默认是 0.1 四、预期结果 如左下图所示，一个水分子位于超胞（尺寸为 3\\times3\\times18 \\mathrm{Å^3}）的中部（即位于9 \\mathrm{Å}）。按照采用 ABACUS 进行表面计算（二）：偶极修正文档中偶极修正参数设置的说明，锯齿即位于 0.0~0.1 的区域。注意在采用偶极修正/外加电场功能的情况下，带电平板的位置应该在真空区域，并且不同于偶极修正锯齿所在的区域。 为了验证结果的正确性，我们可以画出静电势沿 Z 轴（c 方向）的变化如图 2 所示。与只应用偶极修正功能的静电势相比（可参考表面计算二里面的图 3），在分数坐标 0.7（Z 轴 12.6 埃）处，静电势出现了一个向下的凹陷，这来自于此处的补偿电荷带电平板的影响。 静电势计算和作图方法请参考静电势和功函数计算文档。 图 2. 静电势（Electrostatic Potential）沿超胞Z轴变化图 五、参考文献 [1] Phys. Rev. B 89, 245406 (2014), https://doi.org/10.1103/PhysRevB.89.245406 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-01-04 20:50:58 "},"abacus-dos.html":{"url":"abacus-dos.html","title":"ABACUS+Atomkit 计算态密度和能带","keywords":"","body":"ABACUS+Atomkit 计算态密度和能带 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024/04/22 一、介绍 电子的态密度（Density of States，简称DOS）和电子能带结构（Electronic band structure）在凝聚态物理和材料科学中分析物质的光学、磁学等诸多性质都有重要用途，因此学会计算和分析材料的 DOS 和能带结构也是一项重要技能。 电子能带结构描述了材料中电子能量与动量（或波矢K）之间的关系。通过电子能带可以揭示材料中电子能级的分布情况，包括能级的高低、能带的宽度、能带之间的间隙（带隙，band gap）等信息。能带结构中的价带和导带之间的能隙大小决定了材料是导体、半导体还是绝缘体。金属没有能隙，半导体有能隙但带隙不大，绝缘体拥有较大的能隙。 DOS 是指在能量为 E 的能量附近可供电子占据的电子状态数目，DOS 是关于能量的函数，通常以每单位能量范围的态数目来表示。DOS 和能带结构紧密相关，通过对能带结构在能量上的积分得到。DOS 的峰值通常对应于能带结构中的范霍夫奇点，这些点是电子浓度变化剧烈的地方，且在费米能级（通常把这个能量设为 0 点，负数代表费米面以下，正数代表费米面以上）附近的行为对材料的电学性质有显著影响。例如，金属的高 DOS 导致高电导率，而半导体和绝缘体在费米能级附近的低 DOS 则导致低电导率。 使用密度泛函理论软件来计算电子态密度和能带一般包括以下两个步骤：第一步，对结构弛豫后的稳定晶体结构（一般来讲是这样操作）做 self-consistent field（简称 scf）自洽计算输出收敛的体系基态电子密度文件；第二步，读入上一步的电子密度，选取想要计算的能级和 K 点，固定电子密度，做一次非自洽（non-self-consistent field，简称 nscf）计算得到态密度以及能带结构。 二、准备 1. 下载并安装 Atomkit 在本教程里会用到 atomkit（并非一定要使用，只是会方便计算流程）来处理 ABACUS 的输入文件。首先推荐大家阅读以下文档并安装好 atomkit： Atomkit 相关文档：ATOMKIT Code ‒ VASPKIT 1.5 documentation Atomkit v0.8.0 下载地址：Download atomkit.0.8.0.linux.x64.tar.gz (vaspkit) wget https://jaist.dl.sourceforge.net/project/vaspkit/Binaries/atomkit.0.8.0.linux.x64.tar.gz tar -zxvf atomkit.0.8.0.linux.x64.tar.gz cd atomkit/ bash setup.sh # modify ~/.atomkit file based on your machine environment source ~/.bashrc 2. 下载例子 可以从 Gitee 上下载。可以在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载后解压，之后进入 abacus-user-guide/examples/dos_band 文件夹 里面有 Al 和 Fe 两个文件夹，分别演示铝（nspin=1，适用无磁性体系）和铁（nspin=2，适用有磁性体系）的计算，均使用平面波基组 三、铝的态密度以及电子能带结构计算 1. 自洽计算 首先进入 Al 文件夹，铝在常温常压下是面心立方结构（fcc），以下是它经过结构优化（弛豫）后的构型文件： ATOMIC_SPECIES Al 26.982 Al_ONCV_PBE-1.0.upf upf201 LATTICE_CONSTANT 1.88972612546 LATTICE_VECTORS 4.0450551637 0.0000000000 0.0000000000 #latvec1 0.0000000000 4.0450551637 0.0000000000 #latvec2 0.0000000000 0.0000000000 4.0450551637 #latvec3 ATOMIC_POSITIONS Direct Al #label 0 #magnetism 4 #number of atoms 0.0000000000 0.0000000000 0.0000000000 m 0 0 0 0.5000000000 0.5000000000 0.0000000000 m 0 0 0 0.5000000000 0.0000000000 0.5000000000 m 0 0 0 0.0000000000 0.5000000000 0.5000000000 m 0 0 0 这是一个标准的 fcc 单胞结构，但是我们做 DOS 和电子能带结构计算时，常用原胞，因此需要做一步结构转换，转换公式如下图所示： 这时也可以使用 Atomkit，执行如下命令，即可得到原胞 PRIMCELL.STRU echo -e \"2\\n 202\\n 101 STRU\\n 101\" | atomkit # 这里为了方便演示，使用了命令行，表示将'2'、'202'、'101 STRU'和'101'依次传入atomkit，实际可以按照atomkit的提示依次输入 # 2代表进行Symmetry Analysis # 202代表进行Find Primitive Cell # 101 STRU代表读取ABACUS的STRU文件 # 101代表输出格式为ABACUS 接着执行如下命令进行自洽计算，要注意这里 calculation 为 scf，且需要设置 out_chg 为 1 以输出电荷密度文件（SPIN1_CHG.cube）。此外，ABACUS 默认读取 STRU 文件，这里我们设置 stru_file 为 PRIMCELL.STRU，读取得到的原胞 cp INPUT-scf INPUT cp KPT-scf KPT mpirun -n 8 abacus 2. 非自洽计算得到态密度 做态密度计算中的非自洽计算通常情况下需设置更加密的 K 点网格。执行如下命令进行非自洽计算，要注意这里 calculation 为 nscf，且需要设置 init_chg 为 file 以读取电荷密度文件（SPIN1_CHG.cube），out_dos 也需要设置为 1 以输出态密度 电荷密度文件（SPIN1_CHG.cube）默认是放在 OUT.suffix 目录下面，非自洽计算会自动去 OUT.suffix 目录下面找这个文件，如果找不到就会报错。熟悉 VASP 的用户可能习惯将这个文件移到另一个目录，这样也可以，但是需要在 INPUT 里设置 read_file_dir 为 SPIN1_CHG.cube 所在目录，read_file_dir 默认值是 OUT.suffix cp INPUT-nscf INPUT cp KPT-nscf KPT mpirun -n 8 abacus 计算得到的态密度存在 DOS1 和 DOS1_smearing.dat 内，我们常用 DOS1_smearing.dat 绘图，第一列是能量（单位为 eV），第二列是态密度，第三列是对态密度的积分 若需要减去费米能，可使用如下命令抓取费米能，然后在绘图时将第一列的数据减去费米能即可 grep EFERMI OUT.*/running_scf.log # EFERMI = 10.963171515 eV 下面是使用 Origin 绘制的态密度图，出现很多毛刺的原因是为了减少计算量 K 点取得较少，可以通过展宽方法做得更平滑（dos_sigma，默认值为0.07），实际计算也可根据需要增大非自洽计算的 K 点网格 2. 非自洽计算得到电子能带 上一步的自洽计算目的是为了得到收敛的电子密度，有了收敛的电子密度，我们就能够快速的得到任意 K 点以及任意多条能带所对应的波函数。根据能带的习惯画法，这一步的 KPT 文件需要选取晶胞的布里渊区高对称点和路径，不同晶胞的高对称点和路径可以参考这个文献 [1]。 这些高对称点能够反映出材料的电子性质，如能隙大小、有效质量、载流子迁移率等。例如，能隙大小直接影响材料是金属、半导体还是绝缘体；有效质量影响载流子的响应速度；而能带的形态和分布则与材料的光学吸收和发射特性密切相关。因此，通过研究布里渊区内的高对称点的能带结构，我们可以预测和解释材料的多种物理性质，这对于材料的设计和应用具有重要意义 对于 fcc 的原胞，它的高对称点和可选的路径如下图 [1] 所示： KPT 需要选择Line模式（Line模式的介绍可以参考这个链接），并且需要设置 symmetry 为 0（INPUT 文件里若没有设置 symmetry，则会默认设置为 0） 这里可以使用 Atomkit 软件自动生成 KPT，执行如下命令 echo -e \"3\\n 301\\n 3\\n 101 PRIMCELL.STRU\\n 0.06\" | atomkit # 这里为了方便演示，使用了命令行，表示将'3'、'301'、'3'、'101 PRIMCELL.STRU'和'0.06'依次传入atomkit，实际可以按照atomkit的提示依次输入 # 3代表进行Generate K-Mesh & K-Path # 301代表输出K点的格式为ABACUS # 3代表Kpath for Bulk Structure # 101 PRIMCELL.STRU代表读取ABACUS的PRIMCELL.STRU文件 # 0.06为kspacing的取值 生成的 KLINES 即是计算所需的 KPT 文件，前三个数是高对称点的分数坐标，第四个数是两个高对称 K 点间采点数，#号后面是该高对称点的名称 K_POINTS 8 Line 0.00000000 0.00000000 0.00000000 25 # GAMMA 0.50000000 0.00000000 0.50000000 9 # X 0.62500000 0.25000000 0.62500000 1 # U 0.37500000 0.37500000 0.75000000 27 # K 0.00000000 0.00000000 0.00000000 22 # GAMMA 0.50000000 0.50000000 0.50000000 18 # L 0.50000000 0.25000000 0.75000000 12 # W 0.50000000 0.00000000 0.50000000 1 # X 接着执行如下命令进行非自洽计算，要注意这里 calculation 为 nscf，同样需要设置 init_chg 为 file 以读取电荷密度文件（SPIN1_CHG.cube），out_band 也需要设置为 1 以输出电子能带 cp INPUT-band INPUT cp KLINES KPT mpirun -n 8 abacus 计算结束之后在 OUT.* 目录下面会有 BANDS_1.dat 文件，其中第一列为 K 点序号，第二列是 K 点在布里渊区里的间隔（以笛卡尔坐标计算），从第三列往后是每条能带的电子能量，单位为 eV 1 0.00000000 -92.49968796 -54.00929724 ... 2 0.00988862 -92.49960078 -54.00938081 ... 3 0.01977723 -92.50345008 -54.00963444 ... ...... 这里，可以使用目录下的 gene_band_dat.py 生成绘图所需的能带文件 # 假设当前目录存在KPT文件存储能带信息，OUT.*目录下有BANDS_*.dat文件 python gene_band_dat.py 10.963171515 # 10.963171515即为费米能数值，也可空缺，则不将能量减去费米能 运行完之后会在当前目录生成 plot_BANDS_1.dat 文件，即为绘图所需的能带文件，第一行为高对称 K 点的坐标，从第二行开始，第一列为 K 点在布里渊区里的间隔，第二列为每条能带的电子能量，单位为 eV。 # 0.0 0.24721543 0.32490774 0.47629565 0.73850721 0.95260205 1.12740976 1.25101747 0.000000 -103.462859 0.009889 -103.462772 ...... 下面是绘制的能带图，图中有不够光滑连线的原因是为了减少计算量，K 点取得较少，实际计算可根据需要增多 K 点间采点数目 四、铁的态密度以及电子能带结构计算 进入 Fe 文件夹，由于铁具有磁性，因此需要在 INPUT 中打开自旋极化选项，即增加参数 nspin 并设置为 2（默认值为 1），并且将铁的初始磁矩设置为非 0（直接设成 0 得不到铁磁基态）。注意此时再对铁做自洽迭代（相比于 nspin 设置为 1 的计算），程序对自旋向上和向下的电子在每一个布里渊区 K 点上都分别进行了 Kohn-Sham 方程的求解，因此计算时间将会几乎翻倍。 计算铁的态密度和电子能带结构的过程与铝几乎相同，但是要注意计算得到的态密度和电子能带结构文件均有两个（分别对应自旋向上和向下），分别为 DOS1 和 DOS2、BANDS_1.dat 和 BANDS_2.dat 绘图仍推荐使用 DOS1_smearing.dat 和 DOS2_smearing.dat，以及 gene_band_dat.py 生成的 plot_BANDS_1.dat 和 plot_BANDS_2.dat，使用绘图软件可得如下 DOS 以及能带图 图 1. 铁的态密度（DOS），红线表示自旋向下电子的能带图，黑线表示自旋向上电子的能带图。费米面设为 0 点，即蓝色虚线所在能量位置。可以看出铁的两个自旋方向态密度并不相等，因此铁具有磁性。 图 2. 铁的能带图，红线表示自旋向下电子的能带图，黑线表示自旋向上电子的能带图。费米面设为 0 点。 五、参考文献 [1] Wahyu Setyawan and Stefano Curtarolo, High-throughput electronic band structure calculations: Challenges and tools, Comp. Mater. Sci., 49, 299-312 (2010). Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-04-22 20:24:44 "},"abacus-phonopy.html":{"url":"abacus-phonopy.html","title":"ABACUS+Phonopy 计算声子谱","keywords":"","body":"ABACUS+Phonopy 计算声子谱 作者：赵天琦，邮箱：zhaotq13@tsinghua.org.cn；陈涛，邮箱：chentao@stu.pku.edu.cn 审核：刘建川，邮箱：liujianchuan2013@163.com 最后更新时间：2023/08/14 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍采用 ABACUS（基于 ABACUS 3.2.2 版本）做密度泛函理论计算，并且结合 Phonopy 软件计算声子谱的流程。此外，本教程还用到 gnuplot 来绘图。 首先推荐大家阅读以下文档中的详细说明： ABACUS 官方文档：Phonopy - ABACUS documentation Phonopy 相关文档：ABACUS & phonopy calculation — Phonopy v.2.19.1 Gnuplot 主页：gnuplot homepage 二、准备 我们以 FCC Al 这个简单例子来演示使用 有限位移方法 来结合 ABACUS 和 Phonopy 计算声子谱。 1. 下载并安装 Phonopy git clone https://github.com/phonopy/phonopy.git cd phonopy python3 setup.py install 2. 下载 FCC Al 例子 可以从 Gitee 上下载。可以在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载后解压，之后进入 abacus-user-guide/examples/interface_Phonopy 文件夹 三、流程 1. 使用 ABACUS 优化结构 这里我们已经给出一个已经优化好的 FCC Al 结构 ABACUS 中的结构文件名为 STRU： ATOMIC_SPECIES Al 26.982 Al_ONCV_PBE-1.0.upf upf201 NUMERICAL_ORBITAL Al_gga_7au_100Ry_4s4p1d.orb LATTICE_CONSTANT 1.88972612546 LATTICE_VECTORS 4.03459549706 0 0 #latvec1 0 4.03459549706 0 #latvec2 0 0 4.03459549706 #latvec3 ATOMIC_POSITIONS Direct Al #label 0 #magnetism 4 #number of atoms 0 0 0 m 0 0 0 0.5 0.5 0 m 0 0 0 0.5 0 0.5 m 0 0 0 0 0.5 0.5 m 0 0 0 2. 用 Phonopy 产生需要计算的超胞及相应微扰构型 这里我们使用 有限位移方法 计算声子谱，因此需要对晶格进行扩胞并对原子位置进行微扰。执行如下命令即可生成 222 的扩胞并产生微扰结构： phonopy -d --dim=\"2 2 2\" --abacus 这一步 phonopy 会根据晶格对称性自动产生相应个数的微扰结构。由于 FCC 的晶格对称性较强，因此这个例子只产生一个微扰结构：STRU-001。这里类似 K 点的对称性分析，晶体结构对称性越强，所需的微扰结构就越少，对称性稍差的体系一般会产生多个微扰结构。 经验性设置：1）扩胞越大，计算结果越精确，但是计算量也会上升，一般来说扩胞三个方向的 cell 长度均在 10-20 Å 是比较合适的；2）对于优化后的晶胞（复杂体系），原子位置可能不处于高对称点上，phonopy 可能计算存在一定的误差，可以使用 Matertial Studio 等软件把对称性加回去之后，再做上述步骤，这样能够得到准确的声子谱数据（保证计算出来的声子谱满足体系的对称性特征）。 3. 产生 FORCE_SET 文件 接着用 ABACUS 计算原子受力，其中需要注意的是 calculation 需要设置为 scf，并且设置 cal_force 为 1，因为这一步目的是输出原子受力。 小技巧：即为了计算不同的微扰结构的受力，可以在 INPUT 里添加关键字 stru_file 来指定 STRU 文件的路径和文件名：stru_file ./STRU-001 INPUT 内容如下： INPUT_PARAMETERS #Parameters (1.General) suffix Al-fcc calculation scf esolver_type ksdft symmetry 1 pseudo_dir ./psp orbital_dir ./psp cal_stress 1 cal_force 1 stru_file STRU-001 #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-7 scf_nmax 50 #Parameters (3.Basis) basis_type lcao gamma_only 0 #Parameters (4.Smearing) smearing_method mp smearing_sigma 0.015 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.7 mixing_gg0 1.5 算完之后用以下命令产生 FORCE_SET 文件： phonopy -f ./disp-001/OUT*/running_scf.log ./disp-002/OUT*/running_scf.log ... 即要指定所有微扰构型算完之后的 running_scf.log 文件位置。如果运行有错，需要首先检查是否所有构型都已正常结束，且其中有力输出（可以找“FORCE”来确认）。 4. 设置 band.conf 文件计算得到声子谱 执行如下命令： phonopy -p band.conf --abacus band.conf 内容如下： ATOM_NAME = Al DIM = 2 2 2 MESH = 8 8 8 PRIMITIVE_AXES = 0 1/2 1/2 1/2 0 1/2 1/2 1/2 0 BAND = 1 1 1 1/2 1/2 1 3/8 3/8 3/4 0 0 0 1/2 1/2 1/2 BAND_POINTS = 101 BAND_CONNECTION = .TRUE. 这一步结束之后会有 band.yaml 文件输出 以上参数在 Phonopy 的线上文档中均有详细说明，这里再进行简单概述： ATOM_NAME：指定结构文件中的元素种类。 DIM：扩胞的大小，需要跟 3.2 用Phonopy产生需要计算的超胞及相应微扰构型 中的“dim”一致。 MESH：q 点的采样网格。‘8 8 8’意味着采用 888 的 q 点网格，默认以（0，0，0）为中心。 PRIMITIVE_AXES：输入晶胞到目标原胞的转换矩阵，并将根据原胞基矢量作为声子计算的坐标系。这里是 FCC 的原胞转换矩阵。 BAND：采样能带的 q 点路径。不同晶格的高对称点不同，具体可以使用 SeeK-path，自动生成 q 点路径。 BAND_POINTS：给出了包括能带路径末端的采样点的数量。 BAND_CONNECTION：在能带交叉处辅助连接能带。 5. 绘制声子谱 本教程使用 gnuplot 绘制声子谱，在 Ubuntu 上 gnuplot 的安装如下： sudo apt-get install gnuplot 用如下命令输出 gnuplot 格式的声子谱，并使用 gnuplot 绘制声子谱并存为 Al-FCC_plot.png： phonopy-bandplot --gnuplot > pho.dat gnuplot plot_pho.gp plot_pho.gp 内容如下： set terminal pngcairo size 1920, 1080 font 'Arial, 36' ## 格式，大小和字体 set output \"Al-FCC_plot.png\" ###输出的文件名 set ylabel 'Frequency (THz)' set ytics 2 unset key x1 = 0.13115990 x2 = 0.17753200 x3 = 0.31664810 xmax = 0.43023590 ymin = 0 ymax = 12 set xrange [0:xmax] set yrange [ymin:ymax] set xtics (\"{/Symbol G}\" 0, \"X\" x1, \"K\" x2, \"{/Symbol G}\" x3, \"L\" xmax) set arrow 1 nohead from x1,ymin to x1,ymax lt 2 set arrow 2 nohead from x2,ymin to x2,ymax lt 2 set arrow 3 nohead from x3,ymin to x3,ymax lt 2 plot 'pho.dat' using 1:($2) w l lw 3 FCC Al 的声子谱： 也可使用 Origin 绘图，pho.dat 的第一列就是上图的横轴（K 点路径），其中高对称 K 点位置见 pho.dat 的第二行，第二列就是上图的纵轴（声子频率，单位 THz）。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-03-15 15:05:26 "},"abacus-shengbte.html":{"url":"abacus-shengbte.html","title":"ABACUS+ShengBTE 计算晶格热导率","keywords":"","body":"ABACUS+ShengBTE 计算晶格热导率 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/15 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍采用 ABACUS（基于 ABACUS 3.2.0 版本）做密度泛函理论计算，并且结合 ShengBTE 软件计算晶格的热导率的流程。其中，整个计算过程中还用到了：1）采用 Phonopy 程序来计算二阶力常数，2）采用 ASE 程序进行原子结构的转换，3）采用 ShengBTE 的 thirdorder 程序计算三阶力常数，4）最后使用 ShengBTE 来计算材料的晶格热导率。 上述提到了一些需要结合的外部软件，这里推荐大家阅读这些软件的相关文档和说明： ShengBTE：https://bitbucket.org/sousaw/shengbte/src/master/ phonopy：http://abacus.deepmodeling.com/en/latest/advanced/interface/phonopy.html ASE：http://abacus.deepmodeling.com/en/latest/advanced/interface/ase.html thirdorder: https://bitbucket.org/sousaw/thirdorder/src/master/ 二、准备 ABACUS 的软件包中提供了一个 ABACUS+ShengBTE 计算晶格热导率的算例，可以从 Gitee 上下载。算例中包含采用数值原子轨道的 LCAO（Linear Combination of Atomic Orbitals）和采用平面波基矢量的 PW（Plane Wave，平面波）两个文件夹。每个文件夹下分别又包含了 2nd、3rd 和 shengbte 这三个文件夹，分别保存了使用 phonopy 计算二阶力常数（2nd）、thirdorder 计算三阶力常数（3rd）和 ShengBTE 计算晶格热导率（shengbte）的相关文件。 三、流程 以 LCAO 文件夹为例，我们这里提供的测试案例是包含 2 个原子的金刚石结构 Si 结构，采用的模守恒赝势是 Si_ONCV_PBE-1.0.upf，以及原子轨道文件采用的是 Si_gga_7au_100Ry_2s2p1d.orb（GGA 泛函，7 au 截断半径，100 Ry 能量截断，以及包含 2s2p1d 的 DZP 轨道）。 1. 计算二阶力常数 要计算二阶力常数，除了 ABACUS 之外，还需要结合 Phonopy 和 ASE。首先，进入 2nd 文件夹。 1.1 结构优化 做晶格热导率计算之前要先对模拟的材料体系的进行原子构型的优化。下面是采用 ABACUS 做结构优化（relax）后得到的原子构型文件 STRU。在这个例子里，为了简单起见，结构优化过程采用的是 2*2*2 的布里渊区 k 点采样，平面波的能量截断值 ecut（LCAO 里面也用到了平面波基矢量）为 100 Ry，注意实际计算中应该要采用更收敛的 k 点采样。 ATOMIC_SPECIES Si 28.0855 Si_ONCV_PBE-1.0.upf NUMERICAL_ORBITAL Si_gga_7au_100Ry_2s2p1d.orb LATTICE_CONSTANT 1.88972612546 LATTICE_VECTORS 0 2.81594778072 2.81594778072 #latvec1 2.81594778072 0 2.81594778072 #latvec2 2.81594778072 2.81594778072 0 #latvec3 ATOMIC_POSITIONS Direct # direct coordinate Si #label 0 #magnetism 2 #number of atoms 0.875 0.875 0.875 m 0 0 0 0.125 0.125 0.125 m 0 0 0 注意：第一行 Si 的质量 28.0855 在计算中不起作用。 1.2 计算二阶力常数 调用 Phonopy 软件产生需要计算的超胞及相应微扰的多个原子构型，命令如下： phonopy setting.conf --abacus -d 其中 setting.conf 文件的内容为： DIM = 2 2 2 ATOM_NAME = Si 这里我们采用的 Si 的例子只需要产生 1 个微扰构型 STRU-001 即可，对所有微扰构型（这里 Si 的例子只有 1 个）进行 SCF 计算（SCF 代表 Self-consistent field，这里代表进行密度泛函理论的电子迭代自洽计算）获得原子受力，算完之后用以下命令产生 FORCE_SET 文件： phonopy -f OUT.DIA-50/running_scf.log 小技巧：在 ABACUS 的输入文件 INPUT 中可以设置变量 stru_file，该变量对应的原子构型文件为 STRU-001 则 ABACUS 可以直接读取该结构文件。 下一步，设置 band.conf 文件计算得到声子谱以及二阶力常数： phonopy -p band.conf --abacus 这里出现的 band.conf 文件，其内容如下（具体参数含义可以查看 Phonopy 说明文档）： ATOM_NAME = Si DIM = 2 2 2 MESH = 8 8 8 PRIMITIVE_AXES = 1 0 0 0 1 0 0 0 1 BAND = 0.0 0.0 0.0 0.5 0.0 0.5 0.625 0.25 0.625, 0.375 0.375 0.75 00 0.0 0.0 0.5 0.5 0.5 BAND_POINTS = 101 BAND_CONNECTION = .TRUE. FORCE_CONSTANTS = WRITE FULL_FORCE_CONSTANTS = .TRUE. 这一步结束之后，Phonopy 软件会产生 band.yaml（用于绘制声子谱）和 FORCE_CONSTANTS 文件。其中，FORCE_CONSTANTS 文件包含的数据即为二阶力常数，注意这里务必设置 FULL_FORCE_CONSTANTS = .TRUE.，输出全部的二阶力常数，否则 ShengBTE 读取数据会报错。 此外，可以使用如下命令输出 gnuplot 格式的声子谱，用于绘制声子谱： phonopy-bandplot --gnuplot > pho.dat 1.3 后处理 注意 ShengBTE 软件要求 FORCE_CONSTANTS_2ND 文件里数据的单位为 eV/Å^2，但是 ABACUS 结合 phonopy 计算的 FORCE_CONSTANTS 单位为 eV/(Å*au)，其中 au 是原子单位制，1 au=0.52918 Å。可以使用 2nd 目录下提供的 au2si.py 脚本进行单位转换，生成 FORCE_CONSTANTS_2ND 文件，命令如下： python au2si.py 在 shengbte 文件夹中提供了 FORCE_CONSTANTS_2ND 文件供参考计算结果。 2. 计算三阶力常数 要计算三阶力常数，需要结合 thirdorder 程序，计算后输出三阶力常数文件 FORCE_CONSTANTS_3RD。但是，thirdorder 目前只支持读取 VASP 和 QE 的输入输出文件。因此，这里我们是通过将 ABACUS 的结构文件和输出受力分别转换为 POSCAR 和 vasprun.xml 来使用 thirdorder，请先进入 3rd 文件夹，具体步骤将在以下叙述。 2.1 获得微扰构型 首先将 ABACUS 软件进行结构优化（relax）后的 STRU 文件转化为 POSCAR（目录下已给出转化过的 POSCAR，或者需要自己动手进行这个转换）。 之后，运行 thirdorder_vasp 程序，产生微扰过后的一系列原子构型文件 3RD.POSCAR.*，例如这个例子一共产生了 40 个构型： thirdorder_vasp.py sow 2 2 2 -2 运行 pos2stru.py，将上述 POSCAR 转化为 STRU 文件，注意该脚本里调用了 ASE 软件包的函数（需提前安装好 ASE）： python pos2stru.py 注意：这里不能调用 dpdata 软件进行转化。因为 dpdata 会强制将晶格改为下三角矩阵，相当于旋转了晶格，会导致原子间受力方向也相应旋转，从而发生错误。 2.2 计算微扰构型的原子受力 可以参考目录下 run_stru.sh 使用脚本批量产生 SCF-* 文件夹并提交计算，这里需要采用 ABACUS 对 40 个原子构型分别进行 SCF 计算，会有些耗时。建议每个 SCF 单独在 SCF-* 文件夹内运行，这里的 INPUT 中的scf_thr 需要至少小到1e-8才能得到收敛的结果。 计算完成后，运行 aba2vasp.py，将 ABACUS 计算的原子受力包装成 vasprun.xml 格式，放置在每个 SCF-* 文件夹中，命令如下： python aba2vasp.py vasprun.xml 格式示意： 1.865e-05 -0.04644196 -0.00153852 -1.77e-05 -0.00037715 -0.00149635 1.973e-05 0.002213 -0.00149461 -1.976e-05 0.00065303 -0.0014804 8.31e-06 -0.0003306 -0.00024288 -8.25e-06 -0.00038306 -0.00025385 1.071e-05 0.00060621 -0.00025797 -1.05e-05 -0.00014553 -0.00027532 0.00668053 0.00645634 -0.04642593 -0.00668085 0.00645595 -0.00040122 -0.00650454 0.00628877 -0.00025123 0.00650504 0.00628892 -0.00028948 -0.00039591 2.479e-05 0.00223371 0.00039608 2.426e-05 0.0006732 0.0003264 3.122e-05 0.00052874 -0.00032589 3.415e-05 -0.00023577 -2.908e-05 -0.00832477 0.00635709 3.737e-05 -0.00125057 -7.444e-05 -2.582e-05 0.00656076 0.00636285 2.566e-05 -0.00049974 -6.661e-05 -5.431e-05 0.00502637 0.00639077 4.553e-05 -0.00180978 0.0001325 -3.609e-05 -0.00676473 0.00638092 3.806e-05 5.503e-05 0.00012759 -0.00670704 0.00646596 0.01310437 0.00670119 3.673e-05 0.00602948 0.00036366 0.00627899 -0.00657272 -0.00036508 2.288e-05 0.00026009 0.00648649 0.0064463 -0.00036521 -0.00648098 1.594e-05 0.00671469 -0.00034493 0.00630074 0.00662932 0.00034331 4.157e-05 -0.0002028 最后执行如下命令： find SCF-* -name vasprun.xml|sort -n|thirdorder_vasp.py reap 2 2 2 -2 即可得到三阶力常数文件 FORCE_CONSTANTS_3RD。在 shengbte 文件夹中提供了 FORCE_CONSTANTS_3rd 文件供参考计算结果。 3. 运行 ShengBTE 得到晶格热导率 进入 shengbte 文件夹，里面已经准备好 CONTROL（ShengBTE 的参数文件）、FORCE_CONSTANTS_2ND（二阶力常数文件）、FORCE_CONSTANTS_3RD（三阶力常数文件）这三个文件，使用如下命令运行 ShengBTE 即可得到晶格热导率，其中 Ref 文件夹中给出了计算结果供参考： mpirun -n 10 ShengBTE 四、结尾 对于 ABACUS 中使用平面波（PW）来做 ShengBTE 的计算也是采用以上类似的流程，但要注意使用平面波时，计算三阶力常数的 INPUT 中scf_thr 需要至少小到1e-12。通过计算结果可以发现，PW 和 LCAO 基组计算出的 Si 的晶格热导率是接近的，300 K 下均在 100 W/(m K) 左右，而实验中 Si 在 300 K 的热导率在 150 W/(m K) 附近。这是因为作为教学例子，这里使用的是 2*2*2 的扩胞以及 2*2*2 的 K 点，导致计算结果偏小，实际科研中需要测试扩胞的大小以及 K 点的采样方案来达到收敛的结果。以上就是 ABACUS(3.2.0)+ShengBTE 计算晶格热导率的全部流程，如果有什么问题，欢迎通过邮件联系。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-dpgen.html":{"url":"abacus-dpgen.html","title":"ABACUS+DPGEN 使用教程","keywords":"","body":"ABACUS+DPGEN 使用教程 作者：刘建川，邮箱：liujianchuan2013@163.com 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/15 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍结合 ABACUS（中文名原子算筹，这里基于 ABACUS 3.2.0 版本）和 DPGEN 软件结合生成机器学习 DP 势，这里 ABACUS 扮演了提供第一性原理训练数据的作用。本教程以碳化硅（SiC）材料为案例，并且教大家使用 DPGEN autotest 功能，计算 SiC 的 Equation of State (EOS)和弹性常数等性质。先介绍主要软件和计算平台： DPGEN软件：是一个结合第一性原理软件来自动产生训练数据标签的软件，如果不熟悉 DPGEN 的读者，这里可以推荐大家先阅读 DPGEN 的相关原理文档和说明，熟悉这部分的读者可以跳过： https://docs.deepmodeling.com/projects/dpgen/en/latest/ https://bohrium-doc.dp.tech/docs/software/DP-GEN https://bohrium-doc.dp.tech/docs/software/DP-GEN_init https://bohrium-doc.dp.tech/docs/software/DP-GEN_autotest https://www.sciencedirect.com/science/article/pii/S001046552030045X?via%3Dihub 计算平台：由于本案例通过 Bohrium 平台教学，所以所用到的 machine.json 文件仅限于 Bohrium 平台使用，如需在其他平台上使用，可参考下面网址，修改 machine.json 文件： https://docs.deepmodeling.com/projects/dpgen/en/latest/run/example-of-machine.html 二、准备 1. 案例下载地址 本教程用到的所有输入文件，均可点击这里下载。 (https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/abacus-dpgen) 此外，在 Linux 下可以采用的下载命令是： git clone https://gitee.com/mcresearch/abacus-user-guide.git 之后进入 /abacus-user-guide/examples/md 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/md 下载完之后，应该可以看到三个文件夹： init，run，以及 auto-test init 文件夹：包含用于 dpgen init_bulk 步骤所需的输入文件，用户可参考其设置自己的体系参数。 run 文件夹：包含用于 dpgen run 步骤所需的输入文件，用户可参考其设置自己的体系参数。 auto-test 文件夹：包含用于计算弹性常数等性质的输入文件，用户可参考其设置自己的体系参数。 2. 安装相关软件 这里默认读者已经安装好了 ABACUS 软件，本算例中 ABACUS 计算采用的是数值原子轨道的 LCAO（Linear Combination of Atomic Orbitals）方法，因为一般来说 LCAO 会比平面波效率更高，此外读者也可以把密度泛函理论计算部分改成平面波基矢量（后续会讲到）。 开始之前，请务必安装/更新 dpgen 和 dpdata（用来转换数据）到最新版本： 1. 安装/更新 dpdata pip install --user git+``https://gitee.com/deepmodeling/dpdata.git@devel 2. 安装/更新 dpgen pip install --user git+``https://gitee.com/deepmodeling/dpgen.git@devel 三、结合 DPGEN 生成 DP 数据的流程 DPGEN 使用流程如下，接下来我们将一一展开介绍： 1. 准备赝势和数值原子轨道文件 本例子所需文件有： 模守恒赝势文件，格式为*.upf，也可以使用其他 ABACUS 支持的赝势格式，注意 ABACUS 目前不支持 PAW 方法或者超软赝势。 数值原子轨道文件，格式为*.orb，注意这里的数值原子轨道文件要和赝势文件匹配，也就是数值原子轨道是由指定赝势产生的，关于如何生成数值原子轨道，我们会提供中文教程。 注：在 ABACUS 官网上可以下载到赝势和数值原子轨道文件： http://abacus.ustc.edu.cn/pseudo/list.htm 本例采用的赝势和轨道是： C 的 PBE 模守恒 ONCV 模守恒赝势：C_ONCV_PBE-1.0.upf Si 的 PBE 模守恒 ONCV 模守恒赝势：Si_ONCV_PBE-1.0.upf C 的 PBE 模守恒 ONCV 赝势对应的数值原子轨道：C_gga_9au_100Ry_3s3p2d.orb Si 的 PBE 模守恒 ONCV 赝势对应的数值原子轨道：Si_gga_9au_100Ry_3s3p2d.orb 注：如果是使用平面波基矢量来做密度泛函理论计算，则不需要提供数值原子轨道文件，结合 DPGEN 使用的流程是一致的（仅需要删除调用轨道文件的输入参数即可）。如果采用其他 ABACUS 支持的赝势文件，可自行生成轨道文件（请参考本教程系列的其它相关中文教程）. 注：这里 C_gga_9au_100Ry_3s3p2d.orb 的意思是 C 元素、采用 GGA 泛函、轨道截断半径是 9 a.u.（轨道截断半径越大，则 ABACUS 所需求解 Kohn-Sham 方程的时间会越长，而且这个时间对于轨道半径极其敏感，推荐可以测试不同轨道半径，选取合适的、截断半径小的轨道可以加速计算），100 Ry 是推荐的平面波截断值（哪怕用了数值原子轨道，程序里还是会用平面波来做某些物理量的计算，比如模守恒赝势的局域赝势部分），3s3p2d 表示 3 个 s 径向轨道、3 个 p 轨道、2 个 d 轨道。 2. 准备原子体系的结构文件 本步骤所需的描述原子结构的文件有： *.cif 可以从多个渠道下载所需体系的结构文件，本案例主要从 materials project 网站下载 cif 文件，使用的 SiC 对应多个原子构型，主要有 3C、2H、4H、6H 四个构型，采用哪些构型取决于用户所研究的体系和性质，一般可选取所关心的物质温度和压强区间内可能出现的结构。本案例主要采用3C 和 2H构型来演示。 3C-SiC：https://materialsproject.org/materials/mp-8062?formula=SiC 2H-SiC: https://materialsproject.org/materials/mp-7140?_skip=15&formula=SiC 4H-SiC: https://materialsproject.org/materials/mp-11714?formula=SiC 6H-SiC: https://materialsproject.org/materials/mp-7631?formula=SiC 得到了 cif 之后，可以使用下列方法把 cif 转换成 STRU 文件： 1. 安装 ASE-ABACUS 接口： git clone https://gitlab.com/1041176461/ase-abacus.git cd ase-abacus python3 setup.py install 2. 设置环境变量（可选） ABACUS 支持两种基组：平面波（PW）和数值原子轨道（LCAO）。赝势和轨道文件的存放路径可以通过环境变量设置，分别为：ABACUS_PP_PATH 和 ABACUS_ORBITAL_PATH,设置方法如下： PP=${HOME}/pseudopotentials ORB=${HOME}/orbitals export ABACUS_PP_PATH=${PP} export ABACUS_ORBITAL_PATH=${ORB} PW 计算只需要设置 ABACUS_PP_PATH 。 LCAO 需要两个都设置：ABACUS_PP_PATH and ABACUS_ORBITAL_PATH 。 3. CIF 转 STRU from ase.io import read, write from pathlib import Path cs_dir = './' cs_vasp = Path(cs_dir, 'SiC.cif') # 修改为自己的cif文件名 cs_atoms = read(cs_vasp, format='cif') cs_stru = Path(cs_dir, 'STRU') pp = {'Si':'Si_ONCV_PBE-1.0.upf','C':'C_ONCV_PBE-1.0.upf'} # 修改为所对应的赝势文件名 basis = {'Si':'Si_gga_9au_100Ry_3s3p2d.orb','C':'C_gga_9au_100Ry_3s3p2d.orb'} # 修改为所对应的轨道文件名 write(cs_stru, cs_atoms, format='abacus', pp=pp, basis=basis) 运行上述 python 脚本，把 cif 转成 ABACUS 所需的 STRU 文件。 3. 产生初始训练数据 本步骤所需文件有： 原子结构文件：STRU 数值原子轨道文件：*.orb 赝势文件：*.upf 布里渊区 k 点采样：KPT 提交任务的文件：machine.json DPGEN 的输入参数文件：param.json 为每一个构型新建一个名为 init 的文件夹。进入该文件夹后，为每个构型都新建一个单独的文件夹，之后单独运行 dpgen init_bulk 命令，用于产生接下来的 dpgen run 步骤的初始数据集。本案例所提供的初始原子构型为 3C 和 2H 结构，并把赝势文件、轨道文件、STRU 文件放入对应的文件夹里。按照下面链接的案例准备适合自己机器的 machine.json 文件，并分别放入 3C 和 2H 文件夹。 https://docs.deepmodeling.com/projects/dpgen/en/latest/run/example-of-machine.html 本教程所用到的文件可以从 Gitee 下载，修改为符合自己的配置即可。 接下来准备 param.jsion 文件，本步骤最关键的设置也是 param.json 文件设置，案例如下： { \"init_fp_style\": \"ABACUS\", \"stages\": [1,2,3,4], \"cell_type\": \"diamond\", \"super_cell\": [1, 1, 1], \"elements\": [\"Si\",\"C\"], \"from_poscar\": true, \"from_poscar_path\": \"./STRU\", \"potcars\": [\"Si_ONCV_PBE-1.0.upf\",\"C_ONCV_PBE-1.0.upf\"], \"orb_files\": [\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C_gga_9au_100Ry_3s3p2d.orb\"], \"relax_incar\": \"./INPUT_rlx\", \"md_incar\" : \"./INPUT_md\", \"relax_kpt\": \"./KPT\", \"md_kpt\": \"./KPT\", \"md_nstep\": 10, \"scale\": [0.99,1.00,1.01], \"skip_relax\": false, \"pert_numb\": 10, \"pert_box\": 0.03, \"pert_atom\": 0.01, \"deepgen_templ\": \"../generator/template/\", \"coll_ndata\": 5000, \"_comment\": \"that's all\" } init_fp_style 关键字需设置为 ABACUS，如果 from_poscar 为 true，则会读取 from_poscar_path 指定的 STRU 文件，且 cell_type 关键字失效。super_cell 用于括胞，推荐直接使用括胞之后的 STRU 文件，则 super_cell 设置为[1, 1, 1]。括胞一般根据需求而定，使得三个方向的 cell 长度约为 6 埃以上（经验性的）。其中还用到了 *.``upf 和 *.``orb 文件，修改为自己所计算的体系即可。 init_bulk 的基本操作流程分为以下 4 个顺序步骤： 生成初始(平衡)结构：输出文件存储在 00.place_ele。 产生 MD 起始构象：放缩扰动 00.place_ele 中的结构，输出文件存储在 01.scale_pert。 执行 AIMD：取 01.scale_pert 起始构象调用 vasp 执行少步数 AIMD，输出文件存储在 02.md。 整理初始数据：调用 dpdata 提取 02.md 中 AIMD 各 snapshots 的数据作为初始数据，输出文件存储在 02.md。 param.json 中将使用 stages 关键词的取值 1~4 控制以上 4 步的执行，操作中，各步骤(2, 3, 4 在所需前一步输出文件存在的前提下)可独立执行。 其他具体参数含义可参考 dpgen 官网： https://docs.deepmodeling.com/projects/dpgen/en/latest/init/init-bulk-jdata.html 另外，还需准备两个 ABACUS 输入文件 INPUT_rlx 和 INPUT_md。 INPUT_rlx 主要用于优化所下载的结构，如下： INPUT_PARAMETERS #Parameters (1.General) suffix ABACUS calculation cell-relax #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type lcao #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.002 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 cal_stress 1 INPUT_md 主要用于产生一定数量的 AIMD 轨迹，用于 DPGEN 迭代的输出数据，如下： INPUT_PARAMETERS #Parameters (1.General) suffix ABACUS calculation md #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type lcao #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.002 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 cal_stress 1 #MD chg_extrap second-order md_type 2 md_tfirst 300 md_tlast 300 md_nstep 10 md_tfirst 10 md_tfreq 0.5 注：ABACUS 的 MD 关键字在此 3.2.0新版本有所更改，如果是使用的最新版本，请严格参考手册设置关键字，如md_type在新版本里改为了nvt、npt等形式，而不再用数字（如：2）等： 此外，还需准备一个存放布里渊区 k 点的文件，名为 KPT： K_POINTS 0 Gamma 4 4 4 0 0 0 也可在 INPUT 文件里直接指定 kspacing 参数（注意该参数可选 1 维或者 3 维，如果是表面系统可选 3 维因为真空方向不需要太多 k 点）。 用户可自行根据所研究体系，设置、更改上述参数。 所有以上输入文件准备完毕后，采用如下命令分别对 3C 和 2H 结构运行 dpgen： nohup dpgen init_bulk param.json machine.json 1>log 2>err& 上述命令采用后台提交 dpgen，等所有计算完成之后，dpgen 会自动收集训练 DP 势所需的数据，且转换为 DeePMD-kit 的数据格式，保存在 ./STRU.01x01x01/02.md/sys-0036-0036/deepmd 目录里。 4. 进行数据采样的迭代 run主流程包含一系列迭代，各迭代会根据所选系综在给定的温度、压力或体积等条件下进行 DPMD 采样与筛选，实现同步学习，所有迭代希望能够有效覆盖训练可靠模型所需的势能面上样本空间。每个迭代依次：基于init 准备的初始训练数据与之前迭代积累的训练数据|训练多个新的模型->使用当前的模型进行DPMD采样，根据模型间预测偏差(model-deviation)|挑选候选 snapshot 构象->将本轮候选 snapshot 构象进行第一性原理标定并加入数据集|扩展数据集 。 以上每个迭代中包含的 3 个步骤分别被命名为 00.train，01.model_devi，02.fp，细节如下： 00.train: 使用 init 准备的初始训练数据与之前迭代积累的训练数据，调用 DeepMD-kit 训练多个 (默认 4 个) 模型。模型间的唯一区别来自于初始化神经网络时使用不同的随机数种子。 01.model_devi: 指代 model-deviation。 调用 LAMMPS 使用 00.train 的 1 个模型进行 MD 模拟。对于任一 MD 中 snapshot，模型间预测偏差越大意味着当前模型系综对该 snapshot 构象的精度越低，通过引入模型偏差作为误差判据并设定上下限, 挑选出有希望有效改进模型对 PES 整体预测精度的 snapshot 构象，作为准备加入训练数据集的候选构象。 02.fp: 调用 ABACUS 对 01.model_devi 选取的候选构象进行第一性原理定标(单点计算)，并调用 dpdata 收集整理所得数据加入到训练数据集中。 run 执行后，相关文件即存储在....../iter.*(迭代序号)/步骤文件夹内。以上每个迭代中的每个步骤在实现中被分解为 3 个阶段。以 00.train 为例，3 阶段分别对应: 0：make_train ，为训练任务准备脚本；1： run_train，依据机器配置上传文件并执行训练任务；2：post_train，收集整理分析训练任务的结果。01.model_devi 与 02.fp 的实现步骤与之类似，分别使用 3，4，5 及 6，7，8 来标记其阶段。 用输出文件record.dpgen来记录进程已经执行过及当前正在执行的阶段。如进程中断后需要续算，DP-GEN将根据此文件的记录来自动恢复run主进程。用户也可根据需求手动修改record.dpgen中的记录，来控制接下来将执行哪一阶段的任务：例如，删除最后一阶段(可能未执行完成即中断)的记录，并从前一个已完成阶段后恢复任务。可以通过查看record.dpgen文件监控当前任务的执行阶段。 本步骤所需文件有： STRU *.orb *.upf machine.json （可以直接用 dpgen init bulk 里的） param.json dpgen init bulk 产生的初始训练数据 主要步骤如下： 1. 新建一个文件夹，命名为：run，并进入此目录里 2. 在 run 文件夹里面新建 init_conf 和 init_data 文件夹，用于存放 dpgen init bulk 产生的构型和初始训练数据 3. 为了区分不同构型和初始训练数据，在 init_conf 和 init_data 文件夹里新建名为 3C 和 2H 的两个文件夹 4. 拷贝 dpgen init bulk 产生的构型和初始训练数据至 init_conf 和 init_data 文件夹里，如： cp -rf yourPath/init/3C/STRU.01x01x01/02.md/sys-0032-0032 yourPath/run/init_conf/3C cp -rf yourPath/init/2H/STRU.01x01x01/02.md/sys-0036-0036 yourPath/run/init_conf/2H cp -rf yourPath/init/3C/STRU.01x01x01/02.md/sys-0032-0032/deepmd/* yourPath/run/init_data/3C cp -rf yourPath/init/2H/STRU.01x01x01/02.md/sys-0036-0036/deepmd/* yourPath/run/init_data/2H 5. 拷贝 machine.json、*.orb 和 *.upf 文件到 run 文件夹 6. 新建一个 param.json 文件，如下案例： { \"type_map\": [\"Si\",\"C\"], \"mass_map\": [28.085,12.011], \"init_data_prefix\": \"./init_data\", \"init_data_sys\": [ \"3C\", \"2H\" ], \"sys_format\":\"abacus/stru\", \"sys_configs_prefix\": \"./init_conf\", \"sys_configs\": [ [\"3C/sys-0032-0032/scale-1.000/00****/STRU\"], [\"2H/sys-0036-0036/scale-1.000/00****/STRU\"] ], \"_comment\": \" that's all \", \"numb_models\": 4, \"default_training_param\": { \"model\": { \"type_map\": [\"Si\",\"C\"], \"descriptor\": { \"type\": \"se_e2_a\", \"sel\": \"auto\", \"rcut_smth\": 0.5, \"rcut\": 6.0, \"neuron\": [25, 50, 100], \"resnet_dt\": true, \"axis_neuron\": 12, \"seed\": 1 }, \"fitting_net\": { \"neuron\": [240, 240, 240], \"resnet_dt\": false, \"seed\": 1 } }, \"learning_rate\": { \"type\": \"exp\", \"start_lr\": 0.001, \"stop_lr\": 3.5e-8, \"decay_steps\": 2000 }, \"loss\": { \"start_pref_e\": 0.02, \"limit_pref_e\": 2, \"start_pref_f\": 1000, \"limit_pref_f\": 1, \"start_pref_v\": 0.0, \"limit_pref_v\": 0.0 }, \"training\": { \"stop_batch\": 400000, \"disp_file\": \"lcurve.out\", \"disp_freq\": 100, \"numb_test\": 10, \"save_freq\": 1000, \"save_ckpt\": \"model.ckpt\", \"disp_training\": true, \"time_training\": true, \"profiling\": false, \"profiling_file\": \"timeline.json\", \"_comment\": \"that's all\" } }, \"model_devi_dt\": 0.002, \"model_devi_skip\": 1000, \"model_devi_f_trust_lo\": 0.05, \"model_devi_f_trust_hi\": 0.10, \"model_devi_clean_traj\": true, \"model_devi_merge_traj\": true, \"model_devi_jobs\": [ {\"sys_idx\": [0,1], \"temps\":[50, 250, 450, 650], \"press\": [0, 100, 1000, 5000, 10000, 20000, 50000], \"trj_freq\": 10, \"nsteps\": 3000, \"ensemble\": \"npt-tri\", \"_idx\": \"01\"}, {\"sys_idx\": [0,1], \"temps\":[50, 250, 450, 650], \"press\": [0, 100, 1000, 5000, 10000, 20000, 50000], \"trj_freq\": 10, \"nsteps\": 3000, \"ensemble\": \"npt-tri\", \"_idx\": \"02\"} ], \"fp_style\": \"abacus\", \"shuffle_poscar\": false, \"fp_task_max\": 100, \"fp_task_min\": 5, \"fp_accurate_threshold\": 0.999, \"fp_accurate_soft_threshold\": 0.998, \"fp_pp_path\": \"./\", \"fp_pp_files\": [\"Si_ONCV_PBE-1.0.upf\",\"C_ONCV_PBE-1.0.upf\"], \"fp_orb_files\": [\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C_gga_9au_100Ry_3s3p2d.orb\"], \"user_fp_params\":{ \"ntype\": 2, \"symmetry\": 0, \"basis_type\": \"lcao\", \"ecutwfc\": 100, \"scf_thr\": 1e-6, \"scf_nmax\": 100, \"smearing_method\": \"gauss\", \"smearing_sigma\": 0.002, \"mixing_type\": \"pulay\", \"mixing_beta\": 0.3, \"cal_force\": 1, \"cal_stress\": 1, \"kspacing\": 0.08 } } type_map: 用列表方式设置了体系元素，注意顺序要和 STRU 结构文件里一致 mass_map: 记录了对应的原子质量，和 type_map 对应 init_data_prefix：指定初始训练集的位置所在目录，如：./init_data init_data_sys：定位到初始训练集的具体目录，用列表调用多个，即：./init_data/2H sys_format：指定为 ABACUS 计算的结构，即：abacus/stru sys_configs_prefix：指定探索步所需调用的结构目录，如：./init_conf sys_configs：指定具体的某个构型的目录，用列表调用多个，即：./init_conf/3C/sys-0032-0032/scale-1.000/00****/STRU。其中 00为通配符，dpgen 会遍历 00所有文件夹的 STRU 文件 model_devi_f_trust_lo 和 model_devi_f_trust_hi：可由“init 数据” 中力绝对值的平均值，然后取该值的 20%-50%，设置成 trust level 的上下限。可通过以下 python 脚本计算：（注意指定初始数据位置） import dpdata import numpy as np do06=dpdata.Labeledsystem(\"./\"，\"deepmd/raw\") forces = np.absolute(d006[\"forces\"]) af = np.average(forces) f_trust_lo = af*0.2 f_trust_hi = af*0.5 print(f_trust_lo,f_trust_hi) 如果体系温度升高后力的幅度变大，trust level 也要增大设置 model_devi_jobs 里面每一行代表一轮，每轮设置参数为 LAMMPS 进行 MD 模拟的参数 fp_style 指定，使用 ABACUS 进行 SCF 计算 user_fp_params 里面记录 ABACUS 做 SCF 所需的参数 其他参数含义见：https://docs.deepmodeling.com/projects/dpgen/en/latest/run/index.html 1. 准备好所有输入文件之后，运行命令： nohup dpgen run param.json machine.json 1>log 2>err& 为后台提交，等待迭代计算完成即可。 2. 实时监测每轮的 accurate 数据，在 dpgen.log 文件里有记录 1）模型精度是判断每个迭代中的训练是否收敛的重要指标。 2）掌握训练策略有利于快速迭代和收敛。 3）经验性：一般体系在 5-8 轮迭代内会上升到 80% 以上，若没有提升，如下方法排查： a. 检查是否是探索步已经崩溃了，收集了许多不合理的结构 b. 检查train的loss是否是收敛 c. dp test查看fp数据是否偏差很大，或者有不合理的情况 d. 检查是否是温度设置过高而导致的结构变形严重 e. 及时调整trust level，体系温度升高后力的幅度变大，trust level也要增大设置 3. 一些经验 探索步已经崩溃的解决方案 原因：DPMD 跑崩的情况一般发生在 训练温度 高于 熔点，而这个温区的结构是从“有序”到“无序态”的 ，其构型易变，采样空间增大，导致训练难度增加。DPMD 跑崩表明当前势函数对这类构型描述较差，大概率是因为前期数据集中这类构型采集的较少；特别是无序态结构的原子距离变小。 策略：在熔点附近的 参数设置需要平滑缓慢对待，增加“MD 轨迹保存频率”；缩短“MD 模拟步数”或降低“MD 步长”，增加迭代次数，其 DP 训练势函数稳定后再延长 MD 模拟步数。 ABACUS 收敛性测试 对每种体系一定要先做各个参数的收敛性测试，特别是：K 点、能量截断，也可测试 scf_thr 降低计算量。另外，对于赝势文件也一定要做性质测试，看是否能够正确描述目标体系的性质 每隔几轮做一次 dp test 初始数据得到后，第一轮生成了 dp 势之后，一定要检查 trian 步骤收敛情况和做 dp test。dp test 用如下命令： dp test -m frozen_model.pb -s ./collect_data -n 2000 -d out.out frozen_model.pb 为生成的 4 个模型中的某一个，2000 为 collect_data 里面单个结构的总数。out.out 会生成 out.e.out out.f.out out.f.out 三个偏差数据文件，用于作图判断模型优劣屏幕会输出每个构型力、能量等误差平均值，也可用*.out 文件做出 DP 和 DFT 偏差图，如： 经验性的，力的精度在 1e-2 量级，能量精度在 5e-3 量级，说明模型比较好。 四、计算材料 EOS 和弹性常数的流程 本例子里提供了一个 auto-test 文件夹，进入之后可以结合 DPGEN 的 auto-test 命令计算材料 EOS、弹性常数的流程 auto-test 的详细流程，可以从如下网页教程查阅： https://bohrium-doc.dp.tech/docs/software/DP-GEN_autotest 这里贴上如何使用 ABACUS 来计算材料 EOS、弹性常数的相关输入文件 relaxation.json： { \"structures\": [\"conf\"], \"interaction\": { \"type\": \"abacus\", \"incar\": \"./INPUT\", \"potcar_prefix\":\"./\", \"potcars\": {\"Si\": \"Si_ONCV_PBE-1.0.upf\",\"C\": \"C_ONCV_PBE-1.0.upf\"}, \"orb_files\": {\"Si\":\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C\":\"C_gga_9au_100Ry_3s3p2d.orb\"} }, \"relaxation\": { \"cal_type\": \"relaxation\", \"cal_setting\":{ \"input_prop\": \"./INPUT\" } } } property.json： { \"structures\": [\"conf\"], \"interaction\": { \"type\": \"abacus\", \"incar\": \"./INPUT\", \"potcar_prefix\":\"./\", \"potcars\": {\"Si\": \"Si_ONCV_PBE-1.0.upf\",\"C\": \"C_ONCV_PBE-1.0.upf\"}, \"orb_files\": {\"Si\":\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C\":\"C_gga_9au_100Ry_3s3p2d.orb\"} }, \"properties\": [ { \"type\": \"eos\", \"vol_start\": 0.9, \"vol_end\": 1.1, \"vol_step\": 0.02 }, { \"type\": \"elastic\", \"norm_deform\": 1e-2, \"shear_deform\": 1e-2 } ] } INPUT： INPUT_PARAMETERS calculation cell-relax symmetry 0 basis_type lcao ecutwfc 100.0 scf_thr 1.0e-06 scf_nmax 100 smearing_method gauss smearing_sigma 0.002 mixing_type pulay mixing_beta 0.3 cal_force 1 cal_stress 1 kspacing 0.10 在当前目录建立一个 conf 文件夹，把 STRU 文件放进去，依次运行下面命令： dpgen autotest make relaxation.json nohup dpgen autotest run relaxation.json machine.json & dpgen autotest post relaxation.json dpgen autotest make property.json nohup dpgen autotest run property.json machine.json & dpgen autotest post property.json 计算完成之后，会在 conf/elastic_00/result.out 文件里记录弹性常数、模量等信息，conf/eos_00/result.out 里记录 EOS 等数据。 以上即为采用 ABACUS 3.2.0 和 DPGEN 软件结合的介绍，若有任何问题，欢迎给我们反馈。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-libri.html":{"url":"abacus-libri.html","title":"ABACUS+LibRI 做杂化泛函计算教程","keywords":"","body":"ABACUS+LibRI 做杂化泛函计算教程 作者：梁馨元，邮箱：2201111875@stu.pku.edu.cn 审核：林霈泽，邮箱：linpeize@sslab.org.cn 最后更新时间：2023/08/21 在Bohrium Notebook上快速学习： 一、介绍 杂化泛函（Hybrid Functional）是指在密度泛函理论框架中的交换关联项里面加入一部分的 Hartree Fock (简称 HF)的精确交换能。开源密度泛函理论软件 ABACUS 可以结合另一款国产开源软件 LibRI 软件进行杂化密度泛函计算，目前仅支持在数值原子轨道基组下使用该功能。可以通过 dft_functional 参数指定所使用的杂化泛函类型，如可以选择 hf (Hartree-Fock), pbe0(PBE0), hse(HSE06)以及 scan0 杂化泛函。本教程以 HSE 杂化泛函为例，介绍如何在 ABACUS 里调用 LibRI 做杂化泛函自洽迭代、求力和应力以及结构优化。 注 1：使用 ABACUS+LibRI 做杂化泛函计算时，最大并行核数是N_a^4N_K^3，其中N_a是原子个数，N_k是 k 点个数。计算资源超出时可以运行，但会造成浪费。 注 2：使用 ABACUS+LibRI 做杂化泛函计算时，因为内存消耗比较大，推荐给定计算资源的前提下，先尽量使用 OpenMP 多线程并行，再考虑使用 MPI 多进程并行。 二、杂化泛函的使用 1. ABACUS 编译准备 如果要在 ABACUS 中使用杂化泛函进行计算，需要在编译 ABACUS 的时候也编译 Libxc、LibRI 和 LibComm 三个软件包，具体请见线上文档 Advanced Installation Options ‒ ABACUS documentation。 注意在链接 LibRI、LibComm 时如果报错未定义的引用等，可以先注意检查 ABACUS 源代码下 deps 文件夹下是否包含 LibRI、LibComm 两个文件夹。如果未包含这两个文件夹，或文件夹中无内容，在本地Github仓库中可以尝试如下两条语句，以获取这两个子仓库内容： git submodule init git submodule update --remote --recursive 2. 采用杂化泛函进行电子自洽迭代计算 本教程在 Gitee 上准备了一个硅晶体使用杂化泛函做自洽计算（SCF）的例子（Gitee 的下载链接），以下是 INPUT 文件及相关的参数。由 dft_functional 设置为 hse 可知，该例子使用的杂化泛函为 HSE 泛函。KPT 文件取的是 444 的布里渊区 k 点。 INPUT_PARAMETERS calculation scf basis_type lcao ntype 1 nbands 8 ecutwfc 60.0 scf_nmax 100 dft_functional hse scf_thr 1e-7 杂化泛函相关的完整参数列表及解释见 Full List of INPUT Keywords / exact-exchange ‒ ABACUS documentation。这里再进行简单概述： 泛函相关参数： exx_hybrid_alpha：杂化泛函中加入的 HF 精确交换能（Fock 交换能）的比例α，即有E_x=αE_{x}^{HF}+(1-α)E_{x}^{LDA/GGA}。如果 dft_functional 设置为 hf，则默认值为1。目前其他杂化泛函的默认值是0.25。但是，如果是 SCAN0 泛函，有的文献取的是 0.1，所以需要根据你想取的值进行设定[1]。 exx_hse_omega：为 HSE 泛函中的区间分割参数（range-separation parameter）\\omega，即有\\frac{1}{r}=\\frac{erfc({\\omega}r)}{r}+\\frac{erf({\\omega}r)}{r}。默认值为0.11（bohr^{-1}），此时为 HSE06 泛函[2]。 exx_lambda：在 basis_type 设置为 lcao_in_pw 的情况下，用于补偿使用 lcao_in_pw 方法评估精确交换能时 G=0 处的发散点。默认值为0.3。 exx_real_number：该参数设定为 True 时，强制 LibRI 使用 double 数据类型，当设定为 False 时，强制 LibRI 使用 complex 数据类型。当gamma_only=1 时，默认为 True，gamma_only=0 时默认为 False。 循环相关参数： exx_separate_loop：ABACUS 提供了两种迭代方法来评估精确交换能E_{exx}。当 exx_separate_loop 设置为False时：采用单层循环，即先进行 GGA 循环，然后进行 Hybrid 循环，在该过程中，使用电子迭代来更新E_{exx}对应的哈密顿量H_{exx}。当 exx_separate_loop 设置为True时：采用双层循环，在内层循环中，进行自洽迭代并更新密度矩阵，在外层循环中，根据在内层循环中收敛的密度矩阵来计算H_{exx}。默认值为 True，即采用双层循环计算。单层循环有利于难以自洽收敛的体系达到收敛，但会显著增加内存消耗。 exx_hybrid_step：在 exx_separate_loop 设置为 True 的情况下，外层循环的最大迭代步数。默认值为100。 exx_mixing_beta：在 exx_separate_loop 设置为 True 的情况下，内层循环每次迭代时，密度矩阵混合的 mixing_beta 取值，默认为1.0。 exx_pca_threshold：为了加速四中心积分\\langle ik\\vert\\ jl\\rangle的计算，ABACUS 采用 LRI 方法，将原子轨道的乘积在辅助基函数(ABF)的基础上展开，即\\Phi_i\\Phi_j \\approx \\sum_aC_{ij}^aP_a，并利用 PCA 减小辅助基函数(ABF)的大小(即P_a个数)。阈值越大，ABF 的数目越少，计算速度越快，计算精度越低。一个相对安全的值是1e-4，也是默认值。 exx_ccp_rmesh_times：此参数决定计算 Columb 势所需的截断半径比原子轨道的截断半径大多少倍。对于 HSE 泛函，设置为 1 就足够了。但是对于 PBE0，必须使用一个大得多的数字。当使用 HSE 泛函时，默认值为1.5，其他情况下默认值为5。 张量筛选相关参数： 针对杂化泛函计算过程中的物理量进行筛选可以加速计算。具体来说，exx_c_threshold、exx_v_threshold、exx_dm_threshold、exx_c_grad_threshold、exx_v_grad_threshold 分别是针对C_{ij}^a、V_{ab}=\\langle P_a\\vert\\ P_b\\rangle、密度矩阵、\\nabla C_{ij}^a、\\nabla V_{ab}。阈值越大，筛掉的张量越多，计算速度越快，计算精度越低。具体请查看完整 INPUT 参数文档。 Cauchy-Schwartz 不等式相关参数： exx_cauchy_threshold：在实际中，Fock 交换矩阵是稀疏的，利用 Cauchy-Schwartz 不等式，我们可以在进行显式求值之前找到每个矩阵元素的上界。小于 exx_cauchy_threshold 的值将被截断。阈值越大，筛掉的张量越多，计算速度越快，精度越低。一个相对安全的值是1e-7，也是默认值。不等式算法参见参考文献[3]。 exx_cauchy_force_threshold、exx_cauchy_stress_threshold与exx_cauchy_threshold类似，区别在于它们分别针对的是求力、应力计算中的 Fock 交换矩阵元。 opt_orb 相关参数：当dft_functional设置为 opt_orb 时使用，opt_orb 参考文献[4]。本功能仅用于生成 opt 辅助基组，不进行杂化泛函计算。 exx_opt_orb_lmax：球贝塞尔函数的最大角动量 L 值，opt-ABF 的径向部分用球贝塞尔函数的线性组合生成。 exx_opt_orb_ecut：球贝塞尔函数展开的截断，在优化 opt-ABF 的时候采用的是球贝塞尔函数基组。 exx_opt_orb_tolerence：解球贝塞尔函数零点时的阈值。 3. 杂化泛函计算代价 杂化泛函的计算精度高，与此同时它的计算代价也比较高。在 ABACUS 的输入参数文件 INPUT 中，若 exx_separate_loop 参数设为 True（默认），仅在 SCF 步骤中就涉及两层循环。每次内层循环完成，外层循环往前推进一步时，屏幕输出 Updating EXX and rerun SCF。 一次 SCF 需要的时间至少是以上两个循环涉及的单次电子迭代时间之和。对于单次电子迭代所需时间，在此提出一些已有的经验。以一步电子迭代的时间为衡量尺标，使用 DZP 基组，CPU 型号为 Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz，使用 4 核计算一个水分子为 0.6s 左右，使用 14 个核计算 32 个水分子为 0.8s 左右，使用 14 个核计算 64 个水需要 1.9s 左右。 若将 exx_separate_loop 参数设为 False，即使用单层循环时，首先会进行 GGA 迭代直到自洽收敛，然后屏幕输出 Entering 2nd SCF, where EXX is updated，进行 Hybrid 迭代，此时每进行一次电子步得到新的密度后，都会更新一次精确交换能。以一步电子迭代 + 更新精确交换能的时间为衡量尺标，使用 DZP 基组，CPU 型号为 Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz，使用 4 核计算一个水分子为 0.7s 左右，使用 14 个核计算 32 个水分子为 115s 左右，使用 14 个核计算 64 个水需要 330s 左右。对于更大的体系，如 2048 个 Si 原子的晶体，使用 DZP 基组，CPU 型号为 Intel(R) Xeon(R) Silver 4310 CPU @ 2.10GHz，用一个节点（56 核）算时，PBE 下一步电子迭代大概需要 380s，而 HSE 一步电子迭代 + 更新精确交换能大概需要 1680s。 在进行杂化泛函计算时推荐尽量使用多线程计算（OpenMP），此时内存开销相对较小，计算速度相对较快。 三、使用杂化泛函做结构优化 1. 数据准备 在 Gitee 上我们准备了一个简单的使用杂化泛函做结构优化的例子。该例子是在 LCAO 基组下，使用 HSE 泛函，优化单个水分子的结构。文件夹中 log.ref 是使用 3.2.1 版本的 ABACUS 软件包，v0.1.0 版本的 LibRI 和 LibComm 计算所得的屏幕输出。 2. 输入文件 准备计算所需的 INPUT 文件、STRU 文件、KPT 文件，以及 H、O 原子对应的数值原子轨道文件。其中 INPUT 文件如下。注意该文件中指明了计算类型为 relax，即不对晶胞做优化（cell relax），只对原子位置做优化（relax）。更多结构优化类型请看文档 Geometry Optimization ‒ ABACUS documentation。 INPUT_PARAMETERS calculation relax basis_type lcao ntype 2 ecutwfc 60.000000 scf_nmax 100 gamma_only 1 dft_functional hse relax_nmax 100 scf_thr 1e-6 force_thr_ev 1e-2 在该例子中，结构优化包括多个离子步，每个离子步中都要做一次 SCF。由 INPUT 文件可知，SCF 收敛的标准由 scf_thr=1e-6 指定，或达到 SCF 的最大步数 scf_nmax=100，并计算受力。根据上一个离子步计算得到的受力，计算下一个离子步的原子位置，计算收敛的标准此时为 force_thr_ev=1e-2，或达到离子步的最大步数 relax_nmax=100。STRU 文件如下，可见在结构弛豫步骤中，三个原子都可以移动。 ATOMIC_SPECIES O 16.00 O_ONCV_PBE-1.0.upf H 1.00 H_ONCV_PBE-1.0.upf LATTICE_CONSTANT 1 LATTICE_VECTORS 28 0 0 0 28 0 0 0 28 ATOMIC_POSITIONS Direct O #label 0 #magnetism 1 #number of atoms 0.677639488918 0.5227809096584 0.232500040128 m 1 1 1 H #label 0 #magnetism 2 #number of atoms 0.641808457616 0.5785821615863 0.228644198512 m 1 1 1 0.708889637644 0.5204300746076 0.175087721492 m 1 1 1 NUMERICAL_ORBITAL O_gga_6au_60Ry_2s2p1d.orb H_gga_6au_60Ry_2s1p.orb 3. 结果 结构弛豫（relax）后的原子结构可见 OUT.ABACUS/STRU_ION_D。由输出文件可知，即使该例子中采用了相对稳定的构型，且 scf_thr 仅设为 1e-6，使用 HSE 做结构弛豫的计算代价仍然很高，使用 6 个核（Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz）计算需要 5 分钟左右。 四、参考文献 [1] Staroverov V N, Scuseria G E, Tao J, et al. Comparative assessment of a new nonempirical density functional: Molecules and hydrogen-bonded complexes[J]. The Journal of chemical physics, 2003, 119(23): 12129-12137. [2] Aliaksandr V. Krukau, Oleg A. Vydrov, Artur F. Izmaylov, Gustavo E. Scuseria; Influence of the exchange screening parameter on the performance of screened hybrid functionals. J. Chem. Phys. 14 December 2006; 125 (22): 224106. [3] Lin P, Ren X, He L. Efficient hybrid density functional calculations for large periodic systems using numerical atomic orbitals. Journal of Chemical Theory and Computation, 2021, 17(1): 222–239. [4] Lin P, Ren X, He L. Accuracy of localized resolution of the identity in periodic hybrid functional calculations with numerical atomic orbitals[J]. The Journal of Physical Chemistry Letters, 2020, 11(8): 3082-3088. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-25 10:30:38 "},"abacus-candela.html":{"url":"abacus-candela.html","title":"ABACUS+Candela 使用教程","keywords":"","body":"ABACUS+Candela 使用教程 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/12/13 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍采用 Candela 分析 ABACUS（基于 3.2.4 版本）分子动力学轨迹，计算径向分布函数（Radial Distribution Function，简称 RDF），静态结构因子（Static Structure Factor，简称 SSF），离子-离子动态结构因子（Ion-ion Dynamic Structure Factor，简称 DSF）以及均方差位移（Mean Square Displacement，简称 MSD）流程。 上述性质的具体描述可以参考：Qianrui Liu et al 2020 J. Phys.: Condens. Matter 32 144002，径向分布函数（RDF）见文中公式（12），静态结构因子（SSF）见公式（13），离子-离子动态结构因子（DSF）见公式（15，16，17）以及均方差位移（MSD）见公式（18）。 Candela 全称 Collection of ANalysis DEsigned for Large-scale Atomic simulations，目前支持分析 QE、ABACUS、LAMMPS 和 VASP 的分子动力学轨迹，Github 主页：https://github.com/MCresearch/Candela 二、准备 1. 下载并安装 Candela git clone https://github.com/MCresearch/Candela.git cd Candela make -j4 #使用intel oneapi编译器 若使用 Intel Oneapi 编译器，按照上述流程操作，在编译完成后即可在 bin 目录下看到 candela 可执行文件 若使用其他编译器，需要按照 Candela 目录下 Makefile.vars 修改相应的 CXX 2 下载例子 可以从 Gitee 上下载。在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载完成后解压，之后进入 abacus-user-guide/examples/candela 文件夹 算例中包含 RDF、SSF、DSF、MSD 以及 MSD_ntype_2 五个文件夹和 MD_dump 文件。其中 MD_dump 是 32 原子的铝的 MD 轨迹 三、流程 1 计算径向分布函数 进入 RDF 文件夹，INPUT 文件即为 Candela 的输入文件，具体如下： calculation pdf geo_in_type ABACUS geo_directory ../MD_dump geo_1 0 geo_2 100 geo_interval 2 geo_ignore 50 geo_out Al_rdf.txt ntype 1 natom 32 rcut 2.3 dr 0.01 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 pdf（Pair Distribution Function）即计算径向分布函数 geo_in_type：读取的 MD 轨迹的格式，目前支持分析 pw.x（QE2），cp.x（QE），ABACUS（ABACUS）、LAMMPS（LAMMPS）和 VASP（VASP） geo_directory：MD 轨迹的位置 geo_1：MD 轨迹起始的索引 geo_2：MD 轨迹结束的索引 geo_interval：Candela 读取 MD 轨迹的间隔 geo_ignore：需要跳过的 MD 轨迹帧数 geo_out：输出的文件名，默认为 result.dat ntype：原子种类 natom：原子数 rcut：计算 RDF 的截断半径，一般取晶格的一半，单位为 Angstrom dr：计算 RDF 的 r 的间隔，单位为 Angstrom 执行如下命令： mpirun -n 2 candela 即可得到 RDF，输出到 Al_rdf.txt，其中第一列为 r，单位为 Angstrom，第二列即为对应的 RDF，第三列为对第二列积分的结果。 2 静态结构因子 进入 SSF 文件夹，INPUT 文件具体如下： calculation ssf geo_in_type ABACUS geo_directory ../MD_dump geo_1 0 geo_2 100 geo_interval 2 geo_ignore 50 ssf_out Al_ssf.txt ntype 1 natom 32 struf_dgx 1.32656 struf_dgy 1.32656 struf_dgz 1.32656 struf_ng 6 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 ssf，即计算静态结构因子 ssf_out：输出的文件名 struf_dgx：倒空间中的间隔，一般取 2\\pi/a，其中a为x方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} struf_dgy：一般取 2\\pi/b，其中b为y方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} struf_dgz：一般取 2\\pi/c，其中c为z方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} struf_ng：上述倒空间中的间隔的数量 执行如下命令： mpirun -n 2 candela 即可得到 SSF，输出到 Al_ssf.txt（原始的计算结果）以及 sm-Al_ssf.txt（平滑的计算结果），其中第一列为 q，单位为\\mathrm{Angstrom^{-1}}，第二列即为对应的 SSF。 3 离子-离子动态结构因子 进入 DSF 文件夹，离子-离子动态结构因子需要对中间散射函数（Intermediate Scattering Function）进行傅里叶变换得到，因此需要先计算中间散射函数，INPUT 文件具体如下： calculation isf2 geo_in_type ABACUS geo_directory ../MD_dump geo_1 50 geo_2 100 geo_interval 1 isf_outfile isf.txt ntype 1 natom 32 isf_nt1 11 isf_nt2 40 dt_snapshots 0.00006 isf_target_q 2.65 isf_dgx 1.32656 isf_dgy 1.32656 isf_dgz 1.32656 isf_ngx 6 isf_ngy 6 isf_ngz 6 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 isf2，即计算中间散射函数 isf_outfile：输出的文件名 isf_nt1：中间散射函数的时间长度 isf_nt2：用于平均中间散射函数的时间长度，注意需要控制 interval*(nt1+nt2) dt_snapshots：MD 轨迹每一帧之间的时间步长，单位为 ps isf_target_q：中间散射函数计算的目标 q，单位为\\mathrm{Angstrom^{-1}} isf_dgx：倒空间中的间隔，一般取 2\\pi/a，其中a为x方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} isf_dgy：一般取 2\\pi/b，其中b为y方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} isf_dgz：一般取 2\\pi/c，其中c为z方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} isf_ngx：上述倒空间中 x 方向的间隔的数量 isf_ngy：上述倒空间中 y 方向的间隔的数量 isf_ngz：上述倒空间中 z 方向的间隔的数量 执行如下命令： mpirun -n 2 candela 即可得到 ISF，输出到 isf.txt，其中第一列为时间，单位为 ps，第二列即为对应的 ISF。 接着执行如下命令得到离子-离子动态结构因子，其中PathtoCandela指的是Candela的下载目录： python PathtoCandela/examples/e3_dsf/onedsf.py 0.00006 0.0006 其中第一个参数 0.00006 = dt_snapshots * geo_interval，为 ISF 的时间步长，单位为 ps；第二个参数 0.0006，为对 ISF 做傅里叶变换的总时长，单位为 ps。这里 onedsf.py 默认读取 isf.txt，并输出到 dsf.txt，其中第一列为\\hbar \\omega，单位为 meV，第二列即为对应的 DSF。 4 均方差位移 4.1 单种原子 进入 MSD 文件夹，INPUT 文件具体如下： calculation msd_multiple geo_in_type ABACUS geo_directory ../MD_dump geo_1 0 geo_2 100 geo_interval 1 geo_ignore 50 ntype 1 natom 32 msd_n 2 msd_t0 0.003 msd_t 0.0015 msd_dt0 0.0015 msd_dt 0.00006 msd_natom 32 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 msd_multiple，即计算均方差位移 msd_n：计算均方差位移的段数，目的是将 MD 轨迹分成若干段，分别计算均方差位移 msd_t0：计算均方差位移的起始时间，单位为 ps msd_t：每段均方差位移的时长，单位为 ps msd_dt0：两段均方差位移起始位置的间隔，单位为 ps。若设置等于 msd_t，则每段均方差位移之间的时间距离为 0 msd_dt：获取的 MD 轨迹每一帧之间的时间步长（等于geo_interval * dt，其中 dt 为 MD 轨迹每一帧之间的时间步长），单位为 ps msd_natom：需要设置为计算的原子数 执行如下命令： mpirun -n 2 candela 即可得到 MSD，输出到 MSD_each.txt 和 MSD_total.txt。其中 MSD_each.txt 第一列为时间，单位为 ps，第二列到最后一列即为对应的每段的 MSD，单位为\\mathrm{Angstrom^{2}}；MSD_total.txt 第一列为时间，单位为 ps，第二列为平均的每段的 MSD，单位为\\mathrm{Angstrom^{2}}。 4.2 多种原子 进入 MSD_ntype_2 文件夹，INPUT 文件具体如下： calculation msd_multiple geo_in_type ABACUS geo_directory MD_dump geo_1 0 geo_2 100 geo_interval 1 geo_ignore 50 ntype 2 natom 17 natom1 16 natom2 1 id1 C id2 Li msd_n 2 msd_t0 0.003 msd_t 0.0015 msd_dt0 0.0015 msd_dt 0.00006 ele_select C msd_natom 16 以上参数在 Candela 的线上文档中均有详细说明，与单种原子不同的参数如下： natom1、natom2：不同种类原子的个数 id1、id2：不同种类原子的名称，需要与读入的 MD_dump 中原子名称一致 ele_select：计算 MSD 的原子名称，需要与 id1 或 id2 对应 多种原子的计算过程与结果与单种原子并无区别。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-13 11:02:29 "},"abacus-uspex.html":{"url":"abacus-uspex.html","title":"ABACUS+USPEX 接口教程","keywords":"","body":"ABACUS+USPEX 接口教程 作者：柳向阳，邮箱：xiangyangliu@mail.ustc.edu.cn；郭晓庆，邮箱：xiaoqing.guo@mail.nwpu.edu.cn 审核：牛海洋，邮箱：haiyang.niu@nwpu.edu.cn；陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/14 一、背景介绍 近年来，随着高性能计算机的快速发展，晶体结构预测算法已然成为计算材料学的核心研究手段之一，极大地促进了新材料设计与研发的进程。Artem R.Oganov 教授课题组开发的进化类晶体结构预测算法 USPEX 是当前主流的全局搜索类算法之一。软件自 2004 年发布以来，该算法已被广泛应用于科研人员的研究工作中。晶体结构预测算法的主要作用是生成结构以及控制结构的演进，结构预测的效率及可靠性除却算法本身的影响外还对结构弛豫软件有极强的依赖性。ABACUS（原子算筹）作为一款国产开源密度泛函理论软件，同时兼具高精度和高效率，可适用于从小体系到上千原子体系的电子结构优化、原子结构弛豫、分子动力学等计算。因此实现晶体结构预测算法 USPEX（https://uspex-team.org/en）和第一性原理软件 ABACUS 的结合会给广大研究人员在结构预测研究中带来便利。 本教程旨在为大家提供一个 USPEX-ABACUS 接口的实现教程，方便大家程序配置。本教程以单质硅（Si）的结构预测为例, 介绍了该接口使用所需的输入文件和参数设置。 如需了解更多关于 USPEX 的使用信息，请参考 USPEX 官方文档：USPEX Documentation ‒ USPEX 二、接口介绍 当前发行的 USPEX 提供了分别以 matlab 和 python 为核心编程语言的两个版本，前者的版本编号为 USPEX-vXX（如 USPEX_v10.5），后者的版本编号为 USPEX-YEAR-XX（如 USPEX 2023.0.2），需要注意的是当前只有 python 版本可以自定义外部接口。该教程中的接口是在 USPEX 2023.0.2 和 ABACUS 3.3.0 版本进行编写测试的，如发生版本变更引起的异常，根据报错再行修改。 首先通过 USPEX 官网（USPEX 下载 ‒ USPEX）下载 USPEX 2023.0.2 软件（注册后即可免费下载），解压后根据所使用的 python 版本，选择软件压缩包进行安装，例如 pip install uspex-2023.0.2-cp310-cp310-linux_x86_64.whl。 注：若系统提示需要安装虚拟环境，可以在 USPEX 2023.0.2 目录下激活虚拟环境后重新进行安装。 python -m venv tutorial-env source tutorial-env/bin/activate 该接口共包含三个文件 (1) USPEX/components.py（对接口进行注册） (2) USPEX/Stages/Interfaces/ASEInterfacesAdapter.py（完成 ASE 接口中的读 read 和写 write 功能） (3) USPEX/Stages/Interfaces/ABACUS_Interface.py（接口实体，主要功能是准备 Abacus 的输入文件和读取 Abacus 的计算结果） 注：以上路径中 USPEX 为主目录。 上述文件可在 Github 仓库下载：https://github.com/gxq1219/Interface_USPEX-ABACUS/tree/master 安装完成后将以上文件复制到对应的路径下，并且需要手动添加环境变量，例如:export PATH=python3.10/site-packages/USPEX:$PATH，然后将 USPEX 2023.0.2 目录下的 random_cell 复制到设置的环境变量路径下。 该接口需要安装 ase-abacus 版本的 ase 库，测试版本为 ase-3.23.0b1 安装 ase-abacus 接口 git clone https://gitlab.com/1041176461/ase-abacus.git cd ase-abacus python3 setup.py install 此次测试是在 QSUB 任务管理系统下进行测试，如果更换任务管理系统，应修改 USPEX 输入文件 input.uspex 中的 taskManager 和 TM，此外需修改 USPEX/Stages/TaskManager 中所选任务管理方式中对任务队列状态识别的方式，如在 QSUB.py 文件中应根据所使用平台修改 def _parseJobID 中的内容识别出提交任务的 ID，以及下文的 def isReady 和 def isExist 等函数。 QSUB.py 示例（第 56 行的函数，根据自己超算平台修改，功能是执行 qsub sub.sh 后从屏幕输出的文本中提取出 jobID）： \"\"\" USPEX.Stages.TaskManagers.QSUB ============================== \"\"\" import logging from os.path import join as pj logger = logging.getLogger(__name__) class QSUB: shortname = 'QSUB' _RUNSCRIPT = 'jobscript' def __init__(self, header : str, connector): \"\"\" :param header: description of params of TaskManager :param connector: for remote submission \"\"\" self.connector = connector self.header = header def _prepareSubmission(self, COMMAND_EXEC : str, JOB_NAME : str, inputFile : str, outputFile : str, errorFile : str) -> str: \"\"\" Preparing jobscript for submission :param commandExec: :param jobName: :return: jobscript as string \"\"\" content = '' for line in self.header.split('\\n'): if ' -N ' in line: logger.info('Job name found in HEADER will be overwritten') elif ' -o ' in line: logger.info('Output file name found in HEADER will be overwritten') elif ' -e ' in line: logger.info('Error file name found in HEADER will be overwritten') else: content += line + '\\n' content += f'#PBS -N {JOB_NAME}\\n' content += f'#PBS -o {outputFile}\\n' content += f'#PBS -e {errorFile}\\n' content += f'cd $PBS_O_WORKDIR\\n' content += f'\\n{COMMAND_EXEC}\\n' return ''.join(content) async def submit(self, command: str, jobname: str, input: str, output: str, error: str, calcFolder : str) -> int: content = self._prepareSubmission(command, jobname, input, output, error) with open(pj(calcFolder, self._RUNSCRIPT), 'wt') as f: f.write(content) await self.connector.sync_l2r(pj(calcFolder, self._RUNSCRIPT)) returncode, out, err = await self.connector.execute(f'qsub {self._RUNSCRIPT}', cwd=calcFolder) logger.debug(f'process returned code {returncode}') if returncode != 0: logger.error(err) logger.error(out) jobID = self._parseJobID(out, err) logger.info(f\"Job ID is {jobID}\") return jobID def _parseJobID(self, output : str, error : str) -> int: \"\"\" :param output: :param error: :return: jobID \"\"\" if '.mgmt' in output: tmp = output.index('.mgmt') return int(output[:tmp]) elif 'job' in output: tmp = output.index('job') + 4 return int(output[tmp:]) elif 'comput100' in output: tmp = output.index('comput100')-1 return int(output[:tmp]) else: return int(output) async def isReady(self, jobID): returncode, out, err = await self.connector.execute(f'qstat {jobID}') return not (' R ' in out or ' Q ' in out) async def isExist(self, jobID): returncode, out, err = await self.connector.execute(f'qstat {jobID}') return len(out) > 0 async def kill(self, jobID): returncode, out, err = await self.connector.execute(f'qdel {jobID}') #logger.info(f'Process with jobID={jobID} killed.') 三、流程（以 Si 为例） 1. 准备 USPEX 的输入文件 input.uspex { optimizer: { type: GlobalOptimizer target: { type: Atomistic conditions: {externalPressure: 0.00001} compositionSpace: {symbols: [Si] blocks: [[4]]} } optType: enthalpy selection: { type: USPEXClassic popSize: 4 initialPopSize: 4 bestFrac: 0.6 optType: (aging enthalpy) fractions: { heredity: (0.4 0.7 0.5) softmodemutation: (0.2 0.5 0.3) randSym: (0.05 0.5 0.1) randTop: (0.05 0.5 0.1) } } } stages: [abacus1 abacus2 abacus3 abacus4 abacus5] numParallelCalcs: 4 numGenerations: 25 stopCrit: 10 } #define abacus1 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.20, taskManager: TM} #define abacus2 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.16, taskManager: TM} #define abacus3 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.12, taskManager: TM} #define abacus4 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.08, taskManager: TM} #define abacus5 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.05, taskManager: TM} #define TM { type : QSUB, header:\"#PBS -S /bin/bash #PBS -N single #PBS -l nodes=1:ppn=16 #PBS -j oe #PBS -V\" } 注意：ABACUS在任务提交时，应注意指定OMP_NUM_THREADS，防止内存不足引起计算错误 2. 准备 Specific 文件夹 所需文件：INPUT_X（使用ABACUS弛豫）、ATOMIC_SPECIES、NUMERICAL_ORBITAL以及轨道和赝势文件。 INPUT 文件内容和个数由用户自行设置（需要与 input.uspex 中 stages 对应），具体可参考 uspex 官方文档。 需要注意的是：INPUT 的 suffix 需指定为 USPEX； 需给出 ATOMIC_SPECIES 和 NUMERICAL_ORBITAL 两个文件指定所使用的 upf 文件和 orb 文件。 ATOMIC_SPECIES 内容：元素符号 质量 赝势文件名 NUMERICAL_ORBITAL 内容：元素符号 轨道文件名 3. 根据计算实际需求添加 Seeds 结构（可选，非必须） 4. 提交运算 nohup ./uspex-sub.sh >> log & ### content of uspex-sub.sh #!/bin/sh while true;do data >> log uspex -r >> log sleep 300 ### Users can adjust this value to manipulate the frequency of the call to uspex. done 5. 计算结果 如果程序可以正常提交任务，log文件中会打印如下内容： 2023-08-09 16:52:47,115 - USPEX.Optimizers.Target - INFO - Following utilities was not initialized: ['PowderSpectrumAnalyzer', 'SingleCrystalSpectrumAnalyzer']. 2023-08-09 16:52:47,115 - USPEX.Optimizers.Target - INFO - Permutation does not work when number of symbols in calculation is 1. 2023-08-09 16:52:47,123 - USPEX.Stages.GenerationController - INFO - Calculation initialized from input parameters. 2023-08-09 16:52:47,441 - USPEX.Selection.USPEXClassic - INFO - System 0 successfully created by RandSym operator. 2023-08-09 16:52:47,866 - USPEX.Selection.USPEXClassic - INFO - System 1 successfully created by RandSym operator. 2023-08-09 16:52:48,638 - USPEX.Selection.USPEXClassic - INFO - System 2 successfully created by RandSym operator. 2023-08-09 16:52:48,767 - USPEX.Selection.USPEXClassic - INFO - System 3 successfully created by RandSym operator. 2023-08-09 16:52:48,788 - USPEX.Stages.Executor - INFO - System 0 with tag 1 will be submitted now. 2023-08-09 16:52:48,788 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,792 - USPEX.Stages.Executor - INFO - System 1 with tag 1 will be submitted now. 2023-08-09 16:52:48,792 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,796 - USPEX.Stages.Executor - INFO - System 2 with tag 1 will be submitted now. 2023-08-09 16:52:48,797 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,801 - USPEX.Stages.Executor - INFO - System 3 with tag 1 will be submitted now. 2023-08-09 16:52:48,801 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,812 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37768 2023-08-09 16:52:48,818 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37769 2023-08-09 16:52:48,822 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37770 2023-08-09 16:52:48,825 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37771 如果程序可以正常输出结果，在 results1/Individuals 中会打印相关的信息，示例如下： +----+------------------+-------------+---------------+--------------+---------------+-----------------+---------------+--------------+ | ID | Origin | Composition | Enthalpy (eV) | Volume (A^3) | SYMMETRY (N) | Structure order | Average order | Quasientropy | +----+------------------+-------------+---------------+--------------+---------------+-----------------+---------------+--------------+ | 0 | RandSym | Si: 4 | -425.452 | 59.320 | P6/mmm (191) | 0.334 | 0.334 | -0.000 | | 2 | RandSym | Si: 4 | -418.078 | 59.320 | I4/mmm (139) | 0.287 | 0.287 | -0.000 | | 3 | RandSym | Si: 4 | -425.038 | 59.320 | P4_332 (212) | 0.392 | 0.392 | -0.000 | | 4 | Softmodemutation | Si: 4 | -428.592 | 59.320 | I4/mmm (139) | 0.325 | 0.325 | 0.000 | | 5 | Softmodemutation | Si: 4 | -428.592 | 59.320 | I4/mmm (139) | 0.325 | 0.325 | 0.000 | | 6 | Heredity | Si: 4 | -427.892 | 59.320 | P2_1/m (11) | 0.202 | 0.215 | 0.077 | | 8 | Softmodemutation | Si: 4 | -427.882 | 59.320 | P2_1/m (11) | 0.201 | 0.215 | 0.076 | | 9 | Softmodemutation | Si: 4 | -427.887 | 59.320 | P2_1/m (11) | 0.202 | 0.215 | 0.075 | | 10 | Heredity | Si: 4 | -428.645 | 59.320 | Cmce (64) | 0.261 | 0.261 | 0.000 | | 11 | Softmodemutation | Si: 4 | -428.644 | 59.320 | Cmce (64) | 0.261 | 0.261 | 0.000 | | 12 | Softmodemutation | Si: 4 | -428.645 | 59.320 | Cmce (64) | 0.261 | 0.261 | 0.001 | | 14 | Heredity | Si: 4 | -428.628 | 59.320 | Cmce (64) | 0.263 | 0.263 | 0.000 | | 15 | Heredity | Si: 4 | -428.928 | 59.320 | Cmcm (63) | 0.291 | 0.291 | 0.000 | | 16 | Heredity | Si: 4 | -428.949 | 59.320 | P2_1/m (11) | 0.283 | 0.284 | 0.006 | | 17 | RandSym | Si: 4 | -422.987 | 59.320 | C2/m (12) | 0.250 | 0.250 | 0.000 | | 19 | Softmodemutation | Si: 4 | -428.927 | 59.320 | Cmcm (63) | 0.291 | 0.291 | 0.000 | | 20 | Softmodemutation | Si: 4 | -428.928 | 59.320 | Cmcm (63) | 0.290 | 0.290 | 0.000 | | 21 | Heredity | Si: 4 | -428.926 | 59.320 | Cmcm (63) | 0.290 | 0.290 | 0.000 | 四、结语 建议大家在使用前，首先选择小体系进行测试；此外大家也可根据自己的实际需要对接口文件进行修改扩充，有相关问题可通过邮件方式沟通。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-14 15:07:32 "},"abacus-namd.html":{"url":"abacus-namd.html","title":"ABACUS+Hefei NAMD 使用教程","keywords":"","body":"ABACUS+Hefei NAMD 使用教程 作者：李源波，邮箱：liyuanbo9812@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/01 一、介绍 激发态动力学一直是凝聚态物理中的重要问题，在激发状态下，凝聚态体系中的准粒子会发生复杂的相互作用，涉及到不同时间尺度的超快过程，因此，研究凝聚态体系的激发态动力学不仅需要从时间、空间、能量和动量等多个维度对其进行描述，还需要描述不同准粒子之间的动态耦合，而目前商用的第一性原理软件无法满足这样的需求。针对这一问题，中国科学技术大学赵瑾教授团队发展了自主可控的激发态动力学软件 Hefei-NAMD（https://hefei-namd.org/code/），基于面跳跃算法（Surface Hopping）与经典路径近似，初步实现激发态动力学在时间、空间、动量、能量、自旋等多个维度上的描述，并可以研究激发态电子、空穴、激子、声子、极化子等准粒子的动态相互作用。Hefei-NAMD 程序采用模块化架构，包含单粒子动力学、自旋动力学、动量空间动力学以及 GW+rtBSE 模块。目前程序使用周期性边界条件，可处理上百个原子，且与密度泛函软件 VASP、Quantum Espresso 等存在接口，Hefei-NAMD 和 ABACUS v3.2 建立的接口（主要针对局域轨道算法，涉及波函数与局域轨道下的交叠矩阵等信息，用来计算非绝热耦合项和电子跃迁概率）和提供的相关案例，可以进一步拓宽 Hefei-NAMD 的使用范围。 本教程旨在介绍采用 ABACUS（基于 ABACUS 3.2.0 版本）做分子动力学计算，将结果作为 Hefei NAMD 软件的输入文件进行后续非绝热分子动力学计算的流程。 这里推荐大家阅读 Hefei NAMD 软件的相关文档和说明： http://staff.ustc.edu.cn/~zqj/posts/Hefei-NAMD-Training/ https://github.com/QijingZheng/Hefei-NAMD https://github.com/vtzf/abacus-namd（这个是拥有与 ABACUS 接口的 Hefei NAMD 仓库，功能与上面的仓库是一样的），第一步请先下载这个链接上面的 python 代码。 二、计算流程 我们这里提供的测试案例是包含 2 个原子的金刚石结构 Si 结构，采用的模守恒赝势是 Si_ONCV_PBE-1.0.upf，以及原子轨道文件采用的是 Si_gga_8au_60Ry_2s2p1d.orb（GGA 泛函，8 au 截断半径，60 Ry 能量截断，以及包含 2s2p1d 的 DZP 轨道）。 1. 用 ABACUS 进行分子动力学(MD)计算 1.1 输入文件 INPUT 大部分参数为做分子动力学计算所需要参数，具体含义可以参考 ABACUS 的分子动力学教程。为了后续用 Hefei NAMD 进行非绝热分子动力学计算，ABACUS 会输出每一步分子动力学模拟的哈密顿量矩阵 H、交叠矩阵 S、波函数文件。因此需将相关的 ABACUS 的 INPUT 文件中的输入参数 out_wfc_lcao 和 out_mat_hs 都设置为 1，表示输出这些物理量。计算完成后，在 OUT.*** 文件夹中，每一个分子步都对应一个文件夹 MD_n，在每个文件夹中会有 data-0-H、data-0-S、LOWF_GAMMA_S1.dat 三个文件储存我们需要输出的物理量。 INPUT_PARAMETERS #Parameters (General) suffix autotest pseudo_dir ../../tests/PP_ORB orbital_dir ../../tests/PP_ORB nbands 8 calculation md #Parameters (Accuracy) ecutwfc 50 scf_nmax 20 basis_type lcao md_nstep 10 cal_stress 1 stress_thr 1e-6 cal_force 1 force_thr_ev 1.0e-3 ks_solver genelpa mixing_type pulay mixing_beta 0.7 md_type nve md_restart 0 md_tfirst 10 init_vel 1 read_file_dir ./ gamma_only 1 out_wfc_lcao 1 out_mat_hs 1 1.2 结构文件 STRU ATOMIC_SPECIES Si 1 Si_ONCV_PBE-1.0.upf NUMERICAL_ORBITAL Si_gga_8au_60Ry_2s2p1d.orb LATTICE_CONSTANT 10.2 LATTICE_VECTORS 0.5 0.5 0 #latvec1 0.5 0 0.5 #latvec2 0 0.5 0.5 #latvec3 ATOMIC_POSITIONS Cartesian Si #label 0 #magnetism 2 #number of atoms 0 0 0 m 1 1 1 v 1.75205850628e-05 0.000155425594558 -3.99334763874e-05 0.241 0.255 0.250999999999 m 1 1 1 v -1.75205850628e-05 -0.000155425594558 3.99334763874e-05 2. 用 Hefei NAMD 进行非绝热分子动力学（NAMD）计算 Hefei NAMD 代码为 python 代码，在 src 目录下，建议使用 python 3.9。需要的 python 库有 Numpy，Scipy，Numba，MPI4py（>= 3.1.3）。 2.1 设置 NAMD 计算参数 在 Args.py 中设置 NAMD 的各种参数，在 Args.py 的注释中有关于各种参数具体含义的详细介绍。 # NAMD parameter # manual input start dftdir = '/public/share/zhaojin/tuyy/abacus/sh/OUT.autotest1/' namddir = '../namd_test/' # output NAMD output file in namddir dt = 1 # MD time step (fs) start_t = 1 # start MD step end_t = 2000 # end MD step istart_t = 901 # isample start MD step iend_t = 1000 # isample end MD step LCHARGE = True # output atom projected charge density atom = [13,26]# atom number of all species (only needed in atomic basis) orbital = [27,13]# atomic orbital basis number (only needed in atomic basis) whichA = [0,13,14,15] # atom index for projected charge density (starts from 0) LRANGE = True # select range of band, change iband # if not given, LRECOMB specifies energy range # if LRECOMB not given, energy range: [0,nbands] LHOLE = True # Hole/electron transfer dE = 2.0 # initial energy from VBM/CBM (eV) LPHASE = True # phase correction TEMP = 300 # temperature in Kelvin NACTIME = 1000 # time for used NAC (i_end_t-state_t+NACTIME 2.2 读取 ABACUS 的输出文件 运行 NAC.py 即可将 ABACUS 的输出文件转成 Hefei NAMD 需要的 NATXT 和 EIGTXT 文件。 在超算上计算的话，可以直接使用用 sub_scripts 目录下的 sub_nac 脚本提交任务，用户可在 sub_nac 中自行修改节点数等信息。 sbatch sub_nac 2.3 进行非绝热分子动力学计算 运行 SurfHop.py 即可进行 NAMD 的计算。 在超算上计算的话，可以直接使用用 sub_scripts 目录下的 sub_sh 脚本提交任务，用户可在 sub_sh 中自行修改节点数等信息。 sbatch sub_sh 输出文件中，SUPROP 文件中包含了电子驰豫能量和电子占据数随时间的演化，PSICT 文件则包含波函数系数随时间的演化。可用 https://github.com/QijingZheng/Hefei-NAMD/tree/master/scripts 中的脚本进行画图。 三、结语 本篇主要介绍了如何利用 ABACUS 和 Hefei NAMD 进行非绝热分子动力学的计算，简单来说就是通过 ABACUS 跑分子动力学得到每一步的波函数和哈密顿量等信息，Hefei NAMD 再读入这些信息进行非绝热分子动力学的计算。关于非绝热分子动力学的详细介绍则可以查看 Hefei NAMD 的相关网站（见最上面的网站），如有问题欢迎联系。 四、参考文献 Zheng, Q.; Chu, W.; Zhao, C.; Zhang, L.; Guo, H.; Wang, Y.; Jiang, X.; Zhao, J. Ab initio nonadiabatic molecular dynamics investigations on the excited carriers in condensed matter systems. Wiley Interdiscip. Rev. Comput. Mol. Sci. 2019, 9, e1411. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-02 10:24:57 "},"abacus-wannier.html":{"url":"abacus-wannier.html","title":"ABACUS+Wannier90 使用教程","keywords":"","body":"ABACUS+Wannier90 使用教程 作者：刘人熙，邮箱：rxliu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/11/09 教程使用说明 Wannier 函数是周期性晶格势场中局域表象下的波函数，Wannier 函数在 1937 年由 Gregory H. Wannier 提出，它可以通过傅立叶变换和布洛赫波函数互相转换。Wannier 函数对于理解半导体、过渡金属、分子晶体等价电子局域程度比较高的凝聚态系统有重要帮助，因而在物理中有广泛的应用。 在 ABACUS 等密度泛函理论（Density Functional Theory，简称 DFT）软件中，单电子近似下的布洛赫波函数可以通过自洽迭代求解 Kohn-Sham 方程得到。但是布洛赫波函数存在规范不确定性，进而导致 Wannier 函数[1-4]也不是唯一的。1997 年到 2001 年间，Nicola Marzari、David Vanderbilt 和 Ivo Souza 等人发展了最大局域化的 Wannier 函数（Maximally localized Wannier function, 简称 MLWF）的方法[1,2,4]，提出可以通过优化 Wannier 表象下的电子位置的方差（即 spread 函数）来确定一个规范，在该规范下 Wannier 函数是最局域的；该方法可以在 DFT 电子结构计算完之后以后处理的方式实现计算 MLWF。2008 年，用于产生 MLWF 的 Wannier90 软件发布，并在随后几年获得了广泛的应用。 本教程分为两部分，第一部分 最大局域化 Wannier 函数方法简介 介绍最大局域化 Wannier 函数的算法，主要介绍 1997 年和 2001 年的两篇 PRB 文章中提出的优化算法，侧重物理与算法原理；第二部分即本文档，是 Wannier90 软件的 ABACUS 接口说明，主要介绍如何使用 ABACUS 计算 Wannier90 需要的输入文件，侧重具体软件使用。 一、Wannier90 软件介绍 Wannier90 软件[5-7]是 Arash A. Mostofi 同 Marzari、Vanderbilt 等人在 2008 年写的做 Wannier 函数最局域化的 Fortran 语言写成的软件，目前是做 Wannier 函数最局域化的主流软件。在 Wannier 函数方面，Wannier90 软件可以输出 Wannier 函数的中心（负电中心），也可以画出 Wannier 函数的等值面图像。除了做 Wannier 函数相关的计算，Wannier90 还具有计算能带与态密度、Berry Phase、输运性质等方面的功能，程序的下载和使用方法可以参考其官网：Wannier90。 二、使用 ABACUS 准备 Wannier90 需要的文件 目前的 ABACUS 平面波基组功能支持 Wannier90 接口，LCAO 的接口还在完善中。 使用 Wannier90 接口不需要编译 ABACUS 过程中做额外操作。 1. ABACUS 软件的输入参数解释 参数名 默认值 变量类型 参数解释 towannier90 0 bool 是否打开 Wannier90 接口的计算功能 nnkpfile seedname.nnkp string Wannier90 产生的 nnkp 文件的路径，nnkp 文件包含了 k 点邻居关系等计算 mmn 和 amn 文件必要的信息。 wannier_spin up string 输出向上/向下的波函数及其内积 out_wannier_mmn 1 bool 是否输出 mmn 文件，mmn 文件存储了$M_{mn}^{\\mathbf{k,b}}$，即布洛赫波函数之间的内积。mmn 文件在计算 Wannier 最局域化时必须输出。 out_wannier_amn 1 bool 是否输出 amn 文件，amn 文件存储了$A_{mn}$，即初猜的 Wannier 函数和布洛赫波函数之间的内积。在 Wannier 最局域化计算中最好有该文件（可以加快优化迭代的收敛），也可以没有。 out_wannier_eig 1 bool 是否输出 eig 文件，eig 文件存储了各个 k 点、各个能带的本征能量。在计算输出能带时需要输出，如果不需要输出能带则不需要输出该文件。 out_wannier_unk 1 bool 是否输出 UNK 文件，UNK 文件存储了布洛赫波函数$u_{n\\mathbf{k}}$。计算 Wannier 函数最局域化，输出 Wannier 函数的中心和 spread 不需要波函数信息。只有画 Wannier 函数图像时需要 UNK 文件。 out_wannier_wvfn_formatted 1 bool 输出的 UNK 文件是否是文本文件。非文本文件即二进制文件，输出速度会比文本文件快很多。 在运行 ABACUS+wannier90 程序前，需要准备自洽计算（SCF）的输入文件、非自洽计算（NSCF）的输入文件和 Wannier90 的输入文件，ABACUS 的输入文件有如下注意事项： 自洽计算：需要注意 INPUT 中一定要指定 out_chg 参数为 1，即输出电荷密度，以供给非自洽计算计算使用； 非自洽计算：需要注意 INPUT 中需要把 init_charge 参数设置为 file，即读取文件中的电荷密度；一定要指定 towannier90 参数为 1，同时指定 nnkpfile 参数为 Wannier90 产生的 nnkp 文件的地址；另外需要注意 KPT 文件中的布里渊区 k 点要和 Wannier90 输入文件中的 k 点一模一样，所以最好手动输入 K 点坐标指定； 非自洽计算：INPUT 中有 out_wannier_mmn、out_wannier_amn、out_wannier_eig、out_wannier_unk、out_wannier_wvfn_formatted 五个控制 Wannier90 相关文件输出的参数，默认值都是 1，其中 out_wannier_eig 和 out_wannier_mmn 是必须打开的，out_wannier_unk 和 out_wannier_amn 在需要使用 Wannier90 绘制波函数图时需要打开，out_wannier_wvfn_formatted 控制输出的 UNK 文件是文本文件还是二进制文件，输出文本文件的时间成本和存储空间都会比较大，输出二进制文件的时间开销和存储开销则会相对较小。 2. 运行流程 这里给出了运行 ABACUS+wannier90 的一个脚本文件，结合 examples/interface_wannier90/ 中的例子讲解结合 ABACUS 和 Wannier90 计算最局域化 Wannier 函数的完整运行流程，这里的流程对平面波基组和原子轨道基组均适用，原子轨道基组的 NSCF 会比平面波基组慢一些。 export W90=wannier90.x export ABACUS=abacus export NP=12 # 1. 运行Wannier90软件，生成nnkp文件； cd wannier mpirun -np $NP $W90 -pp diamond.win # 2. 运行ABACUS软件，执行电子结构的自洽计算； cd ../ABACUS cp INPUT-scf INPUT cp KPT-scf KPT mpirun -np $NP $ABACUS >> scf.out # 3. 将nnkp文件放在ABACUS的非自洽计算的INPUT文件中指定的位置，运行ABACUS软件，执行非自洽计算； cp ../wannier/diamond.nnkp . cp INPUT-nscf INPUT cp KPT-nscf KPT mpirun -np $NP $ABACUS >> nscf.out # 4. 将非自洽计算生成的Wannier90所需要的文件（mmn、amn、eig、UNK）放在Wannier90的运行路径下，运行Wannier90软件。 cd ../wannier cp ../ABACUS/OUT.ABACUS/diamond.amn ../ABACUS/OUT.ABACUS/diamond.mmn ../ABACUS/OUT.ABACUS/diamond.eig ../ABACUS/OUT.ABACUS/UNK* . mpirun -np $NP $W90 diamond.win 在这个例子中，Wannier90 的输入文件 diamond.win 中指定要求画出 Wannier 函数的图像，运行结束之后会得到 diamond_0000[1-4].xsf 四个文件，存有 Wannier 函数的实空间格点数值，放在 VESTA 中可以画出如下图的 Wannier 函数的等值面。 3. 运行时间参考 由于 Wannier90 接口只涉及上述步骤中的 NSCF 计算，所以这里只提供 NSCF 部分的时间统计。 在 12 个 CPU（型号：Intel(R) Xeon(R) Bronze 3104 CPU @ 1.70GHz）上并行运行样例，UNK 文件采用二进制格式输出，平面波基组耗时 4 秒，原子轨道基组耗时 98 秒。 4. 样例文件 下载地址为（国内 gitee）： https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/interface_Wannier90 三、参考文献 Nicola Marzari, Arash A. Mostofi, Jonathan R. Yates, Ivo Souza, and David Vanderbilt, Maximally localized Wannier functions: Theory and applications, Rev. Mod. Phys. 84, 1419 (2012). （关于最大局域化 Wannier 函数的综述文献） Nicola Marzari and David Vanderbilt, Maximally localized generalized Wannier functions for composite energy bands, Phys. Rev. B 56, 12847 (1997). （提出最大局域化 Wannier 函数方法的文献） Blount, E. I., Solid State Phys. 13, 305 (1962). （关于 Bloch 状态的诸多基础性质的讨论，最大局域化中$\\langle n\\mathbf{R}|\\mathbf{r}|m\\mathbf{0}\\rangle$在布洛赫表象下的表达式来源于此） Ivo Souza, Nicola Marzari, and David Vanderbilt, Maximally localized generalized Wannier functions for entangled energy bands, Phys. Rev. B 65, 035109 (2001). （从纠缠能带中解耦出部分能带，做最大局域化 Wannier 函数的文献） Arash A. Mostofi, Jonathan R. Yates, Young-Su Lee, Ivo Souza, David Vanderbilt, Nicola Marzari, wannier90: A tool for obtaining maximally-localised Wannier functions, Comput. Phys. Commun., 178, 9, 685 (2008). (发布 Wannier90 软件的文献) Giovanni Pizzi et al. Wannier90 as a community code: new features and applications. J. Phys.: Condens. Matter, 32, 165902 (2020). (Wannier90 软件近期的更新) ABACUS 的 Wannier90 接口的英文文档：Wannier90 ‒ ABACUS documentation Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-11-10 10:15:08 "},"develop-C++.html":{"url":"develop-C++.html","title":"ABACUS 开源项目 C++ 代码规范","keywords":"","body":"ABACUS 开源项目 C++ 代码规范 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/04 ABACUS（Atomic-orbtial Based Ab-initio Computation at UStc，中文名原子算筹）是国产开源密度泛函理论软件，相关介绍 ABACUS 的新闻可在 ABACUS 新闻稿整理查看。此文档用于给 ABACUS 开发者提供代码编程规范方面的建议。 前言 让任何开发者都可以快速读懂别人的代码，这点对于 ABACUS 项目很重要。此外，使代码易于管理的方法之一是加强代码一致性，这需要从代码规范开始着手。 一、命名约定 1. 普通变量的命名统一是小写，并使用下划线命名法 以下是四种命名方法：下划线命名法、匈牙利命名法、驼峰式命名法、帕斯卡命名法 string table_name; // 下划线命名法（推荐） - 用下划线区分单词（推荐使用） string sTableName; // 匈牙利命名法 - 前缀字母用变量类型缩写，单词首字母大写 string tableName; // 驼峰命名法 - 混合大小写（不推荐使用） string TableName; // 帕斯卡命名法 - 每个单词首字母大写（不推荐使用) 下划线命名法：推荐使用 匈牙利命名法：目前 ABACUS 中有些变量（例如指针），首字母为数据类型（指针为 p），可以考虑用这种方式命名，但不推荐用大写字母 驼峰命名法/帕斯卡命名法：目前 ABACUS 大部分的代码不是用这种命名方式的，为了代码风格统一，所以不推荐使用 2. 函数命名 建议使用下划线命名法且所有字母全部小写，建议小于 18 个字符 void calculate_area() { // function body } 3. private 的类数据成员在最后以下划线结尾 private 的类数据成员和普通变量的命名方式一样，但要在最后以下划线结尾，以区分自己是 private 的类数据成员。 class TableInfo { ... private: string table_name_; // 好 - 后加下划线 string tablename_; // 好 static Pool* pool_; // 好 }; 4. 只有全局变量用全大写命名 在 ABACUS 中，例如 NBANDS（能带数），NLOCAL（局域轨道数目）这种全大写的变量名是全局变量，其它的不建议用大写字母给变量命名。另外，ABACUS 将通过重构或者删除的方式逐步淘汰全局变量，因此不建议增加新的全局变量。 二、关于头文件 1. 只有在真正需要使用某个库/头文件时才 #include 它们 不需要的 #include 删除。 2. #include避免使用快捷目录 . (当前目录) 或 .. (上级目录) 项目内头文件应按照项目源代码目录的树结构排列，避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录)。例如 source/module_hsolver/diago_cg.h 文件是这样引用 module_base 的头文件： #include \"diagh.h\" #include \"module_base/complexmatrix.h\" 3. #include 顺序（clang-format 可以自动） 使用标准的头文件包含顺序，这样可以可增强可读性，避免隐藏依赖。 foo.cpp 中包含头文件的次序如下： 与源文件对应的头文件：dir2/foo2.h（这种优先的顺序排序保证当 dir2/foo2.h 遗漏某些必要的库时， dir/foo.cpp 的构建会立刻中止） C 系统文件 C++ 系统文件 其他库的 .h 文件 本项目内 .h 文件 4. 头文件需要 #define 保护 #ifndef FOO_BAR_BAZ_H_ #define FOO_BAR_BAZ_H_ ... #endif // FOO_BAR_BAZ_H_ 5. 避免使用前置声明 使用 #include 包含需要的头文件，尽量避免使用前置声明（见以下例子解释什么是前置声明）。 // 什么是前置声明？ // MyClassB.h // Bad: Overuse of forward declarations class MyClassB; class MyClassA { public: void DoSomething(MyClassB* obj_b); }; void MyClassA::DoSomething(MyClassB* obj_b) { // ... } 在这段代码中，MyClassB 被声明为一个类，但没有给出其定义。这被称为前置声明（Forward Declaration），它告诉编译器 MyClassB 是一个存在的类，但不提供该类的详细信息。 6. 当函数只有 10 行甚至更少时，才将其定义为内联函数 只有当函数只有 10 行甚至更少时才将其定义为内联函数（关键字 inline）。 三、关于类（Class） 1. 先声明类的成员变量，再声类的成员函数 2. 将public 部分放在最前，之后是protected数据，最后是private 3. 不使用运算符重载 若要使用，建议提交 issue 讨论 4. 什么时候用 struct？ 只有数据成员、没有成员函数时可以用 struct 5. 类型转换使用static_cast<>() 建议使用 C++ 的类型转换，如 static_cast<>()。 不要使用 int y = (int)x 或 int y = int(x) 等转换方式。 用 static_cast 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时。 用 const_cast 去掉 const 限定符。 用 reinterpret_cast 指针类型和整型或其它指针之间进行不安全的相互转换。 仅在你对所做一切了然于心时使用。 6. 继承采用 public 继承 如果你想使用私有继承，你应该替换成把基类的实例作为成员对象的方式去定义类。 7. 不过度使用实现继承，可以考虑组合 例如，如下案例： class Engine { public: void start() { /* 启动引擎 */ } }; class Car { public: Car(const std::string& n, Engine& e) : name_(n), engine_(e) {} void drive() { engine_.start(); std::cout 四、关于函数（Function） 1. 函数传参：不变参数用 const 和 & 函数的输入参数与输出参数: 在一个函数中，不变的量，我们可以看作是函数的输入参数；变化的量，我们可以看作是函数的输出参数。 在输入参数中可以选择 const T* （指向常量对象的指针，不能通过这个指针来修改其指向的对象的值。然而，你可以改变指针本身的值）。 也可以使用 const T& （不能通过这个引用来修改其引用的对象的值，在其生命周期内不能重新引用另一个对象）。 所以，建议使用 const T&，若要使用 const T*，则应给出相应的理由，否则会使读者感到迷惑。 void Foo(const string &in, string *out); // 输入参数：in （const + 引用&） // 输出参数：out（指针变量） 2. 函数传参：会变的参数用指针 什么是引用参数: 在 C 中, 如果函数需要修改输入变量的值, 参数必须为指针, 如 int foo(int *pval)。 在 C++ 中, 函数还可以声明为引用参数: int foo(int &val)。 引用参数在语法上是值变量却拥有指针的语义（变量可以被改变！）。 3. 每个函数不超过 50 行 建议编写简短，凝练的函数，有特殊情况的除外。 4. 函数返回值（return 的值）多使用值返回和引用返回，避免使用指针返回 五、关于作用域 1. 变量要初始化 无初始化的变量可能会引起结果不稳定（例如出现随机数），因此建议养成习惯，对所有变量的值要初始化，见下面的例子： int i; i = f(); // 坏——初始化和声明分离 int j = f(); // 好——初始化时声明 vector v; // 坏——初始化和声明分离 v.push_back(1); v.push_back(2); vector v = {1, 2}; // 好——初始化时声明 2. 将局部变量置于最小作用域 在 if, while 和 for 语句中： 变量不是对象，则变量应当在内部声明与初始化，这样子这些变量的作用域就被限制在这些语句中了，举例而言： while (const char* p = strchr(str, '/')) { str = p + 1; } 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数。这会导致效率降低。建议将构造函数调用次数减少以提高程序效率。 Foo f; // 构造函数和析构函数只调用 1 次 for (int i = 0; i 3. 仅在局部作用域使用using namespace 使用 using namespace 语句来引入命名空间中的所有名称可能会导致名称冲突。因此，建议在需要时使用它并仅在局部作用域内使用（例如只在调用的时候使用）。 // 建议不在程序开头使用，而是在具体用到std库的函数内使用该语句 using namespace std; 4. 用全局函数要加命名空间 以下是两种建议的方式，或者用类，或者用 namespace // 类的静态成员函数 class MyMath { public: static int add(int a, int b) { return a + b; } static int sub(int a, int b) { return a - b; } }; // or // 命名空间内的非成员函数 namespace my_math { int add(int a, int b) { return a + b; } int sub(int a, int b) { return a - b; } } 5. 优先使用命名空间的非成员函数 能使用命名空间的非成员函数，就不用类的静态成员函数。 // 使用命名空间内的非成员函数 namespace my_math { int add(int a, int b) { return a + b; } int sub(int a, int b) { return a - b; } } int main() { int x = 3, y = 5; int z = my_math::add(x, y); // 调用 my_math 命名空间中的函数 return 0; } // 不要使用类的静态成员函数模拟命名空间 class MyMath { public: static int add(int a, int b) { return a + b; } static int sub(int a, int b) { return a - b; } }; int main() { int x = 3, y = 5; int z = MyMath::add(x, y); // 调用 MyMath 静态方法 return 0; } 六、其他 C++ 特性 1. 每个代码文件不超过 500 行 太长的代码阅读理解和维护的成本都太高，因此不建议一个文件太长。如果有文件超过 500 行，建议重构，把对象进一步的划分。 2. 禁止用 C++11 之后版本的语法 目前的主要考虑是用新语法会使得编译器编译成功的概率降低，另外提高开发者的开发门槛。因此，我们规定不能使用 C++11 之后的语法。 3. 多用前置自增 (++i) 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增，自减运算符。 不考虑返回值的话，前置自增 (++i) 通常要比后置自增 (i++) 效率更高。 4. 尽可能用 sizeof(a) 代替 sizeof(int) 这里 a 是一个参数名 原因：当代码中变量类型改变时会自动更新。 5. 多使用列表初始化 C++11 中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下： // Vector 接收了一个初始化列表。 // 不考虑细节上的微妙差别，大致上相同。 // 可以任选其一。 vector v{\"foo\", \"bar\"}; vector v = {\"foo\", \"bar\"}; // 可以配合 new 一起用。 auto p = new vector{\"foo\", \"bar\"}; // map 接收了一些 pair, 列表初始化大显神威。 map m = {{1, \"one\"}, {2, \"2\"}}; // 初始化列表也可以用在返回类型上的隐式转换。 vector test_function() { return {1, 2, 3}; } // 初始化列表可迭代。 for (int i : {-1, -2, -3}) {} // 在函数调用里用列表初始化。 void TestFunction2(vector v) {} TestFunction2({1, 2, 3}); 6. 初始化时：整数用0，实数用0.0，指针用nullptr，字符 (串) 用'\\0' C++11 引入了一个新的关键字 nullptr，用来表示空指针。相对于传统的 NULL 或 0，nullptr 更加明确、类型安全。使用 nullptr 可以避免一些潜在的编程错误，比如将整数值误传给函数，导致出现不可预期的行为。 因此，建议在 C++11 及以上的版本中使用 nullptr 来表示空指针。 7. 少用 auto，使用前需对 auto 有更全面的了解 auto 是 C++11 引入的关键字，它可以让编译器自动推导出变量的类型。之后，C++14 和 C++17 对 auto 的使用也有了一些扩展和改进。 C++11：auto 只能用于定义局部变量，并且必须初始化。例如： auto i = 42; // 推导出 i 的类型为 int auto f = 3.14f; // 推导出 f 的类型为 float auto s = \"hello\"; // 推导出 s 的类型为 const char* C++14：auto 可以用于定义函数返回值类型，使得函数定义更加简洁。例如： auto add(int x, int y) { return x + y; } // 推导出返回类型为 int auto divide(double x, double y) { return x / y; } // 推导出返回类型为 double C++17：auto 进一步扩展为 auto 和模板结合使用时，可以直接指定模板类型参数，从而实现更加灵活的类型推导。例如： std::vector v{1, 2, 3}; auto it = v.begin(); // 推导出 it 的类型为 std::vector::iterator auto [first, second] = std::make_pair(1, 3.14); // 使用结构化绑定和 auto 推导出 first 和 second 的类型 但是大家注意，在 abacus 中，我们只支持 C++11 的标准，C++14/17 语法是不接受的。 8. auto 和 for 的混合使用时注意事项 在 C++11 中，auto 和 for 循环的结合使用已成为一种常见的编程范式，它可以让代码更加简洁、易读，并且减少了手动指定类型的错误。 int arr[] = {1, 2, 3}; for (auto i : arr) // 相当于复制 { std::cout 9. constexpr 替代宏定义和 const 常量 在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。（真正的常量在编译时和运行时都不变） #define PI 3.14159 // PI 是一个宏定义常量，它不会进行类型检查，容易出错； const double kE = 2.71828; // kE 是一个 const 常量，它不能用于编译期计算。 constexpr double kGravity = 9.8; constexpr 可以替代宏定义和 const 常量的主要原因是： 类型安全：使用 constexpr 定义的常量会进行类型检查，避免了宏定义可能带来的类型错误，同时也比 const 常量更加严格。 编译时计算：constexpr 声明的变量或函数在编译时就可以被求值，而不需要在运行时计算。这比宏定义和 const 常量更高效，尤其是在需要多次使用同一个值的情况下。 更好的可读性和可维护性：使用 constexpr 可以使代码更加清晰易懂，减少了宏定义可能导致的代码混乱问题。同时，由于 constexpr 可以使用函数、类等 C++ 语言特性，因此更加灵活，对于复杂的计算也更容易维护和修改。 因此，在 C++11 及以上的版本中，建议使用 constexpr 来替代宏定义和 const 常量，以提高代码的可读性、可维护性和效率。 七、关于 ABACUS 中常用的关键词缩写 有些名字很长，我们希望尽量言简意赅的表达出一些关键词的意思。原则是一般 3-5 个字母的范围下尽量说清楚一个变量的含义。这些统一的命名会出现在函数名或者变量名里。 1. 两个字符 pw：代表plane wave平面波 op：代表具有multi-device和multi-precision支持的算子（operator），和Operator模块含义不同 2. 三个字符 fft：快速傅里叶变换 kpt：布里渊区kpoint的缩写 nao：代表numerical atomic orbitals （nao经常用来表示number of atomic orbitals，不知道会不会混） orb：orbital，轨道 hmt：代表hamilt或者hamiltonian pot：代表potential chg：代表charge den：代表density（电荷密度尽量都用chg） scf：代表自洽迭代self consistent field thr：代表threshold tab：代表table kin：代表kinetic，动能的 cal：代表calculate opt：代表optimize gen：代表generate 3. 四个字符 iter：代表iteration init：代表初始化initializaiton read：读入 stru：代表structure veff：代表有效势 vloc：代表局域势 Reference Google C++ Style Guide Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-09 17:05:52 "},"develop-format.html":{"url":"develop-format.html","title":"ABACUS 中使用格式化工具 clang-format","keywords":"","body":"ABACUS 中使用格式化工具 clang-format 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/23 一、引言 良好统一的代码风格在多人协同开发中至关重要，这一点在 ABACUS 团队里也尤其重要，特别是考虑到大部分的开发者都是研究生，没有经过特别系统的编程训练，那么好的代码风格能够降低阅读代码的障碍，加快开发效率，甚至可以防止一些不必要的 bug 的产生。 clang-format 是一个开源的代码格式化工具，它可以帮助程序员自动调整源代码的格式，以符合指定的编码风格规范。clang-format 可以在保持代码功能不变的情况下，自动处理缩进、空格、括号、逗号等细节，提高代码的可读性和一致性。 二、在 ABACUS 中使用 clang-format clang-format 支持包括 LLVM、Google、Chromium、Mozilla、WebKit 等在内的多种代码风格，如果不指定自定义的代码风格，每次对代码进行格式化时使用的将是 clang-format 默认的风格。 clang-format 还支持在已有的代码风格基础之上自定义一个名为 .clang-format 的代码风格文件，clang-format 就可以根据文件中定义的规则对代码进行格式化。 在 ABACUS 开源项目中，开发者已经制定了针对 ABACUS 项目的代码风格文件 .clang-format，其位于项目的根目录下。（https://github.com/deepmodeling/abacus-develop/blob/develop/.clang-format） 注意事项：ABACUS 开源项目中的.clang-format是依赖于 clang-format-14 标准的，因此请确保你的 clang-format 不低于 14 版本。 1. 在系统上安装 clang-format clang-format 有诸多版本可供使用，目前最新版本为 clang-format 18。不同版本所支持的格式化选项不尽相同，但向后兼容。 安装统一版本的 clang-format（ABACUS 项目中统一选择 clang-format-14） # Linux上，以Ubuntu为例： sudo apt install clang-format-14 # 验证是否安装成功，并查看安装的版本号： clang-format-14 --version ⚠ 这里应注意，不能通过 sudo apt install clang-format 命令进行安装，因为对于不同的 Ubuntu 发行版而言，通过该命令安装得到的 clang-format 版本是不同的。 安装完成后，我们能够使用的命令名是 clang-format-14，我们将其提级为 clang-format： sudo update-alternatives --install /usr/bin/clang-format clang-format /usr/bin/clang-format-14 100 后面当我们使用 clang-format 命令时，指代的即为 clang-format-14。 # 此时再次验证安装的版本号：（应为 14 版本） clang-format --version 2. 基于 vscode 使用 clang-format 基于 vscode 使用 clang-format，我们可以选择安装支持 clang-format 的插件，即可更方便的使用 clang-format。 但由于插件商场有很多插件都支持 clang-format 功能，且其支持的 clang-format 版本经常变化。所以我们应尽量选择支持更为稳定的插件进行使用。 通过 vscode 进行 C++ 开发时，我们一般会安装微软官方的 C/C++ 插件，打开该插件的安装目录我们会发现，该插件已经封装了一个内置的 clang-format。那为什么不直接使用这个 C/C++ 插件内置的 clang-format 呢？ 不同版本的 C/C++ 插件内置的 clang-format 版本往往不同，就带来不必要的麻烦。 为了使用统一的 clang-format-14，我们建议在 vscode 中安装 Clang-Format（Xaver Hellauer） 插件 。 安装完成后，打开“File -> Preferences -> Settings”，搜索“format”，如下图： 将 Default Formatter 刚换为新下载的 Clang-Format 插件。 之后在一个文件内，通过 \"option\" + \"shift\" + \"F\" 快捷键，即可实现对当前代码文件的格式化。 3. 基于命令行使用 clang-format 除了使用 vscode ，可能还会有使用命令行进行开发的开发者。 使用方式： clang-format -style=file -i demo.cpp 三、格式化时的注意事项： 由于直接对整个文件格式化会导致每一行的历史修改信息被覆盖，因此我们要求在您修改某文件相应的代码内容之后，先commit一次，然后再对该文件进行格式化，再提交一次专门对文件格式化的commit。 这样细化每一个commit具体的信息，更有利于PR的审核和项目的管理。 四、参考文献： 使用 clang-format 进行 C++ 代码风格管理 Clang-Format 用法详解 Clang-Format Style Options — Clang 14.0.0 documentation C++ programming with Visual Studio Code 基于 vscode 使用 clang-format（旧版） Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-11-07 09:47:31 "},"develop-dox.html":{"url":"develop-dox.html","title":"ABACUS 注释规范：Doxygen 入门 (c++)","keywords":"","body":"ABACUS 注释规范：Doxygen 入门 (c++) 作者：金祖鑫，邮箱：jinzx@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/15 一、简介 开源密度泛函理论软件 ABACUS 目前由众多社区开发者共同开发，因此有一个统一的代码注释规范是非常重要的，本文主要推荐以 Doxygen 工具为辅助的代码注释格式。 1. 什么是 Doxygen Doxygen 是一款支持包括 C/C++, Python, Fortran 等多种语言的静态程序分析与文档生成工具。通过搜集并整理代码中的信息，包括但不限于 函数的调用/被调用 类的成员以及继承、协作关系 文件夹之间的依赖关系 头文件 include 关系 Doxygen 不仅能自动生成包含以上信息的图表与列表，也能将代码中采用特定格式的注释附到相应位置，最终生成内容翔实的文档。在适当的 Doxygen 配置与良好的代码注释下，Doxygen 自动生成的文档能为开发者提供诸多便利，降低阅读代码的难度，从而促进开发者社区的建设。 2. 功能与文档范例 Doxygen 可以生成某个函数的调用与被调用图(call & caller graph)。以开源密度泛函理论软件 ABACUS 代码为例，其中负责计算三次样条插值的函数 ModuleBase::CubicSpline::eval，doxygen 可将其调用关系自动可视化为如下图表： Doxygen 可以将类的继承关系生成图表。下图展示了 ModuleESolver::ESolver 的一系列继承 Doxygen 可以生成类的协作图（collaboration diagram）。下图展示了 container::Tensor 的成员以及成员的成员之间的关系： Doxygen 可以生成文件夹之间的依赖关系图。下图展示了 source/module_basis 及其内部成员文件夹与其他文件夹的耦合。 Doxygen 可以将头文件的 include 关系可视化成图表 (include dependency graph)。下图（部分地）展示了 module_basis/module_nao/numerical_radial.h 包含与被包含的情况： 大量项目使用 Doxygen 生成文档 (https://www.doxygen.nl/projects.html)。对科学计算开发者而言一个著名的例子是 LAPACK 的在线文档 https://www.netlib.org/lapack/explore-html/ 二、如何使用 Doxygen Doxygen 可以自动识别代码逻辑并生成以上例子中的函数调用、类的继承与协作、文件夹依赖以及头文件依赖等图表。但是，对理想的开发者文档而言代码注释中的信息亦不可或缺。在最终生成的文档中，除以上自动生成的图表外，Doxygen 会将类的成员与函数一一列举，并识别代码中特定格式的注释后将其附在对应位置。 1. 如何写能被 Doxygen 识别的注释 通常开发者会希望一部分精心撰写的注释——比如类的功能介绍或者函数参数的含义——出现在开发者文档里，而不希望文档充斥着临时变量的描述或某一行意义的解释。Doxygen 充分考虑了这一点。事实上，普通的注释均会被 Doxygen 忽略；只有特定格式的注释会被 Doxygen 识别。下面的代码是一个简单的例子。尽管其中各处都附上了注释，但这些均不会出现在最终生成的文档中： // A class that represents a circle. // This toy class will be used to demonstrate the usage of Doxygen. class Circle { public: // Initializes a Circle object with a given radius. // A unit circle is assumed by default. Circle(double r = 1.0); // Rescales a Circle object. // The radius of the given Circle object is multiplied by the given factor. static void rescale(Circle* circ, // pointer to the Circle object double factor // radius rescaling factor ); private: double r_; // radius of the Circle object static constexpr double PI = 3.14159265358979324; }; 以上代码生成的文档如下。Doxygen 会自动将成员变量和函数一一列举，但由于注释不符合特定格式，因而不会出现在文档相应位置。 下面介绍如何写能被 Doxygen 识别的注释以及一些基本用法。 1.1 基本格式 在 c++ 中 Doxygen 会识别以下三种注释格式： Javadoc-style /** * This is a Javadoc-style comment */ Qt-style /*! * This is a Qt-style comment */ Extended c++ style /// This is the so-called extended c++-style comment //! This also works! 以上三种格式本身均是合法的 C++ 注释，只是在 // 和 / / 的基础上添加了额外的 '*' ，'!' 或 '/' 。一旦文档中出现了以上三者之一，Doxygen 便会将之后的注释内容填入文档的相应位置。这三种基本格式是所有 Doxygen 用法的基础，所有的进阶功能（如 group，module，equation 等）均需在这三者之一开启的注释行/块内实现。这三种基本格式可以混用，开发者可以按自己的习惯选择一种或多种使用。 Doxygen 默认注释作用于之后的类、变量或函数（允许有空行）。如我们希望注释作用于之前的对象，则可在基本格式后立刻添加 ' //！ this comment line applies to print(), even though there's an empty line below void print(); /// 1.2 详细与简略描述 如之前例子所示，Doxygen 自动生成类的文档时会先把成员函数与变量罗列在开头，随后才是每个成员的介绍（当然，由于之前的例子里没有采用 doxygen 格式，详细描述为空）。只要使用了基本格式，Doxygen 就会自动将注释附在对应成员处。比如若将之前构造函数前的 // 注释替换为 /// : /// Initializes a Circle object with a given radius. /// A unit circle is assumed by default. Circle(double r = 1.0); 这些内容即会出现在原先为空的 Constructor & Destructor Documentation 下 Circle()的描述里: Doxygen 还允许让一些简略描述出现在类文档的开头部分。有两种方式可以实现这一目的。较为正式的方式是在注释块里添加 @brief 或者 \\brief。以这种方式指定的简略描述可以跨多行（如下面开头 Circle 类的注释）。另一种较为轻便的方式是使用单行的 extended C++ style 注释，如下面 Circle 的构造函数。【多行的 extended c++ style 注释只会被当做详细描述】 /** * @brief A class that represents * a circle. * * This toy class will be used to demonstrate the usage of Doxygen */ class Circle { public: /// Initializes a Circle object with a given radius. /*! * A unit circle is assumed by default. */ Circle(double r = 1.0); /*! * \\brief Rescales a Circle object. * * The radius of the given Circle object is multiplied by the given factor. * */ static void rescale(Circle* circ, double factor ); private: double r_; /// 以上代码生成的 Doxygen 文档在开头罗列部分会出现对应的简略描述；详细介绍部分则会包括所有的注释（包括 brief）。 1.3 函数参数 一个开发者写的函数经常会被很多其他开发者使用。除对函数整体功能的描述外，每个参数含义的注释也十分重要。Doxygen 支持两种给函数参数添加注释的方式。较为正式的方式是在注释块内添加 @param 或 \\param： /*! * \\brief Rescales a Circle object. * * The radius of the given Circle object is multiplied by the given factor. * * @param [in,out] circ Pointer to the Circle object to be rescaled. * @param [in] factor Radius rescaling factor. */ static void rescale(Circle* circ, double factor ); 较为轻便的方式是在函数声明的参数列表里直接添加（加在参数后注意要使用 ' /*! * \\brief Rescales a Circle object. * * The radius of the given Circle object is multiplied by the given factor. */ static void rescale(Circle* circ, /// [in], [out] 或 [in, out] 可以提示该参数是输入还是输出参数。这并非 Doxygen 的强制要求，但十分推荐。 以上两种参数注释方式对 Doxygen 而言是等价的，开发者可按习惯选择一种使用，生成的函数描述如下： 1.4 数学公式 有时一些函数严格对应了某个公式，这种情况下直接用数学公式作为注释的效果可能胜过大段的文字描述。Doxygen 允许开发者以 Latex 的语法实现公式注释。如有在文字中嵌入公式的需求，可以采用 \\f$ ... \\f$： /// A constant that represents the value of \\f$ \\pi \\f$. static constexpr double PI = 3.14159265358979324; 单行公式由 \\f[ ... \\f] 实现： /*! * @brief Returns the area of the current Circle object. * * The area of the a circle is given by * * \\f[ S = \\pi r^2 \\f] */ double area() const; 如有多行公式的需求，Doxygen 支持调用 eqnarray 等 latex 数学环境： /*! * @brief Returns the circumference of the current Circle object. * * The circumference of the a circle is given by * * \\f{eqnarray*}{ * L &= \\pi d \\\\ * &= 2 \\pi r * \\f} * */ double circumference() const; 【在配置文件中采用 “USE_MATHJAX = YES” 可以调用 mathjax 渲染公式得到更好的视觉效果】 1.5 列表 Doxygen 还有大量用法可供用户生成理想的文档。 对齐的 '-', '+' 或 '*' 可自动生成列表 (bullet list)；'-#'则可用来生成带序号的列表： /** * @brief A class that represents * a circle. * * This toy class will be used to demonstrate the usage of Doxygen * * List of functionalities: * -# initialize a Circle object with a given radius * - a unit circle is assumed by default * -# get the radius of the current Circle object * -# get the area of the current Circle object * -# get the circumference of the current Circle object * -# rescale a Circle object by a factor * */ class Circle */ */ 1.6 Member Group & Module 变量或函数可以由 @{ ... ``@} 归类为 member group 并附上相应注释，这能使文档更有层次感： ///@{ @name Properties /// Functions that return the properties of the current Circle object. /// Gets the radius of the current Circle object. double radius() const { return r_; } /*! * @brief Returns the area of the current Circle object. * * The area of the a circle is given by * * \\f[ S = \\pi r^2 \\f] */ double area() const; /*! * @brief Returns the circumference of the current Circle object. * * The circumference of the a circle is given by * * \\f{eqnarray*}{ * L &= \\pi d \\\\ * &= 2 \\pi r * \\f} * */ double circumference() const; ///@} 有共性的类之间亦可归类组成 Modules: /// @defgroup shape Shape Module /// @brief A module that contains various shape classes. /// /// This module contains the following classes: /// - Circle /// - Rectangle /// - Triangle /// @addtogroup shape /// @{ class Circle { ... }; ///@} /// @addtogroup shape /// @{ class Rectangle { ... }; ///@} /// @addtogroup shape /// @{ class Triangle { ... }; ///@} 更多用法可参考官方文档 Doxygen Manual: Overview 2. 如何生成文档 上一节介绍了 Doxygen 支持的注释格式以及一些常见的使用方式。以下以 Ubuntu 用户为例介绍让开发者在本地生成 html 文档的方法： 1. 安装 doxygen 与 graphviz sudo apt install doxygen graphviz 2. 生成 Doxygen 的配置文件 doxygen -g 默认的配置文件名为 Doxyfile。 3. 修改配置文件 配置文件内已经包含介绍各选项的注释。常用的选项包括： INPUT：用以生成文档的文件夹或文件路径 RECURSIVE：是否遍历给定路径下的所有子文件夹 EXCLUDE：是否要排除一些子文件夹或子文件 EXTRACT_PRIVATE, EXTRACT_STATIC, EXTRACT_PRIV_VIRTUAL：文档是否要包括私有成员/静态成员/私有虚函数 CALL_GRAPH, CALLER_GRAPH: 文档是否要包含函数调用/被调图 PREDEFINED：预编译宏 MACRO_EXPANSION：是否要展开宏定义 EXPAND_ONLY_PREDEF：是否只展开 PREDEFINED 的宏定义 一个可供参考的 Doxyfile 可见于 Doxygen 使用 （赵天琦） 完整的配置选项可参考官网 Doxygen Manual: Configuration 4. 运行 doxygen 假设配置文件叫 my_doxyfile： doxygen my_doxyfile 附录：Doxygen 与 VS Code Visual Studio Code 上有 doxygen 插件 Doxygen Documentation Generator - Visual Studio Marketplace 可供 VS Code 用户方便使用。 【注：前文中有提到对 doxygen 而言三种基本注释格式可以混用；混用的注释会合并在一起作用于注释后的对象。这个特性与 VS Code 中鼠标悬停于类或函数上时出现的预览窗口不兼容；如注释格式混用则会导致前一种格式的注释被忽略】 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-09-15 19:30:43 "},"develop-issue.html":{"url":"develop-issue.html","title":"ABACUS 的 Github 仓库 Issues 处理流程","keywords":"","body":"ABACUS 的 Github 仓库 Issues 处理流程 作者：赵天琦，邮箱：zhaotq@aisi.ac.cnmailto:zhaotq@aisi.ac.cn； 审核：陈默涵，邮箱：mohanchen@pku.edu.cnmailto:mohanchen@pku.edu.cn 最后更新时间：2023/10/01 一、Github 的 Issues 机制 1. 简介 Github 的 Issues GitHub 上的 Issues 机制是一个用于跟踪和讨论项目相关问题、需求、任务和改进的功能。它为开发者们提供了一个集中式的平台，使得项目的参与者们能够跟踪项目进展、报告错误、提出新功能、讨论改进方向等。 2. Issues 对 ABACUS 软件的作用 ABACUS（原子算筹）是一款国产密度泛函理论（Density Functional Theory，简称 DFT）软件，其涉及到的功能繁多，仅 2023 年上半年统计到的输入参数就有三百多个，应用的对象也很广，在材料、物理、化学、能源和工程等多个领域都有应用。因此，常见的问题是开发者开发出的功能不能包含所有可能的应用对象，因此软件在某些特定场合出现效率不高甚至某个功能无法运行的情况是时有发生的。另外一方面，ABACUS 项目参与的开发人员广泛，不同开发者对同一个软件代码进行修改，容易引发新的 bug。因此，建立一个良好的用户和开发者，乃至开发者之间互动交流的平台，对于发现软件问题，不断改善软件质量和提高稳定性易用性方面具有重要作用。Github 上的 Issues 机制则承担起了这一部分功能。因此，将 Issues 机制建立好是不断提升 ABACUS 软件，使其快速迭代的重要措施。 3. Issues 功能介绍 创建 Issue：项目的任何参与者都可以新建一个 Issue。创建 Issue 时，需要填写标题、描述（可以使用 Markdown 语法格式化描述内容）、分配处理人（Assignees，可选）、添加分类标签（Labels，可选）、关联项目看板（Projects，可选）和设置里程碑（Milestones，可选）。 标签（Labels）：标签是用来对 Issues 进行分类和过滤的。项目维护者可以创建自定义标签，例如：bug、feature、documentation、enhancement 等。这有助于组织和优先处理不同类型的问题。 里程碑（Milestones）：里程碑用于对 Issues 进行分阶段管理和规划。项目维护者可以创建里程碑并为其分配截止日期，这样有助于按照计划进行项目开发。 指派（Assignees）：在 Issue 上指派处理人意味着将该 Issue 的负责人分配给特定的项目参与者。这有助于清楚地了解谁负责解决某个问题。 评论和讨论：项目的参与者们可以在 Issue 下面发表评论，进行讨论。评论支持 Markdown 语法，因此可以方便地插入代码、图片和链接等。 引用和关联 Issue：在评论和提交（Commit）中，可以通过输入类似 #issue编号 的格式引用其他 Issue，这有助于将讨论串联起来。此外，还可以使用关键字（如：close、fix、resolve 等）在提交信息中自动关闭相关 Issue。 通知和订阅：当您参与某个 Issue 时（如创建、评论或被指派），如果您希望及时收到回复，建议您关注是否会收到邮件通知（关注一下 Github 的功能） 关闭和重开 Issue：当某个问题被解决或者不再适用时，项目维护者或 Issue 创建者可以关闭 Issue。如果后续发现问题没有解决或者需要重新讨论，可以重新打开 Issue。 二、ABACUS 项目的 Issues 标签分类 提交 Issues 会让提交者（提交者可以是用户或者开发者）选择标签，以下是 ABACUS 开发者团队推荐的标签及其使用场景 分类 ： Bug Report（开发者/用户）: 用于报告代码问题，例如崩溃、错误或意外行为。 Code Quality（开发者）：用于报告与代码质量相关的问题，例如代码不规范、设计不良、全局类或去全局变量使用不当、或者可维护性问题，开发者会用重构来解决相关问题。 Docs（开发者/用户）：用于报告与软件文档相关的问题，例如缺少或不完整的文档，或难以理解的文档。 Feature Request（开发者/用户）：用于请求新功能或对现有功能进行增强。 Performance（开发者/用户）：用于报告与用户角度下软件性能相关的问题，例如响应时间慢、资源使用率高或可扩展性问题。 Questions（开发者/用户）：软件安装、软件易用性等用户或开发者需要帮助解决的问题。 Tests （开发者）：用于报告与测试相关的问题，例如测试失败、缺少或不完整的测试或测试自动化问题 优先级： Priority High: 通常指的是需要尽快解决的紧急问题，如 CI 不通过，新 PR 全部报错 Priority Medium: 重要且需要近期解决的问题，如... Priority Low：可能是一些不紧急但需要解决的问题，如需求调整、性能优化 专题 DFTU, EXX, big system 等用于记录一些专题类 Issues，以方便开发者系统解决同一个主题的 Issues 三、Issues 处理流程 1. 介绍 提交的Issues会在24小时内得到开发者团队的回复。当前Issues处理的闭环方式有： 提交PR修改代码，解决对应Issues，之后关闭相应的Issue。 ISSUE历史大于两周以上，且ISSUE提出者不对有效回应做回应，则提醒用户后关闭 属于Discussion机制而不属于Issues的范围，会转移到Github的Discussion模块：例如用户的想法，用户的建议，用户对社区的问题等以用户的满意程度为指标的问题 2. 创建一个 ISSUE 有多种方法可以创建 ISSUE，您可以选择最方便的方法来。本例将使用 GitHub UI。有关其他创建 ISSUE 的方法的更多信息，请参考 Github 文档“创建 ISSUE”。以下是具体步骤： 在 GitHub 上，导航到 ABACUS 仓库的主页。 https://github.com/deepmodeling/abacus-develop.git 在 ABACUS 仓库名称下面，单击“Issues”。 单击“New issue”。 选择一个最适合您的 ISSUE 的一个标签模版，点击“Get started”。如果 ABACUS 提供的默认模版不符合您的 ISSUE 类型，可以选择“Open a blank issue”。 3. 填入 ISSUE 信息 给您的 ISSUE 一个描述性的标题。标题应该一眼就能传达问题的内容。 添加一个解释 ISSUE 目的的描述，包括任何可能有助于解决问题的细节。例如，如果这是一个 bug 报告，描述重现 bug 的步骤、预期结果和实际结果。 您可以使用 Markdown 添加格式、链接、表情等。有关更多信息，可参阅“在 GitHub 上撰写”。 以下是 ABACUS 的 Bug report 类型 ISSUE 的模版，您可以根据 ISSUE 模版示例来填入 ISSUE 信息。其中带“*”的项是必填项。 4. ISSUE 的任务列表 请注意“Task list for Issue attackers”是为了帮助开发者检查 ISSUE 解决的进度，并不是要求您选择解决 ISSUE 需要完成哪些工作。所以您只需要提供足够详细的信息以帮助开发者来解决 ISSUE。如果您提供的信息已经完成其中的一些任务列表，可以在相应的任务前打对勾，但是如果没有可以不用关心“Task list for Issue attackers”。当然，了解解决一个 ISSUE 所需要经过的一般步骤，有助于您了解 ABACUS 代码的开发过程。如果您想通过自定义的任务列表给开发者一些提示，可以参考 Github 文档“About task lists”。 5. 添加 ISSUE 标签 如果您选择 ISSUE 模版，创建完 ISSUE 之后会自然有相应的标签出现，如： 此外，您也可以参考 ABACUS 的专题标签（例如 DFTU, EXX 等）添加相应的标签，或者通过“Edit labels”创建新标签： 6. 提交 ISSUE 点击“Submit new issue”以创建您的 ISSUE。您可以在创建问题后编辑上述任何字段。您的 ISSUE 有一个唯一的 URL，您可以与团队成员分享，或在其他 ISSUE 或 Pull Requat 中引用。 7. 与开发者交流 创建 ISSUE 后，通过添加评论与开发者或其他协作者交流对话。您可以键入 @ 邀请协作者或团队关注评论。 要在同一仓库中可以链接相关问题，您可以键入#，后跟 ISSUE 标号或部分标题，然后单击要链接的问题。有关更多信息，请参见““在 GitHub 上撰写””。 8. 查看 ISSUE 解决进度 查看 ISSUE 解决有 3 种方式，如下图所示： 可以通过“task list”的完成进度查看 ISSUE 的解决进度 新建的 ISSUE 会被自动加入 ABACUS ISSUEs 项目，开发者通过讨论之后会在其中加入\"Iteration\"解决周期，\"Priority\"优先级，\"Collaborators\"开发者单位，\"Project\"是否纳入近期的开发者项目等信息，您也可以在这里看到 ISSUEs 的进展。 Assignees 是解决 ISSUE 的开发者，需要 ABACUS 管理员进行分诊。 9. 关闭 ISSUE 以第 1 步和第 2 步同样的方式找到想要关闭的 ISSUE。 点击“Close issue”，关闭 ISSUE。 如果要添加关闭 ISSUE 的原因，可以在“Leave a comment”处添加关闭原因，然后点击“Close with comment”，关闭 ISSUE。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-02 11:02:27 "},"develop-input.html":{"url":"develop-input.html","title":"ABACUS 线上文档输入参数撰写规范","keywords":"","body":"ABACUS 线上文档输入参数撰写规范 作者：刘建川，邮箱：liujianchuan2013@163.com 审核：陈默涵，邮箱：mohanchen@pku.edu.cn；韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 最后更新时间：2023/10/03 一、背景 ABACUS 代码仓库地址：https://github.com/deepmodeling/abacus-develop ABACUS 线上文档地址：https://abacus.deepmodeling.com/en/latest/ （ ABACUS 线上文档是包括开发者在内的所有用户了解 ABACUS 软件使用方法的重要渠道。） 本文档关注：“关键字”部分的文档 对应的文档地址：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html 对应的代码地址：https://github.com/deepmodeling/abacus-develop/blob/develop/docs/advanced/input_files/input-main.md 更新方式：目前对该文档的更新同样是通过 PR 的方式提交到 ABACUS 的 Github 仓库上，因此任何人都可以通过提交 PR 的方式对文档做出修改，我们也鼓励用户如果发现问题后可以主动修复文档。 二、规范格式 每个输入参数都应遵循以下格式： Name of Parameter Type: Availability: (可选) Description: Default: Unit: (可选) Example: (可选) 按照上述顺序排列，上述所有字段需加粗，后面使用英文冒号（不加粗），冒号后空一格开始写内容（不加粗） 上述关键字用黑色实心圆，关键字后的介绍不用加粗 错误示范：Type:Integer 错误示范：Type: integer 错误示范：Type: integer 正确示范：Type: Integer 错误示范：Default: 0 错误示范: Default: false 正确示范：Default: False 1. Name of Parameter 这个参数代表了参数的名称，建议起参数名称的时候遵从以下规范（xxx 由设定参数名的开发者指定）： 输出某物理量的参数：建议以 out_xxx 为参数名，其中 out 是 output 的缩写。可参考的变量名有 out_chg（输出电荷密度），out_pot（输出势函数），out_dm（输出密度矩阵 density matrix） 收敛阈值相关参数：建议以 xxx_thr 为参数名，其中 thr 是 threshold 的缩写。可参考的变量名有 scf_thr（电子自洽迭代的收敛阈值），force_thr（结构弛豫时原子中的最大受力域值），和 stress_thr(晶格优化时的应力收敛阈值) 计算某物理量的参数：建议以 cal_xxx 为参数名，其中 cal 是 calculate 的缩写 初始化某物理量的参数：建议以 init_xxx 为参数名，其中 init 是 initialize 的缩写。可参考的变量名有 init_wfc（初始化波函数）, init_chg（初始化电荷密度）, init_vel（初始化原子速度） 结构弛豫相关参数：建议以 relax_xxx 为参数名，其中 relax 代表（结构）弛豫 并行策略相关参数：建议以 xxxpar 为参数名，其中 par 是代表 parallel，即并行。可参考的变量名有 kpar（k 点并行），bndpar（能带并行） 其它参数：建议先寻找 ABACUS 目前支持的参数名来设计相关参数 2. Type Type：冒号之后首字母大写，输入参数的种类，有 Integer，Real 和 String 三种类型。对于 Boolean 类型，Default 字段后的内容统一写：True 或 False（首字母大写），且先写 True，再写 False 注意 Real 类型不要写成 double 或者 float 类型 3. Availability（Optional） 如果是完整的一句话就首字母大写，如果是单词或短语就小写 4. Description 冒号之后首字母大写 如果有 Note 的标注，可在 Description 字段下，单独写一个 Note，不用加粗。 Description 字段里如果有涉及到 1 和 0 是表示 True 或 False，统一改成 True 或 False。 字段如果是完整句子，末尾要加英文句号：\".\"，若是单词和短语则不加。其他字段均不加。 String 类型的参数 直接列出所有选项 当一个参数有多种取值时，按照从小到大顺序描述不同的取值，例如 propagator 这个参数，就在 description 里面描述参数是 0，1，2 三种情况下的波函数演化方法。 不写“when set to”、“if set to”，直接写参数后，再写该参数的描述 5. Default 参数默认的数值，分成有单位的和没有单位的两种。如果是小数，建议采用科学计数法表示，“e”一律小写，如: 2e-6 6. Unit（Optional） 如有需要使用 Unit 来标定输入参数的单位，紧接在 Unit 后面描述单位，另外内容里如果涉及到写单位，需要用空格隔开，如：U (eV) 单位撰写需符合标准： 错误示范：KBar 错误示范：ev 正确示范：kbar 正确示范：eV 7. Example（Optional） 如有案例，可添加相关例子的链接和简单描述。如果需要，可以添加上述的 Example 字段描述案例。 三、其他问题 所有简写应该大写，以及后面用括号写出全称，每一个关键字的描述出现了简写均需要写全称，如:“soc”改成“SOC（spin-orbital-coupling）”。即使最常见的如 PW、MD 等也均写出全称 对参数的描述保持客观，如：不写“An important parameter”这种话 相关的参数建议放在文档上靠近的地方。举例：symmetry 参数是控制是否打开对称性操作的参数，而 symmetry_prec 是用来控制对称性操作的精度，这两个参数就可以放在一起先后介绍，并且在介绍的时候，可以提及相关的参数 一些太长的输出，单独开辟一个专区去介绍 如关键字告诉了用户输出了文件，建议告诉用户文件名称和文件保存的路径 注意语法问题 标点符号格式要一致 注意不要出现乱码 以上若有问题或者建议，欢迎写信给作者！虽然我们邮箱基本不会收到类似邮件，但开源精神的意义就在于提供了这种可能性，然后坚信更好的事情会到来。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-03 22:28:26 "},"develop-rule.html":{"url":"develop-rule.html","title":"ABACUS 代码存放规范","keywords":"","body":"ABACUS 代码存放规范 作者：路登辉，邮箱：denghuilu@pku.edu.cn；赵天琦，邮箱：zhaotq13@tsinghua.org.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/11/09 一、背景 截止到 ABACUS 3.4 版本，ABACUS 的 Github 仓库（https://github.com/deepmodeling/abacus-develop）代码已超过 30万 行，涉及上千个源代码文件，有时一周内在 Github 仓库上就会 Merge 近 20 个 PR，涉及数千乃至上万行代码的修改。随着社区规模不断壮大，为了更好的在各个开发者之间协同合作，在过去已有的一些代码管理的共识的基础上，我们提出这个代码存放规范文档。 二、代码目录 进入主仓库之后，ABACUS 的源代码目录位于 source 文件夹下： $ tree source -d -L 1 source ├── module_base #基础模块 ├── module_basis #LCAO和PW基组模块 ├── module_cell #晶胞模块 ├── module_elecstate #电子波函数相关性质模块 ├── module_esolver #能量求解器模块 ├── module_hamilt_general #对于PW和LCAO基组共享的哈密顿量模块 ├── module_hamilt_lcao #LCAO基组下哈密顿量的相关模块 ├── module_hamilt_pw #PW基组下哈密顿量求解的相关模块 ├── module_hsolver #对角化求解矩阵特征值/特征向量等哈密顿求解器模块 ├── module_io #输入输出模块 ├── module_md #分子动力学模块 ├── module_psi #波函数模块 ├── module_relax #结构优化模块 ├── module_ri #Resolution of identity相关的Beyond DFT的模块 其中，14 个主模块的核心功能如上面注释所言，代码存放建议按照模块化管理，相关功能的代码存放到对应的模块当中。如果需要涉及到新建模块以及更新模块位置等需求，应该按照 ABACUS 的 Github 仓库 Issues 处理流程 · GitBook 中相关规范要求去 Github 仓库提交 ISSUE 并邀请开发者讨论来进行。 2.1 模块内部代码存放规范 以 module_base 目录为例，该目录下包含了 ABACUS 中内存管理，错误处理，基础通讯以及基础算法等等功能的代码实现，是 ABACUS 中最底层的代码，其他模块大多依赖于 module_base。该模块中的代码分布如下，相应文件夹功能如注释所言： $ tree source/module_base -d -L 1 source/module_base CMakeLists.txt ├── abfs-vector3_order.cpp #基础代码 ├── abfs-vector3_order.h #基础代码 ├── ... ├── CMakeLists.txt #负责module_base中cmake编译的CMakeLists.txt ├── kernels #module_base中的异构计算代码 ├── libm #libm模块，包含一些优化过后的数学库运算 ├── module_container #ABACUS中底层容器Tensor的实现 ├── module_mixing #charge-mixing实现 ├── test #module_base中的单元测试 ├── test_parallel #module_base中并行相关的单元测试 ├── ... ├── ylm.cpp #基础代码 └── ylm.h #基础代码 我们提出如下的模块代码存放规范： 基础代码存放规范：模块中的基础代码（除去部分特殊代码外的大部分代码）应直接存放到当前模块目录下，头文件以 .h 命名；源文件以 .cpp 命名；代码规范应该遵循 ABACUS 开源项目 C++ 代码规范 · GitBook 中的要求。 异构计算代码存放规范：模块中涉及到异构计算（CPU 结合GPU计算）部分的代码应直接存放于当前模块的 kernels 目录下；这部分代码的结构将会在稍后详细介绍。 子模块代码存放规范： 在主模块下同样可能存在一些子模块，它们通常是具有特定功能的代码的集合：以 module_base 举例，libm，module_container 以及 module_mixing 分别表示了 libm 模块（后续建议改成 module_libm 模块），ABACUS 中底层 Tensor 容器模块（用来方便在不同硬件上存放数据）以及 charge-mixing 相关的功能模块，它们为 module_base 模块下的子模块，子模块中同样也可能有类似于主模块的文件代码排布。 如果要在当前模块中新建或者调整子模块应当去 Github 仓库提交相关的 ISSUE 讨论。 单元测试代码存放规范： 模块中代码的单元测试应当存放到当前模块的 test 目录下，特殊情况可以存放到以 test 开头的目录下面。例如，test_parallel 存放了一些并行计算的单元测试，因为 test 目录下面的 CMakeList 文件有时候会把 MPI 宏定义去除，再比如 test_mpi 里面只测试了 mpi 代码，没有打开 OPENMP。module_base 下面还有一个针对数值精度的测试，命名成了 test_precision。 当前模块的子模块的单元测试应当存放到相应子模块的 test 目录下； CMakeLists.txt 存放规范：各个模块以及子模块通过各自目录中的 CMakeLists.txt 管理 CMake 编译结构，添加或修改代码要注意维护 CMake 编译的完备性，此外还应该维护 Makefile 编译的实现，确保代码可以通过 Github 的 CI 测试。 2.2 异构计算代码存放规范 当前 ABACUS 中 PW 部分代码已经实现了初步的 GPU 化，Source 目录中包含 GPU 的 module 如下，相应文件夹功能如注释所言： ├── module_base #基础模块 │ ├── kernels #module_base模块下的异构计算代码 │ │ ├── cuda #module_base/kernels中函数的CUDA实现 │ │ ├── rocm #module_base/kernels中函数的ROCm/DCU实现 │ │ └── test #module_base/kernels中函数的单元测试 │ ├── libm #子模块libm │ │ └── test #libm的单元测试 │ ├── module_container #子模块，负责实现ABACUS中的底层Tensor容器 │ │ ├── ATen #定义了Tensor容器的基本实现 │ │ ├── base #定义了一些Tensor对象无关的基础函数 │ │ └── test #module_container的单元测试 │ ├── test #module_base的单元测试 │ │ └── data #module_base的但愿测试依赖的数据 │ └── test_parallel #module_base的并行测试 ├── ... ├── module_elecstate #电子波函数相关性质模块 │ ├── kernels #module_elecstate中相关的异构计算代码 │ │ ├── cuda │ │ ├── rocm │ │ └── test │ ├── module_charge #charge子模块 │ ├── module_dm #dm子模块 │ │ └── test #module_dm的单元测试 │ ├── potentials #potentials子模块 │ ├── test #module_elecstate中的单元测试 │ │ └── support #放置单元测试需要的输入文件 │ └── test_mpi #只测试mpi并行代码的单元测试 ├── ... ├── module_hamilt_pw #PW基组下哈密顿量求解的相关模块 │ ├── hamilt_ofdft #OFDFT子模块 │ ├── hamilt_pwdft #PWDFT子模块 │ │ ├── kernels │ │ ├── operator_pw │ │ └── test │ └── hamilt_stodft ├── module_hsolver #对角化求解矩阵特征值/特征向量的模块 │ ├── genelpa │ ├── kernels │ │ ├── cuda │ │ ├── rocm │ │ └── test │ └── test ├── ... ├── module_psi #波函数存储模块 │ ├── kernels │ │ ├── cuda │ │ ├── rocm │ │ └── test │ └── test │ └── support └── ... 为了更进一步的规范异构计算代码在 ABACUS 中的维护和管理，以 module_base/kernels 举例，针对异构计算代码的位置和目录结构做出如下规范： module_base/kernels/ ├── cuda #存放算子的CUDA实现 │ └── math_op.cu #算子的CUDA实现存放于cuda目录下 ├── math_op.cpp #算子的CPU实现 ├── math_op.h #算子的声明 ├── rocm #存放算子的ROCM实现 │ └── math_op.hip.cu #算子的ROCM实现存放于rocm目录下 └── test #提供了算子的单元测试 ├── CMakeLists.txt └── math_op_test.cpp 异构计算代码存放规范：在每个 module 下，异构计算相关的代码都应该存放在 kernels 目录下。异构计算代码都是以算子（OP）的形式存在的，一个算子包含了：CPU，CUDA 以及 ROCM 的实现，使得该算子可以作为统一的计算接口供 ABACUS 调用。 算子的声明和 CPU 实现存放规范：以 module_base 目录举例：module_base/kernels 目录应该直接存放当前 module 中涉及到的异构计算算子的声明 .h 文件和其 CPU 实现 .cpp 文件； 算子的CUDA实现存放规范：kernels 目录下的 cuda 子目录中相应的 .cu 文件存放算子的 CUDA 实现； 算子的 ROCM 实现存放规范：kernels 目录下的 rocm 子目录存放算子的 ROCM 实现； 算子的单元测试存放规范：kernels 子目录下的 test 目录存放当前 kernels 中涉及到的全部算子的单元测试。 三、总结 我们提倡在 ABACUS 中将各个模块的代码按照上述规范建议进行存放，目录结构可以延续上述风格以便代码识别；涉及到代码目录的问题欢迎到 Github 仓库进行讨论交流。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-11-09 17:26:15 "},"develop-linedete.html":{"url":"develop-linedete.html","title":"ABACUS 全局数据结构和代码行数检测","keywords":"","body":"ABACUS 全局数据结构和代码行数检测 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/11/20 一、背景 第一部分背景。我们将从 ABACUS 的两个主要方面来介绍目前重构还需要进行的工作：一是全局变量和全局类。二是文件的大小和长度。这个文档的主要目的也是要呼吁更多的开发者能够有意识的，主动的对代码目前的一些问题进行重构，这有利于提升代码整体的质量。我们也欢迎更多的开源社区伙伴能够加入进来，提升 ABACUS 代码的质量。 第二部分，我们提供了一个测试 ABACUS 代码关于全局数据结构和代码行数的脚本。 第三部分，我们针对 ABACUS 3.4.2 版本进行了一次检测，检测结果和检测时间已列在文档中，希望这个数据能够帮助到想要对代码进行相关重构的同学。我们会隔一段时间后再对本文档进行更新。 1. 全局变量和全局类 ABACUS 代码里长期存在一些全局变量（程序里以 GlobalV：：开头的变量，V 代表 variables）和全局类（程序里以 GlobalC：：开头的类，C 代表 classes）。这里全局的含义说明这些变量和类可以在程序的任何一个角落调用，不需要通过函数的接口传递。 在程序发展早期，使用全局变量和全局类可以加速程序新功能的开发，使得开发者可以快速的调用到想要的模块，例如 ucell 代表原胞信息的类，那么只要需要使用到诸如原子位置和种类等信息，都可以直接调用，就显得很方便。 然而，随着 ABACUS 代码数量的增加，对一些全局变量和全局类不加控制的使用导致了严重的问题，即当某一个全局变量或者全局类被修改之后，会影响大量的代码，从而可能引发不同功能的 bug，另外也会给对全局变量或者全局类修改的开发者带来很多额外的工作量。 大多数的开发者会延用 ABACUS 目前的全局类和全局变量的使用，但我们认为这可能会慢慢的导致 ABACUS 的代码结构越来越变得不可维护，因此有必要做出一些代码结构上的调整甚至重构。 目前 ABACUS 开发团队觉得需要做两件事情来提升代码质量，一方面需要对全局变量和全局类的使用加以控制，不在特殊情况下一般不建议使用。另外一方面，对一些可以不成为全局变量或者全局类的代码加以修改和重构，逐步减少全局变量和全局类的使用次数，通过一些更规范的函数参数传递来进行替代。但是，这项工作涉及到的工作量较大，因此需要逐步的推进完成，甚至依赖开源的力量来推动它完成，从而根本上提升 ABACUS 的代码质量。 2. 代码长度 在 ABACUS 开发的过程中，有些开发者倾向于将同一类功能的代码都放入到同一个代码文件，但后期我们发现如果对这个过程不加以一定条件的约束，会使得代码质量下降。首先，随着程序的不断发展，一个长的代码里可能会有一些代码可以被别的地方重用，但是这部分代码不容易被抽出来。其次，当要对一个长代码里的一些函数进行局部修改时，也会容易使得开发者难以聚焦到一个特定功能代码上。反之，如果把代码尽可能按照“一定的规则”分散开来，例如每个代码文件长度不超过 500 行，那会使得维护和更新变得更容易，因此我们倡导开发者持续的针对代码长度进行重构，目前软件里有不少超过 >500 行的程序。 二、测试脚本 此脚本功能： # --------------1. 计算总代码行数-------------- # --------------2. 统计每个文件夹内 GlobalV 和 GlobalC 出现的次数-------------- # --------------3. 输出行数大于 500 行的文件路径及其行数-------------- import os def count_lines_of_code(file_path): \"\"\" 计算文件的代码行数 :param file_path: 文件路径 :return: 代码行数 \"\"\" with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as file: lines = file.readlines() return len(lines) def count_lines_in_folder(folder_path): \"\"\" 计算文件夹中所有文件的代码行数 :param folder_path: 文件夹路径 :return: 总代码行数 \"\"\" total_lines = 0 for root, dirs, files in os.walk(folder_path): for file in files: # 构建文件的完整路径 file_path = os.path.join(root, file) # 跳过非文本文件 if not file_path.endswith((\".cpp\", \".c\", \".h\")): continue # 计算文件的代码行数并累加到总行数中 lines = count_lines_of_code(file_path) total_lines += lines return total_lines # ---------------------------------------------- def count_globals_in_file(file_path): \"\"\" 统计一个文件中出现了多少次 GlobalV 和 GlobalC :param file_path: 文件路径 :return: {'globalv_count': GlobalV 出现的次数, 'globalc_count': GlobalC 出现的次数} \"\"\" globalv_count = 0 globalc_count = 0 try: with open(file_path, 'r', encoding='utf-8', errors='ignore') as file: content = file.read() globalv_count = content.count('GlobalV') globalc_count = content.count('GlobalC') except FileNotFoundError: print(f\"File not found: {file_path}\") except Exception as e: print(f\"An error occurred: {e}\") return {'globalv_count': globalv_count, 'globalc_count': globalc_count} def count_globals_in_folder(folder_path): \"\"\" 统计一个文件夹中出现了多少次 GlobalV 和 GlobalC :param folder_path: 文件夹路径 :return: {'globalv_count': GlobalV 出现的总次数, 'globalc_count': GlobalC 出现的总次数} \"\"\" globalv_count = 0 globalc_count = 0 for root, dirs, files in os.walk(folder_path): for file in files: # 构建文件的完整路径 file_path = os.path.join(root, file) # 跳过非文本文件 if not file_path.endswith(('.cpp', '.c', '.h')): continue # 调用 count_globals_in_file 函数，统计文件中 GlobalV 和 GlobalC 的出现次数 file_counts = count_globals_in_file(file_path) globalv_count += file_counts['globalv_count'] globalc_count += file_counts['globalc_count'] return {'globalv_count': globalv_count, 'globalc_count': globalc_count} def count_globals_in_subfolders(main_folder_path): \"\"\" 统计一个文件夹内所有子文件夹的 GlobalV 和 GlobalC 出现次数 :param main_folder_path: 主文件夹路径 :return: 字典，包含每个子文件夹的 GlobalV 和 GlobalC 出现次数 \"\"\" subfolder_counts = {} for root, dirs, files in os.walk(main_folder_path): for folder in dirs: folder_path = os.path.join(root, folder) # 调用 count_globals_in_folder 函数，统计子文件夹中 GlobalV 和 GlobalC 的出现次数 folder_counts = count_globals_in_folder(folder_path) subfolder_counts[folder] = folder_counts return subfolder_counts def print_folder_tree_with_counts(folder_path, indent=\"\"): \"\"\" 输出文件夹树结构，同时统计每个文件夹内出现了多少次 GlobalV 和 GlobalC :param folder_path: 文件夹路径 :param indent: 缩进字符串，用于表示层级关系 \"\"\" folder_info = count_globals_in_folder(folder_path) # 输出当前文件夹的名称 print(indent + \"|-- \" + os.path.basename(folder_path)) # 输出当前文件夹内的 GlobalV 和 GlobalC 出现次数 print(indent + f\" GlobalV 出现了 {folder_info['globalv_count']} 次\") print(indent + f\" GlobalC 出现了 {folder_info['globalc_count']} 次\") # 获取文件夹中的所有项目（文件和子文件夹） items = os.listdir(folder_path) for item in items: # 构建项目的完整路径 item_path = os.path.join(folder_path, item) # 检查项目是否是文件夹 if os.path.isdir(item_path): # 递归调用，打印子文件夹的树结构 print_folder_tree_with_counts(item_path, indent + \" \") # 指定文件夹路径 folder_path = \"./abacus-develop/source\" # --------------1. 计算代码行数-------------- # 调用函数，获取文件夹中所有文件的代码行数 total_lines = count_lines_in_folder(folder_path) print(f\"整个文件夹中所有文件总共有 {total_lines} 行代码。\") # --------------2. 统计 GlobalV 和 GlobalC 出现的次数-------------- # 调用函数，输出文件夹树和统计 GlobalV 和 GlobalC 的出现次数 print_folder_tree_with_counts(folder_path) # --------------3. 出文件夹内行数大于 500 行的文件及其行数-------------- def count_lines(file_path): \"\"\" 统计一个文件的行数 :param file_path: 文件路径 :return: 文件的行数 \"\"\" try: with open(file_path, 'r', encoding='utf-8', errors='ignore') as file: lines = file.readlines() return len(lines) except FileNotFoundError: print(f\"File not found: {file_path}\") return 0 except Exception as e: print(f\"An error occurred: {e}\") return 0 def count_lines_in_folder(folder_path): \"\"\" 统计一个文件夹内行数大于 500 行的文件 :param folder_path: 文件夹路径 :return: 文件路径及其行数的字典 \"\"\" files_over_500_lines = {} for root, dirs, files in os.walk(folder_path): for file in files: # 构建文件的完整路径 file_path = os.path.join(root, file) # 跳过非文本文件 if not file_path.endswith(('.txt', '.py', '.java', '.cpp', '.c', '.html', '.css', '.js')): continue # 调用 count_lines 函数，统计文件的行数 lines_count = count_lines(file_path) # 检查行数是否大于 500 if lines_count > 500: files_over_500_lines[file_path] = lines_count return files_over_500_lines # 输入文件夹路径 folder_path = \"./abacus-develop/source\" # 调用函数，获取文件夹内行数大于 500 行的文件 files_over_500_lines = count_lines_in_folder(folder_path) # 出文件夹内行数大于 500 行的文件及其行数 if files_over_500_lines: print(\"行数大于 500 行的文件:\") for file_path, lines_count in files_over_500_lines.items(): print(f\"{file_path}: {lines_count} 行\") else: print(\"文件夹内没有行数大于 500 行的文件。\") import subprocess def get_git_info(folder_path): try: # 获取最新提交的版本号 commit_version = subprocess.check_output(['git', 'rev-parse', 'HEAD'], cwd=folder_path, text=True).strip() # 获取最新提交的时间 commit_time = subprocess.check_output(['git', 'show', '-s', '--format=%ci', 'HEAD'], cwd=folder_path, text=True).strip() # 获取最近一次标签的名称 latest_tag = subprocess.check_output(['git', 'describe', '--tags', '--abbrev=0'], cwd=folder_path, text=True).strip() return commit_version, commit_time, latest_tag except subprocess.CalledProcessError as e: print(f\"Error: {e}\") return None, None, None from datetime import datetime import pytz # 设置时区为东八区（北京时间） beijing_timezone = pytz.timezone('Asia/Shanghai') # 获取当前时间，并设置时区为北京时间 current_datetime_utc = datetime.utcnow() current_datetime_beijing = current_datetime_utc.replace(tzinfo=pytz.utc).astimezone(beijing_timezone) # 格式化输出 formatted_datetime_beijing = current_datetime_beijing.strftime(\"%Y-%m-%d %H:%M:%S\") print(\"东八区时间（北京时间）:\", formatted_datetime_beijing) # 指定要检查的文件夹路径 folder_path = './abacus-develop' # 获取Git信息 commit_version, commit_time, latest_tag = get_git_info(folder_path) if commit_version: print(f\"The latest commit version in the repository is: {commit_version}\") print(f\"The commit time is: {commit_time}\") print(f\"The latest tag is: {latest_tag}\") else: print(\"Failed to retrieve Git information.\") 三、检测结果 整个文件夹中所有文件总共有 324219 行代码。 |-- source GlobalV 出现了 7972 次 GlobalC 出现了 3504 次 |-- module_relax GlobalV 出现了 289 次 GlobalC 出现了 207 次 |-- relax_old GlobalV 出现了 244 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 130 次 GlobalC 出现了 0 次 |-- relax_new GlobalV 出现了 19 次 GlobalC 出现了 200 次 |-- test GlobalV 出现了 3 次 GlobalC 出现了 117 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_io GlobalV 出现了 2022 次 GlobalC 出现了 501 次 |-- test GlobalV 出现了 262 次 GlobalC 出现了 28 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test_serial GlobalV 出现了 20 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_basis GlobalV 出现了 101 次 GlobalC 出现了 7 次 |-- module_pw GlobalV 出现了 3 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 3 次 GlobalC 出现了 0 次 |-- test_serial GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_ao GlobalV 出现了 72 次 GlobalC 出现了 7 次 |-- test GlobalV 出现了 23 次 GlobalC 出现了 0 次 |-- GaAs GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- orb_obj GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- lcao_H2O GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- 1_Documents GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- doxygen GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- sphinx GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- source GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_nao GlobalV 出现了 26 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 17 次 GlobalC 出现了 0 次 |-- module_hamilt_pw GlobalV 出现了 704 次 GlobalC 出现了 620 次 |-- hamilt_pwdft GlobalV 出现了 492 次 GlobalC 出现了 527 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 6 次 GlobalC 出现了 36 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- operator_pw GlobalV 出现了 1 次 GlobalC 出现了 1 次 |-- hamilt_stodft GlobalV 出现了 124 次 GlobalC 出现了 93 次 |-- hamilt_ofdft GlobalV 出现了 88 次 GlobalC 出现了 0 次 |-- module_md GlobalV 出现了 57 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 50 次 GlobalC 出现了 0 次 |-- module_psi GlobalV 出现了 150 次 GlobalC 出现了 24 次 |-- test GlobalV 出现了 48 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 1 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_ri GlobalV 出现了 167 次 GlobalC 出现了 121 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test_code GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_elecstate GlobalV 出现了 896 次 GlobalC 出现了 88 次 |-- module_dm GlobalV 出现了 2 次 GlobalC 出现了 1 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 1 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 337 次 GlobalC 出现了 11 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test_mpi GlobalV 出现了 20 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 2 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- potentials GlobalV 出现了 73 次 GlobalC 出现了 11 次 |-- module_charge GlobalV 出现了 234 次 GlobalC 出现了 32 次 |-- module_cell GlobalV 出现了 885 次 GlobalC 出现了 129 次 |-- test GlobalV 出现了 290 次 GlobalC 出现了 100 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test_pw GlobalV 出现了 8 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_neighbor GlobalV 出现了 75 次 GlobalC 出现了 2 次 |-- test GlobalV 出现了 26 次 GlobalC 出现了 0 次 |-- module_paw GlobalV 出现了 54 次 GlobalC 出现了 2 次 |-- test GlobalV 出现了 3 次 GlobalC 出现了 0 次 |-- module_symmetry GlobalV 出现了 100 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_base GlobalV 出现了 488 次 GlobalC 出现了 1 次 |-- test GlobalV 出现了 74 次 GlobalC 出现了 0 次 |-- data GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test_parallel GlobalV 出现了 153 次 GlobalC 出现了 0 次 |-- module_container GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- ATen GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- ops GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- core GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- base GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- third_party GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- backward-cpp GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- macros GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- utils GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- core GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- libm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 1 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_mixing GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_esolver GlobalV 出现了 775 次 GlobalC 出现了 326 次 |-- test GlobalV 出现了 4 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_hamilt_lcao GlobalV 出现了 1088 次 GlobalC 出现了 1257 次 |-- module_tddft GlobalV 出现了 92 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_deepks GlobalV 出现了 186 次 GlobalC 出现了 2 次 |-- test GlobalV 出现了 67 次 GlobalC 出现了 0 次 |-- doxygen GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- sphinx GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- source GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- hamilt_lcaodft GlobalV 出现了 478 次 GlobalC 出现了 897 次 |-- operator_lcao GlobalV 出现了 8 次 GlobalC 出现了 48 次 |-- test GlobalV 出现了 1 次 GlobalC 出现了 0 次 |-- module_gint GlobalV 出现了 178 次 GlobalC 出现了 213 次 |-- module_hcontainer GlobalV 出现了 6 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 6 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_dftu GlobalV 出现了 142 次 GlobalC 出现了 145 次 |-- module_deltaspin GlobalV 出现了 6 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 4 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_hsolver GlobalV 出现了 154 次 GlobalC 出现了 23 次 |-- test GlobalV 出现了 35 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- genelpa GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_hamilt_general GlobalV 出现了 167 次 GlobalC 出现了 196 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_ewald GlobalV 出现了 19 次 GlobalC 出现了 6 次 |-- module_vdw GlobalV 出现了 2 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 2 次 GlobalC 出现了 0 次 |-- module_xc GlobalV 出现了 80 次 GlobalC 出现了 19 次 |-- test GlobalV 出现了 20 次 GlobalC 出现了 5 次 |-- module_surchem GlobalV 出现了 66 次 GlobalC 出现了 171 次 |-- test GlobalV 出现了 53 次 GlobalC 出现了 137 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 行数大于 500 行的文件: ./abacus-develop/source/module_relax/relax_old/ions_move_cg.cpp: 501 行 ./abacus-develop/source/module_relax/relax_old/test/ions_move_cg_test.cpp: 556 行 ./abacus-develop/source/module_relax/relax_old/test/lattice_change_basic_test.cpp: 526 行 ./abacus-develop/source/module_relax/relax_old/test/lattice_change_cg_test.cpp: 534 行 ./abacus-develop/source/module_relax/relax_new/relax.cpp: 616 行 ./abacus-develop/source/module_io/to_wannier90.cpp: 2091 行 ./abacus-develop/source/module_io/parameter_pool.cpp: 1633 行 ./abacus-develop/source/module_io/write_HS_sparse.cpp: 961 行 ./abacus-develop/source/module_io/numerical_basis.cpp: 792 行 ./abacus-develop/source/module_io/unk_overlap_lcao.cpp: 853 行 ./abacus-develop/source/module_io/cal_r_overlap_R.cpp: 645 行 ./abacus-develop/source/module_io/input.cpp: 4041 行 ./abacus-develop/source/module_io/berryphase.cpp: 717 行 ./abacus-develop/source/module_io/write_dos_lcao.cpp: 669 行 ./abacus-develop/source/module_io/input_conv.cpp: 748 行 ./abacus-develop/source/module_io/winput.cpp: 721 行 ./abacus-develop/source/module_io/write_HS.cpp: 1363 行 ./abacus-develop/source/module_io/test/input_conv_test.cpp: 540 行 ./abacus-develop/source/module_io/test/bessel_basis_test.cpp: 561 行 ./abacus-develop/source/module_io/test/write_input_test.cpp: 916 行 ./abacus-develop/source/module_io/test/input_test.cpp: 1691 行 ./abacus-develop/source/module_basis/module_pw/fft.cpp: 789 行 ./abacus-develop/source/module_basis/module_ao/ORB_atomic_lm.cpp: 772 行 ./abacus-develop/source/module_basis/module_ao/ORB_table_alpha.cpp: 550 行 ./abacus-develop/source/module_basis/module_ao/ORB_gen_tables.cpp: 1015 行 ./abacus-develop/source/module_basis/module_ao/ORB_table_phi.cpp: 880 行 ./abacus-develop/source/module_basis/module_ao/ORB_read.cpp: 589 行 ./abacus-develop/source/module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp: 755 行 ./abacus-develop/source/module_basis/module_ao/test/ORB_atomic_lm_test.cpp: 886 行 ./abacus-develop/source/module_basis/module_nao/beta_radials.cpp: 761 行 ./abacus-develop/source/module_basis/module_nao/test/gaunt.txt: 7242 行 ./abacus-develop/source/module_basis/module_nao/test/numerical_radial_test.cpp: 549 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp: 1841 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp: 717 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp: 755 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/forces.cpp: 1100 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/wavefunc.cpp: 739 行 ./abacus-develop/source/module_hamilt_pw/hamilt_stodft/sto_iter.cpp: 638 行 ./abacus-develop/source/module_md/nhchain.cpp: 873 行 ./abacus-develop/source/module_psi/psi_initializer_nao.cpp: 522 行 ./abacus-develop/source/module_psi/test/psi_initializer_unit_test.cpp: 635 行 ./abacus-develop/source/module_psi/kernels/device.cpp: 654 行 ./abacus-develop/source/module_ri/exx_lip.cpp: 950 行 ./abacus-develop/source/module_elecstate/elecstate_pw.cpp: 527 行 ./abacus-develop/source/module_elecstate/occupy.cpp: 1007 行 ./abacus-develop/source/module_elecstate/module_dm/density_matrix.cpp: 823 行 ./abacus-develop/source/module_elecstate/test/potential_new_test.cpp: 646 行 ./abacus-develop/source/module_elecstate/test/elecstate_base_test.cpp: 699 行 ./abacus-develop/source/module_elecstate/test/support/WAVEFUNC1.txt: 4231 行 ./abacus-develop/source/module_elecstate/module_charge/charge.cpp: 748 行 ./abacus-develop/source/module_elecstate/module_charge/charge_mixing.cpp: 729 行 ./abacus-develop/source/module_cell/read_pp_upf201.cpp: 908 行 ./abacus-develop/source/module_cell/read_atoms.cpp: 1290 行 ./abacus-develop/source/module_cell/unitcell.cpp: 1764 行 ./abacus-develop/source/module_cell/klist.cpp: 1429 行 ./abacus-develop/source/module_cell/test/unitcell_test.cpp: 1573 行 ./abacus-develop/source/module_cell/test/klist_test.cpp: 778 行 ./abacus-develop/source/module_cell/test/read_pp_test.cpp: 705 行 ./abacus-develop/source/module_cell/module_neighbor/sltk_atom_input.cpp: 672 行 ./abacus-develop/source/module_cell/module_neighbor/sltk_grid.cpp: 1109 行 ./abacus-develop/source/module_cell/module_paw/paw_cell.cpp: 668 行 ./abacus-develop/source/module_cell/module_paw/paw_cell_libpaw.cpp: 719 行 ./abacus-develop/source/module_cell/module_symmetry/symmetry.cpp: 2118 行 ./abacus-develop/source/module_cell/module_symmetry/symmetry_basic.cpp: 1166 行 ./abacus-develop/source/module_base/math_sphbes.cpp: 810 行 ./abacus-develop/source/module_base/spherical_bessel_transformer.cpp: 546 行 ./abacus-develop/source/module_base/math_ylmreal.cpp: 706 行 ./abacus-develop/source/module_base/mcd.c: 884 行 ./abacus-develop/source/module_base/ylm.cpp: 1884 行 ./abacus-develop/source/module_base/opt_DCsrch.cpp: 644 行 ./abacus-develop/source/module_base/test/math_chebyshev_test.cpp: 536 行 ./abacus-develop/source/module_base/test/complexmatrix_test.cpp: 588 行 ./abacus-develop/source/module_base/test/global_function_test.cpp: 794 行 ./abacus-develop/source/module_base/test/complexarray_test.cpp: 511 行 ./abacus-develop/source/module_base/test/cubic_spline_test.cpp: 1468 行 ./abacus-develop/source/module_base/test/vector3_test.cpp: 749 行 ./abacus-develop/source/module_base/test/math_ylmreal_test.cpp: 513 行 ./abacus-develop/source/module_base/test_parallel/parallel_reduce_test.cpp: 558 行 ./abacus-develop/source/module_base/module_container/test/tensor_test.cpp: 536 行 ./abacus-develop/source/module_base/module_container/ATen/ops/einsum_op.cpp: 1048 行 ./abacus-develop/source/module_base/libm/sincos.cpp: 1262 行 ./abacus-develop/source/module_esolver/esolver_ks.cpp: 576 行 ./abacus-develop/source/module_esolver/esolver_ks_pw.cpp: 1129 行 ./abacus-develop/source/module_esolver/esolver_ks_lcao_tddft.cpp: 621 行 ./abacus-develop/source/module_esolver/esolver_ks_lcao_elec.cpp: 627 行 ./abacus-develop/source/module_esolver/esolver_ks_lcao.cpp: 970 行 ./abacus-develop/source/module_esolver/esolver_sdft_pw_tool.cpp: 1332 行 ./abacus-develop/source/module_esolver/esolver_of.cpp: 1380 行 ./abacus-develop/source/module_hamilt_lcao/module_tddft/propagator.cpp: 616 行 ./abacus-develop/source/module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp: 824 行 ./abacus-develop/source/module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp: 769 行 ./abacus-develop/source/module_hamilt_lcao/module_deepks/test/klist_1.cpp: 604 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/FORCE_k.cpp: 1248 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/wavefunc_in_pw.cpp: 695 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp: 1003 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp: 1096 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp: 539 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp: 889 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/LCAO_hamilt.cpp: 930 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp: 507 行 ./abacus-develop/source/module_hamilt_lcao/module_gint/gint.cpp: 585 行 ./abacus-develop/source/module_hamilt_lcao/module_gint/gint_k_pvpr.cpp: 702 行 ./abacus-develop/source/module_hamilt_lcao/module_gint/gint_k_sparse1.cpp: 529 行 ./abacus-develop/source/module_hamilt_lcao/module_gint/gint_tools.cpp: 1376 行 ./abacus-develop/source/module_hamilt_lcao/module_gint/grid_technique.cpp: 529 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/hcontainer.cpp: 728 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/transfer.cpp: 671 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/func_transfer.cpp: 663 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/atom_pair.cpp: 737 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/test/test_hcontainer_complex.cpp: 577 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/test/test_hcontainer.cpp: 674 行 ./abacus-develop/source/module_hamilt_lcao/module_deltaspin/spin_constrain.cpp: 547 行 ./abacus-develop/source/module_hsolver/diago_david.cpp: 1080 行 ./abacus-develop/source/module_hsolver/diago_cg.cpp: 641 行 ./abacus-develop/source/module_hsolver/kernels/test/math_kernel_test.cpp: 736 行 ./abacus-develop/source/module_hamilt_general/module_vdw/vdwd3.cpp: 1435 行 ./abacus-develop/source/module_hamilt_general/module_vdw/vdwd3_parameters_tab.cpp: 33131 行 ./abacus-develop/source/module_hamilt_general/module_vdw/test/vdw_test.cpp: 610 行 ./abacus-develop/source/module_hamilt_general/module_xc/xc_functional_gradcorr.cpp: 725 行 ./abacus-develop/source/module_hamilt_general/module_xc/xc_functional_vxc.cpp: 776 行 ./abacus-develop/source/module_hamilt_general/module_xc/test/test_xc2.cpp: 519 行 ./abacus-develop/source/module_hamilt_general/module_xc/test/test_xc.cpp: 922 行 东八区时间（北京时间）: 2023-11-20 11:28:29 The latest commit version in the repository is: baccbe3356f81c9b349582e4b02fd723d77a50d9 The commit time is: 2023-11-17 22:22:05 +0800 The latest tag is: v3.4.2 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-11-20 15:16:51 "},"develop-test1.html":{"url":"develop-test1.html","title":"ABACUS 中的测试（一）：测试的重要性","keywords":"","body":"ABACUS 中的测试（一）：测试的重要性 作者：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/12/07 一、背景 1. 问题 在 ABACUS 软件的发展过程中，测试极其重要。 以下情景纯属虚构，但至少在 ABACUS 软件开发过程中时有发生： 故事一：小明是程序 ABC 的积极开发者，有一天他发现已经写好的新功能在之前版本可用，但在最新版本不能用了！这件事情影响了小明目前的进度，只好停下来维修。小明找上级说明事情缘由之后，开始找程序错误的原因，经过一段时间查找（可能是几个小时，可能是几天），发现是另一位开发者小强同学在几日前提交的代码中破坏了这个功能。小明比较郁闷，因为代码发生错误责任不在自己，是别人把它改错的。小强也是有责任心的开发者，收到反馈后尽快修改了错误。但从此小明总是担心自己的代码被破坏，而小强写代码时也更加谨小慎微。 故事二：有热心用户小风在用户群里提问，为什么照着文档跑程序，程序就崩了。有责任心的开发者小云看到后回答：“我自己的电脑上能跑，但为什么你的电脑上跑不了？”经过小云地毯式搜索验证（可能是几个小时，可能是几天）找到原因：“因为编译环境不一样导致的，某段语法在另外一个编译器上会得到错误的结果”。小云提出的解决方案是建议小风换个环境，或者等小云忙完手头的事情有空之后，再帮忙解决一下这个问题。小风有点不满这个程序带来的体验，遂决定弃坑。小云也被这额外多出来的工作量搞得身心俱疲。 以上第一个故事来自开发者和开发者，第二个故事来自开发者和用户，小明、小强、小风、小云的故事，就是 ABACUS 软件过去几年不断会上演的故事。当以上事情反复出现时，我们知道不管是开发者还是用户，这些老师同学从自身的角度出发都是积极参与的，那我们不禁要问： 到底是哪里出了问题？ 需要采取什么样的方法？ 是否可以防止这样的事情再发生？ 2. 结果 如果我们软件最终的目标还是希望这个功能能够被更多人更好的使用，而不是仅仅用来申请软件专利，发文章之类的，那么出现功能 bug 后，会产生两个结果。 第一：这些 bug 的发现和修复本质上是要消耗开发者大量时间的！例如小明和小云都花了很久时间去找问题，这个过程他（她）几乎得不到任何其他人的帮助！能否快速找到取决于开发者自身对算法和 bug 的认识程度。有人把复杂程序的排错认为更多是一门艺术而不是技术，“程序高手”可能会更快的定位到问题，但我们认为真正的程序高手可以避免出现这类问题。 第二：如果不采取更为有效的方式，那么修完一次还有可能要修第二次，例如小明的代码又被另一位开发者大强破坏了，或者小云修完之后发现另一位用户大风在别的环境又出错了。这件事情会反复出现，而开发者的热情会在这个过程被一点点磨光。 没有意识到以上两点的开发者（包括所谓的“程序高手”）建议阅读到这里自己静下来想一想。 3. 方案 究竟什么方法才是避免以上问题的最根本方法？答案是两个字，测试！只是如果直接说出来可能大家并不会意识到这个方法本身的重要性。 以上发生的结果其实是软件开发的流程出了问题，当一个软件庞大到一定程度时，许多代码互相影响之后，出 bug 是难免的，发生上面故事里的情节也是时有发生的。 所以，如果时间反正是要消耗的，我们是否可以劝说开发者意识到：在开发到“某个阶段”（什么阶段？）就让新功能的测试尽可能充分和完整，就可以减少将来“维修代码“带来的时间消耗？实际上简单的修复并不能做到一劳永逸。更糟糕的是，经过一段时间，开发者可能对当初开发算法的记忆也变淡了，因此整体修复的效果不见得会比当初做完整来得更好。经年累月的结果是，持续修复这些问题所花的精力和资源实际上是累加到原来功能开发的时间和资源成本上，这样不知不觉整个软件团队实际上需要为整个项目付出更高的时间甚至经济成本买单，而对任何软件资助方来讲，要解释清楚这个成本，解释成本是极高的（就是解释不清楚，理由也不充分）。所以 ABACUS 团队对所有开发者的建议是，尽可能的把写测试的工作乃至为了让代码减少错误所需的重构工作放入功能开发周期内执行，让一个软件的 feature 满足：功能正确、代码规范、框架合理，注释清楚、测试完整。 最后回答的一点是：什么时候添加测试合适？一般来讲，开发者能把一个新功能实现正确是可以带来巨大成就感的一件事情，是能类比打仗的时候把己方旗帜插上对方阵地山头的高光时刻。所以这个时候让开发者加测试一般是不愿意的，或者觉得没必要。在学术界，往往结果对了之后可以进入写文章投稿的阶段，至于程序的维护在发文章前面往往是排后面的。等到文章发完之后，马上又会进入一个新的课题。以上原因也导致一般在高校课题组很难维持发展一个大型软件。 所以添加测试合适的时间，我们对 ABACUS 开发者的建议是：开发完新功能之后，如果确认这个功能会有用，请添加测试，并且在这个整理代码的过程中把上一段话的最后四点补充做完： 代码规范，程序的各种命名、注释、代码行的格式等应符合程序开发的命名标准和编码规范。 框架合理，如果不合理就请重构代码，趁你的记忆还鲜活。 注释清楚，如果有些代码可能别人看不懂，不要吝惜你的语言，用英文注释！ 测试完整，最后把相应主要的功能函数加上测试，具体怎么加，请看这个系列的文档。 二、论测试的重要性 程序测试是软件开发过程中至关重要的一个环节，是一种实际输出和预期结果之间的客观对比，它保证软件能以预期的形式运行，得到预期的结果。软件测试试图最大程度上防范潜在的缺陷和错误。通过对软件进行有效测试，可以降低项目风险，确保软件功能在各种条件下的正确性，提高软件功能的稳定性，甚至提前发现和修复问题，节省软件的维护成本。 ABACUS 作为开源的密度泛函理论项目，涉及到的不同背景开发人员较多，每位开发人员负责开发代码的一部分功能。为了确保软件功能在持续更新的代码中保持正确，我们建议开发人员掌握测试的方法，对每个功能函数编写相应的测试函数。新添加的测试函数会被 ABACUS 加入整个软件的测试流程，一旦有新提交的代码对该功能产生破坏，代码审核人员和代码开发者可以快速得到反馈，从而避免错误或者漏洞的产生而留下隐患。 三、测试要满足的条件 我们从 https://google.github.io/googletest/primer.html 网页上把关于一个好的测试的标准进行了中文翻译，列举如下： 测试需要独立，以及可以被重复。调试一个因其他测试的结果而成功或失败的测试是很麻烦的。GoogleTest 通过在不同对象上运行每一个测试来隔离测试。当一个测试失败时，GoogleTest 允许你单独运行这个测试，以便快速调试。 测试需要被好好的组织起来，并且能够反映出被测试代码的结构。GoogleTest 将相关测试归组到测试套件中，这些测试套件可以共享数据和子程序。这种常见模式很容易识别，并且使得测试易于维护。当人们切换项目并开始工作在一个新的代码库上时，这种一致性尤其有帮助。 测试应该具有可移植性和可复用性。谷歌拥有大量与平台无关的代码；它的测试也应当是平台中立的。GoogleTest 能够在不同的操作系统上工作，配合不同的编译器，无论是否支持异常处理，因此 GoogleTest 的测试可以适用于多种配置。 当测试失败了，该测试应该尽可能多的提供错误信息。 GoogleTest 在遇到第一个测试失败时不会停止。相反，它只会停止当前的测试并继续执行下一个测试。你还可以设置测试以报告非致命性失败，此后当前测试将继续进行。因此，你可以在单次编辑-编译循环中检测并修复多个错误。 测试框架应该使编写测试的人摆脱杂务，让他们专注于测试内容。GoogleTest 会自动记录所有定义的测试，并且不需要用户列举它们就可以运行这些测试。 测试需要能快速运行。使用 GoogleTest，您可以跨测试重用共享资源，并且只需为设置/拆卸支付一次费用，而无需使测试相互依赖。 四、测试种类 测试里的几个术语解释： 黑盒测试：又叫功能测试，关注被测软件的功能实现，而不是内部逻辑。在测试中，被测对象的内部结构，运作情况对测试人员是不可见的。 白盒测试：称为结构测试或者透明盒测试，要求测试人员对软件的内部结构和工作原理（例如 ABACUS 的密度泛函理论算法）有深入的了解，也迫使测试人员去思考算法的实现过程，可以检测代码的每条分支和路径，揭示隐藏在代码中的错误。单元测试属于白盒测试的范畴。白盒测试可以识别难以在黑盒测试里发现的问题。缺点是昂贵，且花时间。 灰盒测试：混合着白盒和黑盒的测试方法。最常见的灰盒测试是集成测试。 单元测试：单元测试（Unit Test）是对软件最基本组成单元（例如函数）进行的测试。这里的单元就是指软件设计的最小单位。单元测试分为两个步骤： 人工静态检查法：是测试的第一步，通过不执行代码而检查程序的逻辑算法，尽可能的发现问题。例如检查算法的前后逻辑，函数和类的接口是否合理，包括输入参数个数、顺序、类型，以及返回值类型是否一致；检查全局变量和全局类的使用是否必须；检查所用语法是否在不同编译器下通用。 动态执行跟踪法：执行测试案例来看是否有预期故障，包括预期的错误提示都可以编写单元测试来覆盖。 测试出问题分下列四种情况： 错误：可以执行，结果错误。 缺陷：可以执行，但是实际的结果和期望的结果有偏差。 失效：执行功能的能力丧失。 故障：不能执行，可能由错误，缺陷和失效导致。 ABACUS 中主要包含单元测试和完整性测试两种。其中单元测试确保每个单元函数的正确性，完整性测试确保一些功能能够顺利跑完，得到正确的结果。 五、测试案例 测试案例（Test Case）是为检测程序的某个程序功能而准备的一组数据，包含测试的输入以及预期结果。随着测试案例数量的增加，开发者对产品质量和测试流程也就越有信心。除了对功能正确性的验证之外，建议也要考虑对程序不能运行，甚至错误的情况进行测试案例的编写，使得所有程序的行为都被测试所覆盖。 另外，我们积极的建议所有 ABACUS 的开发者采用“测试驱动开发”的方法来开发程序新功能，就是一个新功能在编写代码之前，就考虑清楚并且准备好测试案例来验证程序满足需求。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-07 15:05:24 "},"develop-test2.html":{"url":"develop-test2.html","title":"ABACUS 中的测试（二）：测试工具 gtest","keywords":"","body":"ABACUS 中的测试（二）：测试工具 gtest 作者：彭星亮，邮箱：pxlppq007@163.com；赵天琦，邮箱：zhaotq13@tsinghua.org.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/12/08 一、gtest 简介 手动编写和执行测试用例可能会非常繁琐和耗时，因此我们在 C++ 程序的开发流程中引入了 Google Test 框架（以下简称 gtest）。gtest 是一个由 Google 开发的 C++ 单元测试框架。它为开发者提供了一套强大的工具和功能，用于编写、组织和运行测试用例。通过使用宏和断言，开发者可以较为轻松地定义测试用例和验证预期结果。 测试套件（test suite）的设计可以反映程序的结构。测试套件内的测试所共享的数据可放入同一个文件夹。一个测试项目可以包括多个测试套件。 gtest 的使用需要定义好对应的 TEST，TEST_F，TEST_P 宏来自动运行算例，结果的对比主要通过使用 ASSERT_* 或者 EXPECT_* 宏来进行。 gtest 框架支持 C++11 及以上的 C++ 标准，支持 Linux、MacOS、Windows 等众多平台，支持 gcc 5.0+、clang5.0+、MSVC2015+ 编译器，支持 Bazel 以及 cmake 构建工具。 关于 gtest 的 User's Guide 的链接如下: GoogleTest User’s Guide | GoogleTest gtest 的 github 仓库地址：google/googletest: GoogleTest - Google Testing and Mocking Framework (github.com) 二、gtest 的安装及测试 在 Linux 环境下安装 gtest 的第一种方法：apt 安装（如果无效，请尝试后面的方法） sudo apt install googletest 第二种方法：从 github 下载并安装（需要有管理员 sudo 权限）： git clone [https://github.com/google/googletest](https://github.com.cnpmjs.org/google/googletest) cd googletest cmake . make sudo make install 使用如下的算例验证是否安装成功 //test.cpp #include \"gtest/gtest.h\" TEST(TestInt,TestTrue) { EXPECT_TRUE(2 == 2); } /* int main(int argc, char** argv) { testing::InitGoogleTest(&argc, argv); return RUN_ALL_TESTS(); } */ 以上算例可以不包含 main 函数（也可以写 main 函数），只要以下编译的时候加上 -lgtest_main，之后执行 g++ test.cpp -lgtest -lpthread -lgtest_main ./a.out 注意，如果 g++ 编译器版本太旧，需要添加参数 -std=c++14 才能编译通过。 运行之后，预期程序输出如下 三、gtest 的断言 gtest里有一个核心概念叫“断言”，是对预期程序是否正确的一种“逻辑判断”，并且返回判断结果。 gtest 提供了一个测试断言指令集。每个断言是宏，类似于函数调用。 测试断言会产生测试结果，分成 3 种情况： success（成功，代表测试通过） nonfatal failure（失败，非致命失败，程序不中断） fatal failure（失败，致命失败，程序中断）。 gtest 中有 2 种断言类型：ASSERT_* 和 EXPECT_*。 ASSERT_* 版本的断言失败会产生致命失败，并结束当前函数。 EXPECT_* 版本的断言产生非致命失败，不会终止当前函数。推荐使用 EXPECT_* 断言。 注意：当某个断言不通过时，开发者可以自定义输出的故障消息，只需在函数后面添加相应的 C++ 流运算符 四、gtest 的宏 1. TEST 宏 在测试文件里，可以直接定义 TEST（类似一个 C++ 的函数）来编写测试代码，TEST 是一个 gtest 里被经常使用的宏（TEST 的英文介绍），是 gtest 里最基本的组成单元，其代码格式如下： TEST(TestSuiteName, TestName) { ... statements ... } TestSuiteName是该 TestSuite 的名字，可以自己起名 TestName是在这个 TestSuite 里具体的测试的名字，可以自己起名 注意 TestSuiteName 和 TestName 的命名中不要包含“_”，当然如果你加了编译也不会报错，但是会有隐患，推荐使用首字母大写来分隔单词 在 TEST 宏里面定义的 statements 是要被执行的测试代码。 下面是一个例子： //test2.cpp #include #include TEST(TestABACUS,TestTrue) { using namespace std; EXPECT_TRUE(2 == 2) 编译后的运行结果是 可以看到，这里提示第二个测试是失败的。 2. TEST_F 宏 在测试中如果要对相同的数据进行不同的判断（不同的判断指不同的测试）时，可以使用 TEST_F 宏，此时需要在测试代码里额外定义一个类（从给定的基类派生出一个类），我们管它叫做 test fixture 类（Test Fixtures 英文介绍），这个类的作用是包含所要测试的数据，并且可以传到不同的 TEST_F“函数”里，下面例子是 TEST_F 宏使用的格式。 TEST_F(TestFixtureName, TestName) { ... statements ... } 第一个参数 TestFixtureName 是需要定义的类的名字，定义这个类的时候，它需继承自 ::testing::Test 类。第二个参数 TestName 是自己命名的任务名。 创建一个 test`` ``fixture 类需要注意的是： 从 testing::Test 派生一个类。在类的开始部分使用 protected:，因为我们希望在子类中访问固件成员。 在类里，定义你想使用的任何数据成员，这样这个类可以在多个 TEST_F 宏里使用。 在编写单元测试时，经常需要对测试中使用的对象进行初始化。这可以通过编写默认构造函数或 SetUp() 函数来实现。SetUp() 函数是 Google Test 测试框架中用于在每个测试用例开始前准备对象的一个函数。也可以用 C++ 的关键字 override 来标明覆盖了基类的同名虚函数 SetUp()。 如果需要，还可以在 Test Fixtures 类里面定义 TearDown() 函数，把分配的临时空间给释放掉。 如果需要，还可以在 Test Fixtures 类里面定义其它成员函数，以方便不同的 TEST_F 调用。 //test3.cpp #include #include class Positive : public testing::Test { protected: int a; int b; void SetUp() override { a = 1; b = -1; } }; TEST_F(Positive,TestA) { using namespace std; EXPECT_TRUE(a>0) 0) 编译执行，结果如下 五、gtest 的 mock 功能 在某些测试里，需要中间调用别的类（例如类 A）才能够完成接下去的程序运行，但是类 A 太复杂，不适合定义在类里，这个时候可以造一个假类（MockA）来模仿真正的类 A 的操作，这个过程就叫做 mock！但是要注意的是：虽然 mock 某个对象可以帮助你在测试中消除不必要的依赖关系，使它们变得快速和可靠，但在 C++ 中手动去写 mock 代码是困难的。因此，Google Test 提供了 gmock，它是 gtest 的一个库，一个辅助框架，用来创建 mock 类，使用时需要 include \"gmock/gmock.h\"。 实际写测试的时候，mock 的思想可以借鉴。然而实际上，目前 ABACUS 的大部分需要 mock 的地方都可以通过自己写一个空的类来实现替代功能，因此如果有同学老师感兴趣这部分内容，可以参考 Goolge Test 官网教程。这部分就不多做介绍了。 六、gtest 里的全局环境设置 在 Google Test 中，全局环境（Global Environment）是指一个测试程序的全局设置，它允许在整个测试程序开始前和结束后执行一些特定的代码。例如，全局测试资源的初始化和清理，全局状态的设置，运行只需要一次性执行的代码。 全局环境设置方法：可以通过继承 testing::Environment 类并实现 SetUp() 和 TearDown() 方法来使用全局环境。 下面是一个例子： // test environment #include #include class MyEnvironment : public ::testing::Environment { public: void SetUp() override { std::cout 编译后运行结果，可以看到测试开始前打印出的“ABACUS，Made in China”信息，以及测试结束后打印出来的“I clean up.”信息，分别对应的是上面的 MyEnvironment 类里 SetUp 和 TearDown 函数所执行的内容。 七、常用 ASSERT 和 EXPECT 语句 常用的 ASSERT 和 EXPECT 这两大类断言的相关语句如下，开发者可以在处理需要的数据类型时候灵活运用，例如布尔类型、二元值、字符串、浮点数等数据类型（附上这些语句的原文链接：Assertions Reference | GoogleTest)。 致命断言 非致命断言 通过条件 布尔类型 ASSERT_TRUE(condition) EXPECT_TRUE(condition) condition 为 true ASSERT_FALSE(condition) EXPECT_FALSE(condition) condition 为 false 二元值 ASSERT_EQ(val1, val2) EXPECT_EQ(val1, val2) val1 = val2 ASSERT_NE(val1, val2) EXPECT_NE(val1, val2) val1 != val2 ASSERT_LT(val1, val2) EXPECT_LT(val1, val2) val1 ASSERT_LE(val1, val2) EXPECT_LE(val1, val2) val1 ASSERT_GT(val1, val2) EXPECT_GT(val1, val2) val1 > val2 ASSERT_GE(val1, val2) EXPECT_GE(val1, val2) val1 >= val2 字符串(C string) ASSERT_STREQ(val1, val2) EXPECT_STREQ(val1, val2) val1 == val2 ASSERT_STRNE(val1, val2) EXPECT_STRNE(val1, val2) val1 != val2 ASSERT_STRCASEEQ(val1, val2) EXPECT_STRCASEEQ(val1, val2) 忽略大小写 val1 == val2 ASSERT_STRCASENE(val1, val2) EXPECT_STRCASENE(val1, val2) 忽略大小写 val1 != val2 浮点型 ASSERT_FLOAT_EQ(val1, val2) EXPECT_FLOAT_EQ(val1, val2) float 型 val1 和 val2 相等 ASSERT_DOUBLE_EQ(val1, val2) EXPECT_DOUBLE_EQ(val1, val2) double 型 val1 和 val2 相等 ASSERT_NEAR(val1, val2,abs_error) EXPECT_NEAR(val1, val2,abs_error) val1 和 val2 差的绝对值不大于 abs_error 异常检查 ASSERT_THROW(statement, exception_type); EXPECT_THROW(statement, exception_type); statement throws an exception of the given type ASSERT_ANY_THROW(statement); EXPECT_ANY_THROW(statement); statement throws an exception of any type ASSERT_NO_THROW(statement); EXPECT_NO_THROW(statement); statement doesn't throw any exception 死亡断言 Death Assertions ASSERT_DEATH(statement,matcher); EXPECT_DEATH(statement, matcher); statement 引起程序非 0 退出，并产生的 stderr 与 matcher 一致。matcher 为可设为“”表示任意的 stderr 都成立。 ASSERT_EXIT(statement,predict,matcher); EXPECT_EXIT(statement, predict, matcher); statement 产生的结束时的返回值与 predict 一致，产生的 stderr 与 matcher 一致 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-12-08 14:44:33 "},"develop-path1.html":{"url":"develop-path1.html","title":"Introduction to ABACUS: Path to PW calculation - Part 1","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 1 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 1 &#x1F4A1;写在前面 作为 SIAB（Systematically Improvable Atomic orbital Basis, link）数值原子轨道生成程序的数据上游，本系列文档将首先从平面波基组/SCF（Self-Consistent Field，即自洽场迭代）讲起，将《从 SIAB 到 ABACUS》的讲述延续下去，之后再探索 SIAB 的下游，即涉及 NAOs 的 LCAO method（basis_type = 'lcao'）。 本系列文档的预期受众：新晋 ABACUS 开发者 &#x1F3A8;写在前面 实际上，在 2023 Q1（第一季度），ABACUS 发布了面向团队内部的代码编程规范，因此在代码阅读过程中可能遇到各种还没有被更正的变量命名，请格外注意。代码的缩进与其他格式则由 2023.5 发布的新 Pull request 标准，采用clang-format-16标准执行。 &#x1F4C3;写在前面 本系列文档内容的组织原则为： 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 首先通过位于根目录下的 main.cpp 进入程序： int main(int argc, char **argv) { ModuleIO::parse_args(argc,argv); Parallel_Global::read_mpi_parameters(argc,argv); Driver DD; DD.init(); // Driver 在本文档中，我们跳过所有关于记录时间的函数，只关心最主要的部分。在 main.cpp 中定义的 Driver 类对象 DD，其类成员函数 Driver::init() 在根目录 driver.cpp 下被定义： void Driver::init() { this->reading(); this->atomic_world(); INPUT.close_log(); } Driver::reading() 首先从 Driver::init() 来到其所调用第一个函数 Driver::reading()： void Driver::reading(void) { INPUT.Init(GlobalV::global_in_card); .... } Input 便发现 Driver 类可能有数据成员 INPUT，查看头文件 driver.h，并没有关于 Input INPUT 的声明，并且 Driver 类实际上并无任何数据成员，因此需要从 #include 中寻找： #include \"driver.h\" #include \"module_io/input.h\" #include \"module_io/input_conv.h\" #include \"module_hamilt_pw/hamilt_pwdft/global.h\" #include \"module_base/memory.h\" #include \"module_base/timer.h\" #include \"module_esolver/esolver.h\" #include \"module_io/cal_test.h\" #include \"module_io/print_info.h\" #include \"module_io/winput.h\" 追踪到 input.h，发现外部变量声明： extern Input INPUT; 在 input.cpp 中则有 Input INPUT; 这一 INPUT 的变量定义。类似地，我们在更多的被 include 文件中寻找 extern 变量，这些变量都会在程序运行一开始被定义，直到程序结束时才会销毁： // module_hamilt_pw/hamilt_pwdft/global.h namespace GlobalC { // line 284 extern pseudopot_cell_vnl ppcell; // line 292 extern UnitCell ucell; extern Parallel_Grid Pgrid; extern Parallel_Kpoints Pkpoints; extern Restart restart; // Peize Lin add 2020.04.04 即是说例如对于 UnitCell ucell，其数据成员全部会在程序运行一开始被创建。 Input::init() Driver 首先调用的 INPUT 的成员函数 Input::Init()（ABACUS 中很多类都具有 init() 函数，但存在函数名无法体现其功能的问题，可能会在后续工作中修改），该成员函数定义在 source/module_io/input.cpp，同时也发现了 Input INPUT 的定义： //source/module_io/input.cpp Input INPUT; void Input::Init(const std::string &fn) { this->Default(); bool success = this->Read(fn); this->Default_2(); #ifdef __MPI Parallel_Common::bcast_bool(input_error); Parallel_Common::bcast_bool(success); Bcast(); #endif bool out_dir = false; if(!out_app_flag && (out_mat_hs2 || out_mat_r || out_mat_t || out_mat_dh)) out_dir = true; ModuleBase::Global_File::make_dir_out(this->suffix, this->calculation, out_dir, GlobalV::MY_RANK, this->mdp.md_restart, this->out_alllog); Check(); } Input::init() 唯一参数为 fn，实际被传入参数 GlobalV::global_in_card（这里 GlobalV 代表 Global Variables，是全局变量的意思，一般用全大写的变量名，C++ 区分字母大小写，Fortran 不区分）。这一参数在 module_base/global_variable.cpp 中被定义，类似的文件还有 stru_file 和 global_kpoint_card： //source/module_base/global_variable.cpp std::string global_in_card = \"INPUT\"; std::string stru_file = \"STRU\"; std::string global_kpoint_card = \"KPT\"; 因此 Input::init() 函数实际上将要打开 INPUT 文件。 Input::Default() Input::init() 调用 Input::Default() 函数， //source/module_io/input.cpp void Input::Init(const std::string &fn) { this->Default(); // Read(fn); this->Default_2(); .... 其定义为： //source/module_io/input.cpp void Input::Default(void) { suffix = \"ABACUS\"; stru_file = \"\"; // xiaohui modify 2015-02-01 kpoint_file = \"\"; // xiaohui modify 2015-02-01 pseudo_dir = \"\"; orbital_dir = \"\"; // liuyu add 2021-08-14 read_file_dir = \"auto\"; wannier_card = \"none\"; latname = \"none\"; calculation = \"scf\"; esolver_type = \"ksdft\"; pseudo_rcut = 15.0; // qianrui add this parameter 2021-5 pseudo_mesh = false; // qianrui add this pararmeter ntype = 0; ... 即 Input::Default() 函数为所有变量赋默认值。当前所展示的这些变量实际上均为 Input 类的数据成员，而非 GlobalV 等全局类。全局类的存在是为了避免出现巨大的形参表。在 Input::Default() 之后，调用 Input::Read() 函数读取 INPUT 文件，并确定是否读取成功。 Input::Read() //source/module_io/input.cpp void Input::Init(const std::string &fn) { this->Default(); bool success = this->Read(fn); // Default_2(); .... Input::Read() 函数： //source/module_io/input.cpp bool Input::Read(const std::string &fn) { .... std::ifstream ifs(fn.c_str(), std::ios::in); ifs.clear(); ifs.seekg(0); char word[80]; char word1[80]; .... while (ifs.good()) { ifs >> word1; if (ifs.eof()) break; strtolower(word1, word); if (strcmp(\"suffix\", word) == 0) read_value(ifs, suffix); else if (strcmp(\"stru_file\", word) == 0) read_value(ifs, stru_file); ... &#x1F527;重构思考 Input::read() 函数的功能为读取 INPUT 文件（创建 ifstream 类对象 ifs），之后使用对 N 行参数定义，使用最多 N 次 if 判断 strcmp 的方法进行参数读取，若参数读取成功，被传递给 Input 类的数据成员（覆盖）。 由于我们现在考察针对 PW（Plane Wave，平面波）的相关功能，因此额外注意包含 pw 的相关字段： bool Input::Read(const std::string &fn) { .... if (basis_type == \"pw\" && gamma_only != 0) // pengfei Li add 2015-1-31 { gamma_only = 0; GlobalV::ofs_running 这里 \"gamma_only\" 不为 0，是因为目前 ABACUS 不支持只计算单个布里渊区 k=（0，0，0）（通常称为 Gamma 点）的算法，只用 Gamma 点的算法可以把平面波基矢量减少一半，但目前 ABACUS 还不支持。 Input::Default_2() //source/module_io/input.cpp void Input::Init(const std::string &fn) { this->Default(); bool success = this->Read(fn); this->Default_2(); // 接下来 Input 类成员调用其 Input::Default_2() 方法： //source/module_io/input.cpp void Input::Default_2(void) // jiyy add 2019-08-04 { if (GlobalV::MY_RANK != 0) return; if (vdw_s6 == \"default\") { if (vdw_method == \"d2\") vdw_s6 = \"0.75\"; else if (vdw_method == \"d3_0\" || vdw_method == \"d3_bj\") vdw_s6 = \"1.0\"; } if (vdw_s8 == \"default\") { if (vdw_method == \"d3_0\") vdw_s8 = \"0.722\"; else if (vdw_method == \"d3_bj\") vdw_s8 = \"0.7875\"; } ... if (calculation == \"scf\") { if (mem_saver == 1) { mem_saver = 0; ModuleBase::GlobalFunc::AUTO_SET(\"mem_saver\", \"0\"); } this->relax_nmax = 1; } else if (calculation == \"relax\") { if (mem_saver == 1) { mem_saver = 0; ModuleBase::GlobalFunc::AUTO_SET(\"mem_saver\", \"0\"); } cal_force = 1; if (!this->relax_nmax) this->relax_nmax = 50; } 在首先设置 Default，即参数默认值后再覆盖，然后再调用 Default_2 的好处是可以再次覆盖某些参数的实际取值，并根据 case-by-case 地，调整某些值。实际上，此处暗示了一些已经成熟的参数搭配方式，即是说根据特征的任务，实际上都有其一套参数赋值方案。 void Input::Default_2(void) // jiyy add 2019-08-04 { .... if (basis_type == \"pw\") { if (ks_solver == \"default\") { ks_solver = \"cg\"; ModuleBase::GlobalFunc::AUTO_SET(\"ks_solver\", \"cg\"); } else if (ks_solver == \"cg\") { GlobalV::ofs_warning 考虑到一般而言第一性原理软件分支功能众多，且对于 ABACUS，其功能的扩展需要入侵性修改众多代码，行数过多，易扩展性有待提高（关于程序的易扩展性设计方案，见之后单独文档）。因此以下我们首先假设情景为使用 PW 进行 SCF 计算。 ModuleBase::Global_File::make_dir_out() //source/module_io/input.cpp .... void Input::Init(const std::string &fn) { .... bool out_dir = false; if(!out_app_flag && (out_mat_hs2 || out_mat_r || out_mat_t || out_mat_dh)) out_dir = true; ModuleBase::Global_File::make_dir_out(this->suffix, this->calculation, out_dir, GlobalV::MY_RANK, this->mdp.md_restart, this->out_alllog); // 区别于之前的 Input 类中成员函数，这里突然调用的函数变成了 ModuleBase 类。这个函数的功能为读取 INPUT 文件之后，在 INPUT 中定义的 out_dir、suffix 等，在这里可以拼合成为完整路径，并使用 C++/Linux interface 来根据具体任务创建不同的具体输出路径（jump to the code）： //source/module_io/input.cpp void ModuleBase::Global_File::make_dir_out(const std::string &suffix, const std::string &calculation, const bool &out_dir, const int rank, const bool &restart, const bool out_alllog) { std::string prefix ; #ifdef __EPM #ifdef __MPI prefix = \"OUT_EPM_MPI.\"; #else prefix = \"OUT_EPM.\"; #endif #else prefix = \"OUT.\"; #endif GlobalV::global_out_dir = prefix + suffix + \"/\"; GlobalV::global_stru_dir = GlobalV::global_out_dir + \"STRU/\"; GlobalV::global_matrix_dir = GlobalV::global_out_dir + \"matrix/\"; #ifdef __MPI MPI_Barrier(MPI_COMM_WORLD); #endif int make_dir = 0; std::string command0 = \"test -d \" + GlobalV::global_out_dir + \" || mkdir \" + GlobalV::global_out_dir; if(calculation == \"md\") { int make_dir_stru = 0; std::string command1 = \"test -d \" + GlobalV::global_stru_dir + \" || mkdir \" + GlobalV::global_stru_dir; ....} if((out_dir) && calculation == \"md\") { int make_dir_matrix = 0; std::string command1 = \"test -d \" + GlobalV::global_matrix_dir + \" || mkdir \" + GlobalV::global_matrix_dir; times = 0; ....} std::stringstream ss,ss1; if(out_alllog) { ss &#x1F527;重构思考 这部分定义出了相当多的输出文件和目录，然而多个输出文件往往不利于对 ABACUS 新上手使用者，容易在繁多的文件中迷路，因此可以考虑重新设计输出信息。 最后调用 Input::check() 函数对某些参数进行核对。 Input_Conv 返回 Driver::reading()，来到 Input_Conv::Convert(). void Driver::reading(void) { INPUT.Init(GlobalV::global_in_card); Input_Conv::Convert(); // Input_Conv::Convert() 这个函数实现了从 Input 类对象的数据成员到 GlobalV 和 GlobalC 等全局变量集合的转换。相当于从 Input 到 GlobalV 和 GlobalC，以及其他直接的类的参数上载： 其他内容见 ABACUS 第一版开发手册（02. IO 模块，目前暂为飞书内部文档）： void Input_Conv::Convert(void) { .... else if (INPUT.stru_file != \"\") { GlobalV::stru_file = INPUT.stru_file; } GlobalV::global_wannier_card = INPUT.wannier_card; if (INPUT.kpoint_file != \"\") GlobalV::global_kpoint_card = INPUT.kpoint_file; .... GlobalC::ucell.setup(INPUT.latname, INPUT.ntype, INPUT.lmaxmax, INPUT.init_vel, INPUT.fixed_axes); if (INPUT.calculation == \"relax\" || INPUT.calculation == \"cell-relax\") { if (INPUT.fixed_ibrav && !INPUT.relax_new) { ModuleBase::WARNING_QUIT(\"Input_Conv\", \"fixed_ibrav only available for relax_new = 1\"); } .... GlobalV::fixed_atoms = INPUT.fixed_atoms; } for(int i=0;i &#x1F527;重构思考 对模拟体系的完全与分层次描述，是每个模拟软件包的核心设计要求。INPUT 的数据成员不仅录入到 GlobalV, GlobalC，还录入到 BFGS_Basic, Ions_Move_Basic 等类中，或许部分扰乱了这种层级。 winput &#x1F4DD;开发者旁注 本部分内容已经过时，在未来发行版中将会完全弃用 void Driver::reading(void) { INPUT.Init(GlobalV::global_in_card); Input_Conv::Convert(); .... winput::Init(GlobalV::global_wannier_card); // 接下来来到 Wannier 函数计算部分，调用 Init()函数，传入参数为 wannier 文件的具体路径（winput 相关的这部分功能目前已经基本不使用，相关读入参数都在 INPUT 里面实现，后续版本会把这部分代码删除）。 在 Input::Default() 中，该量被设置为 \"none\"，在 Input::Read() 中，该量对应于关键词 wannier_card 被读入。实际上，一般将 wannier_card 赋值为 INPUTw。 winput::Init() void winput::Init(const std::string &fn) { Default(); Read(fn); Check(); #ifdef __MPI Bcast(); #endif } winput::Default() wannier_card 部分同样具有 Default() 函数， void winput::Default() { //======================== // part1 : control //======================== target = \"test\"; wlmr_dir = \"./\"; rcut = 10; before_iter = false; after_iter = false; begin_stop_flag = false; end_flag = false; ... } 其中各变量均为 winput 中数据成员，类型附加 static 关键词。 winput::Read() &#x1F527;重构思考 此处仍然使用 if(strcmp()) 方法读入输入文件中参数 void winput::Read(const std::string &fn) { if(GlobalV::MY_RANK!=0) return; std::ifstream ifs(fn.c_str(), std::ios::in); ifs.clear(); ifs.seekg(0); char word[80]; .... while (ifs.good()) { ifs >> word; for(auto &i : word) { i = tolower(i); } //parameters for users if (strcmp(\"target\", word) == 0) {read_value(ifs, target);} else if (strcmp(\"trial\", word) == 0) {read_value(ifs, trial);} ... winput::check() 则同样地，进行一些检查。 变量分发举例：winput::Bcast()和 Input::Bcast() 和 Input 一样，winput::Bcast() 对读入所有参数进行节点间广播： #include \"module_base/parallel_common.h\" #ifdef __MPI void winput::Bcast(void) { Parallel_Common::bcast_string( target ); Parallel_Common::bcast_bool( before_iter ); ... Parallel_Common::bcast_double( rcut ); ... Parallel_Common::bcast_string( wlmr_dir ); ... Parallel_Common::bcast_int( imp_pao ); ... 同理在 Input::Bcast() 中： #ifdef __MPI void Input::Bcast() { Parallel_Common::bcast_string(suffix); Parallel_Common::bcast_string(stru_file); // xiaohui modify 2015-02-01 Parallel_Common::bcast_string(pseudo_dir); // Parallel_Common::bcast_string(pseudo_type); // mohan add 2013-05-20 (xiaohui add 2013-06-23) Parallel_Common::bcast_string(orbital_dir); Parallel_Common::bcast_string(kpoint_file); // xiaohui modify 2015-02-01 Parallel_Common::bcast_string(wannier_card); ... Prallel_Common 属于 module_base 中 parallel_common.h 中声明的自建命名空间，其声明大致如下： namespace Parallel_Common { void bcast_complex_double( std::complex *object, const int n); ... void bcast_complex_double( std::complex &object); ... } 举例其中 Prallel_Common::bcast_int()： void Parallel_Common::bcast_int(int &object) { MPI_Bcast(&object, 1, MPI_INT, 0, MPI_COMM_WORLD); } 其中 MPI_Bcast() 为 MPI 内部函数，其参数表中分别传入了需广播数据的内存地址、、数据类型，以及。 ▶ 离开 winput，回到 source/driver.cpp Driver::reading()，只剩下如下内容： std::stringstream ss1; ss1 Driver::atomic_world() Driver::atomic_world() 函数中执行的内容其实只有 Driver::driver_run() 函数： void Driver::atomic_world(void) { this->driver_run(); } 不要忘记我们已经完成 Driver::reading() 函数内容，到达 Driver::atomic_world()。这一点从本文档设置的分级目录中也可以看得到。 void Driver::init() { this->reading(); this->atomic_world(); // Driver::driver_run() esolver ESolver 是 ABACUS 内部工作流的驱动，根据当前模拟任务所属阶段，按顺序调用各个所需模块， &#x1F4DD;开发者旁注 原则上讲，ESolver 不应当含有 Device 和 FPTYPE 模板参数，未来将会被舍弃 Driver::driver_run() 定义在 source/driver.cpp 文件中，是实际驱动 ABACUS 各模块的驱动（driver）。首先创建 ESolver 类指针，并利用 ModuleESolver::init_esolver() 将其初始化： void Driver::driver_run() { ModuleESolver::ESolver *p_esolver = nullptr; ModuleESolver::init_esolver(p_esolver); ... ModuleESolver::init_esolver() 我们目前只关注 pw 基的方法，首先调用 ModuleESolver::determine_type() 函数，读取具体在 INPUT 中定义的计算类型（GlobalV::ESOLVER_TYPE 和 GlobalV::BASIS_TYPE）： void init_esolver(ESolver*& p_esolver) { std::string esolver_type = determine_type(); 作为回溯，GlobalV::ESOLVER 和 GlobalV::BASIS_TYPE 的赋值在 module_io/input_conv.cpp： GlobalV::BASIS_TYPE = INPUT.basis_type; // line 320 GlobalV::ESOLVER_TYPE = INPUT.esolver_type; // line 273 其在 INPUT 中关键词为（module_io/input.cpp）： else if (strcmp(\"basis_type\", word) == 0) //line 843 { read_value(ifs, basis_type); ... else if (strcmp(\"esolver_type\", word) == 0)// line 685 { read_value(ifs, esolver_type); } ... ModuleESolver::determine_type() 接下来根据 basis_type 和 esolver_type 两关键词对 esolver_type 进行赋值（❗ 此处已经出现 esolver 一词多义，在 ModuleESolver 域中实际上是 [能量计算方法]_[基组](_[任务类型]） 的合并）： std::string determine_type() { std::string esolver_type = \"none\"; if (GlobalV::BASIS_TYPE == \"pw\") { if(GlobalV::ESOLVER_TYPE == \"sdft\") esolver_type = \"sdft_pw\"; else if(GlobalV::ESOLVER_TYPE == \"ofdft\") esolver_type = \"ofdft\"; else if(GlobalV::ESOLVER_TYPE == \"ksdft\") esolver_type = \"ksdft_pw\"; } else if (GlobalV::BASIS_TYPE == \"lcao_in_pw\") { #ifdef __LCAO if(GlobalV::ESOLVER_TYPE == \"sdft\") esolver_type = \"sdft_pw\"; else if(GlobalV::ESOLVER_TYPE == \"ksdft\") esolver_type = \"ksdft_pw\"; #endif } else if (GlobalV::BASIS_TYPE == \"lcao\") { #ifdef __LCAO if(GlobalV::ESOLVER_TYPE == \"tddft\") esolver_type = \"ksdft_lcao_tddft\"; else if(GlobalV::ESOLVER_TYPE == \"ksdft\") esolver_type = \"ksdft_lcao\"; #endif } else { if(GlobalV::ESOLVER_TYPE == \"lj\") esolver_type = \"lj_pot\"; else if(GlobalV::ESOLVER_TYPE == \"dp\") esolver_type = \"dp_pot\"; else if(esolver_type == \"none\") { ModuleBase::WARNING_QUIT(\"ESolver\", \"No such esolver_type combined with basis_type\"); } } return esolver_type; } 得到 esolver_type，返回 ModuleESolver::init_esolver()，之后根据其由 esolver_type 定义的不同内容，为创建的 p_esolver 指定对应类型的内存空间，此时注意到各类 ESolver_* 实际上都是对 ModuleESolver::ESolver 父类的继承，而 p_esolver 为父类指针： if (esolver_type == \"ksdft_pw\") { #if ((defined __CUDA) || (defined __ROCM)) if (GlobalV::device_flag == \"gpu\") { if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); return; } #endif if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); } #ifdef __LCAO else if (esolver_type == \"ksdft_lcao\") p_esolver = new ESolver_KS_LCAO(); else if (esolver_type == \"ksdft_lcao_tddft\") p_esolver = new ESolver_KS_LCAO_TDDFT(); #endif else if (esolver_type == \"sdft_pw\") p_esolver = new ESolver_SDFT_PW(); else if (esolver_type == \"ofdft\") p_esolver = new ESolver_OF(); else if (esolver_type == \"lj_pot\") p_esolver = new ESolver_LJ(); else if (esolver_type == \"dp_pot\") p_esolver = new ESolver_DP(INPUT.mdp.pot_file); } 各种 esolver 的继承关系如下所示。例如 ESolver_KS_PW 和 ESolver_KS_LCAO，均公有继承自 ESolver_KS： // module_solver/esolver_ks_pw.h namespace ModuleESolver { template class ESolver_KS_PW : public ESolver_KS // module_esolver/esolver_ks_lcao.h namespace ModuleESolver { class ESolver_KS_LCAO : public ESolver_KS ESolver_KS 则公有继承自 ESolver_FP： // module_solver/esolver_ks.h namespace ModuleESolver { template class ESolver_KS : public ESolver_FP ESolver_FP 公有继承自 ESolver： // module_solver/esolver_fp.h namespace ModuleESolver { class ESolver_FP : public ESolver 而 p_esolver 为 ModuleESolver::ESolver 类指针，自然可以如此赋值。其他关于各种 ESolver 的层级关系，可见第一版开发者手册的 09. ESolver 模块 （目前暂为飞书内部文档) 。接下来我们假设 esolver_type == \"ksdft_pw\"，则我们需要关注前面已经展示过的（module_esolver/esolver.cpp ModuleESolver::init_esolver(): line 93）： if (esolver_type == \"ksdft_pw\") { #if ((defined __CUDA) || (defined __ROCM)) if (GlobalV::device_flag == \"gpu\") { if (GlobalV::precision_flag == \"single\") { p_esolver = new ESolver_KS_PW(); } else { p_esolver = new ESolver_KS_PW(); } return; } #endif if (GlobalV::precision_flag == \"single\") { p_esolver = new ESolver_KS_PW(); } else { p_esolver = new ESolver_KS_PW(); } } 我们首先只关注 p_esolver = new ESolver_KS_PW();，即精度为浮点双精度，使用 cpu 为计算设备的情况。 不难发现，关于 ESolver_KS_PW 类的具体实现，同时使用数据类型和设备作为模板： namespace ModuleESolver { template ESolver_KS_PW::ESolver_KS_PW() { this->classname = \"ESolver_KS_PW\"; this->basisname = \"PW\"; this->device = psi::device::get_device_type(this->ctx); #if ((defined __CUDA) || (defined __ROCM)) if (this->device == psi::GpuDevice) { hsolver::createBLAShandle(); hsolver::createCUSOLVERhandle(); } #endif } 其代入的设备类型 psi::DEVICE_CPU，是 psi 命名空间的变量。 至此，ModuleESolver::init_esolver() 退出，p_esolver 有值 &ESolver_KS_PW()，来到设置模拟体系的结构部分。 附录 配置便捷高效 Vscode C++ 工作环境（Windows） 在大型程序的代码阅读过程中，往往遇到变量和函数数量大，源文件、头文件不计其数的情况。因此高效、快速寻找当前感兴趣变量/函数/类/命名空间的上下游就十分重要。Vscode 是由 Microsoft 开发的集成开发环境，具有轻量、灵活、功能健全、插件开发者活跃、程序迭代较快等优点，因此推荐 Vscode 作为 ABACUS 的编辑器。 Vscode 下载链接：Download Visual Studio Code - Mac, Linux, Windows 在选择“是否把 vscode 添加到 PATH 环境变量”时，如无特殊需求，建议选择“是”，同时在选择“是否将 vscode 添加到右键菜单”时，选择“是”。 相关资料：新人教程文档（目前暂为飞书内部文档) Vscode C++ 插件 配置完成 Vscode 后，在其扩展商店搜索“C/C++”，即可顺利一并安装三个插件，用于 C++ 程序的开发工作。 Mingw64 GNU compilers 为了让 C++ 开发环境变得更加智能，需要联合编译器，让编译器寻找变量、函数、类、命名空间等之间跨文件的引用关系。为了实现这一点，见 Microsoft Vscode 关于 C++ 编译器的官方配置教程： Get Started with C++ and Mingw-w64 in Visual Studio Code 之后在 vscode setting.json 添加 “C_Cpp.default.compilerPath” 值，且可选 \"C_Cpp.default.cppStandard\" 值，对于 ABACUS，通常选择 \"c++11\" 或 \"c++14\"。 Mingw64 fftw3, mpi and googletest libraries 为了能够尽可能多避免 vscode 浏览 ABACUS 代码过程中报错，可以选择安装发行在 msys2 系列平台上的 fftw3 和 msmpi 库： fftw3: https://packages.msys2.org/package/mingw-w64-i686-fftw?repo=mingw32 msmpi: https://packages.msys2.org/package/mingw-w64-x86_64-msmpi Googletest: https://packages.msys2.org/base/mingw-w64-googletest 其他常见的库也可以在 https://packages.msys2.org/进行搜索后，复制命令在 msys2 prompt 进行下载安装 CMake ABACUS 使用 CMake 便捷编译，因此也可以在本地配置 CMake。 下载、安装 CMake：Download | CMake 将安装好的 CMake 一并放入 PATH 环境变量，之后在 Vscode setting.json 中添加 “cmake.generator”，以及 \"cmake.cmakePath\" 值，设置 \"cmake.additionalCompilerSearchDirs\"。 将本地 Vscode 连通 Bohrium 平台进行高效编译开发 Bohrium 平台提供在线云计算服务，对于 ABACUS 开发工作，可以在其服务器上进行软件编译。 Bohrium 网站： 之后请 follow 单元测试环境搭建教程：新人教程文档 （目前暂为飞书内部文档) 变量、函数、类的声明、定义、调用快捷跳转 对准想要查看其声明、定义和调用（引用）的量，点击鼠标右键： 若跳转到声明（.h 文件），发现其声明旁未添加注释，或注释并非 Doxygen 格式，可以在 Vscode 扩展应用商店下载 Doxygen 插件后，发现菜单出现“生成 Doxygen 注释”，将注释内容复写为 Doxygen 格式。 相关材料：自动文档 Doxygen 使用说明 （目前暂为飞书内部文档) 给你的开发加点魔法：Github.copilot vscode 部署 首先进行 Github 学生认证：https://education.github.com/pack 然后在 vscode 上 Extension 界面下载 Github copilot 插件。vscode 通过最下角 Github 账号登录来验证 Github.copilot 的使用权限（完成学生认证后自动拥有 Github.copilot 的使用权限）。 系列链接 上篇：从 SIAB 到 ABACUS（一）：准备工作（施工中 &#x1F6A7;） 下篇：Introduction to ABACUS: Path to PW calculation - Part 2 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-04 22:18:52 "},"develop-path2.html":{"url":"develop-path2.html","title":"Introduction to ABACUS: Path to PW calculation - Part 2","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 2 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 2 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 承接上篇对 INPUT 文件的解析，本篇延续 ABACUS workflow，介绍和 STRU 文件中信息读取紧密相关的 UnitCell 类。 Driver Driver::atomic_world() Driver::driver_run() ucell 在 driver_run.cpp 中直接调用了 GlobalC 的数据成员 UnitCell ucell 的成员函数 UnitCell::setup_cell()， // driver_run.cpp void Driver::driver_run() { .... GlobalC::ucell.setup_cell(GlobalV::stru_file, GlobalV::ofs_running); 则自然回忆回溯在何时 ucell 被声明、定义、初始化的（尽管在上篇中已经明确提到）。寻得在 module_hamilt_pw/hamilt_pwdft/global.h 中，有关于 ucell 为 extern 变量的声明： namespace GlobalC { extern UnitCell ucell; 同时在 module_hamilt_pw/hamilt_pwdft/global.cpp 中，有其定义： namespace GlobalC { UnitCell ucell; 则对于需要使用到 UnitCell 对象 ucell 的场合，只需要包含 module_hamilt_pw/hamilt_pwdft/global.h 头文件即可，其中 ucell 为全局类（将来可能会把这个全局类去掉，换成指定范围内可以使用的模块）。 UnitCell:setup_cell() ucell 的一些数据成员在 Input_Conv::Convert() 函数中赋值： // line 266 GlobalC::ucell.setup(INPUT.latname, INPUT.ntype, INPUT.lmaxmax, INPUT.init_vel, INPUT.fixed_axes); GlobalC::UnitCell::setup() 函数除了导入前四个量外，根据最后一个传入参数，控制 UnitCell ucell 中晶格矢量的约束条件 lc[0], lc[1] 和 lc[2]。可见 lc[i] 实际上可能会出现在晶格矢量的 rescale factor 里，额外使用 lc[i] 作为变化量的 factor，若为 0，固定，则该晶格矢量在程序运行中不会有变化。 void UnitCell::setup(const std::string& latname_in, const int& ntype_in, const int& lmaxmax_in, const bool& init_vel_in, const std::string& fixed_axes_in) { this->latName = latname_in; this->ntype = ntype_in; this->lmaxmax = lmaxmax_in; this->init_vel = init_vel_in; if (fixed_axes_in == \"None\") this->lc[0] = 1; this->lc[1] = 1; this->lc[2] = 1; else if (fixed_axes_in == \"volume\") { this->lc[0] = 1; this->lc[1] = 1; this->lc[2] = 1; if (!GlobalV::relax_new) { ModuleBase::WARNING_QUIT( \"Input\", \"there are bugs in the old implementation; set relax_new to be 1 for fixed_volume relaxation\"); } } else if (fixed_axes_in == \"shape\") { if (!GlobalV::relax_new) { ModuleBase::WARNING_QUIT(\"Input\", \"set relax_new to be 1 for fixed_shape relaxation\"); } this->lc[0] = 1; this->lc[1] = 1; this->lc[2] = 1; } else if (fixed_axes_in == \"a\") this->lc[0] = 0; this->lc[1] = 1; this->lc[2] = 1; ....//omit b and c else if (fixed_axes_in == \"ab\") this->lc[0] = 0; this->lc[1] = 0; this->lc[2] = 1; ....//omit without b and c else if (fixed_axes_in == \"abc\") this->lc[0] = 0; this->lc[1] = 0; this->lc[2] = 0; else ....//warning and quit return; } 回到 Driver::driver_run() 的 line 33（Link），其所调用 UnitCell::setup_cell() 函数首先根据前文提到在 Input_Conv::Convert() 中调用的 UnitCell::setup() 函数，确定了 UnitCell::ntype，因此使用 ntype 重新为 magnet.start_magnetization 分配内存空间。UnitCell::magnet 成员变量在 module_cell/unitcell.h 中被声明。类似的还有 ucell.atoms 等。 void UnitCell::setup_cell(const std::string &fn, std::ofstream &log) { delete[] magnet.start_magnetization; magnet.start_magnetization = new double[this->ntype]; this->atoms = new Atom[this->ntype]; this->set_atom_flag = true; class UnitCell { public: Magnetism magnet; // magnetism Yu Liu 2021-07-03 在 Driver::driver_run() 中调用 UnitCell::setup_cell() 时，传入参数 GlobalV::stru_file 和文件流对象 GlobalV::ofs_running，前者具有默认值 STRU（Introduction to ABACUS: Path to PW calculation - Part 1 Input::init()），后者同样具有默认值，见 global_file.cpp。 STRU file parse 若 STRU 文件存在，读取其中内容： const int error = this->read_atom_species(ifa, log); ok2 = this->read_atom_positions(ifa, log, GlobalV::ofs_warning); ifa 即为打开 STRU 的 ifstream 文件流对象，log 为 GlobalV:ofs_running 变量。 Basic structure of STRU file: examples 在开始阅读 STRU 文件解析程序部分之前，首先展示几种 STRU 文件样例： // with latname = 'fcc' in INPUT file ATOMIC_SPECIES Si 28.00 Si_ONCV_PBE-1.0.upf // label; mass; pseudo_file NUMERICAL_ORBITAL Si_gga_8au_60Ry_2s2p1d.orb //numerical_orbital_file LATTICE_CONSTANT 10.2 // lattice scaling factor (Bohr) ATOMIC_POSITIONS Direct //Cartesian or Direct coordinate. Si // Element type 0.0 // magnetism 2 // number of atoms 0.00 0.00 0.00 0 0 0//the position of atoms and other parameter specify by key word 0.25 0.25 0.25 1 1 1 // with latname = 'none' or do not set it in INPUT file ATOMIC_SPECIES Si 28.00 Si_ONCV_PBE-1.0.upf upf201 // label; mass; pseudo_file; pseudo_type NUMERICAL_ORBITAL Si_gga_8au_60Ry_2s2p1d.orb //numerical_orbital_file LATTICE_CONSTANT 10.2 // lattice scaling factor (Bohr) LATTICE_VECTORS 0.5 0.5 0.0 // latvec1 0.5 0.0 0.5 // latvec2 0.0 0.5 0.5 // latvec3 ATOMIC_POSITIONS Direct //Cartesian or Direct coordinate. Si // Element type 0.0 // magnetism(Be careful: value 1.0 refers to 1.0 bohr mag, but not fully spin up !!!) 2 // number of atoms 0.00 0.00 0.00 0 0 0 0.25 0.25 0.25 1 1 1 ATOMIC_SPECIES Pt 195.08 Pt_ONCV_PBE-1.0.upf LATTICE_CONSTANT 1.8897259886 // 1 Angstrom, but unit required is Bohr, so it is this value LATTICE_VECTORS 8.4359998703 0.0000000000 0.0000000000 -4.2179999352 7.3057901940 0.0000000000 0.0000000000 0.0000000000 25.1919994354 ATOMIC_POSITIONS Cartesian // Cartesian (Unit is LATTICE_CONSTANT) Pt 0.0 27 0.000000000 0.000000000 3.288052246 1.405985941 0.811746362 1.643526123 0.000000000 1.623492723 0.000000000 2.811971882 0.000000000 3.287052246 ... // directly start after ATOMIC_POSITIONS' title Fe 1.0 2 0.0 0.0 0.0 m 0 0 0 mag 1.0 angle1 90 angle2 0 0.5 0.5 0.5 m 1 1 1 mag 1.0 angle1 90 angle2 180 &#x1F527;重构思考 将来可以增添 xyz 格式的原子信息文件到 ABACUS 的接口以增强易用性。 UnitCell::read_atom_species() ⚙UnitCell::read_atom_species() 函数实际上读取除原子坐标外的所有信息，如晶格矢量 latvec 等。这些变量都是 UnitCell 的数据成员。具体读取的 section 有 ATOMIC_SPECIES, NUMERICAL_ORBITAL, NUMERICAL_DESCRIPTOR, ABFS_ORBITAL, LATTICE_CONSTANT, LATTICE_VECTORS, LATTICE PARAMETERS 等。 int UnitCell::read_atom_species(std::ifstream &ifa, std::ofstream &ofs_running) { int error = 0; delete[] atom_label; this->atom_mass = new double[ntype]; delete[] atom_mass; this->atom_label = new std::string[ntype]; delete[] pseudo_fn; this->pseudo_fn = new std::string[ntype]; delete[] pseudo_type; this->pseudo_type = new std::string[ntype]; delete[] orbital_fn; this->orbital_fn = new std::string[ntype]; ... if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"ATOMIC_SPECIES\") ) { ... #ifdef __LCAO if(GlobalV::BASIS_TYPE==\"lcao\" || GlobalV::BASIS_TYPE==\"lcao_in_pw\") { if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"NUMERICAL_ORBITAL\") ) { for(int i=0; i> orbital_fn[i]; } if(GlobalV::deepks_setorb) { if (ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"NUMERICAL_DESCRIPTOR\")) { ifa >> descriptor_file; } } else descriptor_file = GlobalV::global_orbital_dir + orbital_fn[0]; } ... #ifdef __EXX if( GlobalC::exx_info.info_global.cal_exx ) { if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"ABFS_ORBITAL\") ) { for(int i=0; i> ofile; GlobalC::exx_info.info_ri.files_abfs.push_back(ofile); } } } if (GlobalV::rpa_setorb) { if (ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"ABFS_ORBITAL\")) { GlobalV::rpa_orbitals.resize(ntype); for (int i = 0; i > GlobalV::rpa_orbitals[i]; } } .... if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_CONSTANT\") ) { ModuleBase::GlobalFunc::READ_VALUE(ifa, lat0); lat0_angstrom = lat0 * 0.529177 ; this->tpiba = ModuleBase::TWO_PI / lat0; this->tpiba2 = tpiba * tpiba; } ... if(latName==\"none\"){ if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_VECTORS\") ) { ifa >> latvec.e11 >> latvec.e12; ModuleBase::GlobalFunc::READ_VALUE(ifa, latvec.e13); ifa >> latvec.e21 >> latvec.e22; ModuleBase::GlobalFunc::READ_VALUE(ifa, latvec.e23); ifa >> latvec.e31 >> latvec.e32; ModuleBase::GlobalFunc::READ_VALUE(ifa, latvec.e33); // read e(i)3 in this way is to change to the next line } if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_PARAMETERS\") ) { ModuleBase::WARNING_QUIT(\"UnitCell::read_atom_species\",\"do not use LATTICE_PARAMETERS without explicit specification of lattice type\"); } } else{ if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_VECTORS\") ) { ModuleBase::WARNING_QUIT(\"UnitCell::read_atom_species\",\"do not use LATTICE_VECTORS along with explicit specification of lattice type\"); } if(latName==\"sc\"){//simple-cubic, ibrav = 1 latvec.e11 = 1.0; latvec.e12 = 0.0; latvec.e13 = 0.0; latvec.e21 = 0.0; latvec.e22 = 1.0; latvec.e23 = 0.0; latvec.e31 = 0.0; latvec.e32 = 0.0; latvec.e33 = 1.0; else if(latName==\"fcc\"){//face-centered cubic, ibrav = 2 ...} else if(latName==\"bcc\"){//body-centered cubic, ibrav = 3 ...} ... else if(latName==\"triclinic\"){//triclinic, ibrav = 14 double bba = 0.0; double cba = 0.0; double cosab = 0.0; double cosac = 0.0; double cosbc = 0.0; double sinab = 0.0; double term = 0.0; if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_PARAMETERS\") ) { ifa >> bba >> cba >> cosab >> cosac; ModuleBase::GlobalFunc::READ_VALUE(ifa, cosbc); sinab = sqrt(1.0-cosab*cosab); } latvec.e11 = 1.0; latvec.e12 = 0.0; latvec.e13 = 0.0; latvec.e21 = bba * cosab; latvec.e22 = bba * sinab; latvec.e23 = 0.0; latvec.e31 = cba * cosac; latvec.e32 = cba * (cosbc - cosac*cosab) / sinab; term = 1.0 + 2.0 * cosab*cosac*cosbc - cosab*cosab - cosac*cosac - cosbc*cosbc; term = sqrt(term)/sinab; latvec.e33 = cba * term; } else{ std::cout 我们约定，LATTICE_CONSTANT无量纲，LATTICE_VECTORS有量纲，STRU文件中原子坐标无量纲。 UnitCell::read_atom_positions() &#x1F527;重构思考 同样地，UnitCell::read_atom_positions() 函数也不仅仅读取原子的位置，还额外读取各种具体涉及每个原子的速度、固定、磁化等等信息。 首先来到读取 STRU ATOMIC_POSITIONS 部分： bool UnitCell::read_atom_positions(std::ifstream &ifpos, std::ofstream &ofs_running, std::ofstream &ofs_warning) { if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifpos, \"ATOMIC_POSITIONS\")) { ModuleBase::GlobalFunc::READ_VALUE( ifpos, Coordinate); STRU 第二行指定坐标类型，被读取为 UnitCell::Coordinate。UnitCell::Coordinate 在 STRU 里有不同选项，⚙ 决定原子的具体位置和单位： if(Coordinate != \"Cartesian\" && Coordinate != \"Direct\" && Coordinate != \"Cartesian_angstrom\" && Coordinate != \"Cartesian_au\" && Coordinate != \"Cartesian_angstrom_center_xy\" && Coordinate != \"Cartesian_angstrom_center_xz\" && Coordinate != \"Cartesian_angstrom_center_yz\" && Coordinate != \"Cartesian_angstrom_center_xyz\" ) { ModuleBase::WARNING(\"read_atom_position\",\"Cartesian or Direct?\"); ofs_warning 这将决定最后实际的原子坐标： // module_cell/read_atom.cpp: line 695 if(Coordinate==\"Direct\") { atoms[it].taud[ia] = v; atoms[it].tau[ia] = v * latvec; } else if(Coordinate==\"Cartesian\") { atoms[it].tau[ia] = v ; } else if(Coordinate==\"Cartesian_angstrom\") { atoms[it].tau[ia] = v / 0.529177 / lat0; } else if(Coordinate==\"Cartesian_angstrom_center_xy\") { latcenter.x = (latvec.e11 + latvec.e21 + latvec.e31)/2.0; latcenter.y = (latvec.e12 + latvec.e22 + latvec.e32)/2.0; latcenter.z = 0.0; atoms[it].tau[ia] = v / 0.529177 / lat0 + latcenter; ... &#x1F527;重构思考 ABACUS 代码中现在分原子类型导入数据，尽管在代码中分种类管理原子是十分自然的选择，但 ABACUS 将这种选择表露在用户端，因此 STRU 中关于原子位置的定义也必须按类型分开输入。 接下来是按原子种类循环 ATOMIC_POSITIONS section: int na = 0; this->nat = 0; assert(ntype>0); for (int it = 0;it &#x1F527;重构思考 进入循环体，检查在 ATOMIC_POSITIONS section 中原子定义的顺序是否和 ATOMIC_SPECIES 相同 &#x1F4DD;开发者旁注 已在重构计划中 ModuleBase::GlobalFunc::READ_VALUE(ifpos, atoms[it].label); bool sequence_match = false; for(int it2=0; it2atoms[it].label == this->atom_label[it2] ) { if (it2 == it) sequence_match = true; } } if(!sequence_match) { ... return 0; } 读取当前原子类型的 starting_magnetization、原子总数 na ModuleBase::GlobalFunc::READ_VALUE(ifpos, magnet.start_magnetization[it] ); ... ModuleBase::GlobalFunc::READ_VALUE(ifpos, na); this->atoms[it].na = na; .... this->nat += na; .... 在当前 type 下刷新 type-specific 的原子性质： // positions and positional constraints delete[] atoms[it].tau; delete[] atoms[it].taud; delete[] atoms[it].mbl; atoms[it].tau = new ModuleBase::Vector3[na]; atoms[it].taud = new ModuleBase::Vector3[na]; atoms[it].mbl = new ModuleBase::Vector3[na]; // evoluation delete[] atoms[it].vel; delete[] atoms[it].dis; atoms[it].vel = new ModuleBase::Vector3[na]; atoms[it].dis = new ModuleBase::Vector3[na]; // magnetization delete[] atoms[it].mag; delete[] atoms[it].angle1; delete[] atoms[it].angle2; delete[] atoms[it].m_loc_; atoms[it].mag = new double[na]; atoms[it].angle1 = new double[na]; atoms[it].angle2 = new double[na]; atoms[it].m_loc_ = new ModuleBase::Vector3[na]; ⚙ 然后在 ATOMIC_POSITIONS 中读取： atoms[it].mass = this->atom_mass[it]; ❗ 此处的 atoms[it].mass 与 this->atom_mass[it] 的用法与 atomis[it].label 与 this->atom_label[it] 不同：传值 vs 核对。 接下来读取类中每个原子的速度信息，在做分子动力学模拟的时候可能需要用到： for (int ia = 0;ia > v.x >> v.y >> v.z; 然而，当前 STRU 文件在 ATOMIC_POSITIONS 的设计比较复杂，其可以包括任何一组 atom-specific 数据，且数量和顺序均不受限制，这导致判断条件变得复杂，详见 module_cell/read_atoms.cpp:line 536 - 567（link）。 atoms[it].mag 的赋值并非直接读取： else if ( tmpid == \"mag\" || tmpid == \"magmom\") { set_element_mag_zero = true; double tmpamg=0; ifpos >> tmpamg; tmp=ifpos.get(); while (tmp==' ') tmp=ifpos.get(); // ASCII code 48 to 57 are 0 to 9 the Arabic number if((tmp >= 48 && tmp > atoms[it].m_loc_[ia].y>>atoms[it].m_loc_[ia].z; atoms[it].m_loc_[ia].x=tmpamg; atoms[it].mag[ia]=sqrt(pow(atoms[it].m_loc_[ia].x,2) +pow(atoms[it].m_loc_[ia].y,2) +pow(atoms[it].m_loc_[ia].z,2) ); input_vec_mag=true; } else { ifpos.putback(tmp); atoms[it].mag[ia]=tmpamg; } } ⚙ 若 mag/magmom 后有一个值，则读取其值赋给 atoms[it]::mag[ia]，将 input_vec_mag 置为 false，若有三个值，则三个值依次被传入 atoms[it].m_loc_[ia].x, atoms[it].m_loc_[ia].y 和 atoms[it].m_loc_[ia].z，并将 input_vec_mag 置为 true，之后其向量模长为 atoms[it]::mag[ia]，然后在使用 angle1, angle2 来重新生成 mag。 if(GlobalV::NSPIN==4) { if(GlobalV::NONCOLIN) { if(input_angle_mag) { atoms[it].m_loc_[ia].z = atoms[it].mag[ia] * cos(atoms[it].angle1[ia]); if(sin(atoms[it].angle1[ia]) > 1e-10 ) { atoms[it].m_loc_[ia].x = atoms[it].mag[ia] * sin(atoms[it].angle1[ia]) * cos(atoms[it].angle2[ia]); atoms[it].m_loc_[ia].y = atoms[it].mag[ia] * sin(atoms[it].angle1[ia]) * sin(atoms[it].angle2[ia]); .... else if (input_vec_mag) { double mxy=sqrt(pow(atoms[it].m_loc_[ia].x,2)+pow(atoms[it].m_loc_[ia].y,2)); atoms[it].angle1[ia]=atan2(mxy,atoms[it].m_loc_[ia].z); if(mxy>1e-8) { atoms[it].angle2[ia]=atan2(atoms[it].m_loc_[ia].y,atoms[it].m_loc_[ia].x); .... else { // isn't this corresponds to common unrestricted case? atoms[it].m_loc_[ia].x = 0; atoms[it].m_loc_[ia].y = 0; atoms[it].m_loc_[ia].z = atoms[it].mag[ia]; } .... else if(GlobalV::NSPIN==2) { atoms[it].m_loc_[ia].x = atoms[it].mag[ia]; atoms[it].m_loc_[ia].y = 0; atoms[it].m_loc_[ia].z = 0; ... &#x1F914;批判性思考 然而，在 Quantum ESPRESSO 中，并不允许出现 nspin=4 且 noncolinear=.false. 的情况，在 ABACUS≤3.3.0 中是允许的，你怎么看？ Quantum ESPRESSO 相关信息：pw.x input description ABACUS 对 nspin=4 情况的参数处理： //module_io/input_conv.cpp line 376 if (INPUT.noncolin || INPUT.lspinorb) { GlobalV::NSPIN = 4; } if (GlobalV::NSPIN == 4) { GlobalV::NONCOLIN = INPUT.noncolin; // wavefunctions are spinors with 2 components GlobalV::NPOL = 2; // set the domag variable to make a spin-orbit calculation with zero magnetization GlobalV::DOMAG = false; GlobalV::DOMAG_Z = true; GlobalV::LSPINORB = INPUT.lspinorb; GlobalV::soc_lambda = INPUT.soc_lambda; if (INPUT.cal_force || INPUT.cal_stress) { ModuleBase::WARNING_QUIT(\"input_conv\", \"force & stress not ready for soc yet!\"); } if(INPUT.gamma_only_local) { ModuleBase::WARNING_QUIT(\"input_conv\", \"soc does not support gamma only calculation\"); } } else { GlobalV::LSPINORB = false; GlobalV::NONCOLIN = false; GlobalV::DOMAG = false; GlobalV::DOMAG_Z = false; GlobalV::NPOL = 1; } Input::noncolin 等变量使用默认值初始化为： //input.cpp line 409 noncolin = false; lspinorb = false; soc_lambda = 1.0; Summary 经过 UnitCell::read_atom_species() 和 UnitCell::read_atom_positions()，以下量被赋值： // lattice info. // unit UnitCell::Coordinate; // lattice constant (real space) UnitCell::lat0; UnitCell:: lat0_angstrom; // lattice constant (reciprocal space) UnitCell::tpiba; UnitCell::tpiba2; // lattice vectors UnitCell::latvec; UnitCell::latcenter; UnitCell::a1; UnitCell::a2; UnitCell::a3; // atoms overall info. UnitCell::nat; // types UnitCell::ntype; UnitCell::atom_mass; UnitCell::atom_label; // supplementary element-specific info. // pseudopotential UnitCell::pseudo_fn; UnitCell::pseudo_type; // numerical orbital UnitCell::orbital_fn // atom type specific info. // atom type overall info. UnitCell::atoms::label; UnitCell::atoms::na; // atom position info. （constraint included） UnitCell::atoms::taud; UnitCell::atoms::tau; UnitCell::atoms::mbl; // atom move info. (velocities and displacements) UnitCell::atoms::vel; UnitCell::atoms::dis; // atom magnetization info. UnitCell::magnet::starting_magnetization; UnitCell::atoms::mag; // nspin = 4; noncolinear case UnitCell::atoms::m_loc_; UnitCell::atoms::angle1; UnitCell::atoms::angle2; UnitCell::setup_cell(): the rest, and an example of backtracking unclear variable 离开 STRU 文件的解析部分，接下来计算了初始磁化强度： //after read STRU, calculate initial total magnetization when NSPIN=2 if(GlobalV::NSPIN == 2 && !GlobalV::TWO_EFERMI) { for(int it = 0;itntype; it++) { for(int ia = 0; iaatoms[it].na; ia++) { GlobalV::nupdown += this->atoms[it].mag[ia]; } } } 由于 INPUT 中参数众多，因此在前文中对参数有所遗漏。但基于前文已有内容介绍，关于 GlobalV::TWO_EFERMI 变量，可以通过如下方式查找其意义： 在 module_io/input_conv.cpp 中寻找该变量，是何变量赋其值，发现： if (std::abs(INPUT.nupdown) > 1e-6) { GlobalV::TWO_EFERMI = true; GlobalV::nupdown = INPUT.nupdown; } 因此 GlobalV::TWO_EFERMI 变量实际依赖于 INPUT.nupdown。 接下来在 module_io/input.cpp 中寻找含 INPUT.nupdown 的 if(strcmp(...)) 单元，查看在 INPUT 文件中是何参数赋予其具体值： else if (strcmp(\"nupdown\", word) == 0) { read_value(ifs, nupdown); } 即 INPUT.nupdown 在 INPUT 中也为 nupdown。接下来打开 Full keyword list 寻找其解释。 得到结果，即 nupdown 为 spin up 和 spin down 电子数量差值： 因此该部分逻辑为：若未使用 nupdown 来指定单电子数量，则对每种原子内每个原子，累加其 mag/magmom，即磁矩模长，赋予 GlobalV::nupdown。❗ 但对于两种方式均赋予，但值不一致的情况未进行处理。 接下来根据在 STRU 中读取的晶胞参数，计算晶胞体积，并计算倒空间矢量（在上篇中已经对 latvec, G, GT, GGT 有所介绍，invGGT 的意义也不言自明）： this->omega = std::abs( latvec.Det() ) * this->lat0 * lat0 * lat0 ; this->GT = latvec.Inverse(); this->G = GT.Transpose(); this->GGT = G * GT; this->invGGT = GGT.Inverse(); this->GT0 = latvec.Inverse(); this->G0 = GT.Transpose(); this->GGT0 = G * GT; this->invGGT0 = GGT.Inverse(); 然后建立从[原子索引]到[原子种类]和[种类内原子索引]的映射： this->set_iat2itia(); 即该函数的函数名实际应该写为：set_iat2ia_iat2it()： void UnitCell::set_iat2itia(void) { delete[] iat2it; delete[] iat2ia; this->iat2it = new int[nat]; this->iat2ia = new int[nat]; int iat = 0; for (int it = 0; it iat2it[iat] = it; this->iat2ia[iat] = ia; ++iat; } } return; } 至此，UnitCell::setup_cell() 函数的内容全部结束。 回溯：how many objects are created when we see \"init_esolver()\"? 在阅读整个程序的过程中，还有一个重要的方面需要注意：伴随变量的创建，尤其是创建类对象时，其中同样非简单数据类型的数据成员又是在何时初始化，拥有具体数值？由于 Driver.h 中并无任何变量的声明（如前所述，有变量直接被声明为 extern），且 Input.h 中声明变量的值分别靠 Input::Default()、Input::Read() 和 Input::Default2() 给定，且关系简单直接，因此只剩下 ESolver 和其派生类需要注意。 Constructor: ESolver() class ESolver { .... ESolver() { classname = \"ESolver\"; } ESolver 类的构造函数非常简单，因为其是所有具体 ESolver_* 的抽象基类，所以本身的操作设计原则应该尽可能抽象且共通。关于设计抽象基类和编程范式的问题，请见文档（暂缺失） Constructor: ESolver_FP() ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); pw_big = static_cast(pw_rho); pw_big->setbxyz(INPUT.bx, INPUT.by, INPUT.bz); sf.set(INPUT.nbspline); this->symm.epsilon = this->symm.epsilon_input = INPUT.symmetry_prec; } check 其头文件中变量声明： namespace ModuleESolver { class ESolver_FP : public ESolver { public: ModulePW::PW_Basis* pw_rho; ModulePW::PW_Basis_Big* pw_big; ....// constructor and destructor declarations omitted elecstate::ElecState* pelec = nullptr; Charge chr; ModuleSymmetry::Symmetry symm; psi::Psi>* psi = nullptr; psi::Psi* psid = nullptr; Structure_Factor sf; K_Vectors kv; private: ....// member function(s) omitted }; 创建当前类和子类对象时，该构造函数被调用，Charge 类对象 chr、ModuleSymmetry::Symmetry 类对象 symm、Structure_Factor 类对象 sf，以及 K_Vectors 类对象 kv 被创建并分配内存，而 ModulePW::PW_Basis 类 pw_rho、ModulePW::PW_Basis_Big 类 pw_big、elecstate::ElecState 类 pelec、psi::Psi> 类 psi，以及 psi::Psi 类 psid 则为指针，只创建但并未调用其所属类的构造函数。 Special topic: 继承与多态 在 ESolver_FP 的构造函数中有两行格外醒目： ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); pw_big = static_cast(pw_rho); 对于 ESolver 本身，其指针对象 p_esolver 实际上也有类似操作： //Some API to operate E_Solver void init_esolver(ESolver*& p_esolver) { //determine type of esolver based on INPUT information std::string esolver_type = determine_type(); //initialize the corresponding Esolver child class if (esolver_type == \"ksdft_pw\") { #if ((defined __CUDA) || (defined __ROCM)) if (GlobalV::device_flag == \"gpu\") { if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); return; } #endif if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); } #ifdef __LCAO else if (esolver_type == \"ksdft_lcao\") p_esolver = new ESolver_KS_LCAO(); else if (esolver_type == \"ksdft_lcao_tddft\") p_esolver = new ESolver_KS_LCAO_TDDFT(); #endif else if (esolver_type == \"sdft_pw\") p_esolver = new ESolver_SDFT_PW(); else if(esolver_type == \"ofdft\") p_esolver = new ESolver_OF(); else if (esolver_type == \"lj_pot\") p_esolver = new ESolver_LJ(); else if (esolver_type == \"dp_pot\") p_esolver = new ESolver_DP(INPUT.mdp.pot_file); } “为基类指针分配派生类内存空间，以降低代码复写、提高代码复用率”这种操作称为 C++ 的多态编程，举简单例子如下： //a.cpp #include class a{ public: a() {}; ~a() {}; void TestFunction(); void AnotherFunction(); int GetPrivate(){return this->private_;} bool SetPrivate(int p){this->private_ = p; return true;} void GetPrivateAddress(){std::coutprivate_) //b.cpp #include \"a.cpp\" class b: public a{ public: b() {}; ~b() {}; void TestFunction(); void AnotherFunction(); int GetPrivate(){return this->private_;} bool SetPrivate(int p){this->private_ = p; return true;} void GetPrivateAddress(){std::coutprivate_) //main.cpp #include \"b.cpp\" using namespace std; int main() { a* p_a; p_a = new b(); coutTestFunction(); b* p_tmp = static_cast(p_a); coutTestFunction(); coutTestFunction(); coutAnotherFunction(); coutAnotherFunction(); coutSetPrivate(10); coutGetPrivate()GetPrivate()SetPrivate(20); coutGetPrivate()GetPrivate()GetPrivateAddress(); p_tmp->GetPrivateAddress(); delete p_a; return 0; } //result /* call p_a's member function before static_cast This is a function of a Memory address of p_a is 0x55ee8123beb0 Memory address of p_tmp is 0x55ee8123beb0 call p_tmp's member function after static_cast This is a function of b call p_a's member function after static_cast This is a function of a call p_a's member function This is another function of a call p_tmp's member function This is another function of b now test member variable accessibility p_a's private member is 10 p_tmp's private member is 0 p_a's private member is 10 p_tmp's private member is 20 Re-check memory address of p_a and p_tmp: Memory address of p_a is 0x55ee8123beb0 Memory address of p_tmp is 0x55ee8123beb0 Check private member variables' address 0x55ee8123beb0 0x55ee8123beb4 */ 为基类指针分配派生类内存空间，使得基类和派生类指针指向同一个内存地址（基派生类对象的起始内存位置, line 21, 22: 0x55ee8123beb0），但对于上例，基类需要 4 个字节存储基类对象，而派生类需要 4+4 个字节存储基类对象：因为派生类对象创建时会首先创建其中的基类部分，而实际上即使不进行如此操作，单一创建派生类对象时，在派生类中访问基类数据成员则需要额外以基类的名称作为域标识加以区分。此时基类指针相当于切换成对派生类内存空间的基类视角，即基类指针只能看到派生类存储中的基类部分，但看不到派生类所额外派生的部分，也因此上例共占用内存空间 4+4 字节而非 4+4+4 字节。 举例对于不使用基类指针的情况，在派生类的方法中直接访问其基类数据成员，需要写为： void b::PrintBaseAndDerivedClassVariable() { std::coutprivate_ 而使用指针方法则应该写为： std::coutprivate_private_ 另一点需要注意的是虚函数。实际上，因为基类指针使用派生类指针进行初始化，因此其“语境”为派生类，所以对于虚函数而言，调用的基函数实际为派生类的相应函数。如果使用基类指针调用非虚函数，则调用的是基类的同名函数（examples provided by New Bing Creative）。 注意：不能使用基类指针（即使已经申请派生类内存空间）访问派生类中声明和定义（但基类中无虚函数声明）的函数。 // polymorphism_example.cpp#include using namespace std; class A { public: virtual void f() { cout (p_a); // 以B* p_b=static_cast(p_a)给p_b初始化 p_a->f(); // 调用B::f()，因为f()是虚函数，会根据实际类型进行动态绑定 p_a->g(); // 调用A::g()，因为g()不是虚函数，会根据声明类型进行静态绑定 p_b->f(); // 调用B::f()，因为f()是虚函数，会根据实际类型进行动态绑定 p_b->g(); // 调用B::g()，因为g()不是虚函数，会根据声明类型进行静态绑定delete p_a; // 释放内存空间return 0; } //result /* B::f() A::g() B::f() B::g() */ 当释放内存空间时，则可以使用基类指针为柄，也可以使用派生类指针为柄，编译器将自主判断实际内存占用情况并进行释放（如果声明析构函数为虚函数，则会动态连接并达到如此期望，否则不能）。因此对于 PW_Basis 类对象 pw_rho 而言，其中被声明为虚函数的有： //file module_basis/module_pw/pw_basis.h class PW_Basis { public: .... virtual ~PW_Basis(); .... virtual void initgrids( const double lat0_in, //unit length (unit in bohr) const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors (unit in lat0) const double gridecut //unit in Ry, ecut to set up grids ); .... virtual void initgrids( const double lat0_in, const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors const int nx_in, int ny_in, int nz_in ); .... protected: .... virtual void distribute_r(); //file module_basis/module_pw/pw_basis.h class PW_Basis_Big: public PW_Basis { public: .... virtual void initgrids(const double lat0_in,const ModuleBase::Matrix3 latvec_in, const double gridecut){ .... } .... virtual void initgrids( const double lat0_in, const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors const int nx_in, int ny_in, int nz_in ){ .... } .... protected: .... virtual void distribute_r(){ .... } 派生类的析构函数也可以声明为 virtual。这些函数实际上调用 PW_Basis_Big 此派生类中声明和定义的版本。 其余的数据成员在构造函数中进行初始化均总结于下表： 数据成员 所属类 是否在当前类（ESolver_FP）的构造函数中被调用构造函数 chr Charge 是 symm ModuleSymmetry::Symmetry 是 sf Structure_Factor 是 kv K_Vectors 是 pw_rho ModulePW::PW_Basis 是 pw_big ModulePW::PW_Basis_Big 是 ⚙ 然而，PW_Basis_Big 和 PW_Basis 的关系（后文也有 PW_Basis_K 和 PW_Basis_K_Big）实际并不符合程序设计的抽象理念，这一点将在随后介绍。 变量 声明时赋初值 调用构造函数所赋初值 Charge 类 rho, rho_save, rhog, rhog_save, kin_r, kin_r_save, rho_core, rhog_core, rhopw nulllptr nrxx, nxyz, ngmc, nspin allocate_rho, allocate_rho_final_scf false prenspin 1 Symmetry 类 symm_flag available true s1, s2, s3, a1, a2, a3, p1, p2, p3 ntype, nat, na, istart, itmin_type, itmin_start newpos, rotpos, ptrans, ncell, index cel_const, pcel_const, pre_const symflag_fft, sym_test, pbrav, real_brav, ilattname, plattname gmatrix,kgmatrix, gtrans symop, nop, s_flag, nrot, pgnumber, spgnumber, pgname, spgname optlat,plat nrotk,max_nrotk -1 tab 12 Structure_Factor 类 nbspline, strucFac, eigts1, eigts2, eigts3 c_eigts1, c_eigts2, c_eigts3, z_eigts1, z_eigts2, z_eigts3 nullptr K_Vectors 类 kvec_c, kvec_d, kvec_d_ibz, wk, wk_ibz, ngk, isk, ibz2bz, nmp nspin, nks, nkstot, nkstot_ibz,k_nkstot 0 koffset kc_done, kd_done false k_kword PW_Basis 类 classname \"PW_Basis\" ig2isz, istot2ixy, is2fftixy, d_is2fftixy, fftixy2up, nst_per, npw_per, startz, numz, numg, numr, startg, startr, gdirect, gcar, gg, startnsz_per, ig2igg, gg_uniq nullptr device \"cpu\" precision \"double\" nst, nstnz, nstot, npw, npwtot, nrxx, startz_current, nplane, ngg, ggecut, gridecut_lat, full_pw_dim, poolrank, fftnx, fftny, fftnz, fftnxyz, fftnxy, nx, ny, nz, nxyz, nxy, liy, riy, lix, rix, ng_xeq0, nmaxgr 0 ig_gge0 -1 lat0, tpiba, tpiba2, omega, distribution_type, poolnproc, 1 xprime false PW_Basis:public PW_Basis_big 类 bx, by, bz 1 bxyz, nbx, nby, nbz, nbzp, nbxx, nbzp_start 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 1 下篇：Introduction to ABACUS: Path to PW calculation - Part 3 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-04 22:37:12 "},"develop-path3.html":{"url":"develop-path3.html","title":"Introduction to ABACUS: Path to PW calculation - Part 3","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 3 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 3 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class Trigger: ESolver_FP::Init() 承接上篇中已经导入的结构信息，以及了解到构造函数及其伴随的变量初始化和 ABACUS 里应用到的 C++ 多态编程，接下来即将（逐渐）步入 ABACUS 的核心内容。我们暂时跳过位于 source/driver_run.cpp:driver_run() 的： // 3. For these two types of calculations // nothing else need to be initialized if(GlobalV::CALCULATION == \"test_neighbour\" || GlobalV::CALCULATION == \"test_memory\") { p_esolver->Run(0, GlobalC::ucell); ModuleBase::QUIT(); } 直接来到第 44 行，ModuleESolver::ESolver::Init() 函数对 esolver 进行更多的设置： // driver_run.cpp: line 44 p_esolver->Init(INPUT, GlobalC::ucell); 然而查找该函数的定义和声明时，发现该函数在 module_esolver/esolver.h 被声明为纯虚函数，类似的还有 un(), cal_Energy(), cal_Force(), cal_Stress() 等。 namespace ModuleESolver { class ESolver { public: .... virtual void Init(Input& inp, UnitCell& cell) = 0; virtual void Run(int istep, UnitCell& cell) = 0; virtual void cal_Force(ModuleBase::matrix& force) = 0; virtual void cal_Stress(ModuleBase::matrix& stress) = 0; .... 考虑到我们之前已经根据 basis_type 和 esolver_type 确定基类（ESolver）指针 p_esolver 所指向内存空间所存储变量为 ESolver_KS_PW，因此我们首先只关注该纯虚函数在 esolver_ks_pw 的实例化。 查看 module_esolver/esolver_ks_pw.cpp 中该函数的定义： namespace ModuleESolver { .... template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { ESolver_KS::Init(inp, ucell); 从上篇中可知，ESolver_KS_PW 有从 ESolver_KS 的继承，ESolver_KS 是从 ESolver_FP（FP 代表 First-Principles）的继承，ESolver_FP 是从 ESolver 的继承，因此 ESolver 各子类中 Init() 函数均保持结构统一，且第一行为父类的 Init() 函数： module_esolver/esolver_ks.cpp： namespace ModuleESolver { .... template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { ESolver_FP::Init(inp,ucell); module_esolver/esolver_fp.cpp： namespace ModuleESolver { .... void ESolver_FP::Init(Input& inp, UnitCell& cell) { cell.read_pseudo(GlobalV::ofs_running); 同时由于多层的继承关系，p_esolver 现在具有所有的数据成员，ESolver_FP 具有数据成员： namespace ModuleESolver { class ESolver_FP : public ESolver { public: ModulePW::PW_Basis* pw_rho; ModulePW::PW_Basis_Big* pw_big; elecstate::ElecState* pelec = nullptr; Charge chr; ModuleSymmetry::Symmetry symm; psi::Psi>* psi = nullptr; psi::Psi* psid = nullptr; Structure_Factor sf; K_Vectors kv; }; } 同理，ESolver_KS 的数据成员，也被 ESolver_KS_PW 继承。ESolver_FP::Init() 首先调用 UnitCell::read_pseudo() 函数进行赝势文件读取，而将赝势文件读取任务放在 FP 层级下，也暗示对于 ABACUS 的第一性原理方法实现来讲，都需要使用赝势。 Pseudopotential import: UnitCell::read_pseudo() void UnitCell::read_pseudo(std::ofstream &ofs) { read_cell_pseudopots(GlobalV::global_pseudo_dir, ofs); 在解读赝势文件读取功能之前，首先需要对赝势文件的结构和信息做一定程度的了解。 ONCV pseudopotential file Section 0: Norm-conserving conditions, generation of pseudopotential and header of exact UPF file 赝势的意义不言自明，其中模守恒赝势需满足如下条件： \\epsilon^\\text{ps}_l=\\epsilon_l（赝势得到的能级和全电子方法求解的能级一样，这里 ps 代表 pseudopotentials） \\phi^\\text{ps}_l(r)无节点（赝波函数没有结点，nodeless） 在截断半径之外（r>r_c）有\\phi^\\text{ps}_l(r)=\\phi_l(r)（赝波函数在截断半径之后一致） \\int_{r（电子数守恒，即模守恒） 生成赝势的步骤如下： -\\frac{\\hbar^2}{2m}\\frac{d^2}{dr^2}\\phi_{l}(r)+[\\frac{\\hbar^2}{2m}\\frac{l(l+1)}{r^2}+V(r)]\\phi_l(r)=\\epsilon_l\\phi_l(r)，解得(\\phi_l(r)-\\epsilon_l) pair 满足上述四个模守恒条件前提下生成(\\phi^\\text{ps}_l(r)-\\epsilon^\\text{ps}_l) pair，使得-\\frac{\\hbar^2}{2m}\\frac{d^2}{dr^2}\\phi^\\text{ps}_{l}(r)+[\\frac{\\hbar^2}{2m}\\frac{l(l+1)}{r^2}+V(r)]\\phi^\\text{ps}_l(r)=\\epsilon^\\text{ps}_l\\phi^\\text{ps}_l(r)成立 V_l(r)=\\frac{1}{\\phi^\\text{ps}_l(r)}[\\epsilon^\\text{ps}_l-\\frac{\\hbar^2}{2m}\\frac{l(l+1)}{r^2}+\\frac{\\hbar^2}{2m}\\frac{d^2}{dr^2}]\\phi^\\text{ps}_l(r)，解得V_l(r)。 扣除V_l(r)中 Hartree、xc 部分，得到V^\\text{ps}_l(r)：V^\\text{ps}_l(r)=V_l(r)-V^\\text{H}[\\rho^\\text{ps}(r)]-V^\\text{xc}[\\rho^\\text{ps}(r)]。\\rho^\\text{ps}(r)=\\frac{1}{4\\pi}\\sum_i^\\text{occ}{f_{i}|\\phi^\\text{ps}_l(r)|^2} 更多细节见：www.tcm.phy.cam.ac.uk 从 UPF 文件（注意 UPF 文件也有不同的版本，目前 ABACUS 都支持，若有不支持的，可以提 Github 的 issues 进行讨论）开始，截止到 之前，提供了赝势文件的作者信息，引用信息以及生成赝势文件所使用的程序和相应输入文件，并附带输入文件参数中的解释。由于此块内容对实际计算并不起作用，因此暂时略过。 Section 1: 部分尽管已经位于所谓“not human readable”区域，但也并非如此。这部分“标签”（HTML 语境）/block 实际上包含了众多精简过的信息，如元素名称（element）、赝势类型（pseudo_type，模守恒，norm-conserving，NC），相对论效应（relativistic），是否为超软赝势等等信息。当前 Al 理论上其原子序数 13，因此有 13 个电子，但此处 z_valence 参数为 11，即有两个 1s 电子被赝化，只留下 2s, 2p, 3s, 3p 电子共 2+6+2+1 个。对于某些元素，甚至有大核赝势与小核赝势之分，根据赝化电子数量不同进行区分。显而易见地，赝化电子数量越多，则计算量越小，但计算结果的精确程度可能更低。 Section 2: 0.0000 0.0100 0.0200 0.0300 0.0400 0.0500 0.0600 0.0700 5.9200 5.9300 5.9400 5.9500 5.9600 5.9700 5.9800 5.9900 6.0000 6.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 这部分开始出现了关于实空间格点相关量的定义。在 tag 中不仅指定数据类型为实数，也指定当前数据的长度（size），以及数据存储的列数（columns = 8）。PP_R 为格点坐标，PP_RAB 则为格点间距。 Section 3: -4.5793174225E+01 -4.5788454271E+01 -4.5774276797E+01 -4.5750659428E+01 -3.6912752197E+00 -3.6850921941E+00 -3.6789298138E+00 -3.6727880140E+00 -3.6666666933E+00 -3.6605657501E+00 从 部分开始，正式开始写入赝势的具体数值，建立在 和 所描述的实空间格点上。\\hat{V}=\\hat{V}^\\text{loc}+\\hat{V}^\\text{NL}。 正是赝势的局域势部分。 Section 4: 0.0000000000E+00 8.1959788337E-02 1.6389680452E-01 2.4578292762E-01 -1.2623857798E-05 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 5.3707838603E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 -8.2930195943E-01 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 -6.5836757852E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 -4.6797927123E+00 完全非局域部分，\\hat{V}^\\text{NL}=\\sum_{ij}{|\\beta_i\\rangle D_{ij}\\langle\\beta_j|}。其中|\\beta_i\\rangle一般被称为非局域势投影子（projector）。 Section 5: and 0.0000000000E+00 3.6337392512E-03 1.4532726686E-02 3.2690254089E-02 为赝波函数， 则为赝电荷密度在实空间格点上的数据。一个简单的赝势文件信息提取脚本： ParseUpfWordByWord.py &#x1F914; 玩玩看！ Quantum ESPRESSO 官网上提供了更多关于 UPF 文件格式的信息：Unified Pseudopotential Format - QUANTUMESPRESSO ❗注意 读入的投影子 projector |\\beta\\rangle和 pswfc \\tilde{\\phi}(r)已经乘径向坐标r。 UnitCell::read_cell_pseudopots() link to Github -> link void UnitCell::read_cell_pseudopots(const std::string &pp_dir, std::ofstream &log) { std::stringstream ss; ss pseudo_fn[i]; error = upf.init_pseudo_reader( pp_address, this->pseudo_type[i] ); 赝势文件的读取 type-by-type，每次创建 Pseudopot_upf 类对象 upf，之后调用 upf.init_pseudo_reader() 对文件进行读取，需要指定文件的地址（pp_address）和赝势类型（UnitCell::pseudo_type[i]）。Pseudopot_upf::init_pseudo_reader() 为每种赝势文件进行判断，之后进行不同的解析。为方便起见，这里我们只关注 ABACUS 的常用赝势类型，即模守恒 upf。跟随“转到定义”，来到 module_cell/read_pp.cpp 文件（link）： int Pseudopot_upf::init_pseudo_reader(const std::string &fn, std::string &type) { std::ifstream ifs(fn.c_str(), std::ios::in); if (type == \"auto\") { set_pseudo_type(fn, type); } if (type == \"upf\") { int info = read_pseudo_upf(ifs); return info; } else if (type == \"vwr\") { int info = read_pseudo_vwr(ifs); return info; } else if (type == \"upf201\") { int info = read_pseudo_upf201(ifs); return info; } else if (type == \"blps\") { int info = read_pseudo_blps(ifs); return info; } return 0; } 选择 read_pseudo_upf() 函数，跳转到位于 module_cell/read_pp_upf100.cpp 的该函数定义。read_pseudo_upf() 函数分标签读取 upf 格式赝势文件中信息，每个标签都有单独的解析器： while (ifs.good()) { ifs >> dummy; if(dummy==\"\") { ierr = 1; read_pseudo_header(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); break; } } if ( ModuleBase::GlobalFunc::SCAN_BEGIN(ifs, \"\") ) { read_pseudo_mesh(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); } if (this->nlcc) { ModuleBase::GlobalFunc::SCAN_BEGIN(ifs, \"\"); read_pseudo_nlcc(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); } ModuleBase::GlobalFunc::SCAN_BEGIN(ifs, \"\"); read_pseudo_local(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); 与 类似的还有 , , , 从 则可以读取旋轨耦合相关信息： if (has_so) { ModuleBase::GlobalFunc::SCAN_BEGIN (ifs,\"\"); read_pseudo_so (ifs); ModuleBase::GlobalFunc::SCAN_END (ifs,\"\"); } 每个具体 tag 的解析函数 Pseudopot_upf::read_pseudo_xxx() 均赋值于数据成员，声明在 module_cell/read_pp.h 中（link）。 Functions in Pseudopot_upf class Variables value assgined explain void read_pseudo_header(std::ifstream &ifs); this->nv``this->psd``this->tvanp``this->nlcc``this->xc_func``this->zp``this->etotps``this->ecutwfc``this->ecutrho``this->lmax``this->mesh``this->nwfc``this->nbeta``this->els``this->lchi``this->oc Version numberElement labelIf ultrasoft pseudopotentialIf noncolinear correction addedXc functionalAtomic chargesTotal energySuggested energy cutoff for wavefunctionSuggested energy cutoff for charge densityMaximal angular momentum includedNumber of points in radial meshNumber of wavefunctionsNumber of projectorsDim nwfc, labels of orbitalDim nwfc, angular momentum of orbitalDim nwfc, occupation of orbital void read_pseudo_mesh(std::ifstream &ifs); this->r``this->rab Dim this->mesh, realspace mesh of radiusDim this->mesh, void read_pseudo_nlcc(std::ifstream &ifs); this->rho_atc Dim this->mesh, void read_pseudo_local(std::ifstream &ifs); this->vloc Dim this->mesh, Vlocal void read_pseudo_nl(std::ifstream &ifs); this->kkbeta this->lll this->beta``this->dion``this->nd Dim this->nbeta, number of mesh points of projectors.Dim this->nbeta, angular momentum for projectors.Dim this->nbetathis->mesh.Dim this->nbetathis->nbeta.Number of nonzero D_{ij} void read_pseudo_pswfc(std::ifstream &ifs); this->chi Dim this->nwfc*this->mesh, void read_pseudo_rhoatom(std::ifstream &ifs); this->rho_at Dim this->mesh, atomic electron density on realspace mesh void read_pseudo_addinfo(std::ifstream &ifs); Not implemented Not implemented void read_pseudo_so(std::ifstream &ifs); this->nn this->jchi``this->jjj Dim this->nwfc, quantum number of wavefunctionDim this->nwfc, j=l+s, where s=\\pm\\frac{1}{2}.Dim this->nbeta, j=l+s, where s=\\pm\\frac{1}{2}, for projector. 我们假设 ONCV.upf 格式赝势文件顺利读取完毕，upf.init_pseudo_reader() 返回 0（error == 0），来到条件判断： if(error==0) { if(this->atoms[i].flag_empty_element) upf.set_empty_element(); error_ap = upf.average_p(GlobalV::soc_lambda); } Pseudopot_upf::set_empty_element() 的作用为设置 Vloc、dion 和 rho_at 均为 0，Pseudopot_upf::average_p() 则属于自旋轨道耦合（spin-orbital coupling）功能，这里先不介绍。 我们来到 line 82, if(GlobalV::MY_RANK==0) { atoms[i].ncpp.set_pseudo_nc( upf ); .... } 实际上 ABACUS 目前只能处理模守恒的赝势类型。显然该行实现的为将赝势信息从upf到atoms[i].ncpp的拷贝，而 upf 的意义也不言自明：UPF file parser。解析 UPF 文件后传值给 atoms[i].ncpp void pseudo_nc::set_pseudo_nc(const Pseudopot_upf &upf) { this->set_pseudo_h(upf); this->set_pseudo_atom(upf); this->set_pseudo_vl(upf); delete[] lll; lll = new int[nbeta]; for (int i = 0;i kkbeta = 0; for (int nb = 0;nb kkbeta = (upf.kkbeta[nb] > kkbeta) ? upf.kkbeta[nb] : kkbeta; } this->betar.create(upf.beta.nr, upf.beta.nc); this->betar = upf.beta; this->dion.create(nbeta, nbeta); this->dion = upf.dion; } 该函数属于类 pseudo_nc，而 pseudo_nc 对象为 atom 的数据成员，atoms 则为 UnitCell 的数据成员。pseudo_nc::set_pseudo_h()，pseudo_nc::set_pseudo_atom 和 pseudo_nc::set_pseudo_vl 的内容在此省略，但其分别为将 Hamilton, 原子性质和 Vlocal 相关数据从 upf 对象拷贝。之后(1)使用 lll 刷新为 upf 对象的 projectors 的角动量，然后计算出磁角动量区分时的 projector 个数。(2)取所有 projector 衰减到 0 时候的最大最普适半径。 赝势信息后处理 回到 module_cell/unitcell.cpp line 663，接下来为每个原子创建目录，在目录中写 [原子label].NONLOCAL 文件。[label].NONLOCAL 文件中内容包含 , 和 三个 tag。 中包含内容： ofs \" label ncpp.pp_type ncpp.lmax \" 中包含内容为 projector 数量 atom->ncpp.nbeta、对应于每个原子的 projector 的角动量为指标的 dion 矩阵： ofs \" ncpp.nbeta ncpp.nbeta; ib++) { for(int ib2=0; ib2ncpp.nbeta; ib2++) { ofs ncpp.lll[ib] ncpp.lll[ib2] ncpp.dion(ib,ib2)\" 中包含内容为 projector 仅其值大于 1.0e-10 的值。首先仍然输出当前原子的 projector 索引，以及角动量，然后截断 projector: int cut_mesh = atom->ncpp.mesh; for(int j=atom->ncpp.mesh-1; j>=0; --j) { if( std::abs( atom->ncpp.betar(i,j) ) > 1.0e-10 ) { cut_mesh = j; break; } } if(cut_mesh %2 == 0) ++cut_mesh; 之后按照截断后的网格重新存储 projector 的 realspace grid, projector value, rab 数据，分三列分别存储： for(int j=0; jncpp.r[j] ncpp.betar(i, j) ncpp.rab[j] \" 赝势信息分发：UnitCell::bcast_unitcell2(void) #ifdef __MPI 接下来对赝势信息进行MPI进程（processor）间的分发： #ifdef __MPI bcast_unitcell2(); #endif // module_cell/unitcell.cpp:bcast_unitcell2() void UnitCell::bcast_unitcell2(void) { for (int i = 0; i // module_cell/atom_spec.cpp:Atom::bcast_atom2() void Atom::bcast_atom2() { this->ncpp.bcast_atom_pseudo(); } // module_cell/atom_pseudo.cpp::Atom_pseudo::bcast_atom_pseudo() void Atom_pseudo::bcast_atom_pseudo(void) { .... Parallel_Common::bcast_int( lmax ); .... Parallel_Common::bcast_double( etotps ); .... Parallel_Common::bcast_bool( tvanp ); .... Parallel_Common::bcast_string( psd ); .... // below two 'bcast_double' lines of codes seem to have bugs, // on some computers, the code will stuck here for ever. // mohan note 2021-04-28 Parallel_Common::bcast_double( dion.c , nbeta * nbeta); Parallel_Common::bcast_double( betar.c, nr * nc ); } #endif 赝势信息核对 接下来跨原子种类检验泛函是否一致： for(int it=0; it STRU 结构检查：UnitCell::check_structure() 检验结构中任意两原子之间距离是否大于其固定倍数（ check_structure(GlobalV::MIN_DIST_COEF); 计算轨道数：UnitCell::cal_natomwfc() UnitCell::cal_natomwfc() 函数计算所有种类的原子轨道数量加和，对于非 nspin=4，即非 soc（自旋轨道耦合）情况，角量子数 l 和 s 非耦合，l 单独可以作为好的量子数来区分量子态，因此对于每个赝势中定义的 wfc，若其对应 occupation 大于等于 0（即有效 wfc），则对应于其角量子数 l，轨道数量增加 2l+1，即计数其磁量子数 m，也相当于对 alpha 和 beta spin 的单独计数。对于 nspin=4 的情况，若考虑 soc，则轨道数对 j=l+s 的情况，当前原子种类当前角量子数对应轨道数量记为 2l+1+1，否则为 2l+1。对于非 soc 但 nspin=4，当前原子种类轨道当前角量子数对应轨道数量记(2l+1)*2： void UnitCell::cal_natomwfc(std::ofstream &log) { this->natomwfc = 0; for (int it = 0;it = 0) { if(GlobalV::NSPIN==4) { if(atoms[it].ncpp.has_so) { tmp += 2 * atoms[it].ncpp.lchi[l]; if(fabs(atoms[it].ncpp.jchi[l] - atoms[it].ncpp.lchi[l] - 0.5) 接下来调用 UnitCell::cal_nwfc() 函数，计算并赋值 波函数 index 到角动量，zeta 和磁量子数的表格， 跨原子种类的最大原子数，以及最大 wfc 数量， 轨道数量和： GlobalV::NLOCAL = 0; for(int it=0; it 建立 UnitCell::itia2iat（种类 index，种类内原子 index）->（原子全局 index）映射表、UnitCell::iat2iwt（原子全局 index）->（波函数全局 index）映射表、UnitCell::iwt2iw（波函数全局 index）->（波函数种类内 index）映射表、UnitCell::iwt2iat（波函数全局 index）->（原子全局 index）映射表、UnitCell::iwt2iw（波函数全局 index）->（波函数种类内 index）映射表。 计算跨原子种类最大角量子数 UnitCell::lmax 和某 l 对应最大 zeta 数 UnitCell::nmax，以及跨原子种类的类内 zeta 数总和最大值 UnitCell::nmax_total 寻找赝势中最大角量子数 UnitCell::lmax_ppwf。 价电子数核对 核对赝势中定义的价电子数与 ABACUS 预置库中原子的最小价电子数 获取最大格点数量：UnitCell::cal_meshx() 计算跨原子种类的最大格点数量，存储在 UnitCell::meshx 中，目前 ABACUS 代码中变量命名后缀 x 可能代表 max，正如之前看到 npwx 等。 至此，我们离开函数 UnitCell::read_pseudo()，回到 ModuleESolver::ESolver_FP::Init() 函数。 &#x1F4C3;和 Quantum Espresso 对齐的赝势参数 读入 UPF 格式的模守恒赝势之后，如果要和 QE 的结果做 apple-to-apple 的比较，使得总能量受力等性质计算一致，可以把基矢量调成平面波(basis_type 设成 pw)，然后在 INPUT 文件中，把 pseudo_rcut 设成 10（默认是 15），pseudo_mesh 设成 1 即可（默认是 0）。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 2 下篇：Introduction to ABACUS: Path to PW calculation - Part 4 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-04 23:11:45 "},"develop-path4.html":{"url":"develop-path4.html","title":"Introduction to ABACUS: Path to PW calculation - Part 4","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 4 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 4 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class Trigger: ESolver_FP::Init() 平面波格点初始化：PW_Basis:: initgrids() 完成了 INPUT 和 STRU，以及赝势文件的读取环节，接下来我们来到平面波的初始化设置相关部分。 void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... if (inp.nx * inp.ny * inp.nz == 0) this->pw_rho->initgrids(inp.ref_cell_factor * cell.lat0, cell.latvec, inp.ecutrho); else this->pw_rho->initgrids(inp.ref_cell_factor * cell.lat0, cell.latvec, inp.nx, inp.ny, inp.nz); ⚠️ 注意，PW_Basis::initgrids() 为虚函数（virtual），尽管使用基类指针（pw_rho），实际调用的函数也是与之同名但不同内容的派生类（PW_Basis_Big）成员函数。这一点靠 ESolver_FP 的构造函数实现： ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); pw_big = static_cast(pw_rho); pw_big->setbxyz(INPUT.bx, INPUT.by, INPUT.bz); sf.set(INPUT.nbspline); this->symm.epsilon = this->symm.epsilon_input = INPUT.symmetry_prec; } 在 INPUT 文件中，nx, ny 和 nz 为 FFT 网格大小相关参数，但一般应用场景而言，几乎无用户亲自设置它（对于用户主动设置 nx, ny 和 nz 的情况，ecutrho/ecutwfc 值的设置无效，将会根据格点情况被重新赋值）。在 Input::Default() 中，三个变量的默认值均为 0，因而常规来讲实际唤起 PW_Basis::initgrads() 函数的版本计算了 nx, ny 和 nz，其算法和 SIAB 程序完全相同（view source code: https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_basis/module_pw/pw_init.cpp#L156）： INPUT 中 ecutrho 确定以动量\\mathbf{k}=(0,0,0)为球心的球半径 在倒空间确定所有在“球”中的格点（均为整数坐标，因现在最小可分辨距离为倒格子矢量长度，见下 Fig.1），其中每个点都对应一个平面波 以倒空间内 x/y/z 最大/小值为边界组成正方形盒子，进行（2, 3, 5）质数分解，得到可能更大的盒子尺度（nx, ny 和 nz） 相较于 PW_Basis::initgrids()，PW_Basis_Big::initgrids() 还初始化了 nbx, nby 和 nbz 的值，尽管对于平面波而言整个 PW_Basis_Big 都是冗余功能（PW_Basis_Big 只是在 LCAO 里面做格点积分的时候会用到）： virtual void initgrids(const double lat0_in,const ModuleBase::Matrix3 latvec_in, const double gridecut) { // generation of nx, ny and nz are omitted here .... if(!this->bz) { this->autoset_big_cell_size(this->bz, ibox[2], this->poolnproc); } if(!this->bx) { if(ibox[0] == ibox[2]) this->bx = this->bz; else this->autoset_big_cell_size(this->bx, ibox[0]); } if(!this->by) { if(ibox[1] == ibox[2]) this->by = this->bz; else this->autoset_big_cell_size(this->by, ibox[1]); } this->bxyz = this->bx * this->by * this->bz; if(ibox[0]%this->bx != 0) ibox[0] += (this->bx - ibox[0] % this->bx); if(ibox[1]%this->by != 0) ibox[1] += (this->by - ibox[1] % this->by); if(ibox[2]%this->bz != 0) ibox[2] += (this->bz - ibox[2] % this->bz); .... this->nbx = this->nx / bx; this->nby = this->ny / by; this->nbz = this->nz / bz; delete[] ibox; } 回忆 PW_Basis_Big::bx, by 和 bz 的值则在 namespace ModuleESolver { ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); .... pw_big->setbxyz(INPUT.bx, INPUT.by, INPUT.bz); 设置。回溯 INPUT.bx，在 input.cpp 就可以发现： //line 2664 if (basis_type == \"pw\") // xiaohui add 2013-09-01 { .... bx = 1; by = 1; bz = 1; } 接下来从 Input 对象中拷贝了平面波类 PW_Basis 的数据成员， void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->initparameters(false, inp.ecutrho); void PW_Basis:: initparameters( const bool gamma_only_in, const double pwecut_in, const int distribution_type_in, const bool xprime_in ) { this->xprime = xprime_in; this->gamma_only = gamma_only_in; // if use gamma point only, when convert real function f(r) to F(k) = FFT(f), // we have F(-k) = F(k)*, so that only half of planewaves are needed. this->fftny = this->ny; this->fftnx = this->nx; if (this->gamma_only) { if (this->xprime) this->fftnx = int(this->nx / 2) + 1; else this->fftny = int(this->ny / 2) + 1; } this->fftnz = this->nz; this->fftnxy = this->fftnx * this->fftny; this->fftnxyz = this->fftnxy * this->fftnz; this->ggecut = pwecut_in / this->tpiba2; //ggecut should be no larger than gridecut if(this->ggecut > this->gridecut_lat) this->ggecut = this->gridecut_lat; this->distribution_type = distribution_type_in; } ❗ 注意：这里还完成了倒空间格点数量 fftnx, fftny 和 fftnz 的赋值。因为 FFT 变换前后的格点数量一般相同，因此 fftnx = nx，fftny = ny，...。 然后对平面波在 MPI 进程间进行分发： //module_esolver/esolver_fp.cpp void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->setuptransform(); void PW_Basis::setuptransform() { ModuleBase::timer::tick(this->classname, \"setuptransform\"); this->distribute_r(); this->distribute_g(); this->getstartgr(); this->ft.clear(); if(this->xprime) this->ft.initfft(this->nx,this->ny,this->nz,this->lix,this->rix,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); else this->ft.initfft(this->nx,this->ny,this->nz,this->liy,this->riy,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); this->ft.setupFFT(); ModuleBase::timer::tick(this->classname, \"setuptransform\"); } PW_Basis::setuptransform()（link） 并行机制简述 并行池 到这里，我们不得不开始对平面波的 MPI 并行机制有一个大致的认识。在 ABACUS 中，CPU（=processor）首先根据不同的布里渊区 k 点分组被划分成不同的并行池（parallelizaiton pool），每个 pool 都包含几个 k 点，在每个 pool 里面会有完整的对该 k 点求解 Kohn-Sham 方程的过程。因此，在每个 pool 中采用一定数量的 CPU 进程来完成计算。在 INPUT 文件中，KPAR 参数决定了并行池的数量（即 pool 的个数）。换句话说，ABACUS 的 k 点并行机制为，将 k 点（设其数量为 nkpt）分配在 KPAR 个 pool 中，若一共有 nproc 个 processor，则： 每个 pool 有 nproc/KPAR 个 processor 每个 pool 均分得到 nkpt/KPAR 个 k 点进行计算-> 最多有多少个 k 点同时进行计算（因为均分到每个 pool 的 kpt 将串行计算） KPAR：defines the number of groups the k points are divided into, or the number of kpts on which wavefunctions are solved simultaneously. 另外注意，自旋是通过 k 点这个 index 被包含进计算的。即对同 1 个 k 点的自旋上下是通过在程序里设置两个 k 点来完成计算的。例如，我们采用 444=64 个 k 点进行运算，如果不开对称性，那么 nspin=1 时程序执行的是 64 个 k 点，npsin=2 时程序执行的是 64*2=128 个 k 点。 MPI 进程编号：rank rank 是一个在 MPI 并行里常被用到的变量。在拥有不止一个 processor 的时候，每个 processor 都具有唯一的编号，称为 rank。如果在每个 processor 都有 rank 的基础上还定义了 pool，以及在每个 pool 中的 processor 数量，则 processor 除了有跨 pool 的全局 rank，也可以有 pool 之内的局部 rank，这部分内容见 module_base/global_variable.cpp: int NPROC = 1; int KPAR = 1; int MY_RANK = 0; int MY_POOL = 0; int NPROC_IN_POOL = 1; int RANK_IN_POOL = 0; .... 在 ABACUS 中，部分文件 I/O 操作仅使用 rank0 的 processor 执行（module_cell/read_cell_pseudopots.cpp: line 32）： if(GlobalV::MY_RANK==0) { pp_address = pp_dir + this->pseudo_fn[i]; error = upf.init_pseudo_reader( pp_address, this->pseudo_type[i] ); //xiaohui add 2013-06-23 if(error==0) // mohan add 2021-04-16 { if(this->atoms[i].flag_empty_element) // Peize Lin add for bsse 2021.04.07 { upf.set_empty_element(); } //average pseudopotential if needed error_ap = upf.average_p(GlobalV::soc_lambda); //added by zhengdy 2020-10-20 } } 并行策略 于是问题便到来：在并行条件下，代码究竟是如何执行的？ 对于多核 CPU，是否运行在其上的所有程序都进行了并行化？ 答：否。对于运行在常见操作系统上的软件，并不需要进行显式的并行化，因为系统具有分配算法，会根据当前硬件情况，自动把软件的执行在不同核间进行分配和任务调度。但究竟并行效率和结果如何，取决于操作系统自身。 一个自编程序如果没有进行显式的并行化，直接使用 mpirun 等方式运行，会发生什么？ 答：相同的代码会在每个 processor 上运行一遍。 CPU 和 processor 的关系是什么？ 答：CPU=processor，在并行计算的语境下。 特别地，对于 C++ 而言，没有显式并行化却使用 mpirun 方式运行的程序，若其中包括创建对象等操作，是否意味着每个 processor 都创建了单独的对象，并且都放在了各自的内存空间？ 答：取决于并行策略。对于 OpenMP，processor 间内存共享，即只创建一个对象，之后每个 processor 同时往同一个内存区域读写内容。对于 MPI，processor 间内存相互独立，即每个 processor 在各自隔离的内存上都创建相同对象，之后每个 processor 再独立进行内存区域的读写。 5w. 进程、线程之间是什么关系？ 进程（process）包含线程（thread）。以下为 ChatGPT 生成内容： A process is an instance of a program that is being executed. It has its own memory space, system resources, and execution context. A process can contain multiple threads, each of which can execute independently and concurrently within the same process. Processes are managed by the operating system and can communicate with each other through inter-process communication mechanisms. A thread, on the other hand, is a lightweight unit of execution within a process. It shares the same memory space and system resources as the process it belongs to, but has its own execution context. Multiple threads within a process can execute concurrently and share data and resources within the process. Threads are managed by the operating system or by the application itself, depending on the programming language and platform. OpenMP-MPI 混合编程 通常来讲，尽管 OpenMP 提供了线程并行，但由于共享内存可能并不存在于 processors 之间，或 computer, nodes 之间，且没有适合的内存共享系统（multi-socket server），此时如果以 OpenMP 放心运行，则可能得出错误结果或直接报错——因为内存无法访问。对于这种情况，需要使用 MPI（Message passing interface）来维持无内存共享处理单元之间的信息交换，以及信息分发和分布计算，而在处理单元内部，即可以共享内存的域内，则可以通过 OpenMP 技术来进行线程级并行。 实空间格点分发 在简单介绍完并行机制后，我们知道，对于未显式以并行方式实现的函数，其运行将在每一个 processor。在接下来的平面波分发过程中，请始终牢记这一理念，尤其在 processor-local 变量和 processor-global 变量的传值过程中。 稍加回溯： void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->setuptransform(); void PW_Basis::setuptransform() { this->distribute_r(); this->distribute_g(); .... 而 ModuleESolver::ESolver_FP::Init() 为 ModuleESolver::ESolver_KS::Init() 所调用，ModuleESolver::ESolver_KS::Init() 为 ModuleESolver::ESolver_KS_PW::Init() 所调用，ModuleESolver::ESolver_KS_PW::Init()则为 p_esolver 所调用，p_esolver 虽然属于 ModuleESolver::ESolver 类指针，但由于 basis_type 和 esolver_type 被划定指向 ModuleESolver::ESolver_KS_PW 类内存空间，因此其原本纯虚函数 ModuleESolver::ESolver::Init() 的调用指向 ModuleESolver::ESolver_KS_PW::Init()。p_esolver 在 driver_run 中被创建，driver_run 来源于 atomic_world() 函数，atomic_world() 函数则在 driver.cpp 中被调用。 回到正题： 实空间：PW_Basis::distribute_r() ❗Attention 注意，此时实际调用的也是 PW_Basis_Big 而非 PW_Basis 的 distribute_r() 函数。 namespace ModulePW { class PW_Basis_Big: public PW_Basis { public: virtual void distribute_r() { delete[] this->numz; this->numz = new int[this->poolnproc]; delete[] this->startz; this->startz = new int[this->poolnproc]; ModuleBase::GlobalFunc::ZEROS(this->numz, this->poolnproc); ModuleBase::GlobalFunc::ZEROS(this->startz, this->poolnproc); int npbz = this->nbz / this->poolnproc; int modbz = this->nbz % this->poolnproc; this->startz[0] = 0; for(int ip = 0 ; ip poolnproc ; ++ip) { this->numz[ip] = npbz*this->bz; if(ip numz[ip]+=this->bz; if(ip poolnproc - 1) this->startz[ip+1] = this->startz[ip] + numz[ip]; if(ip == this->poolrank) { this->nplane = numz[ip]; this->startz_current = startz[ip]; } } this->nbzp = this->nplane / this->bz; this->nrxx = this->numz[this->poolrank] * this->nxy; this->nbxx = this->nbzp * this->nbx * this->nby; this->nbzp_start = this->startz[this->poolrank] / this->bz; return; } 基于上一部分简单介绍的并行机制，ABACUS 使用 mpirun 运行，因此上述代码会被每个 processor 所单独运行。直至上述代码片段的第 25 行 if(ip == this->poolrank) {.... 该判断不会 always true。因此 PW_Basis::distribute_r() 将 3D 实空间格点，按照 z 方向进行分发，分给了不同的 processors，并赋值 this->npz，this->nplane, this->startz_current 和 this->nrxx，意义分别为当前 processor 的 z 方向格点数量、xy 平面数量、z 格点的起始索引以及当前 processor 所分得实空间格点总数（分配后 z 方向格点 ×xy 平面格点）。 图 1. PW_Basis::distribute_r()：设一个pool中有5个processors 倒空间：PW_Basis::distribute_g() 倒空间格点的分发采用了和实空间不同的方式，这主要是因为倒空间“球”的存在（ecutwfc 和 ecutrho），使得非空间中所有点都需要考虑在内，而实空间则并非如此。更一般而言，有限的实空间带来无限的倒空间（即实空间 delta 函数需要无限数量的平面波展开）延展，而有限的倒空间（倒空间 delta 点）带来无限的实空间延展（如一个平面波）。 &#x1F527;重构信息 由于目前所考虑基函数为平面波，因此需要同时追踪平面波所属 processor，平面波的 Direct (x, y, z)坐标等信息，ABACUS 现有版本通过多个繁杂的函数，建立了许多映射关系，而从 2d 到 1d 的索引 fold 让代码可读性和代码扩展编写难度进一步上升。实际上，映射关系所携带的信息本质上是“属性”，因此仅需为“属性”寻找正确的归属主体，或平面波或 processor。而 2d 到 1d 的索引映射同样可以进行封装。 倒空间的分发策略现有两种实现： void PW_Basis::distribute_g() { ModuleBase::timer::tick(this->classname, \"distributeg\"); if(this->distribution_type == 1) { this->distribution_method1(); } else if(this->distribution_type == 2) { .... } 由于 PW_Basis::initparameters() 对其有默认调用 method1，因此这里我们先只关心 method1。 void PW_Basis::distribution_method1() { int *st_bottom2D = new int[fftnxy]; int *st_length2D = new int[fftnxy]; .... if (poolrank == 0) { .... this->count_pw_st(st_length2D, st_bottom2D); .... int* st_i = new int[this->nstot]; int* st_j = new int[this->nstot]; int* st_length = new int[this->nstot]; this->collect_st(st_length2D, st_bottom2D, st_i, st_j, st_length); .... this->startnsz_per = new int[this->poolnproc]; this->divide_sticks_1(st_i, st_j, st_length); .... this->get_istot2ixy(st_i, st_j); .... delete[] st_length; delete[] st_i; delete[] st_j; delete[] this->startnsz_per; this->startnsz_per=nullptr; } this->npw = this->npw_per[this->poolrank]; this->nst = this->nst_per[this->poolrank]; this->nstnz = this->nst * this->nz; this->get_ig2isz_is2fftixy(st_bottom2D, st_length2D); delete[] st_bottom2D; delete[] st_length2D; } 分发最小单元：“棍子” - 准备工作 穿过布里渊区的整数点（2pi/a 的整数倍）都代表一个三个 index 的平面波，而一系列的点在截断半径以内沿着某个方向就组成了所谓的“stick”（代表平面波集合的“棍子”，一个“棍子”包含了多个平面波，简称就叫“棍子”）。 PW_Basis::count_pw_st() 函数（Link）计算了每个(x,y)对应的“棍子”的底部和“长度”，即对倒空间只分辨(x,y)，则会得到沿 z 方向的点的集合，被称为“棍子”。而“棍子”区域内部每一个点都代表一个平面波。“棍子”的底部对应于最小的 iz 值，“根子”的长度则为当前(x,y)所包含的平面波数量： for (int ix = ix_start; ix nx; if (y ny; int index = x * this->fftny + y; int length = 0; for (int iz = iz_start; iz GGT * f); if (modulus ggecut || this->full_pw) { if (length == 0) st_bottom2D[index] = iz; ++this->npwtot; ++length; .... } } if (length > 0) { st_length2D[index] = length; ++this->nstot; } } } count_pw_st(st_length2D, st_bottom2D)\">图 2. this->count_pw_st(st_length2D, st_bottom2D) 在倒空间分发平面波时，由于 x/y/z 均等在正负半轴 span，因此常常会涉及到 C++ 不支持负数索引的问题（btw: Python 和 FORTRAN 支持负数索引，但支持方式不同），ABACUS 当前所采取的策略是： if (xnx; if (yny; if (znz; 而在 gamma_only 情况下，由于 F(-k)=F^\\dagger(k) \\\\ 因此倒空间可以缩减（reduce），此两种情况均对倒空间 xy 平面上格点采样有所影响： “棍子”的分发和分发记录 PW_Basis::collect_st() 和 PW_Basis::divide_sticks_1() 分别排序与分发“棍子”到不同 processor： 按照棍子从长到短顺序进行排序，即 st_length2D 由大到小排序，然后适用于 st_bottom2D 等变量 将排在最前面的“棍子”对应平面波分配给任意一个 processor， 如此直到所有 processor 全部被分配过平面波/“棍子” 若还有“棍子”，则寻找具有最小平面波数量的 processor（若平面波数量相等，则寻找最少的“棍子”）继续分配。 重复过程 4 如此一来记录被分配在每个 processor 上的平面波和棍子数量： 变量（所属 PW_Basis 类） 意义 this->npw_per 各 processor 被分配平面波数量 this->nst_per 各 processor 被分配“棍子”数量 this->fftixy2ip 从“棍子”translated (x,y)-pair 到 processor index 的映射，即通过“棍子”所在(x,y)到 processor 的映射关系：cpp // module_basis/module_pw/pw_distributeg_method1.cpp:line 282 this->fftixy2ip[st_i[is] * this->fftny + st_j[is]] = ipmin; translated pair 实际为一维索引，使用 x*fftny + y。进而 fftixy2ip[st_i[is] * this->fftny + st_j[is]] 实现了从“棍子”索引到 processor 索引的映射。 this->startnsz_per 每个包含“棍子”的 processor 其第一个 z-axis grid point 的编号，从 0 开始，跨 processor。 关于 this->startnsz_per 意义的介绍，见辅助阅读材料：Appendix.2 平面波倒空间分发详解。 请自行阅读 PW_Basis::collect_st() 和 PW_Basis::divide_sticks_1() 函数代码： PW_Basis::collect_st()：https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_basis/module_pw/pw_distributeg_method1.cpp#L122 PW_Basis::divide_sticks_1()：https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_basis/module_pw/pw_distributeg_method1.cpp#L247 分发后在 processor 间的广播则显而易见： void PW_Basis::distribution_method1() { .... if (poolrank == 0) this->count_pw_st(st_length2D, st_bottom2D); #ifdef __MPI MPI_Bcast(&this->npwtot, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&this->nstot, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&liy, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&riy, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&lix, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&rix, 1, MPI_INT, 0, this->pool_world); #endif if(poolrank == 0) { #ifdef __MPI .... this->collect_st(st_length2D, st_bottom2D, st_i, st_j, st_length); .... this->divide_sticks_1(st_i, st_j, st_length); .... } #ifdef __MPI MPI_Bcast(st_length2D, this->fftnxy, MPI_INT, 0, this->pool_world); MPI_Bcast(st_bottom2D, this->fftnxy, MPI_INT, 0, this->pool_world); MPI_Bcast(this->nst_per, this->poolnproc, MPI_INT, 0 , this->pool_world); MPI_Bcast(this->npw_per, this->poolnproc, MPI_INT, 0 , this->pool_world); #endif this->npw = this->npw_per[this->poolrank]; this->nst = this->nst_per[this->poolrank]; this->nstnz = this->nst * this->nz; .... 映射表：OOP？ 在倒空间平面波的分发过程中，共建立过四个映射表，分别是 this->fftixy2ip, this->istot2ixy, this->ig2isz 和 this->is2fftixy，其意义分别为： 映射表名称 意义 来源 备注 this->fftixy2ip（同上表） 从“棍子”xy 平面折合坐标到 processor index 的映射，即通过“棍子”所在(x,y)到 processor 的映射，可以用来在 processor 之间 switch PW_Basis::divide_sticks_1()(Link) 折合：索引的 2d->1d：index_folded = x*this->fftny + y;index = x*this->ny + y;折叠：gamma_only 时，实际 fftnx 或 fftny 是 0.5 倍实空间格点数量（nx 或 ny）。 this->istot2ixy 从“棍子”索引到非折叠倒空间折合坐标的映射 PW_Basis::get_istot2ixy()(Link) this->ig2isz 从平面波的 processor 内索引，到其倒空间平移后 z 坐标的映射 PW_Basis::get_ig2isz_is2fftixy(Link) this->is2fftixy 每个 processor 各有一份，建立从 procesor 内“棍子”索引到其折叠后倒空间 xy 平面折合坐标的映射 PW_Basis::get_ig2isz_is2fftixy(Link) 映射表的建立是为了解决实际问题，因此需要思考从建立起来的映射表，可以获得何种信息（processor-local 和 processor-global）。 对其中两个由 rank0 processor 建立的映射表也进行了分发： void PW_Basis::distribution_method1() { .... if(poolrank == 0) { #ifdef __MPI .... this->collect_st(st_length2D, st_bottom2D, st_i, st_j, st_length); .... this->divide_sticks_1(st_i, st_j, st_length); .... this->get_istot2ixy(st_i, st_j); .... #else .... #endif } #ifdef __MPI .... MPI_Bcast(this->fftixy2ip, this->fftnxy, MPI_INT, 0, this->pool_world); MPI_Bcast(this->istot2ixy, this->nstot, MPI_INT, 0, this->pool_world); .... #endif .... } 分发后处理 void PW_Basis::setuptransform() { ModuleBase::timer::tick(this->classname, \"setuptransform\"); this->distribute_r(); this->distribute_g(); this->getstartgr(); .... void PW_Basis::getstartgr() { if(this->gamma_only) this->nmaxgr = ( this->npw > (this->nrxx+1)/2 ) ? this->npw : (this->nrxx+1)/2; else this->nmaxgr = ( this->npw > this->nrxx ) ? this->npw : this->nrxx; this->nmaxgr = (this->nz * this->nst > this->nxy * nplane) ? this->nz * this->nst : this->nxy * nplane; delete[] this->numg; this->numg = new int[poolnproc]; delete[] this->startg; this->startg = new int[poolnproc]; delete[] this->startr; this->startr = new int[poolnproc]; delete[] this->numr; this->numr = new int[poolnproc]; for (int ip = 0;ip numg[ip] = this->nst_per[poolrank] * this->numz[ip]; for (int ip = 0;ip numr[ip] = this->nst_per[ip] * this->numz[poolrank]; this->startg[0] = 0; for (int ip = 1;ip startg[ip] = this->startg[ip-1] + this->numg[ip-1]; this->startr[0] = 0; for (int ip = 1;ip startr[ip] = this->startr[ip-1] + this->numr[ip-1]; } 即 this->numg, this->numr 分别是： 从当前 processor 从实空间 z 方向格点/xy 平面到所有 processors 的倒空间 sticks 的映射数量， 以及当前 processor 从倒空间到所有 processors 所拥有 this->numz，即实空间 z 方向格点/xy 平面数量的映射数量。 this->startg 和 this->startr 则为 this->numg 和 this->numr 的 correspondence 的 starting index。 下面将要调用 PW_Basis::ft:clear() 函数，再之后将和 FFTW 以及 MPI 库进行交互，完成 FFT 操作的准备工作。但至此，所有平面波和实空间格点的分发工作已经完成。 Special topic: utilization of FFTW library in ABACUS void PW_Basis::setuptransform() { .... this->ft.clear(); if(this->xprime) this->ft.initfft(this->nx,this->ny,this->nz,this->lix,this->rix,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); else this->ft.initfft(this->nx,this->ny,this->nz,this->liy,this->riy,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); this->ft.setupFFT(); .... } 暂略 PW_Basis::collect_local_pw() 接下来以一个简单的函数来检验之前的学习效果： void PW_Basis::collect_local_pw() { if(this->npw ig_ggeq0 = -1; // change name of this variable from ig_gge0 to ig_ggeq0 delete[] this->gg; this->gg = new double[this->npw]; delete[] this->gdirect; this->gdirect = new ModuleBase::Vector3[this->npw]; delete[] this->gcar; this->gcar = new ModuleBase::Vector3[this->npw]; ModuleBase::Vector3 f; for(int ig = 0 ; ig npw ; ++ig) { int isz = this->ig2isz[ig]; int iz = isz % this->nz; int is = isz / this->nz; int ixy = this->is2fftixy[is]; int ix = ixy / this->fftny; int iy = ixy % this->fftny; if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; f.x = ix; f.y = iy; f.z = iz; this->gg[ig] = f * (this->GGT * f); this->gdirect[ig] = f; this->gcar[ig] = f * this->G; if(this->gg[ig] ig_ggeq0 = ig; } } 在这个函数里，折合索引的还原分别由 int isz = this->ig2isz[ig]; int iz = isz % this->nz; int is = isz / this->nz; 和 int ixy = this->is2fftixy[is]; int ix = ixy / this->fftny; int iy = ixy % this->fftny; 完成，负数索引的还原则由 if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; 完成。因为当前不同 prcoessor 已经具有不同数量被分发的实空间格点和倒空间格点（即平面波），因此即使每个 processor 执行上述相同的代码内容，其结果也将不相同。 ⚙ 坐标的打包和解包功能可能适合封装成为函数进行调用，或抽象更高级的数据结构，通过重载括号的方式使用。 void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->collect_local_pw(); .... PW_Basis::collect_uniqgg() void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->collect_uniqgg(); .... 这个函数的功能为单调地（递减）存储平面波的模，即对于倒空间中点所对应的平面波的能量，对于包含兼并的情况则只存储一次，分别存放在 tmpgg2 和 gg_uniq 中，而 tmpgg 则是费空间的存储方式：每个平面波都有其对应存储的模长，且一一对应。 void PW_Basis::collect_uniqgg() { if(this->npw ig_gge0 = -1; delete[] this->ig2igg; this->ig2igg = new int [this->npw]; int *sortindex = new int [this->npw]; double *tmpgg = new double [this->npw]; double *tmpgg2 = new double [this->npw]; ModuleBase::Vector3 f; for(int ig = 0 ; ig npw ; ++ig) { int isz = this->ig2isz[ig]; int iz = isz % this->nz; int is = isz / this->nz; int ixy = this->is2fftixy[is]; int ix = ixy / this->fftny; int iy = ixy % this->fftny; if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; f.x = ix; f.y = iy; f.z = iz; tmpgg[ig] = f * (this->GGT * f); if(tmpgg[ig] ig_gge0 = ig; } ModuleBase::GlobalFunc::ZEROS(sortindex, this->npw); ModuleBase::heapsort(this->npw, tmpgg, sortindex); int igg = 0; this->ig2igg[sortindex[0]] = 0; tmpgg2[0] = tmpgg[0]; double avg_gg = tmpgg2[igg]; int avg_n = 1; for (int ig = 1; ig npw; ++ig) { if (std::abs(tmpgg[ig] - tmpgg2[igg]) > 1.0e-8) { tmpgg2[igg] = avg_gg / double(avg_n); ++igg; tmpgg2[igg] = tmpgg[ig]; avg_gg = tmpgg2[igg]; avg_n = 1; } else { avg_n++; avg_gg += tmpgg[ig]; } this->ig2igg[sortindex[ig]] = igg; } tmpgg2[igg] = avg_gg / double(avg_n); this->ngg = igg + 1; delete[] this->gg_uniq; this->gg_uniq = new double [this->ngg]; for(int igg = 0 ; igg ngg ; ++igg) gg_uniq[igg] = tmpgg2[igg]; delete[] sortindex; delete[] tmpgg; delete[] tmpgg2; } 因此调用出平面波模长的方法为 this->gg_uniq[this->ig2igg[ipw]]。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 3 下篇：Introduction to ABACUS: Path to PW calculation - Part 5 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-05 10:45:42 "},"develop-path5.html":{"url":"develop-path5.html","title":"Introduction to ABACUS: Path to PW calculation - Part 5","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 5 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 5 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class 盯紧数据流：Constructor the ESolver_KS() 跟随继承关系，我们从 ESolver_FP 来到 ESolver_KS，之后我们还会进入下一层 ESolver_KS_PW。和之前一样，我们仍然需要关心从 ESolver_FP 到 ESolver_KS，多了哪些数据成员，数据成员在何时被分配内存，何时拥有具体数值，对之后理解程序的整体流程控制十分重要。 check 头文件中数据成员的声明，并且牢记父类的各成员也在当前类中存在： namespace ModuleESolver { template class ESolver_KS : public ESolver_FP { public: ....// constructor and destructor declarations omitted // present class parent class inherited // （will not re-introduce here） double scf_thr; ModulePW::PW_Basis* pw_rho; double drho; ModulePW::PW_Basis_Big* pw_big; int maxniter; elecstate::ElecState* pelec = nullptr; int niter; Charge chr; bool conv_elec; ModuleSymmetry::Symmetry symm; int out_freq_elec; psi::Psi>* psi = nullptr; psi::Psi* psid = nullptr; Structure_Factor sf; K_Vectors kv; ....// member function(s) omitted protected: hsolver::HSolver* phsol = nullptr; hamilt::Hamilt* p_hamilt = nullptr; ModulePW::PW_Basis_K* pw_wfc = nullptr; Charge_Mixing* p_chgmix = nullptr; wavefunc wf; Charge_Extra CE; std::string basisname; 从构造函数中查看哪些量被初始化： namespace ModuleESolver { template ESolver_KS::ESolver_KS() { .... scf_thr = GlobalV::SCF_THR; drho = 0.0; maxniter = GlobalV::SCF_NMAX; niter = maxniter; out_freq_elec = GlobalV::OUT_FREQ_ELEC; pw_wfc = new ModulePW::PW_Basis_K_Big(GlobalV::device_flag, GlobalV::precision_flag); ModulePW::PW_Basis_K_Big* tmp = static_cast(pw_wfc); tmp->setbxyz(INPUT.bx,INPUT.by,INPUT.bz); p_chgmix = new Charge_Mixing(); p_chgmix->set_rhopw(this->pw_rho); p_chgmix->set_mixing(INPUT.mixing_mode, INPUT.mixing_beta, INPUT.mixing_ndim, INPUT.mixing_gg0, INPUT.mixing_tau); if (std::abs(INPUT.mixing_beta + 10.0) need_auto_set(); this->wf.init_wfc = INPUT.init_wfc; this->wf.mem_saver = INPUT.mem_saver; this->wf.out_wfc_pw = INPUT.out_wfc_pw; this->wf.out_wfc_r = INPUT.out_wfc_r; } 因此当调用 ESolver_KS::ESolver_KS() 时，除了父类中各函数会被初始化外，另有 wavefunc 类 wf、Charge_Extra 类 CE 被初始化并分配内存，此外还有 hsolver::HSolver 类 phsol、hamilt::Hamilt 类 p_hamilt、ModulePW::PW_Basis_K 类 pw_wfc、Charge_Mixing 类 p_chgmix 指针被创建。在执行构造函数过程中，有 pw_wfc、p_chgmix 被分配内存，因此调用其构造函数。 wavefunc 类数据成员 在头文件中初始化值 在构造函数中初始化值 allocate out_wfc_pw out_wfc_r 0 init_wfc, mem_saver R, Rmax Charge_Extra 类数据成员 在头文件中初始化值 在构造函数中初始化值 istep 0 pot_order, rho_extr dis_old1, dis_old2, dis_now nulltpr alpha,beta ⚙ 两类均基本没有数据成员在对象建立时被赋值。然而通过上面代码块第 23-26 行可以发现，wavefunc 类 wf 的数据成员直接可以被访问，直接导入（拷贝）Input 类对象 INPUT 的数据成员，即 wavefunc 类的数据成员处于直接暴露的状态，这违反了封装理念。更好一点的做法是为每个类建立 getter 和 setter 函数，通过此两者来访问和修改成员变量，但更多的封装理念此处不再赘述。 接下来我们对 ESolver_KS() 中的其他操作以及其具体结果进行介绍。 Constructor the ModulePW::PW_Basis_K_Big() ModulePW::PW_Basis_K_Big 类的构造函数进行过一次重载，此时调用的版本为重载版本。在重载版本中，完全为继承 PW_Basis 的构造函数对应版本，但内容简单： namespace ModulePW { class PW_Basis_Big: public PW_Basis { public: .... PW_Basis_Big(std::string device_, std::string precision_) : PW_Basis(device_, precision_) {} namespace ModulePW { .... PW_Basis::PW_Basis(std::string device_, std::string precision_) : device(std::move(device_)), precision(std::move(precision_)) { classname=\"PW_Basis\"; this->ft.set_device(this->device); this->ft.set_precision(this->precision); } void FFT::set_device(std::string device_) { this->device = std::move(device_); } void FFT::set_precision(std::string precision_) { this->precision = std::move(precision_); } Constructor the Charge_Mixing() 我们按照相同路数查看 Charge_Mixing 类的构造函数： Charge_Mixing::Charge_Mixing() { rstep = 0; dstep = rstep - 1; initp = false; initb = false; } 以及其所属类的指针 p_chgmix 的相关调用操作： p_chgmix = new Charge_Mixing(); p_chgmix->set_rhopw(this->pw_rho); p_chgmix->set_mixing(INPUT.mixing_mode, INPUT.mixing_beta, INPUT.mixing_ndim, INPUT.mixing_gg0, INPUT.mixing_tau); // using bandgap to auto set mixing_beta if (std::abs(INPUT.mixing_beta + 10.0) need_auto_set(); else if (INPUT.mixing_beta > 1.0 || INPUT.mixing_beta Charge_mixing::set_rhopw() 函数的操作十分简单，即从括号中形参复制到自己的成员变量 Charge_mixing::rhopw 中，其中形参类型被指定为 ModulePW::PW_Basis*。 void Charge_Mixing::set_rhopw(ModulePW::PW_Basis* rhopw_in) { this->rhopw = rhopw_in; } void Charge_Mixing::set_mixing(const std::string &mixing_mode_in, const double &mixing_beta_in, const int &mixing_ndim_in, const double &mixing_gg0_in, const bool &mixing_tau_in) { this->mixing_mode = mixing_mode_in; this->mixing_beta = mixing_beta_in; this->mixing_ndim = mixing_ndim_in; this->mixing_gg0 = mixing_gg0_in; //mohan add 2014-09-27 this->mixing_tau = mixing_tau_in; .... } 而因为在 module_io/input.cpp 中有 INPUT.mixing 初始化为-10，因此 if 判断中的满足意味着默认值未被修改，因而调用 Charge_mixing::need_auto_set()，将 Charge_mixing::autoset 置为 true。 void Charge_Mixing::need_auto_set() { this->autoset = true; } Trigger: ESolver_KS::Init() template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { ESolver_FP::Init(inp,ucell); ucell.cal_nelec(GlobalV::nelec); XC_Functional::set_xc_type(ucell.atoms[0].ncpp.xc_func); .... this->kv.set(this->symm, GlobalV::global_kpoint_card, GlobalV::NSPIN, ucell.G, ucell.latvec); .... if(GlobalV::BASIS_TYPE==\"pw\" || GlobalV::CALCULATION==\"get_wf\") { #ifdef __MPI this->pw_wfc->initmpi(GlobalV::NPROC_IN_POOL, GlobalV::RANK_IN_POOL, POOL_WORLD); #endif this->pw_wfc->initgrids(inp.ref_cell_factor * ucell.lat0, ucell.latvec, this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz); this->pw_wfc->initparameters(false, inp.ecutwfc, this->kv.nks, this->kv.kvec_d.data()); #ifdef __MPI if(INPUT.pw_seed > 0) { MPI_Allreduce(MPI_IN_PLACE, &this->pw_wfc->ggecut, 1, MPI_DOUBLE, MPI_MAX , MPI_COMM_WORLD); } #endif this->pw_wfc->setuptransform(); for (int ik = 0; ik kv.nks; ++ik) this->kv.ngk[ik] = this->pw_wfc->npwk[ik]; this->pw_wfc->collect_local_pw(); .... } GlobalC::Pgrid.init(this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz, this->pw_rho->nplane, this->pw_rho->nrxx, pw_big->nbz, pw_big->bz); this->sf.setup_structure_factor(&GlobalC::ucell, this->pw_rho); CE.Init_CE(GlobalC::ucell.nat); } 首先调用了两函数，以 UnitCell::cal_nelec() 计算体系中总电子数，并存储在 GlobalV::nelec，以及 XC_Functional::set_xc_type() 根据输入文件中设置参数，为三个泛函相关量（XC_Functional::func_id, XC_Functional::func_type 和 XC_Functional::use_libxc）进行赋值，见 source/module_hamilt_general/module_xc/xc_funtional.cpp: line 26（Link）。 变量 数据类型 描述 XC_Functional::func_id std::vector 首先将交换泛函压入，然后是关联泛函。预先通过宏对每种泛函和整数间进行对应，见 source/module_hamilt_general/module_xc/xc_funcs.h（Link） XC_Functional::func_type int LDA: 1; GGA: 2; meta-GGA: 3; hybrid GGA: 4; hybrid meta-GGA: 5 XC_Functional::use_libxc bool 因 Symmetry::analy_sys()功能尚未完全部署，暂时跳过。 波函数 k 点采样：K_Vectors::set() 在一般的第一性原理软件中，或对建模为周期性体系（认定其中包含平移对称性的体系）而言，平移对称性决定了\\mathbf{k}是量子数之一，因此为区分态，并且计算态，k 点采样对于准确计算体系的性质尤为重要（尽量准确计算占据态），但这一 k 点所对应\\mathbf{k}需要和原本用于展开波函数的平面波基其\\mathbf{G}加以区分：\\mathbf{G}（通过 ecut 决定）只能决定当前待求波函数的精度，但还并不能决定当前体系的性质能否计算准确。回顾 Bloch 定理，在 k 点\\mathbf{k}，第 n 个能级在实空间坐标表象下的波函数为： \\psi_{\\text{n}\\mathbf{k}}(\\mathbf{r})=e^{i\\mathbf{k}\\cdot\\mathbf{r}}u_{\\text{n}\\mathbf{k}}(\\mathbf{r}) 平面波基的\\mathbf{G}出现在 Bloch 调幅函数u_{\\text{n}\\mathbf{k}}(\\mathbf{r})中： u_{\\text{n}\\mathbf{k}}(\\mathbf{r})=\\sum_{\\mathbf{G}}c_\\mathbf{G}^{(\\text{n}\\mathbf{k})}e^{i\\mathbf{G}\\cdot\\mathbf{r}}。 老生常谈，平移对称性实际上是指\\psi_{\\text{n}\\mathbf{k}}(\\mathbf{r}+n\\mathbf{a})=\\psi_{\\text{n}\\mathbf{k}}(\\mathbf{r})，则\\psi_{\\text{n}\\mathbf{k}}(\\mathbf{r}+n\\mathbf{a})=e^{i\\mathbf{k}\\cdot(\\mathbf{r}+n\\mathbf{a})}u_{\\text{n}\\mathbf{k}}(\\mathbf{r}+n\\mathbf{a})。认定 Bloch 函数必有该性质，则实际上需要满足： 2N\\pi=n(\\mathbf{k}\\cdot\\mathbf{a}), 一维：2N\\pi/n|\\mathbf{a}|=|\\mathbf{k}| 因此不同 k 点的考虑实际是在考虑体系的不同平移对称性。当 k 点采样无穷多时，即等同于考虑体系（波函数）的所有平移对称性。 void K_Vectors::set(const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { .... this->nspin = nspin_in; if(this->nspin==4) this->nspin = 1;//zhengdy-soc .... bool read_succesfully = this->read_kpoints(k_file_name); #ifdef __MPI Parallel_Common::bcast_bool(read_succesfully); #endif if(!read_succesfully) {....} std::string skpt1=\"\"; std::string skpt2=\"\"; if(!berryphase::berry_phase_flag && ModuleSymmetry::Symmetry::symm_flag != -1) { bool match = true; this->ibz_kpoint(symm, ModuleSymmetry::Symmetry::symm_flag, skpt1, GlobalC::ucell, match); #ifdef __MPI Parallel_Common::bcast_bool(match); #endif if (!match) {....} if (ModuleSymmetry::Symmetry::symm_flag || is_mp) { this->update_use_ibz(); this->nks = this->nkstot = this->nkstot_ibz; } } this->set_both_kvec(reciprocal_vec, latvec, skpt2); if(GlobalV::MY_RANK==0) {....} int deg = 0; if(GlobalV::NSPIN == 1) deg = 2; else if(GlobalV::NSPIN == 2||GlobalV::NSPIN==4) deg = 1; else ModuleBase::WARNING_QUIT(\"K_Vectors::set\", \"Only available for nspin = 1 or 2 or 4\"); this->normalize_wk(deg); GlobalC::Pkpoints.kinfo(nkstot); #ifdef __MPI this->mpi_k(); #endif this->set_kup_and_kdw(); this->print_klists(GlobalV::ofs_running); } k 点生成：K_Vectors::read_kpoints()及变量赋值回溯复习 来到 K_Vectors::read_kpoints() 函数，对于前三条件判断，第一则为让非 rank0 processors 退出该函数， bool K_Vectors::read_kpoints(const std::string &fn) { ModuleBase::TITLE(\"K_Vectors\", \"read_kpoints\"); if (GlobalV::MY_RANK != 0) return 1; .... if(GlobalV::GAMMA_ONLY_LOCAL) { .... } else if (GlobalV::KSPACING[0] > 0.0) { .... 第二和三涉及 GlobalV 中相关参数，按照 Introduction to ABACUS: Path to PW calculation - Part 1 相同方法进行变量赋值回溯，举例对于 GlobalV::GAMMA_ONLY_LOCAL: 首先鼠标右键拉取菜单，选择“查找所有引用”， 仔细检查侧边栏 Vscode 给出引用查找结果 基于我们当前对 ABACUS 工作流的了解，单击左侧 input_conv.cpp 文件后，跳转到 input_conv.cpp 相关行（line 328）： 证明此参数可能也在 Input 类方法中被读取。切换到文件浏览器侧边栏后直接打开 input.cpp，查找 \"gamma_only_local\" 相关内容： 寻得有效赋值操作： 寻找何时有 “gamma_only == 1” 条件： 然而，并非只要将 gamma_only 关键词在 INPUT 文件中置为 true 即可，因为在 line 2350，实际上 pw 基不支持该参数，因此对于 esolver_type == esolver_ks_pw 的情况，gamma_only 为 false 而 gamma_only_local 也从未改变其默认值 false。 类似地我们回溯 GlobalV::kspacing[3]，发现在 input.cpp 中有： Full List of INPUT Keywords ‒ ABACUS documentation 图 1. 善用Ctrl+F 即如果指定了一个值，则 kspacing[1] 和 kspacing[2] 拥有和 kspacing[0] 相同值，若定义三个值，则三个值各不相同，通过 Input::read_kspacing() 实现。定义值后，将覆盖写入 KPT 文件，因此在之后的读取过程中读入的结果其实是刚刚写的结果。 从 examples 文件夹中，可以知道 KPT 文件可能具有的格式，以及在当前函数中会被读取到何变量中。 examples/scf/pw_Si2/INPUT 和 KPT: INPUT_PARAMETERS #Parameters (General) pseudo_dir ../../../tests/PP_ORB symmetry 1 #Parameters (Accuracy) basis_type pw ecutwfc 60 scf_thr 1e-8 scf_nmax 100 K_POINTS 0 Gamma 4 4 4 0 0 0 examples/band/pw_Al/INPUT1 和 KPT: INPUT_PARAMETERS #Parameters (General) pseudo_dir ../../../tests/PP_ORB calculation scf ntype 1 symmetry 0 #Parameters (Methos) basis_type pw ecutwfc 50 scf_thr 1.0e-8 // about iteration scf_nmax 100 smearing_method gauss smearing_sigma 0.01 #Parameters (File) out_chg 1 K_POINTS 0 Gamma 4 4 4 0 0 0 examples/band/pw_Al/INPUT2 和 KLINES（❗ 注意，此时 kpoint_file 参数被赋予 KLINES）: INPUT_PARAMETERS #Parameters (General) kpoint_file KLINES pseudo_dir ../../../tests/PP_ORB calculation nscf ntype 1 symmetry 0 #Parameters (Methos) ecutwfc 50 basis_type pw pw_diag_thr 1e-10 pw_diag_nmax 100 #Parameters (Accuracy) smearing_method gauss smearing_sigma 0.01 #Parameters (File) init_chg file out_band 1 K_POINTS 8 Line 0.0 0.0 0.0 20 0.5 -0.5 0.5 20 0.0 0.0 0.5 20 0.0 0.0 0.0 20 0.25 0.25 0.25 20 0.5 -0.5 0.5 1 0.25 0.25 0.25 20 0.0 0.0 0.5 1 相应地从 klist.cpp line 230（Link）开始，是读取 KPT 文件的相关行。在这里，我们并不逐行解读可读性强，容易理解的代码，而是将可能的情况汇总于下表： K_Vector 类中数据成员 KPT 文件中位置（行数） 取值 k_nkstot 2 0 >0, Depending on exact data kword 3 \"Gamma\" \"Monkhorst-Pack\" \"Cartesian\" \"Direct\" \"Line_Cartesian\" \"Line_Direct\"/“Line” is_mp true true false(default) false(default) false(default) false(default) k_type 0 1 nmp 4 Depending on exact data Depending on exact data koffset 4 Depending on exact data Depending on exact data k 点手动指定模式：[i]: 第 i-1 个 k 点的索引，其中 i 的取值范围由 nkstot 决定，在 KPT 文件中则从第 2 行读取。 kvec_c[i].x/y/z ≥4 Depending on exact data Depending on exact data kvec_d[i].x/y/z ≥4 K_Vectors::Monkhorst_Pack() generated K_Vectors::Monkhorst_Pack() generated Depending on exact data Depending on exact data wk[i] ≥4 K_Vectors::Monkhorst_Pack()generated K_Vectors::Monkhorst_Pack()generated Depending on exact data Depending on exact data 1.0 1.0 kc_done false(defalult) false(default) true true kd_done true true true true nkstot nmp[0]*nmp[1]*nmp[2] nmp[0]*nmp[1]*nmp[2] Depending on exact data Depending on exact data Depending on exact data Depending on exact data nk nkstot nkstot nkstot nkstot nkstot nkstot 备注 斜体变量实际为被 K_Vectors::Monkhorst_Pack() 函数赋值 \"Monkhorst-Pack\" 和 \"Gamma\" 方式对 k 空间采样： 图 2. klist.cpp line 486: K_Vectors::Monkhorst_Pack_formula(), k_type = 0 and 1 以这两种采样方式所给定的在 this->kvec_d 数组中存储顺序： 图 3. klist.cpp line 520: const int i = mpnx * mpny * (z - 1) + mpnx * (y - 1) + (x - 1) k 点归约、后处理与并行同步 归约：K_Vectors::ibz_kpoint() 在按照一定方法（Monkhorst-Pack、直接给定 k 点、Kpath）采样 k 点之后，需要根据对称性减少 k 点数量，使得计算量减少。对称操作可以使得 k vector 发生置换，或使得 k vector 不变。 void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... ModuleBase::Vector3 gb1(ucell.G.e11, ucell.G.e12, ucell.G.e13); ModuleBase::Vector3 gb2(ucell.G.e21, ucell.G.e22, ucell.G.e23); ModuleBase::Vector3 gb3(ucell.G.e31, ucell.G.e32, ucell.G.e33); ModuleBase::Vector3 gk1(gb1.x / nmp[0], gb1.y / nmp[0], gb1.z / nmp[0]); ModuleBase::Vector3 gk2(gb2.x / nmp[1], gb2.y / nmp[1], gb2.z / nmp[1]); ModuleBase::Vector3 gk3(gb3.x / nmp[2], gb3.y / nmp[2], gb3.z / nmp[2]); ModuleBase::Matrix3 gk(gk1.x, gk1.y, gk1.z, gk2.x, gk2.y, gk2.z, gk3.x, gk3.y, gk3.z); .... bool include_inv = false; std::vector kgmatrix(48 * 2); ModuleBase::Matrix3 inv(-1, 0, 0, 0, -1, 0, 0, 0, -1); ModuleBase::Matrix3 ind(1, 0, 0, 0, 1, 0, 0, 0, 1); .... int nrotkm; if (use_symm) {....} else if (is_mp) { nrotkm = 2; kgmatrix[0] = ind; kgmatrix[1] = inv; } ModuleBase::Matrix3* kkmatrix = new ModuleBase::Matrix3 [nrotkm]; symm.gmatrix_convert(kgmatrix.data(), kkmatrix, nrotkm, ucell.G, gk); .... void Symmetry::gmatrix_convert(const ModuleBase::Matrix3* sa, ModuleBase::Matrix3* sb, const int n, const ModuleBase::Matrix3 &a, const ModuleBase::Matrix3 &b)const { ModuleBase::Matrix3 ai = a.Inverse(); ModuleBase::Matrix3 bi = b.Inverse(); for (int i=0;i Symmetry::gmatrix_convert() 函数为对称操作在 3 维空间的矩阵表象进行变换，该函数可以写为如下形式： BA^{-1}O_iAB^{-1}=(AB^{-1})^{-1}O_i(AB^{-1}), i=1,2 O_1=\\begin{pmatrix} 1 &0 &0 \\\\ 0 &1 &0 \\\\ 0 &0 &1 \\end{pmatrix}, O_2=\\begin{pmatrix} -1 &0 &0 \\\\ 0 &-1 &0 \\\\ 0 &0 &-1 \\end{pmatrix} A=\\frac{\\text{lat}_0}{2\\pi}\\begin{pmatrix} b_{11}&b_{12}&b_{13}\\\\ b_{21}&b_{22}&b_{23}\\\\ b_{31}&b_{32}&b_{33} \\end{pmatrix}, B=\\frac{\\text{lat}_0}{2\\pi}\\begin{pmatrix} b_{11}/\\text{nk}_1&b_{12}/\\text{nk}_1&b_{13}/\\text{nk}_1\\\\ b_{21}/\\text{nk}_2&b_{22}/\\text{nk}_2&b_{23}/\\text{nk}_2\\\\ b_{31}/\\text{nk}_3&b_{32}/\\text{nk}_3&b_{33}/\\text{nk}_3 \\end{pmatrix}, AB^{-1}=\\begin{pmatrix} \\text{nk}_1&0&0\\\\ 0&\\text{nk}_2&0\\\\ 0&0&\\text{nk}_3\\\\ \\end{pmatrix} ，where b_{ij} is the j-th component of i-th canonically defined reciprocal vector. In principle \\mathbf{a}_i\\cdot\\mathbf{b}_j=2\\pi\\delta_{ij}, but the G (ucell.G) defined here is latvec.inverse().transpose(), where every element is rescaled by factor 1/lat0, therefore the multiplication between G and latvec cannot obtain 2\\pi but 1. Actually matrix A can relate to B directly via: TA=B, where T matrix is, \\begin{pmatrix} 1/\\text{nk}_1&0&0\\\\ 0&1/\\text{nk}_2&0\\\\ 0&0&1/\\text{nk}_3\\\\ \\end{pmatrix} if (!use_sym), kkmatrix[0]= (AB^{-1})^{-1}O_1(AB^{-1})= \\begin{pmatrix} 1/\\text{nk}_1&0&0\\\\ 0&1/\\text{nk}_2&0\\\\ 0&0&1/\\text{nk}_3\\\\ \\end{pmatrix}\\begin{pmatrix} 1 &0 &0 \\\\ 0 &1 &0 \\\\ 0 &0 &1 \\end{pmatrix}\\begin{pmatrix} \\text{nk}_1&0&0\\\\ 0&\\text{nk}_2&0\\\\ 0&0&\\text{nk}_3\\\\ \\end{pmatrix}\\\\ =\\begin{pmatrix} 1 &0 &0 \\\\ 0 &1 &0 \\\\ 0 &0 &1 \\end{pmatrix} if (!use_sym), kkmatrix[1]= (AB^{-1})^{-1}O_2(AB^{-1})= \\begin{pmatrix} 1/\\text{nk}_1&0&0\\\\ 0&1/\\text{nk}_2&0\\\\ 0&0&1/\\text{nk}_3\\\\ \\end{pmatrix}\\begin{pmatrix} -1 &0 &0 \\\\ 0 &-1 &0 \\\\ 0 &0 &-1 \\end{pmatrix}\\begin{pmatrix} \\text{nk}_1&0&0\\\\ 0&\\text{nk}_2&0\\\\ 0&0&\\text{nk}_3\\\\ \\end{pmatrix}\\\\ =\\begin{pmatrix} -1 &0 &0 \\\\ 0 &-1 &0 \\\\ 0 &0 &-1 \\end{pmatrix} 即实际上对于 is_mp 但 !use_symm 的情况，kgmatrix 和 kkmatrix 中内容相同。在当前情况，ucell.G=A，gk=B， ucell.G*gk.Inverse()=AB^{-1}, =A(TA)^{-1}=AA^{-1}T^{-1}=\\begin{pmatrix} \\text{nk}_1&0&0\\\\ 0&\\text{nk}_2&0\\\\ 0&0&\\text{nk}_3\\\\ \\end{pmatrix} gk*ucell.G.Inverse()=BA^{-1}, =TAA^{-1}=\\begin{pmatrix} 1/\\text{nk}_1&0&0\\\\ 0&1/\\text{nk}_2&0\\\\ 0&0&1/\\text{nk}_3\\\\ \\end{pmatrix} 对于当前所考虑的最简单情况，!use_sym，使得原本采样 k 点坐标（或矢量）由 reciprocal space（kvec_d: k vector in Direct coordinate）变化到 k-lattice space（kvec_d_k: k vector in Direct coordinate transformed in k lattice space）： void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... for (int i=0;i 图 4. 1-dimensional example 图 5. 2-dimensional example k 点归约通过 C++11 开始支持的匿名函数实现： void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... /// @brief PBC, wrap kvec_d into [-0.5, 0.5) auto restrict_kpt = [&symm](ModuleBase::Vector3 &kvec){ // in (-0.5, 0.5] kvec.x = fmod(kvec.x + 100.5-0.5*symm.epsilon, 1)-0.5+0.5*symm.epsilon; kvec.y = fmod(kvec.y + 100.5-0.5*symm.epsilon, 1)-0.5+0.5*symm.epsilon; kvec.z = fmod(kvec.z + 100.5-0.5*symm.epsilon, 1)-0.5+0.5*symm.epsilon; // in [0, 1) // kvec.x = fmod(kvec.x + 100 + symm.epsilon, 1) - symm.epsilon; // kvec.y = fmod(kvec.y + 100 + symm.epsilon, 1) - symm.epsilon; // kvec.z = fmod(kvec.z + 100 + symm.epsilon, 1) - symm.epsilon; if(std::abs(kvec.x) 之后遍历当前体系所具有的所有对称操作，记录新的 k vector（记为 kvec_rot_k）。可以预见，不管是在 k-lattice space 还是 reciprocal space，对称操作应当一致，即 k-lattice space vector 经对称操作后转换回到 reciprocal space 后，应当与直接在 reciprocal space 的 k vector 经历对称操作后结果（kvec_rot）严格相等： void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... for (int i = 0; i 之后匹配已经记录的 kvec_d（在变量 kvec_d_ibz 中，std::vector<> 容器），如果是新的则记录，如果是旧的则提高 k 点权重，用于后续计算需要 k 点平均的物理量。k 点归约部分的程序框图大致如下： 经过 k 点归约，下列变量数据成员的值被改变： 修改变量 意义 this->nkstot_ibz i:irreducible，即当前不可约布里渊区中 k 点数量，小于等于 this->nkstot this->kvec_d_ibz Direct 坐标下的 k 点坐标（归约后） this->wk_ibz 归约后 k 点坐标权重 this->ibz2bz 索引映射，从归约后 k 点索引到归约前。归约后存储在 this->kvec_d_ibz，而归约前存储在 this->kvec_d，可以通过 this->kvec_d[ibz2bz[index1]] 访问到归约前，内容应当相同，也可直接访问到 Cartesian：this->kvec_c[ibz2bz[index1]] 归约前，各 k 点权重均为\\frac{1}{\\text{nkstot}}，归约后则各不可约 k 点权重值需乘简并度： void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... for (int k=0; knkstot_ibz; ++k) { if ( symm.equal(kvec_rot.x, this->kvec_d_ibz[k].x) && symm.equal(kvec_rot.y, this->kvec_d_ibz[k].y) && symm.equal(kvec_rot.z, this->kvec_d_ibz[k].z)) { already_exist = true; this->wk_ibz[k] += weight; exist_number = k; break; } } 该函数的具体实现请自主阅读（Link）。 后处理：K_Vectors::update_use_ibz() 然而到达上层函数 K_Vectors::set(): line 105 后，以下量被更新： 被更新变量 具体值 this->nkstot this->nkstot_ibz this->kvec_d this->kvec_d_ibz this->wk this->wk_ibz this->kd_done true this->kc_done false ⚙ 如此一来 this->*_ibz 不应当为成员变量，而是应该在更新左列各量后销毁。 void K_Vectors::update_use_ibz( void ) { if (GlobalV::MY_RANK!=0) return; ModuleBase::TITLE(\"K_Vectors\",\"update_use_ibz\"); assert( nkstot_ibz > 0 ); this->nkstot = this->nkstot_ibz; ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running,\"nkstot now\",nkstot); this->kvec_d.resize(this->nkstot * nspin); for (int i = 0; i nkstot; ++i) { this->kvec_d[i] = this->kvec_d_ibz[i]; this->wk[i] = this->wk_ibz[i]; } this->kd_done = true; this->kc_done = false; return; } 可见该任务仍然只分配给 rank0 processor 去处理（之后在 K_Vectors::mpi_k() 函数进行广播）。之后同步 this->kvec_c 和 this->kvec_d。❗ 对于 kvec_d 已知而 kvec_d 未知的情况，对其进行了数值噪声的简单处理。而对于 kvec_c 已知而 kvec_d 为止的情况则并没有处理： void K_Vectors::set(const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { .... this->set_both_kvec(reciprocal_vec, latvec, skpt2); .... int deg = 0; if(GlobalV::NSPIN == 1) deg = 2; else if(GlobalV::NSPIN == 2||GlobalV::NSPIN==4) deg = 1; else .... .... void K_Vectors::set_both_kvec(const ModuleBase::Matrix3 &G, const ModuleBase::Matrix3 &R,std::string& skpt) { .... if (!kc_done && kd_done) { for (int i = 0;i 而对于更一般的，科学计算软件编写过程中需要注意的各种数值噪声、精度损失问题，见（文档缺失）。 分发与并行同步：K_Vectors::mpi_k() 生成、归约并进行过简单的 k 点后处理后，接下来对 k 点进行分发（记住 k 点的 MPI 并行在平面波基矢量下是比平面波并行和能带数并行更有效的并行方式，因为每个 k 点的 Kohn-Sham 方程求解基本都是独立的，所以并行效率较高）。 void K_Vectors::set(const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { .... this->normalize_wk(deg); GlobalC::Pkpoints.kinfo(nkstot); #ifdef __MPI this->mpi_k(); #endif 在调用 GlobalC::Pkpoints.kinfo(nkstot) 及 K_Vectors::mpi_k() 函数，以对当前已经读取和建立的相关数据成员在 processors 间进行广播之前，还经过了 this->wk 的重新归一化过程（函数 K_Vectors::normalize_wk()），由于只涉及具体数值而不涉及分发，因此将在下一节介绍。首先只关注分发。如前所述，由于 Parallel_Kpoints 类对象 PKpoints 是全局变量，因此可以直接调用其函数 Parallel_Kpoints::kinfo()。 void Parallel_Kpoints::kinfo(int &nkstot) { #ifdef __MPI Parallel_Common::bcast_int(nkstot); this->get_nks_pool(nkstot); this->get_startk_pool(nkstot); this->get_whichpool(nkstot); #endif return; } Parallel_Kpoints::kinfo() 函数完成三步骤的处理（由于已经完成过平面波的分发代码阅读，此处代码比较简单，故略过。Link）： （Parallel_Kpoints::get_nks_pool()）计算每个 processor/pool 所承担的 k 点数量。让每个 processor 都具有一份 nkstot 的拷贝，之后调用 Parallel_Kpoints::get_nks_pool() 进行计算。和平面波类似地，只不过此处 k point 并行方式为通过用户指定 KPAR 参数，之后以均分为基本原则，但对前 remain 个 processors 多分一个 k 点，即“getnks（of each）pool()”，分得 k 点数量记录在 Parallel_Kpoints::nks_pool 数组中，其中索引 runs over GlobalV::KPAR。 （Parallel_Kpoints::get_startk_pool()）计算每个 processor 对 k 点进行索引的连续编号，之后存储在 Parallel_Kpoints::startk_pool 中，索引仍然 runs over GlobalV::KPAR。 （Parallel_Kpoints::get_whichpool()）whichpool 是 Parallel_Kpoints 类内一个数据成员，其索引 runs over 所有 k 点。this->whichpool 提供了从 k 点可以找到对应 processor 的功能。 然后来到 K_Vectors::mpi_k() 函数。 #ifdef __MPI void K_Vectors::mpi_k(void) { .... Parallel_Common::bcast_bool(kc_done); Parallel_Common::bcast_bool(kd_done); Parallel_Common::bcast_int(nspin); Parallel_Common::bcast_int(nkstot); Parallel_Common::bcast_int(nmp, 3); Parallel_Common::bcast_double(koffset, 3); this->nks = GlobalC::Pkpoints.nks_pool[GlobalV::MY_POOL]; int nks_minimum = this->nks; Parallel_Reduce::gather_min_int_all( nks_minimum ); .... std::vector isk_aux(nkstot); std::vector wk_aux(nkstot); std::vector kvec_c_aux(nkstot*3); std::vector kvec_d_aux(nkstot*3); if (GlobalV::MY_RANK == 0) { for (int ik = 0;ik renew(this->nks * this->nspin); int k_index = 0; for (int i = 0;i 该函数第 12 行为每个 processor 分配了一定数量的 k 点，❗ 注意，此时每个 processor 的 K_Vectors::nks 的数量已经不同。之后在第 41 行，已经按照 this->nks*this->nspin 大小 resize 数组，而非原本的 this->nkstot*this->nspin。K_Vectors::mpi_k() 函数运行结束时，各 processor 已经拥有数量和内容不相同的 this->isk, this->wk, this->kvec_d 以及 this->kvec_c。即分配的 processor-特征变量是直接的 k 点坐标。 Unrestricted Kohn-Sham (UKS) case 贯穿刚刚的过程我们默认了只关心 RKS，即 Restricted Kohn-Sham scheme，对于非限制性情况（即不限制两自旋 channel 必须具有相同空间轨道）却丝毫未提及，仅在 K_Vectors::set() 函数的一开始见过对于 noncolinear 情况，设置 nspin 由 4 到 1。特别地，对于更加一般的情况，nspin=2 是最基本和常见的 scheme。 在归一化 this->wk 的过程中，对于不同数量的 spin-channel 已经具有不同的策略： void K_Vectors::set( const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { .... int deg = 0; if(GlobalV::NSPIN == 1) deg = 2; } else if(GlobalV::NSPIN == 2||GlobalV::NSPIN==4) deg = 1; .... this->normalize_wk(deg); void K_Vectors::normalize_wk(const int &degspin) { if(GlobalV::MY_RANK!=0) return; double sum = 0.0; for (int ik = 0;ik wk[ik]; .... for (int ik = 0;ik wk[ik] /= sum; for (int ik = 0;ik wk[ik] *= degspin; } 在一开始对 this->kvec_c、this->kvec_d、this->wk 等量就进行过 nspin 相关的内存空间分配： void K_Vectors::set(const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { //K_Vectors::set(): line 69 this->nspin = nspin_in; .... if(this->nspin==4) { this->nspin = 1;//zhengdy-soc } 导入 nspin 到 this->nspin 之后，在 K_Vectors::read_kpoints() 函数中对 this->kvec_c, this->kvec_d, this->wk, this->isk, this->ngk 共四个 std::vector> 类数据成员调用 std::vector::resize() 函数。而在先前的 k 点坐标导入中，无论是哪种方式，均只存储在第一个 spin channel 中，即前 nkstot 或前 nkstot_ibz 个元素中，直到 K_Vectors::set_kup_and_kdw() 函数，才对第二个 spin channel 进行设置（简单对第一个 spin channel 的 k vectors 进行复制）。 void K_Vectors::set_kup_and_kdw(void) { switch (nspin) { case 1: for (int ik = 0; ik isk[ik] = 0; break; case 2: for (int ik = 0; ik kvec_c[ik+nks] = kvec_c[ik]; this->kvec_d[ik+nks] = kvec_d[ik]; this->wk[ik+nks] = wk[ik]; this->isk[ik] = 0; this->isk[ik+nks] = 1; } this->nks *= 2; this->nkstot *= 2; break; case 4: for (int ik = 0; ik isk[ik] = 0; break; } } 发现实际上对于 nspin=2 的情况，this->kvec_c, kvec_d, wk 三个数据均 alpba 和 beta spin-channel 内容相同，但靠 this->isk 来区分是哪种自旋。⚙ 但其实已经不存在 nspin=4 的情况，因为在 K_Vectors::set() 中，nspin=1 和 nspin=4 效果相同。 跳过 Print_Info::setup_parameters() 的信息输出，下一篇内容将直接到平面波基波函数的初始化。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 4 下篇：Introduction to ABACUS: Path to PW calculation - Summary 1 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-04 23:18:07 "},"develop-sm1.html":{"url":"develop-sm1.html","title":"Introduction to ABACUS: Path to PW calculation - Summary 1","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Summary 1 作者：黄一珂，邮箱：huangyk@aisi.ac.cn；金祖鑫，邮箱：jinzx@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Summary 1 &#x1F3EE;写在前面 经过 Introduction to ABACUS: Path to PW calculation 的 Part1 到 5，我们已经阅读过上百行程序。在继续之前，有必要将已经解读过的内容再次就重点进行回顾，并凝练和一定程度的抽象。牢记本系列内容组织的两原则： 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 主题 1：dataflow 1. 全局变量 不仅在上篇（Part 5）的最后，在 k 点分发时我们看到了在 GlobalC 中声明为 extern 的 Parallel_Kpoints 类对象 Pkpoints，在很多地方会被直接调用的 UnitCell 类对象 ucell，以及实际上最一开始看到的 Input 类对象 INPUT，也被声明为 extern。 extern 标识变量的好处(1)是跨文件/跨模块可用，以至于可以尽量缩减每个函数的形参表体积，(2)维持变量的唯一性，若又有其他变量具有相同名字，则编译阶段无法通过。但缺点是 extern 变量可能被修改，修改后则所有用到该 extern 变量的地方均受影响。另外 extern 的使用不当可能会(1)破坏封装性，为函数、变量、类、模块带来深度耦合，为之后的开发工作带来困难，(2)带来异常大的程序运行内存开销——因为有些变量确实可以具有短于整个程序的生命周期。 另一方面，如果有 extern 变量的生命周期和整个程序相同，可能给开发者带来困难：判断其何时何阶段具有何值就更有难度。 2. 输入文件读取 综合前 5 篇介绍的内容，结合 ABACUS workflow 的赋值顺序，将有关的全局变量总结如下： 主题 2：分发存储 1. 格点分发 在 Part 4，我们解读过 ABACUS 关于实空间格点与倒空间格点的分发策略。我们需要重新确定所分发的产物是什么。 实际上，在实空间进行积分的量基本都和电荷密度\\rho有关，因此格点数量实际通过 ecutrho 来控制。同时考虑到 FFT 的维数问题，因此基本要求是实空间和倒空间格点数目完全一致（除去 gamma_only 情况），即 this->fftnx = this->nx; this->fftny = this->ny; this->fftnz = this->nz; 1.1 实空间格点（link） 实空间格点的分发策略分两步： xyz 三维实空间沿 z 轴切片 切片按照先按 processors 均分，若有余则再按顺序分配 实空间格点划分后在 PW_Basis 类中，如下成员变量被赋值： PW_Basis 类内数据成员 变量意义 this->numz 列表，每个 processor 所分得 xy 平面数量 this->nplane 当前 processor 所分得 xy 平面数量 this->startz 列表，每个 processor 分得 xy 平面后，所具有平面沿 z 方向的起始索引 this->startz_current 当前 processor 分得 xy 平面后，所具有平面沿 z 方向的起始索引 this->nrxx 当前 processor 分得实空间格点数量 因此实空间的格点分发对于每个 processor 来说，能够特征识别的仅仅是 this->nplane 和 this->startz_current，主要为以上两量具有特征，且真正进行运算时，可以根据 this->startz_current 来分配数据（作为结果地，this->nrxx 是 processor 具有的实空间格点数）。 可以预想，对于三维空间的数据，可以以 this->startz_current 为依据分配具有数据的格点给不同 processor，也可使用一个 processor，访问 this->startz 数组来实现三维空间格点数据在 processor 间的分发。 1.2 倒空间格点（link） 倒空间的格点分发策略分两步： 首先在 ecutrho 划定倒空间球壳（我们约定，以后简称“ecutrho/ecutwfc 球壳”）内沿 z 方向划分出不同数量的“棍子”，即每根“棍子”包含一定数量的相同(x,y)而不同 z 的倒空间格点 将“棍子”长度按照降序排列后，按照“当前所有 processors 中具有最小‘棍子’累计高度的，优先分配”为原则进行分发 倒空间格点划分后在 PW_Basis 类中，如下成员变量被赋值： PW_Basis 类内数据成员 变量意义 this->startnsz_per 每个包含“棍子”的 processor 其第一个 z-axis grid point 的编号，从 0 开始，跨 processor。 this->npw 当前 processor 分得平面波数量（亦即倒空间格点数量） this->npw_per 列表，每个 processor 分得平面波数量（亦即倒空间格点数量） this->nst 当前 processor 分得“棍子”数量 this->nst_per 列表，每个 processor 分得“棍子”数量 this->nstnz this->nstnz = this->nst * this->nz this->npwtot 平面波总数 this->fftixy2ip 从“棍子”translated (x,y)-pair 到 processor index 的映射 this->istot2ixy 从“棍子”索引到非折叠倒空间折合坐标的映射 this->ig2isz 从平面波的 processor 内索引，到其倒空间平移后 z 坐标的映射 this->is2fftixy 每个 processor 各有一份，建立从 procesor 内“棍子”索引到其折叠后倒空间 xy 平面折合坐标的映射 this->numg 列表，从当前 processor 从实空间 z 方向格点/xy 平面到所有 processors 的倒空间 sticks 的映射数量 this->numr 列表，当前 processor 从倒空间到所有 processors 所拥有 this->numz，即实空间 z 方向格点/xy 平面数量的映射数量 this->startg 列表，this->numg 的从当前 processor 到所有 processor 的映射的起始索引 this->startr 列表，this->numr 的从当前 processor 到所有 processor 的映射的起始索引 this->ig2igg 从归约前平面波索引到归约后模长列表的索引的映射 this->gg_uniq 列表，归约后平面波数量 由于倒空间格点的分发比较复杂，因此各个 processor 分得的格点，需要从 ecutrho 球壳中格点到 processor 进行 mapping，也需要方便地从 processor 中格点方便地知道其所对应（x,y,z）。 举例定义分发后的某倒空间格点为（ip, is, iz），其中 ip 为 index_processor，is 为 index_stick_processor，即在当前 processor 中“棍子”的索引，iz 为 index_z_stick，即在当前“棍子”中格点的索引（实际等价于 z 坐标的索引），则（&#x1F600; 以下建立两坐标系的双向 1-1 映射过程可以出成思考题）： （ip, is, iz）→（x, y, z）：ip 人为给定、this->is2fftixy 确定从（ip, is）到（x, y）映射，iz 则实际上可以直接换算——因为 ecutrho 球壳关于 z=0 平面上下对称。 （x, y, z）→（ip, is, iz）：this->fftixy2ip 确定 ip，在 ip 中得到 this->nst，再访问当前 processor 的 this->is2fftixy，核对（x, y），得到 is，然后转换 z 到 iz。 2. k 点分发（link） k 点的分发策略分三步： 按照用户给定方式生成 k 点：Gamma、Monkhorst-Pack、给定 k 点、k path 通过确定的对称性，对所生成的 k 点进行对称变换，对 k 点数量进行归约 k 点先按 processor 均分，若有余则再按顺序分配 k 点分发后在 K_Vectors 类中，主要有如下成员变量被赋值： PW_Basis 类内数据成员 变量意义 this->kvec_c 列表，当前 processor 分得 k 点的 Cartesian 坐标 this->kvec_d 列表，当前 processor 分得 k 点的 Direct 坐标 this->wk 列表，当前 processor 分得 k 点的权重 this->isk 列表，当前 processor 分得 k 点的 spin channel, 0: alpha, 1: beta this->nks 当前 processor 分得 k 点的数量 this->nkstot k 点总数 因此 k 点分发直接获得 k 点坐标和对应权重，以及 spin channel 的标识。 开发初步尝试：doxygen 注释和单元测试 1. 程序注释规范 1.1 现状介绍 诚然这个系列的文档是为让 ABACUS 新晋开发者更快熟悉 ABACUS 代码，清楚 ABACUS 中各个变量和功能可能声明、初始化和实现的位置，以及变量间的从属关系，但文档的发行速度和更新速度远慢于 ABACUS 新版本的开发。因为这一点，ABACUS 开发团队同时希望 ABACUS 的信息 self-contained，即在每个程序文件中都有足够详尽的关于当前文件内容的注释，以及其他可能需要的信息。 然而由于 ABACUS 的历史较长，ABACUS 的开发者也所属组织和单位众多，因此除了代码风格多样外，注释风格也十分多样。格式和缩写各异的注释使得代码整洁程度下降，因此代码主体的可读性降低，并且注释的可读性也难以保证。 目前在 ABACUS 中存在的代码注释风格按添加注释的位置分类主要包括两种：随行注释和 Section 注释。 然而，在头文件中添加 section 型注释可能会导致在 vscode 中讲注释显示在临近的第一个变量/函数上（如上图，会显示在 NPROC 上），而其他各变量和函数均保持未注释状态，此时在其他代码位置鼠标悬停时不会有注释显式。 1.2 基本注释原则 1.2.1 Doxygen 注释 ABACUS 现在推进 doxygen 格式的注释。Doxygen 注释在 vscode 中可以使用插件进行模板插入： Doxygen 函数注释样例： 1.2.2 若干注意事项 对于某个类中数据成员和成员函数的注释，请添加在相应的头文件中，避免在源文件中添加此类注释。对于程序代码的注释则没有要求，只需保证清晰明了。 （对于头文件中添加的函数注释）特别对于一些 void 类型函数，形参表中变量既有输入也有输出的，在 @param 字段注明“[in]”或者\"[out]\"作为标识 @brief 字段尽量保证描述清晰且语言简洁，更多的内容可以添加在 @details 字段 注意事项等可以添加在 @attention 字段 1.3 为了更平滑的开发和维护：扩展注释内容 1.3.1 模块封装化注释 封装、继承和多态是包括 C++ 在内的高级编程语言的核心理念。良好的封装有助于保护程序运行的稳定性，同时有利于开发工作的开展。然而，封装不仅仅是局部而言对某个类的封装，更应该将封装的理念应用于整体的程序设计。程序整体组织层面的封装，有利于在程序因一定需求需大幅改变结构时，能够稳定运行而不出错，同时能够实现各部分的独立、高效开发。 现阶段 ABACUS 缺乏模块层级的注释，即对于某个模块（module）究竟需要传入哪些参数/物理量/性质，传出哪些参数/物理量/性质，是尚未总结和落实到文档中的方面。 1.3.2 上游-下游函数注释 另一方面，除去 vscode 自身所包含的“查找所有引用”/“转到引用”的功能外，鼓励为函数添加注释时，添加 @note 字段，注明引用该函数的下游函数，即：考虑到通过 vscode“查看定义”，以及函数本身的调用方式可以方便查找到当前函数的上游函数，但在上游函数却较为困难获知被何下游函数调用。 注释下游函数有利于局部重构工作的开展。 2. 单元测试 大型程序包含数量众多的函数，对 C++ 等支持 OOP 的语言来说，也包含更多的类等。保障程序中各函数的顺利和正确执行，是保障程序整体能够运行的基础。对于数值计算软件来说，除去正常运行测试外，之后也应包括数值精度测试，这一理念的前提是开发者具有数值计算软件的编程常识，如避免小数位数丢失、DivideZeroError、相减精度丢失等数值错误，同时也将推动 ABACUS 在精度方面进行一定数量的小范围重构，符合 2023 Q2 推行的“测试驱动开发（Test Driven Development, TDD）”理念。 2.1 单元测试的设计原则 独立性：在设计和编写单元测试时，应当尽可能减少对其他部分函数的依赖，当作其他函数并未测试，因此可靠性不能保证。 高覆盖：对于程序流程控制出现分支的情况，应酌情对所有分支进行全面覆盖，以保证所有分支的函数和运算都可以正常执行。 自动：禁止出现 stdin 交互 快速：因为仅需要测试函数是否正常运行，是否可以得到预期结果，因此需要尽可能避免使用需要高时间复杂度的计算方式，而是使用尽可能简单（可以 unphysical）的数据，尽可能快地得出结果，可以考虑对预期结果进行硬编码。 2.2 对 private 变量的访问 由于当前 ABACUS 代码的封装并不完善，部分函数声明为 private 却仍然需要测试。另一方面，getter 和 setter 函数在原则上应当是从外部直接访问私有变量的唯一方式，但在使用之前也需要进行有效性测试。考虑到这两点，我们不得不尝试访问 private 或 protected 变量和成员函数。目前而言 ABACUS 中对 private 变量访问的方式主要有两种： #define private public，已知此种方式有一定情况不兼容，从而导致无法编译通过。 我们曾对访问 private 成员的方法进行过讨论，搜集到解决方案如下：https://github.com/deepmodeling/abacus-develop/issues/2666 C++ 委员会有关于几种访问私有成员的方式及其讨论：http://www.gotw.ca/gotw/076.htm 2.3 更多细节补充 ABACUS 的单元测试依靠 Googletest 框架实现。关于 Googletest 的安装、单元测试的运行、单元测试的注释规范等，见：ABACUS 测试者必知必会 。 为保证本地机器的工作不受影响，建议单元测试的编译和进行在 Bohrium 平台进行。 3. Fork and Pull request：在 ABACUS 上发布你的注释和单元测试，甚至更多！ 3.1 Fork 和 Pull request Fork 是便于进行多人协作开发的机制，其“叉子”体现在： 从待开发的软件仓库其软件的开发时间线创建时间线分支，即 Fork，到自己的仓库 在自己的仓库进行的任何改动将不会直接影响到原程序的时间线，但可以通过代码改动比较，来尽可能无冲突地将多人的改动进行合并 提交自己的改动，将自己 Fork 出的时间线和原有时间线进行合并的操作称为 Pull request (PR) 3.2 工作流示例 1 Fork ABACUS Github 仓库到自己的账号下 在自己的 ABACUS 仓库选择同步到 Github Desktop 在 Github Desktop 中选择自己的 ABACUS 仓库，之后选择在 Vscode 中打开 在 Vscode 上进行代码修改，每一次改动的保存都会同步被 Github Desktop 记录 重新编译、进行测试 在 Github Desktop 里选择左下角“Commit to develop”，然后“Push origin”将代码改动 push 到自己的 ABACUS 仓库 Github Desktop 中选择打开自己的仓库，再次审核代码改动后创建 pull request，待自动代码编译检查通过与代码人工审核 3.3 工作流示例2 Contributing to ABACUS ‒ ABACUS documentation 附：如何在飞书中平滑地分享文档 权限简介 在进行文档写作前，请确定自己账号所在的组织（如深势科技“DP”或北京科学智能研究院“AISI”）。一般而言对于创建的文档，非本人外的访问均需要文档作者进行分享，或在其他地方获得文档链接后，其阅读权限需要向作者发送权限申请。根据作者对文档的开放程度，可以分别赋予可阅读、可编辑、可管理权限，其权限自由度由低到高。 然而对于组织外，一般无文档阅读权限。 无限制访问 为了解决这一问题，可以在文档管理中按照如下方式设置： （电脑端） 打开文档，在文档右上角依次选择： （手机端） 系列链接 INPUT 读取：Introduction to ABACUS: Path to PW calculation - Part 1 STRU 读取：Introduction to ABACUS: Path to PW calculation - Part 2 赝势读取：Introduction to ABACUS: Path to PW calculation - Part 3 平面波并行与分发：Introduction to ABACUS: Path to PW calculation - Part 4 k 点并行与分发：Introduction to ABACUS: Path to PW calculation - Part 5 下篇：Introduction to ABACUS: Path to PW calculation - Part 6 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-04 23:29:29 "},"develop-path6.html":{"url":"develop-path6.html","title":"Introduction to ABACUS: Path to PW calculation - Part 6","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 6 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 6 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class 我们来到 ModuleESolver::ESolver_KS::Init()，在 source/module_esolver/esolver_ks.cpp: line105（link）： template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... if(GlobalV::BASIS_TYPE==\"pw\" || GlobalV::CALCULATION==\"get_wf\") { //Envelope function is calculated as lcao_in_pw //new plane wave basis #ifdef __MPI this->pw_wfc->initmpi(GlobalV::NPROC_IN_POOL, GlobalV::RANK_IN_POOL, POOL_WORLD); #endif this->pw_wfc->initgrids(inp.ref_cell_factor * ucell.lat0, ucell.latvec, this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz); this->pw_wfc->initparameters(false, inp.ecutwfc, this->kv.nks, this->kv.kvec_d.data()); #ifdef __MPI if(INPUT.pw_seed > 0) MPI_Allreduce(MPI_IN_PLACE, &this->pw_wfc->ggecut, 1, MPI_DOUBLE, MPI_MAX , MPI_COMM_WORLD); //qianrui add 2021-8-13 to make different kpar parameters can get the same results #endif this->pw_wfc->setuptransform(); for (int ik = 0; ik kv.nks; ++ik) this->kv.ngk[ik] = this->pw_wfc->npwk[ik]; this->pw_wfc->collect_local_pw(); this->print_wfcfft(inp, GlobalV::ofs_running); } PW_Basis_k::initgrids() ⚠ 注意，在 ESolver_KS 的构造函数中有 namespace ModuleESolver { template ESolver_KS::ESolver_KS() { .... pw_wfc = new ModulePW::PW_Basis_K_Big(GlobalV::device_flag, GlobalV::precision_flag); ModulePW::PW_Basis_K_Big* tmp = static_cast(pw_wfc); 因此对 pw_wfc 中成员函数的调用，和 pw_rho 类似地，此处会调用到其派生类 PW_Basis_K_Big 的对象 tmp 的成员函数。另一方面在 Introduction to ABACUS: Path to PW calculation - Part 4，我们对 PW_Basis_Big::initgrids() 在形参表中不包含 nx, ny 和 nz 的重载情况进行了介绍。当时使用 ecutrho，生成了 nx, ny, nz，bx，by，bz 及其组合，以及倒空间 fftnx, fftny 和 fftnz，然后分别将格点进行了实空间和倒空间的分发，为切片和“棍子”为分配基本单元，在 processors 间进行分发。 此处继续沿用依靠 Input::ecutrho 生成的 nx, ny 和 nz，调用包含 nx, ny 和 nz 在形参表中的 PW_Basis_K::initgrids() 函数（和 PW_Basis_Big 类不同，PW_Basis_K_Big 类并未重载 initgrids()）, template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... this->pw_wfc->initgrids(inp.ref_cell_factor * ucell.lat0, ucell.latvec, this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz); .... 以寻找适配于当前（格点数量增多后）nx, ny 和 nz 的新的 ecutwfc 球半径（PW_Basis_K::gridecut_lat）。 &#x1F914;思考时间 这样做的结果是什么？让 ecutwfc 等于 ecutrho 的操作正确吗？ 图 1. update cutoff value based on factorized nx, ny and nz nx, ny 和 nz 实空间格点数量增多的原因？→ 回顾 nx, ny 和 nz 的生成方式：在给定 ecutwfc 球半径后（通过 ecutrho），在可以分辨每个倒空间中点的情况下所确定出的最小格点数量。之后在给定的 ecutwfc 球中分别寻找可能达到的最大的 x/y/z 格点数，作为 nx, ny 和 nz，然后进行(2, 3, 5)-factorization，此处从 \\Delta l_i=\\frac{\\sqrt{\\text{ecut}}}{n_i^\\text{min}}\\le|\\mathbf{b}_i|→n_i^\\text{min}\\ge\\frac{\\sqrt{\\text{ecut}}}{|\\mathbf{b}_i|}→n_i↑, \\Delta l_i↓ 关系出发正向搜索，会使得 nx, ny 和 nz 增大。 void PW_Basis::initgrids( const double lat0_in, const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors const int nx_in, int ny_in, int nz_in ) { this->lat0 = lat0_in; this->tpiba = ModuleBase::TWO_PI / this->lat0; this->tpiba2 = this->tpiba*this->tpiba; this->latvec = latvec_in; this->omega = std::abs(latvec.Det()) * lat0 * lat0 * lat0; this->GT = latvec.Inverse(); this->G = GT.Transpose(); this->nx = nx_in; this->ny = ny_in; this->nz = nz_in; this->nxy = this->nx * this->ny; this->nxyz = this->nxy * this->nz; int *ibox = new int[3]; ibox[0] = int((this->nx-1)/2)+1; ibox[1] = int((this->ny-1)/2)+1; ibox[2] = int((this->nz-1)/2)+1; this->gridecut_lat = 1e20; int count = 0; for(int igz = -ibox[2]; igz poolnproc != this->poolrank) continue; /* distribute this task over all processors */ if(std::abs(igx) f; f.x = igx; f.y = igy; f.z = igz; double modulus = f * (this->GGT * f); /* if the surface vector has norm shorter than radius of present Bloch sphere, shrink the sphere */ if(modulus gridecut_lat) { this->gridecut_lat = modulus; } } } } #ifdef __MPI MPI_Allreduce(MPI_IN_PLACE, &this->gridecut_lat, 1, MPI_DOUBLE, MPI_MIN , this->pool_world); #endif this->gridecut_lat -= 1e-6; delete[] ibox; return; } 注意，在第 32 行，对该任务进行了分发，使用 MPI 函数 MPI_Allreduce() 以 MPI_MIN 对不同 processor 进行归并，得到其中最小的 this->gridecut_lat，之后共享给所有 processors。 PW_Basis_K::initparameters() 之后使用 PW_Basis_K::initparameters() 函数读取经过 k 点生成、归并、分发后读取的 kvec_c 与 kvec_d、nks 等参数。这三个两存储在 ESolver_FP 对象的 K_Vectors kv 数据成员中： template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... if(GlobalV::BASIS_TYPE==\"pw\" || GlobalV::CALCULATION==\"get_wf\") { .... this->pw_wfc->initparameters(false, inp.ecutwfc, this->kv.nks, this->kv.kvec_d.data()); .... 使得 pw_wfc 以下数值更新（initparameters()函数链接->link）： 属于 PW_Basis_k pw_wfc 的成员变量 取值 意义 this->nks ESolver_FP::K_Vectors::nks 当前 processor 所分得 k 点数量 this->kvec_c ESolver_FP::K_Vectors::kvec_c 采样的 k 点的 Cartesian 坐标 this->kvec_d ESolver_FP::K_Vectors::kvec_d 采样的 k 点的 Direct 坐标 this->gk_ecut (\\sqrt{\\text{this->ggecut}}-|\\mathbf{k}|)^2 min((sqrt(Input::ecutrho)-\\k\\max)^2, Input::ecutwfc) this->ggecut \\min(\\text{Input::ecutrho},(\\sqrt{\\text{Input::ecutwfc}}+|\\mathbf{k}|)^2) 由Input::ecutrho决定nx/ny/nz决定this->gridecut_lat，以及直接的Input::ecutwfc叠加k点后的最大平面波能量，两者其中小值 this->gamma_only false 仅 gamma 点 this->xprime true 是否 x 优先 FFT 变换 this->fftnx, this->fftny, this->fftnz, this->fftnxy, this->fftnxyz, this->nx, this->ny, this->nz, this->fftnx*this->fftny, this->fftnz*this->fftnxy, 倒空间格点数量 this->distribution_type 1 倒空间格点分发方式，默认 1 this->d_kvec_c ESolver_FP::K_Vectors::kvec_d.data() kvec_c 的指针 （for words in red）因此在 ABACUS 当前的实现中，只取更大的 ecutwfc 并不会带来波函数精度的提升，因为 ggecut 同时还受到 ecutrho 的限制：在所有采样的 k 点\\mathbf{k}中，不允许存在用于展开波函数的某平面波基其|\\mathbf{G+k}|超过电荷密度中用于展开的平面波的|\\mathbf{G}|。 之后跨 processors 对 this->ggecut 进行归并，所有 processors 均取跨 processors 中 this->ggecut 最高的那个值。 #ifdef __MPI if(INPUT.pw_seed > 0) MPI_Allreduce(MPI_IN_PLACE, &this->pw_wfc->ggecut, 1, MPI_DOUBLE, MPI_MAX , MPI_COMM_WORLD); //qianrui add 2021-8-13 to make different kpar parameters can get the same results #endif 格点分发 pw_wfc 和 pw_rho 格点分发的相同与不同：PW_Basis_K::setuptransform() 和 PW_Basis::setuptransform() 完全相同，或说 ESolver_KS::pw_wfc 和 ESolver_FP::pw_rho 完全相同地，此处按照实空间进行格点分发，以及平面波所对应的倒空间进行倒空间格点分发。仍然实际调用其派生类 *_Big::distrbute_r()，但 PW_Basis_K_Big 没有重载 initgrids() 函数。可以预见，如果 ecutwfc 取得足够大，则实际上波函数的倒空间分发和电荷密度的完全相同。另外和 ESolver_FP::pw_rho 所不同的是 PW_Basis_K::setuptransform() 多出来一个 PW_Basis_K::setupIndGk() 函数： void PW_Basis::setuptransform() { ModuleBase::timer::tick(this->classname, \"setuptransform\"); this->distribute_r(); this->distribute_g(); this->getstartgr(); this->ft.clear(); if(this->xprime) this->ft.initfft(this->nx,this->ny,this->nz,this->lix,this->rix,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); else this->ft.initfft(this->nx,this->ny,this->nz,this->liy,this->riy,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); this->ft.setupFFT(); ModuleBase::timer::tick(this->classname, \"setuptransform\"); } void PW_Basis_K::setuptransform() { ModuleBase::timer::tick(this->classname, \"setuptransform\"); this->distribute_r(); this->distribute_g(); this->getstartgr(); this->setupIndGk(); this->ft.clear(); if(this->xprime) this->ft.initfft(this->nx,this->ny,this->nz,this->lix,this->rix,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); else this->ft.initfft(this->nx,this->ny,this->nz,this->liy,this->riy,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); this->ft.setupFFT(); ModuleBase::timer::tick(this->classname, \"setuptransform\"); } PW_Basis_K::setupIndGk() PW_Basis_K::setupIndGk() 函数首先计算每个 k 点具有的平面波数量（因为有些 k 点的 k 向量加上平面波向量 G 之后可能会超出截断半径，因此不同 k 点的平面波数量可能会有小的差别），之后赋值给 this->npwk（实际上 this->npwk 是一维数组，具有 this->nks 的长度，而 this->nks 实际上是分发后 k 点数量，即实际上可能每个 processor 被分配到不止一个 k 点），并且在扫描当前 processor 所有的平面波时，同时计算跨 k 点的当前 processor 具有最大平面波数量，存储在 this->npwk_max 中。 在扫描平面波过程中所调用的 PW_Basis_K::cal_GplusK_cartesian() 函数则不外乎之前提到的实现在（ip, is, iz）到（x, y, z）之间的映射关系，此处反而是更加简单的情况：从 processor 所分配的某个平面波 ig，映射到其模长，实现如下： ModuleBase::Vector3 PW_Basis_K:: cal_GplusK_cartesian(const int ik, const int ig) const { int isz = this->ig2isz[ig]; int iz = isz % this->nz; int is = isz / this->nz; int ix = this->is2fftixy[is] / this->fftny; int iy = this->is2fftixy[is] % this->fftny; if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; ModuleBase::Vector3 f; f.x = ix; f.y = iy; f.z = iz; f = f * this->G; ModuleBase::Vector3 g_temp_ = this->kvec_c[ik] + f; return g_temp_; } 上述代码中 f=f*this->G 操作实现了平面波的坐标从 Direct 到 Cartesian 的转换。即 PW_Basis_K::cal_GplusK_cartesian() 函数实现从第 ik 个 k 点，第 ig 个平面波到其向量和的计算。当 ecutwfc 给定较小时，取平面波其对应倒空间矢量模长小于等于 ecutwfc 所对应矢量（但按照 ggecut 进行平面波的分发）： &#x1F914;思考时间 如果 ecutwfc != ggecut 会怎样？是否会有内存空间的浪费？ 平面波“棍子”分发时的能量比较： void PW_Basis::count_pw_st( int* st_length2D, // the number of planewaves that belong to the stick located on (x, y). int* st_bottom2D // the z-coordinate of the bottom of stick on (x, y). ) { .... int length = 0; // number of planewave on stick (x, y). for (int iz = iz_start; iz GGT * f); if (modulus ggecut || this->full_pw) { if (length == 0) st_bottom2D[index] = iz; // length == 0 means this point is the bottom of stick (x, y). ++this->npwtot; ++length; if(iy riy) this->riy = iy; if(iy > this->liy) this->liy = iy; if(ix rix) this->rix = ix; if(ix > this->lix) this->lix = ix; } } if (length > 0) { st_length2D[index] = length; ++this->nstot; } .... } processor 上平面波计数： void PW_Basis_K::setupIndGk() { .... this->npwk_max = 0; delete[] this->npwk; this->npwk = new int [this->nks]; for (int ik = 0; ik nks; ik++) { int ng = 0; for (int ig = 0; ig npw ; ig++) { const double gk2 = this->cal_GplusK_cartesian(ik, ig).norm2(); if (gk2 gk_ecut) ++ng; // this->gk_ecut may be equilvalent with ecutwfc } this->npwk[ik] = ng; .... if ( this->npwk_max npwk_max = ng; } .... 而作为回溯，this->npw 和 this->nks 分别在倒空间格点的分发阶段 PW_Basis::distribution_method1()（该函数 PW_Basis_K 直接从 PW_Basis 继承）和 PW_Basis_K::initparameters() 被赋值，赋值来源分别是 npw_per[this->poolrank]、st_length 和 ESolver_KS::K_Vectors::nks，后者来源于 K_Vectors::mpi_k() 函数。 接下来建立两映射表： //get igl2isz_k and igl2ig_k if(this->npwk_max igl2isz_k = new int [this->nks * this->npwk_max]; delete[] igl2ig_k; this->igl2ig_k = new int [this->nks * this->npwk_max]; for (int ik = 0; ik nks; ik++) { int igl = 0; for (int ig = 0; ig npw ; ig++) { const double gk2 = this->cal_GplusK_cartesian(ik, ig).norm2(); if (gk2 gk_ecut) { this->igl2isz_k[ik*npwk_max + igl] = this->ig2isz[ig]; this->igl2ig_k[ik*npwk_max + igl] = ig; ++igl; } } } .... return; } 由于此处的命名过于抽象，我们可以直接添加注释在头文件，之后提交 PR： class PW_Basis_K : public PW_Basis { public: .... /// @brief flattened, sparse 2d matrix whose row index runs over planewaves distributed on present processor and column index for kpoint (distributed on present processor, also), the matrix element value is PW_Basis::isz. isz is flattened index of (is, iz), where the is, is index of stick on present processor and iz is z index of FFT grid. \"Sparse\" means not every kpoint has as many as npwk_max planewaves, but the unflattened 2D matrix has dimension of npwk_max*nks, which means there will be empty elements (unreasonable isz value). igl is index of g-vector (equilvalent with planewave) local, the \"local\" means every kpoint. int *igl2isz_k=nullptr; .... /// @brief flattened, sparse 2d matrix established in the same way as this->igl2isz_k, mapping from (igl,ik) to ig, ig is index of planewave in present processor, for more info., see comment of this->igl2isz_k. int *igl2ig_k=nullptr; 而 this->igl2isz_k 这一矩阵的使用在紧接着的 PW_Basis_K::collect_local_pw() 中即将展现。 之后反向更新 ESolver_KS::K_Vectors::ngk 中值： template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... for (int ik = 0; ik kv.nks; ++ik) { this->kv.ngk[ik] = this->pw_wfc->npwk[ik]; } .... 后处理 PW_Basis_K::collect_local_pw() 展现了 this->igl2isz_k 如此抽象的 mapping 的使用方法（此处计算平面波的 Cartesian 坐标，即以 0 点为中心的截断半径内的平面波的坐标）： void PW_Basis_K::collect_local_pw() { if(this->npwk_max gk2 = new double[this->npwk_max * this->nks]; this->gcar = new ModuleBase::Vector3[this->npwk_max * this->nks]; .... ModuleBase::Vector3 f; for(int ik = 0 ; ik nks ; ++ik) { ModuleBase::Vector3 kv = this->kvec_d[ik]; for(int igl = 0 ; igl npwk[ik] ; ++igl) { int isz = this->igl2isz_k[ik * npwk_max + igl]; int iz = isz % this->nz; int is = isz / this->nz; int ixy = this->is2fftixy[is]; int ix = ixy / this->fftny; int iy = ixy % this->fftny; if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; f.x = ix; f.y = iy; f.z = iz; this->gk2[ik * npwk_max + igl] = (f+kv) * (this->GGT * (f+kv)); this->gcar[ik * npwk_max + igl] = f * this->G; } } .... this->d_gcar = reinterpret_cast(&this->gcar[0][0]); this->d_gk2 = this->gk2; .... } 的确，尽管我们以稀疏方式存储满足模长小于等于 Input::ecutwfc 的平面波的 isz，也不用担心访问到空元素：this->npwk 数组的存在，标定了究竟对于每一个存储在当前 processor 上的 k 点，有多少个平面波，且此时 this->npwk 里“平面波数量”已经是 ig 和 ik correlate 的结果：他们必须使得平面波模长小于等于 Input::ecutwfc。因此循环 k 点索引即可得到平面波数量，进而根据平面波数量可以获得局部平面波索引 igl，之后使用 igl 与 ik 访问刚刚建立的映射表 this->igl2isz_k，得到 isz，然后使用 isz 和 is、iz 的关系得到后两者，is 传入 this->is2fftixy 映射表，得到平面波的倒空间 Direct 坐标。 经过|\\mathbf{G+k}|以及坐标变换，得到 this->gk2 和 this->gcar，并且使用指针（this->d_gcar、this->d_gk2）指向两者。 至此，我们比起 ESolver_FP::pw_rho 的倒空间分发，多知道了和 k 点相关的众多属性：因波函数本身的平移对称性决定了其和 k 点的相关性，因而 k 点必然参与在内。 GlobalC::Parallel_Grid::init() template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... GlobalC::Pgrid.init(this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz, this->pw_rho->nplane, this->pw_rho->nrxx, pw_big->nbz, pw_big->bz); // mohan add 2010-07-22, update 2011-05-04 .... Parallel_Grid::init() 函数将 PW_Basis pw_rho 的实空间格点数据存储到 Parallel_Grid 类中，并且根据 KPAR 用户设置参数，使得\\mathbf{k}点的分发策略同时适用于实空间格点。 void Parallel_Grid::init(const int &ncx_in, const int &ncy_in, const int &ncz_in, const int &nczp_in, const int &nrxx_in, const int &nbz_in, const int &bz_in) { .... const int remain_pro = nprocgroup%GlobalV::KPAR; for(int i=0; inproc_in_pool[i]++; } this->numz = new int*[GlobalV::KPAR]; this->startz = new int*[GlobalV::KPAR]; this->whichpro = new int*[GlobalV::KPAR]; for(int ip=0; ipnumz[ip] = new int[nproc]; this->startz[ip] = new int[nproc]; this->whichpro[ip] = new int[this->ncz]; ModuleBase::GlobalFunc::ZEROS(this->numz[ip], nproc); ModuleBase::GlobalFunc::ZEROS(this->startz[ip], nproc); ModuleBase::GlobalFunc::ZEROS(this->whichpro[ip], this->ncz); } this->allocate = true; this->z_distribution(); .... } void Parallel_Grid::z_distribution(void) { assert(allocate); int* startp = new int[GlobalV::KPAR]; startp[0] = 0; for(int ipool=0; ipool0) startp[ipool] = startp[ipool-1] + nproc_in_pool[ipool-1]; for(int iz=0; iz=startz[ipool][nproc-1]) { whichpro[ipool][iz] = startp[ipool] + nproc-1; break; } else if(iz>=startz[ipool][proc] && iz PW_Basis_K::setupIndGk() 已经将分发后 k 点和平面波基函数（倒空间格点）相互耦合，最终获得的 processor-specific igl2isz_k 可以实现\\mathbf{k}和\\mathbf{G}的合并存储，即相当于实现了\\mathbf{k}和\\mathbf{G}的一并分发。 我们之前使用 pw_rho 的 PW_Basis::initgrids() 函数对用于电荷密度\\rho的实空间格点数量进行过初始化，也指定了分发策略。也为继承自 ESolver_FP 类的 ModulePW::PW_Basis_Big 类对象 pw_big 数据成员 bx, by, bz, nbx, nby 和 nbz： namespace ModuleESolver { class ESolver_FP : public ESolver { public: .... ModulePW::PW_Basis_Big* pw_big; /// ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); pw_big = static_cast(pw_rho); pw_big->setbxyz(INPUT.bx, INPUT.by, INPUT.bz); .... } Parallel_Grid::init() 调用 Parallel_Grid::z_distribution() 实现具体的分发过程，具体确定了以下三个列表的值： 变量 Dimension 意义 this->numz N(groups)*N(proc_in_group), N(groups)由 GlobalV::KPAR 决定，即该二维索引实际上是一维索引（rank of processor）的展开 存储每个组中每个 processor 所分得 xy 平面的个数。在 Parallel_Grid::z_distribution() 具体实现中，每次为一个 processor 分配一个 bz，即 big grid contained xyplanes，一共分配 nbz 个 xyplane this->startz N(groups)*N(proc_in_group) 每个组中每个 processor 分得的 xy 平面中最小 z 坐标 this->whichpro N(groups)*N(xyplane) 每个组所分得平面归属于哪个 processor ⚙ 在阅读 Parallel_Grid::init() 时还会发现另一个 Parallel_Grid::init_final_scf() 函数，其和 Parallel_Grid::init() 具有高度的相似性。 结构因子计算：ModuleESolver::ESolver_FP::Structure_Factor::setup_structure_factor() template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... // Calculate Structure factor this->sf.setup_structure_factor(&GlobalC::ucell, this->pw_rho); 固体物理中结构因子S(\\mathbf{G})以 atom type-by-atom type 定义为 S_\\alpha(\\mathbf{G})=\\sum_{\\mathbf{G}}{\\sum_{i}^{N_{\\alpha}}{e^{-i\\mathbf{G}\\cdot\\mathbf{\\tau}_{\\alpha,i}}}} 其中\\mathbf{G}为当前晶格所允许的倒空间矢量，即\\mathbf{G}=\\sum_{i}^3{m_i\\mathbf{b}_i}, m_i\\in Z, \\alpha为当前原子种类，i为当前盒子内\\alpha类型原子的索引，N_\\alpha为该种类原子数量。其会出现在任何涉及原子性质加和得到倒空间相应量的过程中： V(\\mathbf{G})=\\int{d\\mathbf{r} e^{i\\mathbf{G}\\cdot\\mathbf{r}} \\sum_{\\mathbf{T}}{ \\sum_{\\alpha}^{N}{ \\sum_{i}^{n^\\alpha} {V^{\\alpha}(\\mathbf{r}-\\mathbf{\\tau}_{\\alpha i}-\\mathbf{T})} } } } =\\sum_\\alpha{V^\\alpha(\\mathbf{G})S^\\alpha(\\mathbf{G})} void Structure_Factor::setup_structure_factor(UnitCell* Ucell, const ModulePW::PW_Basis* rho_basis) { .... const std::complex ci_tpi = ModuleBase::NEG_IMAG_UNIT * ModuleBase::TWO_PI; this->strucFac.create(Ucell->ntype, rho_basis->npw); // itype, iG-vector table .... bool usebspline; if(nbspline > 0) usebspline = true; else usebspline = false; 我们首先考虑不加 b 样条的情况： if(usebspline){....} else { for (int it=0; itntype; it++) /* runs over all atomtypes */ { const int na = Ucell->atoms[it].na; const ModuleBase::Vector3 * const tau = Ucell->atoms[it].tau; ....//parallelization with openmp is omitted in this line for (int ig=0; ignpw; ig++) /* runs over G-vectors */ { const ModuleBase::Vector3 gcar_ig = rho_basis->gcar[ig]; std::complex sum_phase = ModuleBase::ZERO; for (int ia=0; iastrucFac(it,ig) = sum_phase; } } } 注意，来自于形参表的 rho_basis->npw 决定了具体结构因子的倒空间波矢\\mathbf{G}具体取值（取值直接来自 rho_basis->gcar，实际即 pw_rho->gcar，由 INPUT.ecutrho 确定）。然后计算了e^{i\\mathbf{G}\\cdot\\mathbf{\\tau}_{\\alpha i}}在实空间格点上的 map： void Structure_Factor::setup_structure_factor(UnitCell* Ucell, const ModulePW::PW_Basis* rho_basis) { .... int i,j; //ng; this->eigts1.create(Ucell->nat, 2*rho_basis->nx + 1); this->eigts2.create(Ucell->nat, 2*rho_basis->ny + 1); this->eigts3.create(Ucell->nat, 2*rho_basis->nz + 1); .... ModuleBase::Vector3 gtau; int inat = 0; for (i = 0; i ntype; i++) { .... for (j = 0; j atoms[i].na;j++) { gtau = Ucell->G * Ucell->atoms[i].tau[j]; for (int n1 = -rho_basis->nx; n1 nx;n1++) { double arg = n1 * gtau.x; this->eigts1(inat, n1 + rho_basis->nx) = ModuleBase::libm::exp( ci_tpi*arg ); } for (int n2 = -rho_basis->ny; n2 ny;n2++) { double arg = n2 * gtau.y; this->eigts2(inat, n2 + rho_basis->ny) = ModuleBase::libm::exp( ci_tpi*arg ); } for (int n3 = -rho_basis->nz; n3 nz;n3++) { double arg = n3 * gtau.z; this->eigts3(inat, n3 + rho_basis->nz) = ModuleBase::libm::exp( ci_tpi*arg ); } inat++; } } this->z_eigts1 = this->eigts1.c; this->z_eigts2 = this->eigts2.c; this->z_eigts3 = this->eigts3.c; } 经过 Structure_Factor::setup_structure_factor() 函数，计算好的以[原子种类，G-vectors（从 pw_rho）]2D 数组存储结构因子被存储在 ESolver_KS::Structure_Factor::strucFac 中，属于 ESolver_KS 类（当前）对象 p_esolver 的 Structure_Factor 类对象为 sf。同理，还存储了 p_esolver->sf.eigts1, 2 和 3，以及 p_esolver->sf.z_eigts1, 2, 3。this->eigts1, 2, 3 按照如下方式取值： \\text{eigts}_1[i]=e^{i2\\pi(n_1\\mathbf{b}_1)\\cdot\\mathbf{\\tau}_i}, Ucell->G 所存储的是 G 矩阵，其中是倒空间 3 个基矢量，而n_1\\mathbf{b}_1\\equiv\\mathbf{G}_1，因此仍然有 \\text{eigts}_1[i]=e^{i\\mathbf{G}_1[i]\\cdot\\mathbf{\\tau}_i}。 即 this->eigts(i), i=1,2,3 中所存储的是由 INPUT.ecutrho 所确定的球形区域中每个倒空间格点对每个原子的结构因子，或相位项。 电荷外推初始化：Charge_Extra::Init_CE() template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... // Initialize charge extrapolation CE.Init_CE(GlobalC::ucell.nat); } 基本原理 在分子动力学（Molecular dynamics, MD）模拟，或 Born-Oppenheimer MD（BOMD）过程中，由于每步进行完整 SCF 成本较高，使用一定的电荷外推方法，用于构造 Hamiltonian 算符可以节约大部分时间。原本的电荷外推方法原理为： \\rho \\left( t+\\Delta t \\right) =\\rho \\left( t \\right) +\\alpha \\left[ \\rho \\left( t \\right) -\\rho \\left( t-\\Delta t \\right) \\right] +\\beta \\left[ \\rho \\left( t-\\Delta t \\right) -\\rho \\left( t-2\\Delta t \\right) \\right] 波函数其实也按照此方法进行外推，但需要注意波函数能级在 MD 过程中两步间可能发生交换，因此需要额外保证最小化\\min\\sum_{\\text{n}\\mathbf{k}}||\\Psi _{\\mathrm{n}\\mathbf{k}}\\left( t \\right) -\\Psi _{\\mathrm{n}\\mathbf{k}}\\left( t-\\Delta t \\right) ||。 \\alpha和\\beta的确定方法为使得\\sum_i^N{||\\mathbf{r}_{i}^{\\prime}-\\mathbf{r}_i\\left( t+dt \\right) ||^2}最小化，其中 \\mathbf{r}_{i}^{\\prime}\\equiv \\mathbf{r}_i\\left( t \\right) +\\alpha \\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-\\Delta t \\right) \\right] +\\beta \\left[ \\mathbf{r}_i\\left( t-\\Delta t \\right) -\\mathbf{r}_i\\left( t-2\\Delta t \\right) \\right] 。由此可有： \\alpha =\\frac{b_1a_{22}-b_2a_{12}}{\\det A}, \\beta =\\frac{b_2a_{11}-b_2a_{21}}{\\det A} A 矩阵的矩阵元a_{ij}定义为： \\begin{cases} a_{11}=\\sum_i^N{|\\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-\\Delta t \\right) |^2}\\\\ a_{12}=a_{21}=\\sum_i^N{\\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-\\Delta t \\right) \\right] \\cdot \\left[ \\mathbf{r}_i\\left( t-\\Delta t \\right) -\\mathbf{r}_i\\left( t-2\\Delta t \\right) \\right]}\\\\ a_{22}=\\sum_i^N{|\\mathbf{r}_i\\left( t-\\Delta t \\right) -\\mathbf{r}_i\\left( t-2\\Delta t \\right) |^2}\\\\ \\end{cases} B 矢量的定义为： \\begin{cases} b_1=-\\sum_i^N{\\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t+\\Delta t \\right) \\right] \\cdot \\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-\\Delta t \\right) \\right]}\\\\ b_2=-\\sum_i^N{\\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t+\\Delta t \\right) \\right] \\cdot \\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-2\\Delta t \\right) \\right]}\\\\ \\end{cases} 。1999 年，Dario Alfe 提出了新的电荷外推方式，将电荷分割为原子贡献部分和 delta 项： \\rho \\left( t \\right) =\\rho _{\\mathrm{at}}\\left( t \\right) +\\delta \\rho \\left( t \\right) 。采用相同的外推模式，但只外推\\delta\\rho(t)，\\rho_\\text{at}(t+\\Delta t)的值可以迅速在实空间求得： \\delta \\rho \\left( t+\\Delta t \\right) =\\delta \\rho \\left( t \\right) +\\alpha \\left[ \\delta \\rho \\left( t \\right) -\\delta \\rho \\left( t-\\Delta t \\right) \\right] +\\beta \\left[ \\delta \\rho \\left( t-\\Delta t \\right) -\\delta \\rho \\left( t-2\\Delta t \\right) \\right] ， \\rho \\left( t+\\Delta t \\right) =\\rho _{\\mathrm{at}}\\left( t+\\Delta t \\right) +\\delta \\rho \\left( t+\\Delta t \\right) 。另一种实现 BOMD 的方法为 CPMD，即通过给予电子相较于离子极小的质量，导致电子和离子的振动耦合尽可能小，从而使用经典的 MD 方法可以进行 BOMD。但由于计算机算力的更新迭代与应用场景更高的精度要求，目前 CPMD 已经逐渐退出历史舞台。 &#x1F914;思考时间 电荷外推的“旧”方法和 D. Alfe 提出的新方法根本区别在哪里？从物理图像层面考虑看看！ 代码细节 void Charge_Extra::Init_CE(const int& natom) { if(GlobalV::chg_extrap == \"none\") pot_order = 0; else if(GlobalV::chg_extrap == \"atomic\") pot_order = 1; else if(GlobalV::chg_extrap == \"first-order\") pot_order = 2; else if(GlobalV::chg_extrap == \"second-order\") pot_order = 3; else { ModuleBase::WARNING_QUIT(\"Charge_Extra\",\"charge extrapolation method is not available !\"); } if(pot_order == 3) { dis_old1 = new ModuleBase::Vector3[natom]; dis_old2 = new ModuleBase::Vector3[natom]; dis_now = new ModuleBase::Vector3[natom]; } alpha = 1.0; beta = 0.0; } 关于该类的其他函数请自行阅读。关于 GlobalV::chg_extrap： //input_conv.cpp GlobalV::chg_extrap = INPUT.chg_extrap; //input.cpp void Input::Default(void) { .... chg_extrap = \"atomic\"; // xiaohui modify 2015-02-01 .... } bool Input::Read(const std::string &fn) { .... while (ifs.good()) { .... else if (strcmp(\"chg_extrap\", word) == 0) // xiaohui modify 2015-02-01 { read_value(ifs, chg_extrap); // xiaohui modify 2015-02-01 } .... } .... } void Input::Default_2(void) { .... else if (calculation == \"get_pchg\") { .... chg_extrap = \"atomic\"; // xiaohui modify 2015-02-01 .... } else if (calculation == \"get_wf\") { .... chg_extrap = \"atomic\"; // xiaohui modify 2015-02-01 .... } .... } void Input::Check() { .... if (chg_extrap == \"dm\" && basis_type == \"pw\") // xiaohui add 2013-09-01, xiaohui modify 2015-02-01 { ModuleBase::WARNING_QUIT( \"Input\", \"wrong 'chg_extrap=dm' is only available for local orbitals.\"); // xiaohui modify 2015-02-01 } .... } 下篇我们将回到再上一层函数，ESolver_KS_PW::Init() 中去。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Summary 1 下篇：Introduction to ABACUS: Path to PW calculation - Part 7 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-05 10:49:50 "},"develop-path7.html":{"url":"develop-path7.html","title":"Introduction to ABACUS: Path to PW calculation - Part 7","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 7 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 7 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class 终于来到和原本 p_esolver 相同的类的成员函数 Init()： template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { ESolver_KS::Init(inp, ucell); // phsol == nullptr) { this->phsol = new hsolver::HSolverPW(this->pw_wfc, &this->wf); } // Initialize ElecState if (this->pelec == nullptr) { this->pelec = new elecstate::ElecStatePW(this->pw_wfc, &(this->chr), &(this->kv), this->pw_rho, this->pw_big); } // Initialize the charge density this->pelec->charge->allocate(GlobalV::NSPIN); this->pelec->omega = GlobalC::ucell.omega; // Initialize the potential if (this->pelec->pot == nullptr) { this->pelec->pot = new elecstate::Potential(this->pw_rho, &GlobalC::ucell, &(GlobalC::ppcell.vloc), &(this->sf), &(this->pelec->f_en.etxc), &(this->pelec->f_en.vtxc)); } this->Init_GlobalC(inp, ucell); if (GlobalV::ocp) this->pelec->fixed_weights(GlobalV::ocp_kb); } Initialization of HSolverPW object Constructor 首先来到按照注释划分的第一部分“Initialize HSolver”（line 6，HSolver 就是求解体系哈密顿量的求解器）： template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { ESolver_KS::Init(inp, ucell); // Initialize HSolver if (this->phsol == nullptr) { this->phsol = new hsolver::HSolverPW(this->pw_wfc, &this->wf); } 其实 phsol（此处命名逻辑为 p 代表 Pointer，hsol 为 HSolver 的缩写）并非是 ESolver_KS_PW 类中数据成员，而是在 ESolver_KS 中，这意味着 ESolver_KS 的派生类均有可能使用这一数据成员。稍加搜索，发现 ESolver_KS_LCAO::Init() 中也有类似操作： void ESolver_KS_LCAO::Init(Input& inp, UnitCell& ucell) { .... // init HSolver if (this->phsol == nullptr) { this->phsol = new hsolver::HSolverLCAO(this->LOWF.ParaV); this->phsol->method = GlobalV::KS_SOLVER; } 另一点可以预料的是，在基类 ESolver_KS 的声明中，phsol 起始被声明为基类 HSolver 类对象，而非直接地 HSolverPW 这一派生类对象，这一操作再次体现了 C++ 的多态编程思路。具体在当前 Init 函数中，phsol 被分配内存时调用的 HSolverPW 类构造函数，其形参表中，pw_wfc 是属于 PW_Basis_K（以及其派生类 PW_Basis_K_Big）类对象，继承自 ESolver_KS。wf 是 wavefunc 类对象，也继承自 ESolver_KS，这体现了仅对于 ESolver_KS 层级而言需要带有 k 点的平面波波函数，以及波函数的存储类，而再上一级 ESolver_FP 则不一定需要这两者。平行而言 ESolver_OF 也属于“FP”，但在 ESolver_FP 的派生类 ESolver_OF 中，丝毫没有关于平面波波函数的数据成员： 派生类 HSolverPW 的构造函数其结构十分简单： template HSolverPW::HSolverPW(ModulePW::PW_Basis_K* wfc_basis_in, wavefunc* pwf_in) { this->classname = \"HSolverPW\"; this->wfc_basis = wfc_basis_in; this->pwf = pwf_in; this->diag_ethr = GlobalV::PW_DIAG_THR; } ，即将 ESolver_KS::pw_wfc 复制进 HSolverPW 的数据成员 wfc_basis，ESolver_KS::wf 到 HSolverPW::pwf。 Initialization of ElecState object Constructor 接下来来到 ESolver_KS_PW::Init()“第二部分”中 ElecState 类对象的初始化。 template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { .... // init ElecState, if (this->pelec == nullptr) { this->pelec = new elecstate::ElecStatePW(this->pw_wfc, &(this->chr), &(this->kv), this->pw_rho, this->pw_big); } 和 phsol 同样地，这一次 pelec 是继承自 ESolver_FP 类（因此说明 FP 不仅 KS 派生类需要电荷这一物理量），但 pelec 实际被声明为基类 ElecState 的指针，在 ESolver_KS_PW::Init() 中被分配以其派生类 ElecStatePW 的内存空间（同样地也有 ElecStateLCAO 派生类等），因此调用派生类构造函数： template ElecStatePW::ElecStatePW(ModulePW::PW_Basis_K *wfc_basis_in, Charge* chg_in, K_Vectors *pkv_in, ModulePW::PW_Basis* rhopw_in, ModulePW::PW_Basis_Big* bigpw_in) : basis(wfc_basis_in) { this->classname = \"ElecStatePW\"; this->init_ks(chg_in, pkv_in, pkv_in->nks, rhopw_in, bigpw_in); } 在该构造函数的函数体外初始化了成员变量 basis 以 ESolver_KS::pw_wfc。除了设置 ElecStatePW::classname 这一数据成员的具体值外，调用 ElecState::init_ks() 函数（显然继承自基类）。 ElecState::init_ks() void ElecState::init_ks(Charge* chg_in, // pointer for class Charge const K_Vectors* klist_in, int nk_in, ModulePW::PW_Basis* rhopw_in, const ModulePW::PW_Basis_Big* bigpw_in) { this->charge = chg_in; this->charge->set_rhopw(rhopw_in); this->klist = klist_in; this->bigpw = bigpw_in; // init nelec_spin with nelec and nupdown this->init_nelec_spin(); // autoset and check GlobalV::NBANDS, nelec_spin is used when NSPIN==2 this->cal_nbands(); // initialize ekb and wg this->ekb.create(nk_in, GlobalV::NBANDS); this->wg.create(nk_in, GlobalV::NBANDS); } Link Charge* ElecState::charge to Charge ESolver_FP::chg ⚠ 注意在 ElecState/ElecStatePW 类中的数据成员 charge 是 Charge 类指针，被赋值为 ESolver_FP 类的 Charge 类对象，即使得 ElecState 类的 Charge 类指针指向 ESolver_FP 的 chr 数据成员。 namespace ModuleESolver { class ESolver_FP : public ESolver { public: .... elecstate::ElecState* pelec = nullptr; Charge chr; ModuleSymmetry::Symmetry symm; .... K_Vectors kv; 因此 this->charge = chg_in; this->charge->set_rhopw(rhopw_in); 的意义在于由 ElecState::init_ks() 作为被包含在 ESolver_FP（或说 ESolver）对象中的 Charge 类对象 chg 和 PW_Basis 类 pw_rho 的连接。（是否冗余？） 变量 ElecState::klist、ElecState::bigpw、ElecState::rhopw 传入的实参也类似，同样来自于 ESolver_FP。 void Charge::set_rhopw(ModulePW::PW_Basis* rhopw_in) { this->rhopw = rhopw_in; } &#x1F914;在变量命名过程中应当注意避免随意 context 用于展开电荷的 PW_Basis 类指针 包含 Big FFT grid 的用于电荷展开的 PW_Basis_Big 类指针 ElecState 数据成员 bigpw ElecState::init_ks() rhopw_in bigpw_in ESolver_KS_PW::Init() pw_rho pw_big ESolver_FP 数据成员 pw_rho pw_big Charge 数据成员 rhopw Calculate numbers of electrons in different spin channels ElecState::init_nelec_spin() 函数的调用为 this->nelec_spin 赋值，其中 GlobalV::nupdown 的意义已经在（Introduction to ABACUS: Path to PW calculation - Part 2 ）介绍，为 up 和 down spin 的差值： void ElecState::init_nelec_spin() { this->nelec_spin.resize(GlobalV::NSPIN); if (GlobalV::NSPIN == 2) { // in fact, when TWO_EFERMI(nupdown in INPUT is not 0.0), nelec_spin will be fixed. this->nelec_spin[0] = (GlobalV::nelec + GlobalV::nupdown) / 2.0; this->nelec_spin[1] = (GlobalV::nelec - GlobalV::nupdown) / 2.0; } } Get number of bands to solve: ElecState::cal_nbands() ElecState::cal_nbands() 函数的调用为 GlobalV::NBANDS（需要计算的能带数量）这一全局变量赋值或对通过 INPUT 文件中 nbands 关键词进行赋值的值进行合理性检查。对于未在 INPUT 文件中进行赋值的情况，则在此函数之前仍然保持值为 0，之后的赋值策略为： void ElecState::cal_nbands() { .... if (GlobalV::LSPINORB == 1) occupied_bands = static_cast(GlobalV::nelec); /* it can only be the case of uks, but if so, the following method for calculating NBANDS will make this variable meaningless cuz never used! */ if ((occupied_bands - std::floor(occupied_bands)) > 0.0) { occupied_bands = std::floor(occupied_bands) + 1.0; // mohan fix 2012-04-16 } .... ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, \"occupied bands\", occupied_bands); if (GlobalV::NBANDS == 0) { if (GlobalV::NSPIN == 1) { const int nbands1 = static_cast(occupied_bands) + 10; const int nbands2 = static_cast(1.2 * occupied_bands) + 1; GlobalV::NBANDS = std::max(nbands1, nbands2); if (GlobalV::BASIS_TYPE != \"pw\") GlobalV::NBANDS = std::min(GlobalV::NBANDS, GlobalV::NLOCAL); } else if (GlobalV::NSPIN == 4) { const int nbands3 = GlobalV::nelec + 20; const int nbands4 = static_cast(1.2 * GlobalV::nelec) + 1; GlobalV::NBANDS = std::max(nbands3, nbands4); if (GlobalV::BASIS_TYPE != \"pw\") GlobalV::NBANDS = std::min(GlobalV::NBANDS, GlobalV::NLOCAL); } else if (GlobalV::NSPIN == 2) { /* max() is because the keyword nupdown can either be positive or negative */ const double max_occ = std::max(this->nelec_spin[0], this->nelec_spin[1]); const int nbands3 = static_cast(max_occ) + 11; const int nbands4 = static_cast(1.2 * max_occ) + 1; GlobalV::NBANDS = std::max(nbands3, nbands4); if (GlobalV::BASIS_TYPE != \"pw\") GlobalV::NBANDS = std::min(GlobalV::NBANDS, GlobalV::NLOCAL); } ModuleBase::GlobalFunc::AUTO_SET(\"NBANDS\", GlobalV::NBANDS); } &#x1F914;思考时间 Is there any differences bewteen the ways to assign default values for number of bands to calculate in ABACUS and Quantum ESPRESSO? 回溯：GlobalV::nelec 的值从 ESolver_KS::Init() 调用时确定（具体调用 UnitCell::cal_nelec()，Introduction to ABACUS: Path to PW calculation - Part 5）。 //module_base/global_variable.cpp GlobalV::NBANDS = 0; //module_io/input.cpp INPUT.nbands = 0; //module_io/input.cpp::Read() else if (strcmp(\"nbands\", word) == 0) // number of atom bands { read_value(ifs, nbands); } //module_io/input_conv.cpp GlobalV::NBANDS = INPUT.nbands; 对于赋值的情况则需要对其合理性进行检查，一方面是对使用 smearing 时候的 nbands 数量（对于能级简并度较高的情况，SCF 过程中能级的变化将引起能量的变化剧烈，因此可以通过 smearing 方法弥散最高占据能级附近的电子布居，使得能量变化剧烈程度减少。smearing 的具体参照一方面可以由独立费米子体系所遵循 Fermi-Dirac 统计借鉴而来，或直接采用 Gauss 分布。控制 smearing 的参数取值越大，电子偏离“0 温”越严重，但可以加速电子迭代的收敛。实际计算时，一般对半导体或者绝缘体、或者有 gap 的系统，可以不取 smearing，或者 smearing 不起作用；如果对金属系统，可以适当取一点 smearing 加速收敛，但太大容易引起结果不准确）： void ElecState::cal_nbands() { .... if (GlobalV::NBANDS == occupied_bands) { if (Occupy::gauss()) { ModuleBase::WARNING_QUIT(\"ElecState::cal_nbands\", \"for smearing, num. of bands > num. of occupied bands\"); } } Occupy 是在 input_conv 被调用时所赋值的对象， //module_io/input_conv.cpp line 589 Occupy::decision(INPUT.occupations, INPUT.smearing_method, INPUT.smearing_sigma); 而 Occupy::gauss() 的功能仅仅为： class Occupy { public: .... static const bool& gauss(void) {return use_gaussian_broadening;} 剩余部分： void ElecState::cal_nbands() { .... if (GlobalV::NBANDS == 0) {....} else { if (GlobalV::NBANDS nelec_spin[0]) { ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, \"nelec_up\", this->nelec_spin[0]); ModuleBase::WARNING_QUIT(\"ElecState::cal_nbands\", \"Too few spin up bands!\"); } if (GlobalV::NBANDS nelec_spin[1]) { ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, \"nelec_down\", this->nelec_spin[1]); ModuleBase::WARNING_QUIT(\"ElecState::cal_nbands\", \"Too few spin down bands!\"); } } } Others this->pelec->charge->allocate(GlobalV::NSPIN); this->pelec->omega = GlobalC::ucell.omega; 第二行将当前晶胞体积赋值给 ElecState 指针中该成员变量，第一行则为 Charge* ElecState::charge 申请内存空间： void Charge::allocate(const int& nspin_in) { ModuleBase::TITLE(\"Charge\", \"allocate\"); this->nrxx = this->rhopw->nrxx; // number of distributed real space grid points this->nxyz = this->rhopw->nxyz; // total number of real space grid points this->ngmc = this->rhopw->npw; // number of distributed planewaves if (allocate_rho == true) { this->destroy(); allocate_rho = false; } assert(allocate_rho == false); this->nspin = nspin_in; ....// standard output omitted here rho = new double*[nspin]; rhog = new std::complex*[nspin]; rho_save = new double*[nspin]; rhog_save = new std::complex*[nspin]; if (elecstate::get_xc_func_type() == 3 || elecstate::get_xc_func_type() == 5) { kin_r = new double*[nspin]; kin_r_save = new double*[nspin]; } //spin-by-spin (sbs) for (int is = 0; is [ngmc]; // charge density in reciprocal space sbs rho_save[is] = new double[nrxx]; // backup of rho rhog_save[is] = new std::complex[ngmc]; // backup of rhog ....// initialize above four arrays of present spin with zeros if (elecstate::get_xc_func_type() == 3 || elecstate::get_xc_func_type() == 5) { kin_r[is] = new double[nrxx]; kin_r_save[is] = new double[nrxx]; ....// initialize above two arrays of present spin with zeros } } .... // memory record omitted this->rho_core = new double[nrxx]; // core charge in real space this->rhog_core = new std::complex[ngmc]; // reciprocal core charge ....// initialize above two arrays of present spin with zeros .... // memory record omitted this->allocate_rho = true; } Initialization of Potential template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { .... // Initialize the potential. if (this->pelec->pot == nullptr) { this->pelec->pot = new elecstate::Potential(this->pw_rho, &GlobalC::ucell, &(GlobalC::ppcell.vloc), &(this->sf), &(this->pelec->f_en.etxc), &(this->pelec->f_en.vtxc)); } 接下来将各与势能相关变量的内存地址拉取到 ElecStatePW* ESolver_KS_PW::pelec 的指针成员 Potential* pot 下（继承自基类 ElecState），Potential 类构造函数被调用，初始化 pot 指针： namespace elecstate { Potential::Potential(const ModulePW::PW_Basis* rho_basis_in, const UnitCell* ucell_in, const ModuleBase::matrix* vloc_in, Structure_Factor* structure_factors_in, double* etxc_in, double* vtxc_in): ucell_(ucell_in), vloc_(vloc_in), structure_factors_(structure_factors_in), etxc_(etxc_in), vtxc_(vtxc_in) { this->rho_basis_ = rho_basis_in; this->fixed_mode = true; this->dynamic_mode = true; // allocate memory for Potential. this->allocate(); } 在 Potential 构造函数的形参表中，我们发现了从未出现过的 ModuleBase::matrix* GlobalC::ppcell 变量，以及 fenergy ElecState::f_en 变量，这些变量以内存地址形式存入 ElecStatePW* ESolver_KS_PW::pelec 中。对于 Potential::allocate() 函数，则不出例外地为数组申请内存空间： void Potential::allocate() { ModuleBase::TITLE(\"Potential\", \"allocate\"); int nrxx = this->rho_basis_->nrxx; if (nrxx == 0) return; this->v_effective_fixed.resize(nrxx); this->v_effective.create(GlobalV::NSPIN, nrxx); .... // memory record omitted if (elecstate::get_xc_func_type() == 3 || elecstate::get_xc_func_type() == 5) { this->vofk_effective.create(GlobalV::NSPIN, nrxx); .... // memory record omitted } if (GlobalV::device_flag == \"gpu\") {....} else { if (GlobalV::precision_flag == \"single\") {....} else { this->d_v_effective = this->v_effective.c; this->d_vofk_effective = this->vofk_effective.c; } // There's no need to allocate memory for double precision pointers while in a CPU environment } } // module_elecstate/potentials/potential_new.h class Potential : public PotBase { ....//google-style indent? private: .... std::vector v_effective_fixed; // Potential 和其基类 PotBase 拥有漂亮的类注释文档（link）： Initialization of rest parts of GlobalC GlobalC 和 GlobalV 是两个特殊的类，如第一版开发者文档所提到，此两种类的收益为避免过大的形参表，但负向收益为带来对两类中全局变量意外覆盖读写的隐患，因此在 ABACUS 的未来版本中，会逐步弃用 GlobalC 和 GlobalV，转而使用对象：利用高度且合理的封装方式，每次传入对象，对象包含各自相关的数据成员和函数。但就当前而言，GlobalC 提供了一些全局类。此处剩余的一些全局类申请内存空间、被初始化。 template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { if (this->psi != nullptr) delete this->psi; this->psi = this->wf.allocate(this->kv.nks, this->kv.ngk.data(), this->pw_wfc->npwk_max); // init pseudopotential GlobalC::ppcell.init(GlobalC::ucell.ntype, &this->sf, this->pw_wfc); // initalize local pseudopotential GlobalC::ppcell.init_vloc(GlobalC::ppcell.vloc, this->pw_rho); // Initalize non local pseudopotential GlobalC::ppcell.init_vnl(GlobalC::ucell); GlobalC::ppcell.cal_effective_D(); // create GlobalC::ppcell.tab_at , for trial wave functions. this->wf.init_at_1(&this->sf); // Initial start wave functions this->wf.wfcinit(this->psi, this->pw_wfc); // denghui added 20221116 this->kspw_psi = GlobalV::device_flag == \"gpu\" || GlobalV::precision_flag == \"single\" ? new psi::Psi, Device>(this->psi[0]) : reinterpret_cast, Device>*>(this->psi); ....//memory record omitted here } &#x1F4DD;笔者的话 这里有一个有趣的东西是 kspw_psi（在求力部分还有 __kspw_psi）。有兴趣的读者可以自行查看对于 gpu 或者单精度情况，在调用的 psi 构造函数中发生了什么。 实际上，kspw_psi 支持了异构计算，而 psi，如 esolver_fp.h 声明中，实际上只为 psi::Psi, Device = psi::DEVICE_CPU>* 类指针。因此真正计算架构-dependent 的是 kspw_psi。ESolver_KS_PW 为支持异构计算，整个类为模板类。在 psi 被分配内存空间后，为 kspw_psi 赋予了其数据的可达性（accessibility），reinterpret_cast 或者复制内容。 Psi Psi 是 ABACUS 中一类特殊的数据结构，用于存储波函数（平面波基函数系数）信息。其包含如下数据成员： namespace psi { template class Psi { public: int npol = 1; .... private: T* psi = nullptr; // avoid using C++ STL AbacusDevice_t device = {}; // track the device type (CPU, GPU and SYCL are supported currented) Device* ctx = {}; // an context identifier for obtaining the device variable // dimensions int nk = 1; // number of k points int nbands = 1; // number of bands int nbasis = 1; // number of basis mutable int current_k = 0; // current k point mutable int current_b = 0; // current band index mutable int current_nbasis = 1; // current number of basis of current_k // current pointer for getting the psi mutable T* psi_current = nullptr; // psi_current = psi + psi_bias; mutable int psi_bias = 0; const int* ngk = nullptr; bool k_first = true; .... }; } Codes 我们首先阅读为 Psi 申请内存空间的代码 psi::Psi> *wavefunc::allocate(const int nks, const int *ngk, const int npwx_in) { /* parameter list: nks: number of kpoints distributed on present processor ngk: number of planewaves on kpoints respectively on present processor npwx_in: maximal number of planewaves across all kpoints distributed on present processor */ this->npwx = npwx_in; assert(npwx > 0); assert(nks > 0); // if use spin orbital, do not double nks but double allocate evc and wanf2. int prefactor = 1; if(GlobalV::NSPIN==4) prefactor = GlobalV::NPOL;//added by zhengdy-soc const int nks2 = nks; psi::Psi>* psi_out = nullptr; ....// non-pw cases are omitted else { psi_out = new psi::Psi>(nks2, GlobalV::NBANDS, npwx * GlobalV::NPOL, ngk); ....// standard output and memory record omitted } return psi_out; } 即 wavefunc::allocate() 函数核心功能为为不同基组类型按照不同方式分配内存空间，仍然需要调用 psi 自己的构造函数。psi 的构造函数的重载共有 6 个（以及 1 个默认构造函数）： template class Psi { public: // Constructor 1: basic Psi(); // Constructor 2: specify ngk only, should call resize() later Psi(const int* ngk_in); // Constructor 3: specify nk, nbands, nbasis, ngk, and do not need to call resize() later Psi(int nk_in, int nbd_in, int nbs_in, const int* ngk_in = nullptr); // Constructor 4: copy a new Psi which have several k-points and several bands from inputted psi_in Psi(const Psi& psi_in, const int nk_in, int nband_in = 0); // Constructor 5: a wrapper of a data pointer, used for Operator::hPsi() // in this case, fix_k can not be used Psi(T* psi_pointer, const Psi& psi_in, const int nk_in, int nband_in = 0); // Constructor 6: initialize a new psi from the given psi_in Psi(const Psi& psi_in); // Constructor 7: initialize a new psi from the given psi_in with a different class template // in this case, psi_in may have a different device type. template Psi(const Psi& psi_in); 此处我们调用的是\"Constructor 3\"： template Psi::Psi(int nk_in, int nbd_in, int nbs_in, const int* ngk_in) { this->ngk = ngk_in; this->current_b = 0; this->current_k = 0; this->npol = GlobalV::NPOL; this->device = device::get_device_type(this->ctx); this->resize(nk_in, nbd_in, nbs_in); // Currently only GPU's implementation is supported for device recording! ....//device recording omitted } template void Psi::resize(const int nks_in, const int nbands_in, const int nbasis_in) { assert(nks_in > 0 && nbands_in >= 0 && nbasis_in > 0); // This function will delete the psi array first(if psi exist), then malloc a new memory for it. resize_memory_op()(this->ctx, this->psi, nks_in * nbands_in * nbasis_in, \"no_record\"); this->nk = nks_in; this->nbands = nbands_in; this->nbasis = nbasis_in; this->current_nbasis = nbasis_in; this->psi_current = this->psi; // GlobalV::ofs_device //psi.h line 130 using resize_memory_op = psi::memory::resize_memory_op; //module_psi/kernels/memory_op.h namespace psi { namespace memory { template struct resize_memory_op { void operator()(const Device* dev, FPTYPE*& arr, const size_t size, const char* record_in = nullptr); }; //module_psi/kernels/memory_op.cpp namespace psi{ namespace memory{ template struct resize_memory_op { void operator()(const psi::DEVICE_CPU* dev, FPTYPE*& arr, const size_t size, const char* record_in) { if (arr != nullptr) free(arr); arr = (FPTYPE*) malloc(sizeof(FPTYPE) * size); std::string record_string; if(record_in != nullptr) record_string = record_in; else record_string = \"no_record\"; if(record_string != \"no_record\" ) { ModuleBase::Memory::record(record_string , sizeof(FPTYPE) * size); } } }; 因此 Psi 类对象最终使用 resize_memory_op() 来为 Psi::psi 数据成员进行内存申请，用于存储波函数信息/其同样是 3d-flatten，即申请的实际上是一级指针，规模为 [ikpoint][iband][ibasis]。 Feature: struct with overloaded \"()\", extends the way of defining functions Psi 申请内存时使用了在之前介绍的 ABACUS 代码中从未出现过的方式，即创建模板类结构体，之后在其中重载括号运算符，以调用函数的方式使用重载的括号。这种方式为 C++ 结构体所独有，是固定特性，对原本的函数实现方式实现了更大范围的拓展，结合 using 关键字，可以达到模板类实例化、封装、多态等效果。 并且 resize_memory_op()(this->ctx, this->psi, nks_in * nbands_in * nbasis_in, \"no_record\"); 实际可以写为 resize_memory_op(this->ctx, this->psi, nks_in * nbands_in * nbasis_in, \"no_record\"); 和原本的函数使用方法更加相似。类似的例子还有关于 Psi 类对象其他内存空间的操作： namespace psi { template class Psi { public: .... private: .... using set_memory_op = psi::memory::set_memory_op; using delete_memory_op = psi::memory::delete_memory_op; using resize_memory_op = psi::memory::resize_memory_op; using synchronize_memory_op = psi::memory::synchronize_memory_op; }; } // end of namespace psi template struct delete_memory_op { /// @brief free memory for multi-device /// \\param dev : the type of computing device /// \\param arr : the input array void operator()(const Device* dev, FPTYPE* arr); }; template struct delete_memory_op { void operator()(const psi::DEVICE_CPU* dev, FPTYPE* arr) { free(arr); } }; template struct set_memory_op { /// @brief memset for multi-device /// \\param dev : the type of computing device /// \\param var : the specified constant value /// \\param size : array size /// Output Parameters /// \\param arr : output array initialized by the input value void operator()(const Device* dev, FPTYPE* arr, const int var, const size_t size); }; template struct set_memory_op { void operator()(const psi::DEVICE_CPU* dev, FPTYPE* arr, const int var, const size_t size) { ModuleBase::OMP_PARALLEL([&](int num_thread, int thread_id) { int beg, len; ModuleBase::BLOCK_TASK_DIST_1D(num_thread, thread_id, size, (size_t)4096/sizeof(FPTYPE), beg, len); memset(arr + beg, var, sizeof(FPTYPE)*len); }); } }; template struct synchronize_memory_op { /// @brief memcpy for multi-device /// \\param dev_out : the type of computing device of arr_out /// \\param dev_in : the type of computing device of arr_in /// \\param arr_in : input array /// \\param size : array size /// Output Parameters /// \\param arr_out : output array initialized by the input array void operator()( const Device_out* dev_out, const Device_in* dev_in, FPTYPE* arr_out, const FPTYPE* arr_in, const size_t size); }; template struct synchronize_memory_op { void operator()( const psi::DEVICE_CPU* dev_out, const psi::DEVICE_CPU* dev_in, FPTYPE* arr_out, const FPTYPE* arr_in, const size_t size) { ModuleBase::OMP_PARALLEL([&](int num_thread, int thread_id) { int beg, len; ModuleBase::BLOCK_TASK_DIST_1D(num_thread, thread_id, size, (size_t)4096/sizeof(FPTYPE), beg, len); memcpy(arr_out + beg, arr_in + beg, sizeof(FPTYPE)*len); }); } }; 这种方式实现了模板函数的偏特化（partial specialization）需求（see cppreference），即首先实例化其中一个模板参数，之后再在其他地方实例化另一个。在更新的 C++20 版本中，使用 concepts（requires, see C++20）可以达到类似效果（see cppstories）。 在 ESolver_KS_PW()::init()的最后还有如下语句： this->kspw_psi = GlobalV::device_flag == \"gpu\" || GlobalV::precision_flag == \"single\" ? new psi::Psi, Device>(this->psi[0]) : reinterpret_cast, Device>*>(this->psi); 我们不考虑 GPU 和单精度的情况，因此以上等价于： this->kspw_psi = reinterpret_cast>*>(this->psi); pseudopot_cell_vnl Before init() 我们之前没有特别关注过这个被声明在 GlobalC 里的全局类（line 278），这里我们首先非常粗略回顾其顾名思义的非局域项的原理，之后在下一篇中对该类成员函数的一些细节进行详细说明（但仍然不会逐行逐句进行“翻译”）。该类的名字 pseudopot_cell_vnl 实际上是 pseudopotential_cell_V(potential)_nonlocal 的缩写。首先简单介绍 Kleinman-Bylander 方法（Phys. Rev. Lett. 48, 1425（1982））将 pseudopotential 分为完全非局域和局域部分： \\hat{V}^{\\mathrm{KB}}=\\sum_{l=0}^{l_{max}}{\\sum_{m=-l}^{+l}{\\sum_{i=1}{|\\chi _{lm,i}\\rangle V_{li}^{KB}\\langle \\chi _{lm,i}|}}}. Therefore the fully nonlocal part of pp. has projectors of different angular momentum, magnetic quantum number and basis functions. That is to say, this projector will project one state onto some basic states at such kind of resolution. The basis of projector, is constructed in this way: > \\chi _{lm,i}\\left( \\mathbf{r} \\right) =\\langle \\mathbf{r}|\\chi _{lm,i}\\rangle =R_{l,i}\\left( r \\right) Y_{lm}\\left( \\hat{\\mathbf{r}} \\right) > It is, similar with a hydrogen wavefunction that has radial part and angular part. The angular part, is represented by spherical harmonic function, and basis function, is only used for constructing radial part of the basis of projector \\hat{V}^{KB}. However, what is V^{KB}_{li} ? How is it calculated? V_{li}^{KB}=\\langle \\varphi _{li}|\\delta V_l|\\varphi _{li}\\rangle , where \\delta V_l=V_l(r)-V^{local}(r), from semilocal pp. V_l(r) (the one may directly read from portable pp. files like *.UPF), subtract the local part from it, leaving term \\delta V_l(r), is angular momentum-resoluted, while the local part is not. Imagine \\delta V_l(r) itself has its eigenspace and for each axis there is an eigenvalue. Any state can be expanded by eigenvectors \\{|v_{li}\\rangle\\} of \\delta V_l(r)-space. Thus, |\\varphi _{li}\\rangle =\\sum_k{c_{ik}|v_{lk}\\rangle}, > \\langle \\varphi _{li}|\\delta V_l|\\varphi _{li}\\rangle =\\langle \\varphi _{li}|\\sum_j{|v_{lj}\\rangle v_{lj}\\langle v_{lj}|}\\varphi _{li}\\rangle > \\ =\\sum{k^{\\prime}}{c{ik^{\\prime}}^{\\dagger}\\langle v{lk^{\\prime}}}|\\sum_j{|v{lj}\\rangle v{lj}\\langle v{lj}|}\\sumk{c{ik}|v{lk}\\rangle} \\ =\\sum{k^{\\prime}}{\\sumk{\\sum_j{c{ik^{\\prime}}^{\\dagger}c{ik}\\langle v{lk^{\\prime}}|v{lj}\\rangle v{lj}\\langle v{lj}|v{lk}\\rangle}}} \\ =\\sum{k^{\\prime}}{\\sum_k{\\sum_j{c{ik^{\\prime}}^{\\dagger}c{ik}\\delta {k^{\\prime}j}\\delta {kj}v{lj}}}} \\ =\\sumj{c{ij}^{\\dagger}c{ij}v{lj}}=\\sumj{c{ij}^{2}v{lj}} \\ =v{l1}\\left( c{i1}^{2} \\right) +v{l2}\\left( c{i2}^{2} \\right) +... > The result above is, norm of vector/state |\\varphi{li}\\rangle in eigen-space of operator \\delta Vl. > It is the same for any other kinds of scalar product, thus Schmidt orthogonalization in any arbitrary space has a more general form. For example, states {\\varphi{li}} is \\delta V_l-space-orthogonalized version of eigenstates of V_l(r), the semilocal pp employing KS eq.: > > |\\varphi {li}\\rangle =|\\psi {li}\\rangle -\\sum{i^{\\prime}=1}^{i-1}{|\\varphi {li^{\\prime}}\\rangle \\frac{\\langle \\varphi {li^{\\prime}}|\\delta V_l|\\psi {li^{\\prime}}\\rangle}{\\langle \\varphi {li^{\\prime}}|\\delta V_l|\\varphi {li^{\\prime}}\\rangle}} > > The term V^{local} is however, somewhat arbitrary, a sphericallly symmetrical charge distribution is directly given in this paper as: > > \\rho^{local}(r)=A\\exp[-(\\frac{\\sinh(abr)}{\\sinh(br)})^2] > > Parameters aand b are arbitrary. In paper ais optimized to 1.82/r_{core}$$, b is 1. 另一方面，自 ABACUS 开始运行时便调用其构造函数的 pseudopot_cell_vnl，有如下数据成员具有初始值： 变量 默认值 意义 备注 multi_proj false 是否使用多个投影子（projector） s_deeq, d_deeq, c_deeq_nc, z_deeq_nc nullptr s_nhtol, s_nhtolm, s_indv, s_tab nullptr c_vkb nullptr Kleinman-Bylander 完全非局域赝势 d_nhtol, d_nhtolm, d_indv, d_tab nullptr z_vkb nullptr Kleinman-Bylander 完全非局域赝势 wfcpw nullptr 平面波基波函数的指针 Init() 被赋值为 PW_Basis_K* ESolver_KS_PW::pw_wfc psf nullptr 结构因子指针 Init() 被赋值为 Structure_Factor* ESolver_KS_PW::sf 在下一篇中，我们将更加细致地探究这个类的其他被 Init_GlobalC() 函数所调用的成员函数。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 6 下篇：Introduction to ABACUS: Path to PW calculation - Part 8 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-05 11:01:13 "},"develop-path8.html":{"url":"develop-path8.html","title":"Introduction to ABACUS: Path to PW calculation - Part 8","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 8 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 8 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class Initialization of rest parts of GlobalC pseudopot_cell_vnl pseudopot_cell_vnl::init() init() 函数赋值以下变量，并为指针和数组进行初始化： 变量 意义 操作 wfcpw ESolver_KS_PW 对象中 PW_Basis_K 类指针 exact value psf ...对象中 Structure_Factor 类指针 exact value lmaxkb 跨原子种类的 projector 最大角动量 exact value nhm 原子种类的 projector 最大数量 zero nkb 所有原子的 projector 数量总和 zero indv 映射表，从[原子种类索引][projector 全局索引]到“原子种类内 projector 索引” zero nhtol 映射表，从[原子种类索引][projector 全局索引]到 projector 角量子数 l zero nhtolm 映射表，从[原子种类索引][projector 全局索引]到 projector 的(l,m)-pair: 0: s, 1/2/3: p, 4/5/6/7/8: d, ... zero nhtoj 映射表，从[原子种类索引][projector 全局索引]到 projector 总角量子数 zero deeq 赝势block 中数据（projector-projector），存储为[自旋 channel 索引][原子种类索引][projector1 索引][projector2 索引] zero deeq_nc Spin-orbit coupling case specific deeq zero z_deeq_nc double 指针，指向 deeq_nc d_deeq double 指针，指向 deeq exact value d_indv double 指针，指向 indv exact value d_nhtol double 指针，指向 nhtol exact value d_nhtolm double 指针，指向 nhtolm exact value dvan 赝势 projector 间，存储为[原子种类][projector1 全局索引][projector2 全局索引] zero dvan_so Spin-orbit coupling case specific dvan, 存储为[自旋 channel 索引][原子种类][projector1 全局索引][projector2 全局索引] zero becsum 存储为[自选channel索引][原子索引][(projectori,projectorj)-pair数量/2] zero lmaxq 2 * this->lmaxkb + 1; exact value vkb 倒空间V^{KB}值，即V_i(\\mathbf{G}_j)^{KB}, i\\inN(projector)，j\\inN(planewaves) zero GlobalV::NQX 球 Bessel 函数的 q-空间格点数量 exact value tab 插值表，表值\\frac{4\\pi}{\\sqrt{\\Omega}}\\int{r^2\\text{d}r\\beta_{\\alpha i}(r)j_l(qr)}, 存储为[原子种类][projector 索引][q索引] zero tab_at 原子波函数插值表 zero z_vkb double 指针，指向 vkb d_tab double 指针，指向 tab 因此部分函数冗长但功能简单，可读性强，因此不逐行解读，如需寻找代码细节，请自行阅读（link）。 pseudopot_cell_vnl::init_vloc() code template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { .... //================================= // initalize local pseudopotential //================================= GlobalC::ppcell.init_vloc(GlobalC::ppcell.vloc, this->pw_rho); ModuleBase::GlobalFunc::DONE(GlobalV::ofs_running, \"LOCAL POTENTIAL\"); //VL_in_pw.cpp void pseudopot_cell_vl::init_vloc(ModuleBase::matrix& vloc_in, const ModulePW::PW_Basis* rho_basis) { .... double *vloc1d = new double[rho_basis->ngg]; ModuleBase::GlobalFunc::ZEROS(vloc1d, rho_basis->ngg); this->allocate(rho_basis->ngg); for (int it = 0; it ngg); this->zp[it] = atom->ncpp.zv; if(numeric[it]==true) { this->vloc_of_g(atom->ncpp.msh, atom->ncpp.rab, atom->ncpp.r, atom->ncpp.vloc_at, this->zp[it], vloc1d, rho_basis); } else ModuleBase::WARNING_QUIT(\"init_vloc\",\"not available now.\"); if(it>=0 && it=0) ModuleBase::GlobalFunc::COPYARRAY(vloc1d, &vloc_in(it, 0), rho_basis->ngg); } delete[] vloc1d; this->print_vloc(rho_basis); } 回顾在 Part 3（Introduction to ABACUS: Path to PW calculation - Part 3）曾经读取过赝势到 UnitCell::atom.ncpp 数据成员中，pseudopot_cell_vl::init_vloc() 函数调用 pseudopot_cell_vl::vloc_of_g() 对实空间局域势进行傅里叶变换： V_{\\mathrm{loc}}\\left( \\mathbf{G} \\right) =\\mathscr{F} \\left[ V_{\\mathrm{loc}}\\left( \\mathbf{r} \\right) \\right] =\\mathscr{F} \\left[ V_{\\mathrm{loc}}\\left( \\mathbf{r} \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right] -\\frac{Ze^2}{r}\\mathscr{F} \\left[ \\mathrm{erf}\\left( r \\right) \\right] 后一项具有解析解， \\frac{Ze^2}{r}\\mathscr{F} \\left[ \\mathrm{erf}\\left( r \\right) \\right] =Ze^2\\frac{\\exp \\left[ -\\frac{|\\mathbf{G}|^2}{4} \\right]}{|\\mathbf{G}|^2} 前一项的傅里叶变换可以继续化简： \\mathscr{F} \\left[ V_{\\mathrm{loc}}\\left( \\mathbf{r} \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right] =\\frac{1}{\\Omega}\\int{\\mathrm{d}\\mathbf{r}e^{-i\\mathbf{G}\\cdot \\mathbf{r}}\\left[ V_{\\mathrm{loc}}\\left( \\mathbf{r} \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{1}{\\Omega}\\int{r^2\\mathrm{d}r\\int_0^{\\pi}{\\sin \\theta \\mathrm{d}\\theta}\\int_0^{2\\pi}{\\mathrm{d}\\phi}e^{-i|\\mathbf{G}||\\mathbf{r}|\\cos \\theta}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{2\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\int_0^{\\pi}{\\sin \\theta \\mathrm{d}\\theta}e^{-i|\\mathbf{G}|r\\cos \\theta}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{2\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\int_1^{-1}{\\mathrm{d}t}e^{-i|\\mathbf{G}|rt}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{2\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\frac{e^{i|\\mathbf{G}|r}-e^{-i|\\mathbf{G}|r}}{i|\\mathbf{G}|r}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{4\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\frac{\\sin \\left( |\\mathbf{G}|r \\right)}{|\\mathbf{G}|r}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} 最后得到： V_{\\mathrm{loc}}\\left( \\mathbf{G} \\right) =\\frac{4\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\frac{\\sin \\left( |\\mathbf{G}|r \\right)}{|\\mathbf{G}|r}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]}-Ze^2\\frac{\\exp \\left[ -\\frac{|\\mathbf{G}|^2}{4} \\right]}{|\\mathbf{G}|^2} &#x1F914;思考时间 Write a piece of code to calculate the term above! Compare with the version in ABACUS source code, what are your pros and what are your cons? If you are confident enough with your codes in aspect of well-documenting, clean-formatting and even efficiency and accurancy, why not pull a request to replace the present one? Do it! Relevant topic: a glimpse of Ewald summation 数值计算过程中需要考虑更多的技术问题，对于函数积分的可收敛性是其中一个重要的方面。erf(x)和 erfc(x)分别定义为： \\mathrm{erf}\\left( x \\right) \\equiv \\int_0^x{\\exp \\left[ -t^2 \\right] \\mathrm{d}t} \\mathrm{erfc}\\left( x \\right) \\equiv 1-\\mathrm{erf}\\left( x \\right) 就实际应用场景而言，原子势能就是其中之一。为避免V(r)=-\\frac{Ze^2}{r}的傅里叶变换可能存在的积分发散，使用 erf(x)来 rescale 它，得到： V^\\text{loc}(r)\\equiv V(r)\\text{erf}(r) V^\\text{nloc}(r)\\equiv V(r)\\text{erfc}(r) 进而让V^\\text{nloc}(r)在倒空间进行加和，V^\\text{loc}(r)在实空间进行加和。 &#x1F914; 思考时间 The following reading materials are generated by OpenAI GPT-4, read it and try to understand the use of erf(x) function Ewald summation is a method used to compute long-range electrostatic interactions in periodic systems. It's especially important in simulations of crystalline solids and other periodic systems because the straightforward summation of pairwise Coulomb interactions converges very slowly due to the long-range nature of the interaction. Here's a brief outline with the essential mathematical details: The Problem In a periodic system, the electrostatic energy U due to a set of charged particles can be written as: U=\\frac{1}{2}\\sum_{ij, \\mathbf{T}}{\\frac{q_iq_j}{|\\mathbf{\\tau}_i-\\mathbf{\\tau}_j+\\mathbf{T}|}} Where: q_i and q_j are the charges of particles i and j. \\mathbf{\\tau}_i and \\mathbf{\\tau}_j are their positions. \\mathbf{T} represents a lattice vector of the periodic system. The summation over \\mathbf{T} includes all periodic replicas of the system. Ewald's Idea Ewald summation splits the Coulomb interaction into two parts: Short-range, real-space sum: This converges quickly in real space. Long-range, reciprocal-space sum: This converges quickly in Fourier (reciprocal) space. The Split To achieve this, Ewald introduced a splitting function \\text{erf}(r)/r (complementary error function) such that: > \\frac{1}{r}=\\frac{\\text{erf}(\\alpha r)}{r}+\\frac{\\text{erfc}(\\alpha r)}{r} > \\text{erf} is the error function. \\alpha is a free parameter that can be chosen to optimize convergence. The first term on the right-hand side is short-ranged and is treated in real space. The second term is treated in reciprocal space. The Two Parts Real-Space Sum: U_\\text{real}=\\frac{1}{2}\\sum_{ij, \\mathbf{T}}{q_iq_j\\frac{\\text{erf}(\\alpha|\\mathbf{\\tau}_i-\\mathbf{\\tau}_j+\\mathbf{T}|)}{|\\mathbf{\\tau}_i-\\mathbf{\\tau}_j+\\mathbf{T}|}} (Only nearby terms are summed, as this converges quickly in real space.) Reciprocal-Space Sum: U_\\text{recip}=\\frac{1}{2\\pi\\Omega}\\sum_{\\mathbf{G}\\neq0}{\\frac{\\exp[-\\frac{G^2}{4\\alpha^2}]}{G^2}|\\sum_{i}{q_i\\exp[i\\mathbf{G}\\cdot\\mathbf{r}_i]}|^2} Where \\mathbf{G} are the reciprocal lattice vectors and \\Omega is the volume of the unit cell. An additional self-energy term and surface term are added to correct for the self-interaction and surface effects. Conclusion The Ewald summation provides a more efficient way to compute the electrostatic interactions in a periodic system. By treating short-range interactions in real space and long-range interactions in reciprocal space, both parts converge much faster than the naive pairwise sum. &#x1F914;思考时间 More specifically the Ewald summation technique, there are many derivatives of it, for the Ewald summation takes a large part of computation time in classical Molecular dyanmics simulation. Further reading: PME (Particle Mesh Ewald summation), SPME (Smoothed Particle Mesh Ewald summation). Nonlocal pseudopotential initialization template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { .... //====================================== // Initalize non local pseudopotential //====================================== GlobalC::ppcell.init_vnl(GlobalC::ucell); ModuleBase::GlobalFunc::DONE(GlobalV::ofs_running, \"NON-LOCAL POTENTIAL\"); GlobalC::ppcell.cal_effective_D(); pseudopot_cell_vnl::init_vnl() 在上篇（Introduction to ABACUS: Path to PW calculation - Part 7 ）和 init() 函数中（link）已经阐明各变量的意义，init_vnl()则对非局域赝势相关变量（nhtol, nhtolm, nhtoj, indv, dvan/dvan_so, tab 等）进行了实际的赋值操作，使其符合表（link）中描述。考虑到篇幅限制和实际需求，此处 SOC 相关部分略过，但保留链接可供自行查看：link pseudopot_cell_vnl::cal_effective_D() 先前实际上已经对D_{ij}的出现位置进行过介绍（Introduction to ABACUS: Path to PW calculation - Part 3 ），此处 cal_effective_D() 则实现的是从 dvan（[原子种类][global index of projectori][global index of projectorj]）到 deeq（[ispin][global index of atom][index of projectori][index of projectorj]）的数据拷贝。 void pseudopot_cell_vnl::cal_effective_D(void) { ModuleBase::TITLE(\"pseudopot_cell_vnl\", \"cal_effective_D\"); for (int iat = 0; iat deeq(is, iat, ih, jh) = this->dvan(it, ih, jh); this->deeq(is, iat, jh, ih) = this->dvan(it, ih, jh); if(ih != jh && std::fabs(this->deeq(is, iat, ih, jh))>0.0) { this->multi_proj = true; } } } } } } if (GlobalV::device_flag == \"gpu\") {....} else { if (GlobalV::precision_flag == \"single\") {....} } } 亦即对于 nspin≤2 的情况，一开始的 projector 其配置完全相同，而对于 nspin=4 的情况，ispin=0 和 3 的数值和 nspin≤2 的 ispin=0 和 1 相同，而 ispin=1 和 2 则在此处被初始化为 std::complex(0.,0.)。 到这里，GlobalC::pseudopot_cell_vnl ppcell 中大部分数据成员的值均从 UnitCell::atoms::ncpp 中获得，即实现了如下数据传输方式： 即赝势数据从 upf 文件经 UnitCell::atom.ncpp 解析，上传至 GlobalC 中，详细其对应类为 GlobalC::pseudopot_cell_vnl，具体实例化对象为 ppcell。这一操作类似于 Input::INPUT 解析 INPUT 文件，上传至 GlobalV，唯一的区别是 GlobalV 直接以散装变量方式存储。 &#x1F527;重构信息 回顾当前 ABACUS 版本中从外部读入数据的传递模式： STRU 文件的读取，使用的为 UnitCell 中方法，UnitCell 中存储，并且 UnitCell 本身也属于 GlobalC，为全局变量。 KPT 文件的读取，使用 K_Vectors 类中方法，但 K_Vectors 对象被声明在 ESolver_FP 中，并非 GlobalC。 INPUT 文件的读取，使用 Input 类中方法，Input 被声明为 extern，其成员函数 Input::input_conv() 将大部分变量传到 GlobalV，少部分直接传到具体的类数据成员中。 &#x1F616; somewhat in mess wavefunc wf_atomic::init_at_1() template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { .... //================================================== // create GlobalC::ppcell.tab_at , for trial wave functions. //================================================== this->wf.init_at_1(&this->sf); 回忆 wavefunc 实际为 ESolver_KS 中数据成员，因 ESolver_FP 还包括 ESolver_OF 即 orbital-free dft 方法，此种方法不需要显式的波函数，而 init_GlobalC 是 ESolver_KS_PW 类成员函数，因此其中所有\"this->\"都为当前类对象的指针。init_at_1() 由 wavefunc 类继承自 wf_atomic，此函数归一化了原子的 pswfc（\\tilde{\\phi}^\\alpha_{i}(r)，即赝波函数，pseudo wavefunction），之后对其求 tab_at(it, ic, iq) = \\frac{4\\pi}{\\sqrt{\\Omega}}\\int_{0}^{r_\\text{cut}}{j_l(qr)\\tilde{\\phi}^\\alpha_{i}(r)r^2dr} 。注意如 Part 3 所提到，实际读取的 pswfc 已经乘以 r。 wavefunc::wfcinit() template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { .... //================================ // Initial start wave functions //================================ this->wf.wfcinit(this->psi, this->pw_wfc); void wavefunc::wfcinit(psi::Psi> *psi_in, ModulePW::PW_Basis_K *wfc_basis) { .... if (GlobalV::BASIS_TYPE == \"pw\") { if (this->irindex != nullptr) delete[] this->irindex; this->irindex = new int[wfc_basis->fftnxy]; wfc_basis->getfftixy2is(this->irindex); } .... } ASE philosophy: the so-called dynamics 我们通过 ESolver 初始化工作流，之后使用 Relax_Driver 类对象运行工作流。 void Driver::driver_run() { .... if(GlobalV::CALCULATION == \"md\") { Run_MD::md_line(GlobalC::ucell, p_esolver, INPUT.mdp); } else // scf; cell relaxation; nscf; etc { Relax_Driver rl_driver; rl_driver.relax_driver(p_esolver); } 这是我们首次提到这个类，检查发现 Relax_Driver 并非直接显式包含在当前 driver_run.cpp 中，而是位于 #include \"module_hamilt_pw/hamilt_pwdft/global.h\" ，可以发现 #include \"module_relax/relax_driver.h\" 。一窥 Relax_Driver 类的数据成员： class Relax_Driver { public: Relax_Driver(){}; ~Relax_Driver(){}; void relax_driver(ModuleESolver::ESolver *p_esolver); private: // mohan add 2021-01-28 // mohan moved this variable from electrons.h to relax_driver.h int istep = 0; double etot = 0; // new relaxation method Relax rl; // old relaxation method Relax_old rl_old; }; 因为我们只考虑 PW-SCF 计算任务，因此 Relax 和 Relax_old 类成员我们可暂且不去关心。Relax_Driver 类构造函数直接在当前头文件中定义为空，因此只剩下 Relax_Driver::relax_driver() 成员函数： void Relax_Driver::relax_driver(ModuleESolver::ESolver *p_esolver) { ....//omit output and timer if (GlobalV::CALCULATION == \"relax\" || GlobalV::CALCULATION == \"cell-relax\") {....} this->istep = 1; ....//omit force and stree step defnition bool stop = false; while (istep Run(istep - 1, GlobalC::ucell); ....//omit timer if (GlobalV::CALCULATION == \"scf\" || GlobalV::CALCULATION == \"relax\" || GlobalV::CALCULATION == \"cell-relax\") { this->etot = p_esolver->cal_Energy(); ....// omit, calculate and gather all parts of total ionic forces ....// omit, calculate and gather all parts of stress if (GlobalV::CALCULATION == \"relax\" || GlobalV::CALCULATION == \"cell-relax\") {....} } } ....//omit timer ++istep; } ....//omit output and timer } 通过检查 ESolver 各派生类和基类之间的继承关系，ESolver_KS::Run() 为此时实际调用的函数。 ESolver::Run()/ESolver_KS::Run() template void ESolver_KS::Run(const int istep, UnitCell& ucell) { ....//omit totally irelevant lines else { ....//omit timer this->beforescf(istep); //Something else to do before the iter loop ....//omit record and output bool firstscf = true; this->conv_elec = false; this->niter = this->maxniter; for (int iter = 1; iter maxniter; ++iter) { writehead(GlobalV::ofs_running, istep, iter); #ifdef __MPI auto iterstart = MPI_Wtime(); ....//omit non-mpi case #endif double diag_ethr = this->phsol->set_diagethr(istep, iter, drho); eachiterinit(istep, iter); this->hamilt2density(istep, iter, diag_ethr); if(GlobalV::MY_STOGROUP == 0) { drho = p_chgmix->get_drho(pelec->charge, GlobalV::nelec); double hsolver_error = 0.0; if (firstscf) { firstscf = false; hsolver_error = this->phsol->cal_hsolerror(); if (hsolver_error > drho) { diag_ethr = this->phsol->reset_diagethr(GlobalV::ofs_running, hsolver_error, drho); this->hamilt2density(istep, iter, diag_ethr); drho = p_chgmix->get_drho(pelec->charge, GlobalV::nelec); hsolver_error = this->phsol->cal_hsolerror(); } } this->conv_elec = (drho scf_thr); // If drho conv_elec) { if (drho pelec->cal_bandgap(); bandgap_for_autoset = this->pelec->bandgap; } else { this->pelec->cal_bandgap_updw(); bandgap_for_autoset = std::min(this->pelec->bandgap_up, this->pelec->bandgap_dw); } p_chgmix->auto_set(bandgap_for_autoset, GlobalC::ucell); } p_chgmix->mix_rho(iter, pelec->charge); } } #ifdef __MPI MPI_Bcast(&drho, 1, MPI_DOUBLE , 0, PARAPW_WORLD); MPI_Bcast(&this->conv_elec, 1, MPI_DOUBLE , 0, PARAPW_WORLD); MPI_Bcast(pelec->charge->rho[0], this->pw_rho->nrxx, MPI_DOUBLE, 0, PARAPW_WORLD); #endif updatepot(istep, iter); eachiterfinish(iter); #ifdef __MPI double duration = (double)(MPI_Wtime() - iterstart); ....//omit non-mpi case #endif printiter(iter, drho, duration, diag_ethr); if (this->conv_elec) { this->niter = iter; bool stop = this->do_after_converge(iter); if(stop) break; } } afterscf(istep); ....//omit timer } }; 下一篇我们将基于 ESolver_KS::Run() 正式步入 ABACUS 的主要工作部分，并暂时将 Relax_Driver::relax_driver() 函数提级为一级标题。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 7 下篇：Introduction to ABACUS: Path to PW calculation - Part 9 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-05 11:07:43 "},"develop-path9.html":{"url":"develop-path9.html","title":"Introduction to ABACUS: Path to PW calculation - Part 9","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 9 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 9 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 &#x1F914;Walk out! From now on, more codes and fewer explanations, try to understand more ABACUS codes on your own! Relax_Driver::relax_driver() void Relax_Driver::relax_driver(ModuleESolver::ESolver *p_esolver) { ....//omit timer and record if (GlobalV::CALCULATION == \"relax\" || GlobalV::CALCULATION == \"cell-relax\") {....} this->istep = 1; int force_step = 1; // pengfei Li 2018-05-14 int stress_step = 1; bool stop = false; while (istep Run(istep - 1, GlobalC::ucell); 考虑到我们目前仅考虑 pw-scf 的情况，因此跳过第一个 if 判断。GlobalV::RELAX_NMAX 的值在 global_variable.cpp 中被初始化为 20，因此忽略关于 OUT_LEVEL 的判断，来到 p_esolver->Run(istep - 1, GlobalC::ucell); 目前 p_esolver 实际为 ESolver_KS_PW 类，上级基类分别为 ESolver_KS, ESolver_FP, ESolver。Run() 函数在 ESolver 类中被声明为纯虚函数，由于 ESolver_KS_PW 和 ESolver_FP 中并无 Run() 函数定义，ESolver_KS 中定义的 Run() 函数 namespace ModuleESolver { template class ESolver_KS : public ESolver_FP { public: .... virtual void Run(const int istep, UnitCell& cell) override; 会被调用。 ESolver_KS::Run() Source code: ESolver_KS::Run() Visualization: Beforescf beforescf() 函数在 ESolver_KS 中为虚函数，实际调用 ESolver_KS_PW 该派生类对函数的重载。 namespace ModuleESolver { template class ESolver_KS : public ESolver_FP { .... protected: // Something to do before SCF iterations. virtual void beforescf(int istep) {}; Build Hamilton operator 我们省略 relax 和 vcrelax 的部分，来到 p_hamilt 这一属于 hmilt::HamiltPW 类指针的内存刷新（delete and new）： template void ESolver_KS_PW::beforescf(int istep) { .... if (GlobalC::ucell.cell_parameter_updated) {....} if (GlobalC::ucell.ionic_position_updated) {....} if (this->p_hamilt != nullptr) { delete reinterpret_cast*>(this->p_hamilt); this->p_hamilt = nullptr; } // allocate HamiltPW if (this->p_hamilt == nullptr) { this->p_hamilt = new hamilt::HamiltPW(this->pelec->pot, this->pw_wfc, &this->kv); } auto vdw_solver = vdw::make_vdw(GlobalC::ucell, INPUT); if (vdw_solver != nullptr) this->pelec->f_en.evdw = vdw_solver->get_energy(); .... } 这一刷新操作使得 HamiltPW 的构造函数再次被调用，构造 Hamiltonian 算符： template HamiltPW::HamiltPW(elecstate::Potential* pot_in, ModulePW::PW_Basis_K* wfc_basis, K_Vectors* pkv) { this->classname = \"HamiltPW\"; const auto tpiba2 = static_cast(GlobalC::ucell.tpiba2); const auto tpiba = static_cast(GlobalC::ucell.tpiba); const int* isk = pkv->isk.data(); const FPTYPE* gk2 = wfc_basis->get_gk2_data(); if (GlobalV::T_IN_H) { Operator, Device>* ekinetic = new Ekinetic>(....); if(this->ops == nullptr) this->ops = ekinetic; else this->ops->add(ekinetic); } if (GlobalV::VL_IN_H) { std::vector pot_register_in; if (GlobalV::VION_IN_H) pot_register_in.push_back(\"local\"); if (GlobalV::VH_IN_H) pot_register_in.push_back(\"hartree\"); pot_register_in.push_back(\"xc\"); if (GlobalV::imp_sol) pot_register_in.push_back(\"surchem\"); if (GlobalV::EFIELD_FLAG) pot_register_in.push_back(\"efield\"); if (GlobalV::GATE_FLAG) pot_register_in.push_back(\"gatefield\"); if(pot_register_in.size()>0) { pot_in->pot_register(pot_register_in); Operator, Device>* veff = new Veff>(....); if(this->ops == nullptr) this->ops = veff; else this->ops->add(veff); Operator, Device>* meta = new Meta>(....); this->ops->add(meta); } } if (GlobalV::VNL_IN_H) { Operator, Device>* nonlocal = new Nonlocal>(....); if(this->ops == nullptr) this->ops = nonlocal; else this->ops->add(nonlocal); } } 稍加观察就可以发现，T_IN_H、VL_IN_H、VION_IN_H 等量控制了 Hamilton 算符中包含项的多少：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#variables-useful-for-debugging HamiltPW 和其基类 Hamilt 包含数据成员关系如下： Operator (ops)在 Hamilt 中的存储方式类似链表： Operator 类 Operator 类中各算符继承关系如下： 其中算符可能具有部分共享变量。在 HamiltPW 的构造函数中，省略了动能算符、有效势能算符、Meta 算符和非局域算符的构造函数形参表，其具体内容分别为： Kinetic term: the kinetic operator template HamiltPW::HamiltPW(elecstate::Potential* pot_in, ModulePW::PW_Basis_K* wfc_basis, K_Vectors* pkv) { .... if (GlobalV::T_IN_H) { .... Operator, Device>* ekinetic = new Ekinetic>(tpiba2, gk2, wfc_basis->nks, wfc_basis->npwk_max); //source/module_basis/module_pw/pw_basis_k.cpp: line 351 template <> float * PW_Basis_K::get_gk2_data() const { return this->s_gk2; } template <> double * PW_Basis_K::get_gk2_data() const { return this->d_gk2; } //line 246, in function PW_Basis_K::collect_local_pw() this->d_gk2 = this->gk2; //line 217, in function PW_Basis_K::collect_local_pw() this->gk2[ik * npwk_max + igl] = (f+kv) * (this->GGT * (f+kv)); template Ekinetic>::Ekinetic( FPTYPE tpiba2_in, const FPTYPE* gk2_in, const int gk2_row, const int gk2_col) { this->classname = \"Ekinetic\"; this->cal_type = pw_ekinetic; this->tpiba2 = tpiba2_in; this->gk2 = gk2_in; this->gk2_row = gk2_row; this->gk2_col = gk2_col; this->device = psi::device::get_device_type(this->ctx); if( this->tpiba2 gk2 == nullptr) { ModuleBase::WARNING_QUIT(\"EkineticPW\", \"Constuctor of Operator::EkineticPW is failed, please check your code!\"); } } Potential terms Review: Potential类对象的初始化在ESolver_KS_PW::Init()（link） template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { .... if (this->pelec->pot == nullptr) { this->pelec->pot = new elecstate::Potential(this->pw_rho, &GlobalC::ucell, &(GlobalC::ppcell.vloc), &(this->sf), &(this->pelec->f_en.etxc), &(this->pelec->f_en.vtxc)); } .... } 其中 Potential::v_effective_fixed 和 Potential::v_effective 均按照所分发得到实空间格点数量进行内存申请（Introduction to ABACUS: Path to PW calculation - Part 7），但 nrxx 暗示着已经是一维化的数组，而并不直接保持(x, y, z)的形式访问： //source/module_elecstate/potentials/potential_new.cpp Potential::Potential() line 16 namespace elecstate { Potential::Potential(.... // allocate memory for Potential. this->allocate(); } .... /*------------------------------------------------------------------------------------*/ //source/module_elecstate/potentials/potential_new.cpp Potential::allocate() this->v_effective_fixed.resize(nrxx); this->v_effective.create(GlobalV::NSPIN, nrxx); .... // memory record omitted if (elecstate::get_xc_func_type() == 3 || elecstate::get_xc_func_type() == 5) { this->vofk_effective.create(GlobalV::NSPIN, nrxx); .... // memory record omitted Effective potential operator &#x1F914;C++ programming topic: polymorphism Potential is a good example illustrating the use of polymorphism. You can find a base class pointer is created and then used to point to a derived class object. template HamiltPW::HamiltPW(elecstate::Potential* pot_in, ModulePW::PW_Basis_K* wfc_basis, K_Vectors* pkv) { .... if(pot_register_in.size()>0) { .... pot_in->pot_register(pot_register_in); Operator, Device>* veff = new Veff>(isk, pot_in->get_v_effective_data(), pot_in->get_effective_v().nr, pot_in->get_effective_v().nc, wfc_basis); .... void Potential::pot_register(std::vector& components_list) { if (this->components.size() > 0) { for (auto comp: this->components) delete comp; this->components.clear(); } for (auto comp: components_list) { PotBase* tmp = this->get_pot_type(comp); this->components.push_back(tmp); } this->fixed_done = false; } PotBase* Potential::get_pot_type(const std::string& pot_type) { ModuleBase::TITLE(\"Potential\", \"get_pot_type\"); if (pot_type == \"local\") { return new PotLocal(this->vloc_, &(this->structure_factors_->strucFac), this->rho_basis_); } else if (pot_type == \"hartree\") { return new PotHartree(this->rho_basis_); } else if (pot_type == \"xc\") { return new PotXC(this->rho_basis_, this->etxc_, this->vtxc_, &(this->vofk_effective)); } else if (pot_type == \"surchem\") { return new PotSurChem(this->rho_basis_, this->structure_factors_, this->v_effective_fixed.data(), &GlobalC::solvent_model); } else if (pot_type == \"efield\") { return new PotEfield(this->rho_basis_, this->ucell_, GlobalV::DIP_COR_FLAG); } else if (pot_type == \"gatefield\") { return new PotGate(this->rho_basis_, this->ucell_); } .... } //source/module_elecstate/potentials/potential_new.cpp line 251 template <> double * Potential::get_v_effective_data() { return this->v_effective.nc > 0 ? this->d_v_effective : nullptr; } template Veff>::Veff(const int* isk_in, const FPTYPE* veff_in, const int veff_row, const int veff_col, const ModulePW::PW_Basis_K* wfcpw_in) { this->classname = \"Veff\"; this->cal_type = pw_veff; this->isk = isk_in; this->veff = veff_in; //note: \"veff = nullptr\" means that this core does not treat potential but still treats wf. this->veff_row = veff_row; this->veff_col = veff_col; this->wfcpw = wfcpw_in; resmem_complex_op()(this->ctx, this->porter, this->wfcpw->nmaxgr, \"Veff::porter\"); resmem_complex_op()(this->ctx, this->porter1, this->wfcpw->nmaxgr, \"Veff::porter1\"); if (this->isk == nullptr || this->wfcpw == nullptr) { ModuleBase::WARNING_QUIT(\"VeffPW\", \"Constuctor of Operator::VeffPW is failed, please check your code!\"); } } meta-GGA operator Operator, Device>* meta = new Meta>(tpiba, isk, pot_in->get_vofk_effective_data(), pot_in->get_effective_vofk().nr, pot_in->get_effective_vofk().nc, wfc_basis); template Meta>::Meta(FPTYPE tpiba_in, const int* isk_in, const FPTYPE* vk_in, const int vk_row, const int vk_col, const ModulePW::PW_Basis_K* wfcpw_in) { this->classname = \"Meta\"; this->cal_type = pw_meta; this->isk = isk_in; this->tpiba = tpiba_in; this->vk = vk_in; this->vk_row = vk_row; this->vk_col = vk_col; this->wfcpw = wfcpw_in; resmem_complex_op()(this->ctx, this->porter, this->wfcpw->nmaxgr, \"Meta::porter\"); if(this->isk == nullptr || this->tpiba wfcpw == nullptr) { ModuleBase::WARNING_QUIT(\"MetaPW\", \"Constuctor of Operator::MetaPW is failed, please check your code!\"); } } Non-local potential operator template Nonlocal>::Nonlocal(const int* isk_in, const pseudopot_cell_vnl* ppcell_in, const UnitCell* ucell_in, const ModulePW::PW_Basis_K* wfc_basis) { this->classname = \"Nonlocal\"; this->cal_type = pw_nonlocal; this->wfcpw = wfc_basis; this->isk = isk_in; this->ppcell = ppcell_in; this->ucell = ucell_in; this->deeq = this->ppcell->template get_deeq_data(); this->deeq_nc = this->ppcell->template get_deeq_nc_data(); this->vkb = this->ppcell->template get_vkb_data(); if( this->isk == nullptr || this->ppcell == nullptr || this->ucell == nullptr) { ModuleBase::WARNING_QUIT(\"NonlocalPW\", \"Constuctor of Operator::NonlocalPW is failed, please check your code!\"); } } 之后到达 vdw 能量计算函数 vdw::make_vdw()。 Van der Waals calculation: vdw class template void ESolver_KS_PW::beforescf(int istep) { .... auto vdw_solver = vdw::make_vdw(GlobalC::ucell, INPUT); if (vdw_solver != nullptr) { this->pelec->f_en.evdw = vdw_solver->get_energy(); } .... code 查看 make_vdw() 函数，发现其返回 std::unique_ptr 类对象，即 Vdw 实例化的 std::unique_ptr 智能指针。智能指针的优点是会在程序结束时自动释放内存空间，而不会产生内存泄漏问题。 为简单起见，这里我们首先不考虑 vdw 项贡献，因此我们在 INPUT 文件中对 vdw_corr 关键词赋值为判断条件之外的参数是，make_vdw 将返回空指针 nullptr，因此接下来的复制操作不会被执行，f_en.evdw 维持默认值 0。 std::unique_ptr make_vdw(const UnitCell &ucell, const Input &input) { if (ucell.nat vdw_ptr = make_unique(ucell); vdw_ptr->parameter().initial_parameters(input); vdw_ptr->parameter().initset(ucell); return vdw_ptr; } else if (input.vdw_method == \"d3_0\" || input.vdw_method == \"d3_bj\") { std::unique_ptr vdw_ptr = make_unique(ucell); vdw_ptr->parameter().initial_parameters(input); return vdw_ptr; } else return nullptr; } std::vector, std::map 和 std::unordered_map 与智能指针简介 基础的 C++ 知识可以知道，数组和指针等价，尤其依靠一维指针来实现长度可变的一维数组，对于一维以上也是同理。然而，（裸）指针的使用具有较大的内存泄漏风险，且涉及元素访问的操作均需要自行实现。使用 std::vector 这一标准库容器可以对这种应用需求进行替代。对比（裸）指针，std::vector 具有以下优点（generated by Chat-AISI）： There are several advantages of using std::vector compared to a bare pointer: Dynamic memory management: std::vector automatically manages the memory allocation and deallocation for you, so you don't have to worry about manually allocating and deallocating memory. Automatic resizing: std::vector can automatically resize itself when new elements are added or removed, which makes it more convenient to use than a bare pointer. Bounds checking: std::vector provides bounds checking, which means that it will throw an exception if you try to access an element that is out of bounds. This can help prevent bugs and improve the safety of your code. Iterators: std::vector provides iterators that allow you to easily traverse the elements in the vector. This can make it easier to write algorithms that operate on the elements of the vector. Standard library algorithms: std::vector is part of the C++ standard library, which means that it can be used with a wide range of standard library algorithms. This can make it easier to write code that is more concise and easier to read. 同理 std::map 数据类型提供了支持两种数据类型不同的变量间 1-1 映射关系的批量存储，而 std::unordered_map 额外支持了基于 key-value pair 的乱序访问（类似于 Python 中的字典数据结构）。 指针的常见应用场景之二便是保存对象的内存地址，尤其对于 OOP 场景，我们希望通过内存地址来访问已经建立的 std::vector 对象，而不是直接进行深拷贝，以降低内存的消耗。然而，每当 std::vector 等上述容器进行扩容时，都会在内存中重新申请空间，即是说 std::vector 不具有固定的内存地址。为了使得指针能够按照指向的内容来进行锁定，我们可以使用智能指针。 智能指针是 C++11 开始支持的（新 ps.：但 C++11 本身已经不新了）特性，常见类型有两种，分别为 std::unique_ptr 和 std::shared_ptr。这两种智能指针的区别为是否允许多个指针对内存进行访问，前者不允许，后者允许。两种指针的使用方式和普通指针保持大致相同，但创建操作变更为 make_unique 或 make_shared（examples provided by Chat-AISI）： #include int main() { // Create a unique_ptr to an integer and initialize it with a new integer std::unique_ptr myInt = std::make_unique(42); // Use the unique_ptr to access the integer value std::cout #include int main() { // Create a shared_ptr to an integer and initialize it with a new integer std::shared_ptr myInt = std::make_shared(42); // Create another shared_ptr to the same integer std::shared_ptr myInt2 = myInt; // Use the shared_ptrs to access the integer value std::cout 我们可以使用如下方式以 std::shared_ptr 绑定一个基于 std::vector 实现的矩阵： #include #include std::vector> M; for (int irow=0; irow OneRow; for (int icol=0; icol>> M_ptr = make_shared>>(M); Ewald 关于最基本的 Ewald 的原理已经在上篇中提到。 template void ESolver_KS_PW::beforescf(int istep) { .... this->pelec->f_en.ewald_energy = H_Ewald_pw::compute_ewald(GlobalC::ucell, this->pw_rho, this->sf.strucFac); .... } ElecState::init_scf()：review the philosophy describing electronic state template void ESolver_KS_PW::beforescf(int istep) { .... this->pelec->init_scf(istep, this->sf.strucFac); .... } ElecState 类已经出现多次，在正式的对角化开始前，我们有必要完全了解 ElecState 类如何被设计，以描述电子态（Electronic State）： &#x1F914;批判式思考 寻找可能的冗余变量！ void ElecState::init_scf(const int istep, const ModuleBase::ComplexMatrix& strucfac) { this->charge->set_rho_core(strucfac); if (istep == 0) { this->charge->init_rho(this->eferm, strucfac, this->bigpw->nbz, this->bigpw->bz); } this->charge->renormalize_rho(); this->pot->init_pot(istep, this->charge); } Charge::set_rho_core() void Charge::set_rho_core( const ModuleBase::ComplexMatrix &structure_factor ) { ....//omit timer and comments bool bl = false; for (int it = 0; it 我们首先不考虑 noncolinear 情况，因此该函数直接返回。 Charge::init_rho() 我们考虑 calculation = 'scf' 的情况，且 init_chg 为默认值 'atomic'，则在 Input::Default2() 函数中，init_chg 关键字不会被因 calculation = 'nscf' 等条件的满足自动转换为 init_chg = 'file'， else if (calculation == \"nscf\" || calculation == \"get_S\") { ....//omit other cases.... if (init_chg != \"file\") { init_chg = \"file\"; ModuleBase::GlobalFunc::AUTO_SET(\"init_chg\", init_chg); } } 因此在 Charge::init_rho() 函数中，实际执行操作很简单： void Charge::init_rho(elecstate::efermi& eferm_iout, const ModuleBase::ComplexMatrix& strucFac, const int& nbz, const int& bz) { ....//omit timer if (GlobalV::init_chg == \"atomic\") // mohan add 2007-10-17 { this->atomic_rho(GlobalV::NSPIN, GlobalC::ucell.omega, rho, strucFac, GlobalC::ucell); if (XC_Functional::get_func_type() == 3 || XC_Functional::get_func_type() == 5) { const double pi = 3.141592653589790; const double fact = (3.0 / 5.0) * pow(3.0 * pi * pi, 2.0 / 3.0); for (int is = 0; is rhopw->nrxx; ++ir) { kin_r[is][ir] = fact * pow(std::abs(rho[is][ir]) * GlobalV::NSPIN, 5.0 / 3.0) / GlobalV::NSPIN; } } } } ....// omit other cases #ifdef __MPI this->init_chgmpi(nbz, bz); #endif } Charge::atomic_rho() Charge::atomic_rho() 函数初始化了不同自旋分量的电荷密度。考虑每个原子从赝势中读取电荷密度为$\\rho^\\alpha(\\mathbf{r})$，则所有原子的电荷密度加和为： \\rho(\\mathbf{r})\\equiv\\sum_{\\mathbf{T}}{\\sum_{\\alpha,i}{\\rho^\\alpha(\\mathbf{r}-\\mathbf{\\tau}_{\\alpha,i}-\\mathbf{T})}} 其 Fourier transform： \\rho(\\mathbf{G})=\\frac{1}{\\Omega_\\text{cell}}\\int_{\\Omega_\\text{cell}}{\\rho(\\mathbf{r})e^{-i\\mathbf{G}\\cdot\\mathbf{r}}d\\mathbf{r}} \\rho(\\mathbf{G})=\\frac{1}{\\Omega_\\text{cell}}\\sum_{\\mathbf{T}}\\int_{\\Omega_\\text{cell}}{\\sum_{\\alpha,i}{\\rho^\\alpha(\\mathbf{r}-\\mathbf{\\tau}_{\\alpha,i}-\\mathbf{T})e^{-i\\mathbf{G}\\cdot\\mathbf{r}}}}d\\mathbf{r}^\\prime 令\\mathbf{r}^\\prime+\\mathbf{\\tau}_ {\\alpha,i}\\equiv\\mathbf{r}，并在下文中标记S^\\alpha(\\mathbf{G})\\equiv\\sum_{i}^{n^\\alpha}{e^{-i\\mathbf{G}\\cdot\\mathbf{\\tau}_{\\alpha,i}}}： \\rho(\\mathbf{G})=\\frac{1}{\\Omega_\\text{cell}}\\sum_{\\mathbf{T}}\\int_{\\Omega_\\text{cell}}{\\sum_{\\alpha,i}{\\rho^\\alpha(\\mathbf{r}^\\prime-\\mathbf{T})e^{-i\\mathbf{G}\\cdot(\\mathbf{r}^\\prime+\\mathbf{\\tau}_{\\alpha,i})}}}d\\mathbf{r}^\\prime =\\int_{\\text{all space}}{\\sum_{\\alpha,i}{\\rho^\\alpha(\\mathbf{r}^\\prime)e^{-i\\mathbf{G}\\cdot(\\mathbf{r}^\\prime+\\mathbf{\\tau}_{\\alpha,i})}}}d\\mathbf{r}^\\prime =\\int_{\\text{all space}}{\\sum_{\\alpha,i}{\\rho^\\alpha(\\mathbf{r}^\\prime)e^{-i\\mathbf{G}\\cdot(\\mathbf{r}^\\prime+\\mathbf{\\tau}_{\\alpha,i})}}}d\\mathbf{r}^\\prime =\\sum_\\alpha{(\\int_\\text{all space}{\\rho^\\alpha(\\mathbf{r^\\prime})e^{-i\\mathbf{G}\\cdot\\mathbf{r}^\\prime}}d\\mathbf{r}^\\prime)\\sum_i{e^{-i\\mathbf{G}\\cdot\\mathbf{\\tau}_{\\alpha,i}}}} =\\sum_\\alpha{\\rho^\\alpha(\\mathbf{G})S^\\alpha(\\mathbf{G})} 但对 nspin = 2 和 nspin = 4 的情况要更加复杂： 将\\rho(\\mathbf{G})在每个 processor 上进行 iFFT， void Charge::atomic_rho(const int spin_number_need, const double& omega, double** rho_in, const ModuleBase::ComplexMatrix& strucFac, const UnitCell& ucell) const // Peize Lin refactor 2021.04.08 { ....//omit superposition of atomic charges for (int is = 0; is rhopw->recip2real(&rho_g3d(is, 0), rho_in[is]); // decrete integral here for (int ir = 0; ir rhopw->nrxx; ++ir) ne[is] += rho_in[is][ir]; ne[is] *= omega / (double)this->rhopw->nxyz; #ifdef __MPI Parallel_Reduce::reduce_double_pool(ne[is]); #endif ....//omit things following 之后对 rho_in 进行 scale，GlobalV::nelec 在此处被赋值 →（Introduction to ABACUS: Path to PW calculation - Part 5）。 void Charge::atomic_rho(const int spin_number_need, const double& omega, double** rho_in, const ModuleBase::ComplexMatrix& strucFac, const UnitCell& ucell) const // Peize Lin refactor 2021.04.08 { ....//omit superposition of atomic charges, ifft to realspace saved in rho_in and electron number checking ModuleBase::GlobalFunc::OUT(GlobalV::ofs_warning, \"total electron number from rho\", ne_tot); ModuleBase::GlobalFunc::OUT(GlobalV::ofs_warning, \"should be\", GlobalV::nelec); for (int is = 0; is rhopw->nrxx; ++ir) rho_in[is][ir] = rho_in[is][ir] / ne_tot * GlobalV::nelec; ....//omit timer and return } 其余细节请自行阅读该函数：link。 &#x1F914;批判式思考 Charge::atomic_rho() 函数中，对匿名函数的使用是否合理？ Charge::init_chgmpi() 该函数对每个 processor 分得实空间格点数量进行计算： void Charge::init_chgmpi(const int& nbz, const int& bz) { // NPROC_IN_STOGROUP is 1 as default if (GlobalV::NPROC_IN_STOGROUP % GlobalV::KPAR == 0) {....} else { this->use_intel_pool = false; delete[] rec; rec = new int[GlobalV::NPROC_IN_POOL]; delete[] dis; dis = new int[GlobalV::NPROC_IN_POOL]; const int ncxy = this->rhopw->nx * this->rhopw->ny; for (int ip = 0; ip rhopw->numz[ip] * ncxy; dis[ip] = this->rhopw->startz[ip] * ncxy; } } } Charge::renormalize_rho() void Charge::renormalize_rho(void) { ....//omit outputs const double sr = this->sum_rho(); const double normalize_factor = GlobalV::nelec / sr; for (int is = 0; is \\text{sr}=\\sum_\\omega{\\sum_i^{n_\\text{grid}}{\\rho^\\omega(r_i)\\Delta v}}, \\Delta v=\\frac{\\Omega_\\text{cell}}{n_\\text{grid}}，实际为离散积分。 &#x1F914;批判式思考 寻找在 Charge 类中对离散积分实现的冗余 Potential::init_pot() void Potential::init_pot(int istep, const Charge* chg) { ....//omit timer assert(istep >= 0); // fixed components only calculated in the beginning of SCF this->fixed_done = false; this->update_from_charge(chg, this->ucell_); ....//omit timer and return } Potential::update_from_charge() void Potential::update_from_charge(const Charge* chg, const UnitCell* ucell) { ModuleBase::TITLE(\"Potential\", \"update_from_charge\"); ModuleBase::timer::tick(\"Potential\", \"update_from_charge\"); if (!this->fixed_done) { this->cal_fixed_v(this->v_effective_fixed.data()); this->fixed_done = true; } ....//omit gpu and single precision support this->cal_v_eff(chg, ucell, this->v_effective); ....//omit timer and return } Potential::cal_fixed_v() void Potential::cal_fixed_v(double* vl_pseudo) { ....//omit timer this->v_effective_fixed.assign(this->v_effective_fixed.size(), 0.0); //v_effective_fixed's datatype is std::vector for (size_t i = 0; i components.size(); i++) { //components' datatype is std::vector if (this->components[i]->fixed_mode) { this->components[i]->cal_fixed_v(vl_pseudo); } } ....//omit timer } 即此时将所有 v_effective_fixed 中元素设置为 0。 Potential::cal_v_eff() void Potential::cal_v_eff(const Charge* chg, const UnitCell* ucell, ModuleBase::matrix& v_eff) { ....//omit timer int nspin_current = this->v_effective.nr; int nrxx = this->v_effective.nc; // first of all, set v_effective to zero. this->v_effective.zero_out(); // add fixed potential components // nspin = 2, add fixed components for all // nspin = 4, add fixed components on first colomn for (int i = 0; i v_effective_fixed.data(), this->get_effective_v(i), nrxx); } } // cal effective by every components for (size_t i = 0; i components.size(); i++) { if (this->components[i]->dynamic_mode) this->components[i]->cal_v_eff(chg, ucell, v_eff); } ....//omit timer } 也将 v_effective 中部分元素初始化为 0（对 nspin = 1 或 2，设置所有自旋分量的所有元素为 0，nspin = 4，设置 nspin 第一分量中所有元素为 0）。components 在 potential_new.h 中被声明为 PotBase 的 std::vector 容器，因此对于通过 register 压入的每一种 Potential，其 cal_v_eff() 都会调用不同的派生类实现（cal_v_eff() 在 PotBase 里是虚函数）。 以 Hartree term 举例，cal_v_eff() 计算了 Hartree term energy contribution： void PotHartree::cal_v_eff(const Charge* chg, const UnitCell* ucell, ModuleBase::matrix& v_eff) { v_eff += H_Hartree_pw::v_hartree(*ucell, const_cast(this->rho_basis_), v_eff.nr, chg->rho); return; } ModuleBase::matrix H_Hartree_pw::v_hartree(const UnitCell &cell, ModulePW::PW_Basis *rho_basis, const int &nspin, const double *const *const rho) { ModuleBase::TITLE(\"H_Hartree_pw\", \"v_hartree\"); ModuleBase::timer::tick(\"H_Hartree_pw\", \"v_hartree\"); std::vector> Porter(rho_basis->nmaxgr); const int nspin0 = (nspin == 2) ? 2 : 1; for (int is = 0; is nrxx; ir++) Porter[ir] += std::complex(rho[is][ir], 0.0); } rho_basis->real2recip(Porter.data(), Porter.data()); double ehart = 0.0; std::vector> vh_g(rho_basis->npw); #ifdef _OPENMP #pragma omp parallel for reduction(+:ehart) #endif for (int ig = 0; ig npw; ig++) { if (rho_basis->gg[ig] >= 1.0e-8) { const double fac = ModuleBase::e2 * ModuleBase::FOUR_PI / (cell.tpiba2 * rho_basis->gg[ig]); ehart += (conj(Porter[ig]) * Porter[ig]).real() * fac; vh_g[ig] = fac * Porter[ig]; } } Parallel_Reduce::reduce_double_pool(ehart); ehart *= 0.5 * cell.omega; H_Hartree_pw::hartree_energy = ehart; rho_basis->recip2real(vh_g.data(), Porter.data()); ModuleBase::matrix v(nspin, rho_basis->nrxx); if (nspin == 4) { #ifdef _OPENMP #pragma omp parallel for schedule(static, 512) #endif for (int ir = 0; ir nrxx; ir++) v(0, ir) = Porter[ir].real(); } else { #ifdef _OPENMP #pragma omp parallel for collapse(2) schedule(static, 512) #endif for (int is = 0; is nrxx; ir++) v(is, ir) = Porter[ir].real(); } .... return v; } Symmetry_rho template void ESolver_KS_PW::beforescf(int istep) { .... // Symmetry_rho should behind init_scf, because charge should be initialized first. Symmetry_rho srho; for (int is = 0; is pelec->charge), this->pw_rho, GlobalC::Pgrid, this->symm); } } As long as we can return, we return. ——woshuode 下篇我们将开始解读 beforescf() 之后，即 SCF 过程。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 8 下篇：Introduction to ABACUS: Path to PW calculation - Part 10 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-05 17:57:38 "},"develop-path10.html":{"url":"develop-path10.html","title":"Introduction to ABACUS: Path to PW calculation - Part 10","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 10 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 10 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Relax_Driver::relax_driver() ESolver_KS::Run() HSolverPW::set_diagethr() 进入迭代，首先以 HSolverPW::set_diagethr() 函数设置能量收敛限（本身并无复杂的原理，因此安排读者自行阅读代码细节（link））。HSolverPW 构造函数（link）已经对 HSolverPW::diag_ethr 由默认值 0.0 赋值为 GlobalV::PW_DIAG_THR，并且回溯 input_conv.cpp（link）以及 input.cpp（link, link），我们可以知道 GlobalV::PW_DIAG_THR 的默认值为 1.0e-2，用户的一般默认值设置为 1.0e-6。因此无论如何对于上述程序块的第 7 行，都判断为真（注意，if 判断中 1.0e-6 是数值层面的0。相较于纯公式推导，数值计算过程中应当注意来自各方面可能的误差来源： Conventional numerical errors due to unawareness: provided by meta-llama2 Division by zero: This is a classic example of a numerical error that can occur when calculating a function like sin(x)/x as x approaches zero. When x is close to zero, the denominator (x) becomes very small, and the numerator (sin(x)) may become very large due to the amplification effect of the sine function near zero. This can cause the computation to overflow or underflow, resulting in a NaN (Not a Number) value. Loss of significance: This occurs when a number becomes too small to be accurately represented by the available floating-point precision. For example, suppose we have two vectors u and v, both with a magnitude of 1.0, but one has a tiny component in the direction of the other. If we subtract the two vectors, the result will be a vector with a magnitude of 0.0, because the difference between the two vectors is smaller than the machine epsilon (the smallest representable number). However, if we then try to normalize this vector, we may find that its length is no longer 0.0, but rather a small positive value, due to roundoff errors. This can cause the vector to appear non-orthogonal, even though it should be orthogonal. Roundoff errors: These occur when a number is rounded to the nearest representable value, either during computation or when storing intermediate results. Rounding errors can accumulate over time, especially when performing repeated operations, and can eventually cause significant errors in the final result. For example, suppose we compute the dot product of two vectors using the formula dot(u,v) = u_1v_1 + u_2v_2 + ... + u_n*v_n. If any of the components of u or v are very small, roundoff errors may cause the computed dot product to differ significantly from the actual value. Cancellation errors: These occur when two nearly equal quantities are subtracted, resulting in a much smaller quantity. For example, suppose we compute the difference between two very large vectors, one of which has a slightly larger magnitude than the other. The subtraction operation may cancel out most of the digits, leaving behind only a few significant figures. This can cause the result to be very small, even though the original vectors were very large. Overflow and underflow: These occur when a computation produces a result that exceeds the maximum or minimum representable value of the available floating-point format. For example, suppose we compute the sum of two very large vectors using the formula sum = u + v. If the sum exceeds the maximum representable value, it will wrap around to a very small value, potentially causing significant errors in downstream computations. Similarly, if the sum is negative and exceeds the minimum representable value in absolute value, it will also wrap around to a very small value. Truncation errors: These occur when an intermediate result is truncated to fit within the available precision, causing the final result to differ from the exact value. For example, suppose we compute the square root of a number using a binary search algorithm that requires us to repeatedly divide the range of possible values in half until we find the correct interval containing the square root. If the range of possible values is very large, we may need to perform many iterations of the algorithm before finding the correct interval, and each iteration will introduce a small amount of truncation error. Over time, these errors can add up and cause the final result to differ significantly from the exact value. Aliasing: This occurs when a periodic function is sampled at a rate that is not sufficient to capture its full frequency content. For example, suppose we compute the discrete Fourier transform of a periodic function using a finite number of samples. If the sampling rate is not high enough, aliasing effects may cause the reconstructed function to contain spurious features or artifacts that do not correspond to the underlying physical phenomenon. Numerical instability: This occurs when a computation involves very large or very small numbers, or when the computation involves unstable mathematical operations like division by zero or taking the inverse of a very small number. Unstable computations can cause the result to vary widely depending on slight changes in the input parameters or intermediate results, leading to non-deterministic or chaotic behavior. An example of numerical instability is the Lorenz attractor, which exhibits chaotic behavior for certain parameter values despite being derived from simple, deterministic equations ），HSolverPW::diag_ethr = 1.0e-2，到达流程图的下一部分。 ESolver_KS_PW::eachiterinit() template void ESolver_KS::Run(const int istep, UnitCell& ucell) { .... for (int iter = 1; iter maxniter; ++iter) { .... eachiterinit(istep, iter); .... template void ESolver_KS_PW::eachiterinit(const int istep, const int iter) { if (iter == 1) this->p_chgmix->reset(); this->pelec->f_en.deband_harris = this->pelec->cal_delta_eband(); //(2) save change density as previous charge, // prepared fox mixing. if (GlobalV::MY_STOGROUP == 0) { this->pelec->charge->save_rho_before_sum_band(); } } p_chgmix 为 ESolver_KS 的数据成员，已经在构造函数中被初始化（link），且 mixing_mode, mixing_beta, mixing_ndim, mixing_gg0, mixing_tau 已经根据 Input 类赋值（默认值或用户给定），其数据成员 rhopw 也已赋值 pw_rho。 Charge_Mixing::reset() 函数重置四个数据成员： void Charge_Mixing::reset() // Peize Lin add 2018-11-01 { this->new_e_iteration = true; irstep = 0; idstep = 0; totstep = 0; ....//omit irrelevant conditions } ElecState::cal_delta_eband() double ElecState::cal_delta_eband() const { .... return deband0; // is \\Delta E in the following formulation } 此处涉及到具体且比较复杂的计算，我们此处只阐明原理，读者之后可以根据原理来对比代码（link）进行理解。 Harris functional E^{\\mathrm{Harris}}\\left[ \\rho ^{\\mathrm{in}} \\right] =\\sum_i{n_{\\mathrm{i}}^{\\mathrm{out}}\\langle \\psi _{\\mathrm{i}}^{\\mathrm{out}}|\\hat{H}^{\\mathrm{in}}|\\psi _{\\mathrm{i}}^{\\mathrm{out}}\\rangle}-\\frac{1}{2}\\iint{\\mathrm{d}\\mathbf{r}\\mathrm{d}\\mathbf{r}^{\\prime}\\frac{\\rho ^{\\mathrm{in}}\\left( \\mathbf{r} \\right) \\rho ^{\\mathrm{in}}\\left( \\mathbf{r}^{\\prime} \\right)}{|\\mathbf{r}-\\mathbf{r}^{\\prime}|}}+\\int{\\mathrm{d}\\mathbf{r}\\left( \\epsilon _{\\mathrm{xc}}^{\\mathrm{in}}\\left( \\mathbf{r} \\right) -v_{\\mathrm{xc}}^{\\mathrm{in}}\\left( \\mathbf{r} \\right) \\right) \\rho ^{\\mathrm{in}}\\left( \\mathbf{r} \\right)}+\\sum_{I Non-meta-GGA functional, nspin != 4 case \\Delta E=-\\frac{\\Omega _{\\mathrm{cell}}}{\\sum_p{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}}\\sum_{\\omega}^{\\alpha ,\\beta}{\\sum_i^{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}{\\{[V_{\\mathrm{eff}}^{\\omega}(r_i)-V_{\\mathrm{fixed}}(r_i)]\\rho ^{\\omega}(r_i)\\}}}-2E_{\\mathrm{xx}} (discrete form) \\Delta E=-\\int_{\\Omega _{\\mathrm{cell}}}{d\\mathbf{r}\\int{d\\omega}(V_{\\mathrm{eff}}[\\rho]-V_{\\mathrm{fixed}}[\\rho])\\rho (\\mathbf{r},\\omega )}-2E_{\\mathrm{xx}} (continuous form) Meta-GGA functional, nspin != 4 case \\Delta E=-\\frac{\\Omega _{\\mathrm{cell}}}{\\sum_p{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}}\\sum_{\\omega}^{\\alpha ,\\beta}{\\sum_i^{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}{\\{[V_{\\mathrm{eff}}^{\\omega}(r_i)-V_{\\mathrm{fixed}}(r_i)]\\rho ^{\\omega}(r_i)+\\tau ^{\\omega}(r_i)V_{\\mathrm{ofk}}^{\\omega}(r_i)\\}}}-2E_{\\mathrm{xx}} (discrete form) \\Delta E=-\\int_{\\Omega _{\\mathrm{cell}}}{\\mathrm{d}\\mathbf{r}\\int{\\mathrm{d}\\omega (V_{\\mathrm{eff}}[\\rho]-V_{\\mathrm{fixed}}[\\rho])\\rho (\\mathbf{r},\\omega )+\\tau (\\mathbf{r},\\omega )V_{\\mathrm{ofk}}(\\mathbf{r})}}-2E_{\\mathrm{xx}} (continuous form) Non-meta-GGA functional, nspin = 4 case \\Delta E=-\\frac{\\Omega _{\\mathrm{cell}}}{\\sum_p{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}}\\left[ \\sum_i^{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}{\\left( \\sum_{\\omega}^4{V_{\\mathrm{eff}}^{\\omega}(r_i)\\rho ^{\\omega}(r_i)} \\right) -V_{\\mathrm{fixed}}(r_i)\\rho ^0(r_i)} \\right] -2E_{\\mathrm{xx}} (discrete form) Meta-GGA functional, nspin = 4 case \\Delta E=-\\frac{\\Omega _{\\mathrm{cell}}}{\\sum_p{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}}\\left[ \\sum_i^{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}{\\left( \\sum_{\\omega}^4{V_{\\mathrm{eff}}^{\\omega}(r_i)\\rho ^{\\omega}(r_i)} \\right) -V_{\\mathrm{fixed}}(r_i)\\rho ^0(r_i)+\\tau ^0(r_i)V_{\\mathrm{ofk}}^{0}(r_i)} \\right] -2E_{\\mathrm{xx}} (discrete form) , where \\tau ^{\\omega}(r_i)\\equiv \\frac{1}{2}\\sum_i^{\\mathrm{occ}}{\\left( \\nabla \\psi _i\\left( r_i \\right) \\right) ^2} is the kinetic energy density mapped on realspace grid (kin_r), n_{\\mathrm{grid}}^{\\mathrm{rs}}(p) is the number of grid points in realspace (\\text{rs}) distributed on processor p。 (source code link) Charge::save_rho_before_sum_band() 此函数备份电荷密度 rho，当使用 meta-GGA 时，同时备份动能密度 kin_r： void Charge::save_rho_before_sum_band(void) { for (int is = 0; is rhopw->nrxx); if (elecstate::get_xc_func_type() == 3 || elecstate::get_xc_func_type() == 5) ModuleBase::GlobalFunc::DCOPY(kin_r[is], kin_r_save[is], this->rhopw->nrxx); } return; } ESolver_KS_PW::hamilt2density() 然后来到 SCF 迭代的主体——对角化。hamilt2density 即为 Hamiltonian to electron density，从固定的 Hamiltonian 矩阵到新的电荷密度信息。hamilt2density() 函数的主体梗概如下： template void ESolver_KS_PW::hamilt2density(const int istep, const int iter, const double ethr) { if (this->phsol != nullptr) { this->pelec->f_en.eband = 0.0; this->pelec->f_en.demet = 0.0; if ((istep == 0 || istep == 1) && iter == 1) { hsolver::DiagoIterAssist::need_subspace = false; } else { hsolver::DiagoIterAssist::need_subspace = true; } hsolver::DiagoIterAssist::PW_DIAG_THR = ethr; hsolver::DiagoIterAssist::PW_DIAG_NMAX = GlobalV::PW_DIAG_NMAX; this->phsol->solve(this->p_hamilt, this->kspw_psi[0], this->pelec, GlobalV::KS_SOLVER); .... } 不难发现 phsol（pointer to HSolver）所调用其成员函数 solve() 一定是对角化的主体，HSolver 其顾名思义为 Hamiltonian 矩阵的求解器。针对具体的软件编写，我们关心在对角化过程中，究竟需要哪些（哪类）变量。最小地，我们对于 general 的对角化问题最统一的预想为仅仅需要 Hamiltonian 矩阵自身，ABACUS 的方案为： p_hamilt: HamiltPW: Introduction to ABACUS: Path to PW calculation - Part 9，Hamiltonian 的 handle（指针为 handle 实现的实体） kspw_psi: Psi: Introduction to ABACUS: Path to PW calculation - Part 7，Kohn-Sham planewave wavefunction 的 handle，同样指针是 handle 实现实体 pelec: ElecState: Introduction to ABACUS: Path to PW calculation - Part 9，电子态 handle &#x1F914;为了明天 寻找可能存在的变量冗余！ HSolverPW::solve() HSolverPW::solve() 中编写了 HamiltSolvePsiK() 函数的主功能，在 solve 之后则仅仅为能隙的计算。 template void ESolver_KS_PW::hamilt2density(const int istep, const int iter, const double ethr) { .... this->phsol->solve(this->p_hamilt, this->kspw_psi[0], this->pelec, GlobalV::KS_SOLVER); .... } 根据早先的总结，ABACUS 的并行策略应当如图所示： 按照 GlobalV::KPAR 确定并行池数量 每个并行池同时处理 1 个 k 点的计算任务 在 pool 中的 processor，则按照原先分发策略，分别按照实空间和到空间进行并行计算。 作为平行比较，Quantum ESPRESSO 官方不仅提供了更加灵活和精细的并行策略，也提供了基本的教学文档： https://www.quantum-espresso.org/Doc/user_guide/node18.html template void HSolverPW::solve(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, elecstate::ElecState* pes, const std::string method_in, const bool skip_charge) { ....//omit timer this->precondition.resize(psi.get_nbasis()); this->method = method_in; this->initDiagh(); std::vector eigenvalues(pes->ekb.nr * pes->ekb.nc, 0); for (int ik = 0; ik wfc_basis->nks; ++ik) { pHamilt->updateHk(ik); this->updatePsiK(pHamilt, psi, ik); update_precondition(precondition, ik, this->wfc_basis->npwk[ik]); this->hamiltSolvePsiK(pHamilt, psi, eigenvalues.data() + ik * pes->ekb.nc); if(skip_charge) { ....//omit output DiagoIterAssist::avg_iter = 0.0; } } castmem_2d_2h_op()(cpu_ctx, cpu_ctx, pes->ekb.c, eigenvalues.data(), pes->ekb.nr * pes->ekb.nc); this->endDiagh(); if(skip_charge) {....} reinterpret_cast*>(pes)->psiToRho(psi); ....//omit timer and return } 图 1. parallelization over kpoints 图 2. parts on which we are concentrated now HSolverPW::initDiagh() 初始化对角化 template void HSolverPW::initDiagh() { if (this->method == \"cg\") { if(this->pdiagh!=nullptr) { if(this->pdiagh->method != this->method) { delete (DiagoCG*)this->pdiagh; this->pdiagh = new DiagoCG(precondition.data()); this->pdiagh->method = this->method; } } else { this->pdiagh = new DiagoCG(precondition.data()); this->pdiagh->method = this->method; } } else if (this->method == \"dav\") { DiagoDavid::PW_DIAG_NDIM = GlobalV::PW_DIAG_NDIM; if (this->pdiagh != nullptr) { if (this->pdiagh->method != this->method) { delete (DiagoDavid*)this->pdiagh; this->pdiagh = new DiagoDavid(precondition.data()); this->pdiagh->method = this->method; } } else { this->pdiagh = new DiagoDavid( precondition.data()); this->pdiagh->method = this->method; } } else {....} } 若 pdiagh 已经存在，且 diagonalization_method 一致，do nothing，若不一致，delete, new 为当前 method。若 pdiagh 不存在，则按照 method new 相应 method 对应类内存空间。new 具有一致的形式。 图 3. PW和LCAO的代码设计平行关系与调用 HamiltPW::updateHk() and Operator::init() template void HSolverPW::solve(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, elecstate::ElecState* pes, const std::string method_in, const bool skip_charge) { ....//omit timer and previous lines for (int ik = 0; ik wfc_basis->nks; ++ik) { pHamilt->updateHk(ik); template void HamiltPW::updateHk(const int ik) { ModuleBase::TITLE(\"HamiltPW\",\"updateHk\"); this->ops->init(ik); ModuleBase::TITLE(\"HamiltPW\",\"updateHk\"); } template void Operator::init(const int ik_in) { this->ik = ik_in; if(this->next_op != nullptr) this->next_op->init(ik_in); } ik 实参为 k point index，因此最后是将 k point index 赋予每一个 Operator 的 this->ik 数据成员。回忆此操作，实际上建立在 GlobalV::KPAR 的基础上，KPAR 决定同时有多少 k 点并行。要求是 nproc/KPAR > 1，因此实际每个 processor 上不会同时存在多于 1 个 k 点，即同一个 processor 上不存在 Operator 被赋予不同 ik 值的情况。这一操作使得H(\\mathbf{k})的\\mathbf{k}获得更新。 更具体而言，根据每个 processor 上 k 点数量（归约后）nks，可以访问 k vector 的具体坐标，see：Introduction to ABACUS: Path to PW calculation - Part 5 ，即在H(\\mathbf{k})和具体的\\mathbf{k}之间联系实际也有存储。 图 4. Relationship between variables that matter presently HSolverPW::updatePsiK() template void HSolverPW::solve(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, elecstate::ElecState* pes, const std::string method_in, const bool skip_charge) { ....//omit timer and previous lines for (int ik = 0; ik wfc_basis->nks; ++ik) { .... this->updatePsiK(pHamilt, psi, ik); template void HSolverPW::updatePsiK(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, const int ik) { psi.fix_k(ik); if(!this->initialed_psi) { if(GlobalV::BASIS_TYPE==\"pw\") { hamilt::diago_PAO_in_pw_k2(this->ctx, ik, psi, this->wfc_basis, this->pwf, pHamilt); } else {....} } } Psi::fix_k() template void Psi::fix_k(const int ik) const { assert(ik >= 0); this->current_k = ik; if (this->ngk != nullptr && this->npol != 2) this->current_nbasis = this->ngk[ik]; else this->current_nbasis = this->nbasis; this->current_b = 0; if (ik >= this->nk) // this k point is not in present pool { // mem_saver case this->psi_current = const_cast(&(this->psi[0])); this->psi_bias = 0; } else { this->psi_current = const_cast(&(this->psi[ik * this->nbands * this->nbasis])); this->psi_bias = ik * this->nbands * this->nbasis; } } fix_k()函数锁定了当前的 k 点，使得 psi_current 指向当前 psi 一维数组中的正确位置。此处用到了 Psi::ngk 和 Psi::npol 值，这两值曾经出现在 Psi 构造函数中： template Psi::Psi(int nk_in, int nbd_in, int nbs_in, const int* ngk_in) { this->ngk = ngk_in; this->current_b = 0; this->current_k = 0; this->npol = GlobalV::NPOL; this->device = device::get_device_type(this->ctx); this->resize(nk_in, nbd_in, nbs_in); // Currently only GPU's implementation is supported for device recording! device::print_device_info(this->ctx, GlobalV::ofs_device); device::record_device_memory(this->ctx, GlobalV::ofs_device, \"Psi->resize()\", sizeof(T) * nk_in * nbd_in * nbs_in); } 我们的 psi 相关参数设定是在 wavefunc::allocate() 函数（link），即： psi::Psi> *wavefunc::allocate(const int nks, const int *ngk, const int npwx_in) { ... else { // initial psi rather than evc psi_out = new psi::Psi>(nks2, GlobalV::NBANDS, npwx * GlobalV::NPOL, ngk); const size_t memory_cost = nks2 * GlobalV::NBANDS*(GlobalV::NPOL*npwx) * sizeof(std::complex); std::cout Psi::npol 所取 GlobalV::NPOL 则在 input_conv.cpp 中可以找到： if (INPUT.noncolin || INPUT.lspinorb) { GlobalV::NSPIN = 4; } if (GlobalV::NSPIN == 4) { GlobalV::NONCOLIN = INPUT.noncolin; // wavefunctions are spinors with 2 components GlobalV::NPOL = 2; // set the domag variable to make a spin-orbit calculation with zero magnetization GlobalV::DOMAG = false; GlobalV::DOMAG_Z = true; GlobalV::LSPINORB = INPUT.lspinorb; GlobalV::soc_lambda = INPUT.soc_lambda; .... } else { GlobalV::LSPINORB = false; GlobalV::NONCOLIN = false; GlobalV::DOMAG = false; GlobalV::DOMAG_Z = false; GlobalV::NPOL = 1; } hamilt::diago_PAO_in_pw_k2() 接下来到达 HSolverPW::updatePsiK() 调用的第二个函数。 template void HSolverPW::updatePsiK(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, const int ik) { .... if(!this->initialed_psi) { if(GlobalV::BASIS_TYPE==\"pw\") { hamilt::diago_PAO_in_pw_k2(this->ctx, ik, psi, this->wfc_basis, this->pwf, pHamilt); } else {....} } } void diago_PAO_in_pw_k2(const int &ik, psi::Psi> &wvf, ModulePW::PW_Basis_K *wfc_basis, wavefunc *p_wf, hamilt::Hamilt *phm_in) { ModuleBase::TITLE(\"wavefunc\",\"diago_PAO_in_pw_k2\"); const int starting_nw = p_wf->get_starting_nw(); if(starting_nw == 0) return; assert(starting_nw > 0); std::vector etatom(starting_nw, 0.0); const int nbasis = wvf.get_nbasis(); const int nbands = wvf.get_nbands(); const int current_nbasis = wfc_basis->npwk[ik]; if( p_wf->init_wfc==\"random\" || ( p_wf->init_wfc.substr(0,6)==\"atomic\" && GlobalC::ucell.natomwfc == 0 )) { p_wf->random(wvf.get_pointer(),0,nbands,ik, wfc_basis); if(GlobalV::KS_SOLVER==\"cg\") { if(phm_in!= nullptr) { hsolver::DiagoIterAssist::diagH_subspace(phm_in, wvf, wvf, etatom.data()); return; } else ModuleBase::WARNING_QUIT(\"wavefunc\",\"Hamiltonian does not exist!\"); } } else if(p_wf->init_wfc.substr(0,6)==\"atomic\") { ModuleBase::ComplexMatrix wfcatom(starting_nw, nbasis); if(GlobalV::test_wf)ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, \"starting_nw\", starting_nw); p_wf->atomic_wfc(ik, current_nbasis, GlobalC::ucell.lmax_ppwf, wfc_basis, wfcatom, GlobalC::ppcell.tab_at, GlobalV::NQX, GlobalV::DQ); if (p_wf->init_wfc == \"atomic+random\" && starting_nw == GlobalC::ucell.natomwfc) { p_wf->atomicrandom(wfcatom, 0, starting_nw, ik, wfc_basis); } p_wf->random(wfcatom.c, GlobalC::ucell.natomwfc, nbands, ik, wfc_basis); if(GlobalV::KS_SOLVER==\"cg\") { if(phm_in!= nullptr) { hsolver::DiagoIterAssist::diagH_subspace_init(phm_in, wfcatom.c, wfcatom.nr, wfcatom.nc, wvf, etatom.data()); return; } else ModuleBase::WARNING_QUIT(\"wavefunc\",\"Hamiltonian does not exist!\"); } assert(nbands 且此操作遍历 k 点。 &#x1F914;家庭作业 我们不打算花费太多时间在波函数初始化这个议题上，但是仍然推荐你自主阅读它！仔细看看有时候你搬弄的 starting_wfc/init_wfc/scf_guess 关键词背后到底是怎么运行的吧！ HSolverPW::update_precondition() template void HSolverPW::solve(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, elecstate::ElecState* pes, const std::string method_in, const bool skip_charge) { ....//omit timer and previous lines for (int ik = 0; ik wfc_basis->nks; ++ik) { .... update_precondition(precondition, ik, this->wfc_basis->npwk[ik]); template void HSolverPW::update_precondition(std::vector &h_diag, const int ik, const int npw) { h_diag.assign(h_diag.size(), 1.0); int precondition_type = 2; const auto tpiba2 = static_cast(this->wfc_basis->tpiba2); if (precondition_type == 1) { for (int ig = 0; ig (this->wfc_basis->getgk2(ik,ig)) * tpiba2; h_diag[ig] = std::max(static_cast(1.0), g2kin); } } else if (precondition_type == 2) { for (int ig = 0; ig (this->wfc_basis->getgk2(ik,ig)) * tpiba2; h_diag[ig] = 1 + g2kin + sqrt(1 + (g2kin - 1) * (g2kin - 1)); } } if(GlobalV::NSPIN==4) { const int size = h_diag.size(); for (int ig = 0; ig 对角化时的 preconditioner 一般兼具数学和数值计算的 trick，因此我们只观察其形式而不做过多解读。 Preconditioner of CG diagonalization method: PreconditionerCGDiag.pdf Preconditioner of Davidson diagonalization method: PreconditionerDavidsonDiag.pdf HSolverPW::hamiltSolvePsiK() template void HSolverPW::solve(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, elecstate::ElecState* pes, const std::string method_in, const bool skip_charge) { .... for (int ik = 0; ik wfc_basis->nks; ++ik) { .... // each column corresponds to one energy band, row corresponds to k point. Therefore it // is ekb[ikpoint][iband], see declaration in CLASS elecstate std::vector eigenvalues(pes->ekb.nr * pes->ekb.nc, 0); .... /// solve eigenvector and eigenvalue for H(k), nr, nc are number of rows and columns this->hamiltSolvePsiK(pHamilt, psi, eigenvalues.data() + ik * pes->ekb.nc); .... } template void HSolverPW::hamiltSolvePsiK(hamilt::Hamilt* hm, psi::Psi, Device>& psi, FPTYPE* eigenvalue) { this->pdiagh->diag(hm, psi, eigenvalue); } 回忆刚刚在 initDiagh 函数中，根据不同的对角化方法，pdiagh 被分配不同派生类的内存空间（因此 pdiagh 很可能一开始被声明为 DiagH 基类指针，diag 可能在基类中被声明为纯虚函数）。这里我们跟随 Davidson 方法，因此 pdiag 的 diag 方法实际为 DiagoDavid::diag()。 DiagoDavid::diag() template void DiagoDavid::diag(hamilt::Hamilt* phm_in, psi::Psi, Device>& psi, FPTYPE* eigenvalue_in) { /// record the times of trying iterative diagonalization int ntry = 0; this->notconv = 0; #if defined(__CUDA) || defined(__ROCM) if (this->device == psi::GpuDevice) { resmem_var_op()(this->ctx, this->d_precondition, psi.get_nbasis()); syncmem_var_h2d_op()(this->ctx, this->cpu_ctx, this->d_precondition, this->precondition, psi.get_nbasis()); } #endif do { this->diag_mock(phm_in, psi, eigenvalue_in); ++ntry; } while (DiagoIterAssist::test_exit_cond(ntry, this->notconv)); if (notconv > std::max(5, psi.get_nbands() / 4)) { std::cout notconv; std::cout DiagoDavid::diag_mock()与 ABACUS-BLAS, LAPACK interfaces Source code link: https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_hsolver/diago_david.cpp#L49 图 5. Higher resolution framework of diag_mock() and relationship with other modules and functions &#x1F527;重构信息 diag_mock() will be renamed as diag_once() in the future &#x1F914;复习 Try to recall all details introduced from Part.1 to now as many as possible! In Driver::reading(), it is where Input::Default(), Read() and Default_2(), Input_conv::Convert() are called. From then on, we have parameters defined both from user input and default. In Driver::atomic_world(), it is where real space grid and planewave distributed. Remember ESolver driven the creation and initialization of pw_rho, pw_wfc? PW_Basis and PW_Basis_K? setuptransform(), initgrids(), distribute_r() and _g()? In UnitCell::setup_cell(), we read atom positions, pseudopotentials and kpoints, then we have (ir)reducible k vector list, and so (k+G) the planewave expanded wavefunction. In present contents, we initialize psi, then construct H|psi>, use HSolver flow to orthogonalize and diagonalize it. 基于上图，我们将选择数个关键点进行说明。 1. 对角化维度（ndim）设定 由于平面波数量众多-> 基函数数量众多-> 待对角化 Hamiltonian 矩阵维度巨大，而真正关心特征值/本征值/本征态数量远小于基函数数量，因此考虑使用子空间方法迭代求解其中能量最低的 n 个特征值/特征向量，而非一次性计算全部。由于子空间对角化方法的特性，实际需要对角化的子空间维度比用户所需能带数量要多（ndim 倍），ndim 被设计为用户设定参数： nbasis: Introduction to ABACUS: Path to PW calculation - Part 7 : npwx*GlobalV::NPOL, npwx: maximal number of planewaves among all kpoints, for non-noncolinear cases, GlobalV::NPOL is 1, otherwise is 2. ngk: Introduction to ABACUS: Path to PW calculation - Part 6 current_nbasis: ngk[ik] or nbasis ABACUS Quantum ESPRESSO 在 ABACUS 中，首先对角化子空间维数为 nbnd，若有部分本征值无法收敛，则使子空间维数递增，直到子空间维数增至 ndim*nbnd，然后重新开始计算 Hamiltonian 矩阵（refresh()，保留最初始 psi，即 ndim≥2 必须满足，从 dim=2 开始覆盖），直到达到最大迭代次数或收敛。 2. hpsi_info 在对角化之前，确认被对角化的对象具体形式十分重要。hpsi_info 存储 hpsi 操作后的数据，出现于 template void DiagoDavid::diag_mock(hamilt::Hamilt* phm_in, psi::Psi, Device>& psi, FPTYPE* eigenvalue_in) { .... /// initialize H|psi>... hpsi_info dav_hpsi_in(&basis, psi::Range(1, 0, 0, this->n_band - 1), this->hphi); // pack up |psi>, range (for finding psi on present processor), and H|psi> phm_in->ops->hPsi(dav_hpsi_in); this->cal_elem(this->dim, nbase, this->notconv, basis, this->hphi, this->sphi, this->hcc, this->scc); this->diag_zhegvx(nbase, this->n_band, this->hcc, this->scc, this->nbase_x, this->eigenvalue, this->vcc); .... hpsi_info 的设计非常类似于裸露的，具有迭代器的数据结构，其中迭代器实际来源于 psi::range 这一 psi namespace 中名为 range 的结构体的支持。更加具体而言： a. hpsi_info定义封装 //source/module_hamilt_pwdft/operator_pw/operator_pw.h /// @brief short name of type hamilt::Operator, Device>::hpsi_info, which is a tuple std::tuple*, const psi::Range, FPTYPE*> /// @param Psi const psi::Psi* /// @param Range const psi::Range, a struct in namespace psi, contains information about range, see source/module_psi/psi.h /// @param FPTYPE* pointer to the memory of hpsi /// @note in PW code, different operators donate hPsi independently. run this->act function for the first operator and run all act() for other nodes in chain table using hpsi_info = typename hamilt::Operator, Device>::hpsi_info; b. hpsi_info定义 //source/module_hamilt_general/operator.h typedef std::tuple*, const psi::Range, FPTYPE*> hpsi_info; virtual hpsi_info hPsi(hpsi_info& input)const; c. psi与其赝迭代器range：psi::Psi::psi的多维数组存储 d. hpsi_info的调用方式 template typename OperatorPW::hpsi_info OperatorPW::hPsi( hpsi_info& input) const { ModuleBase::timer::tick(\"OperatorPW\", \"hPsi\"); auto psi_input = std::get(input); std::tuple*, int> psi_info = psi_input->to_range(std::get(input)); int n_npwx = std::get(psi_info); // number of bands or k-points, as explained std::complex *tmhpsi = this->get_hpsi(input); const std::complex *tmpsi_in = std::get(psi_info); if(tmpsi_in == nullptr) { ModuleBase::WARNING_QUIT(\"OperatorPW\", \"please choose correct range of psi for hPsi()!\"); } this->act(psi_input, n_npwx, tmpsi_in, tmhpsi); OperatorPW* node((OperatorPW*)this->next_op); while(node != nullptr) { node->act(psi_input, n_npwx, tmpsi_in, tmhpsi); node = (OperatorPW*)(node->next_op); } ModuleBase::timer::tick(\"OperatorPW\", \"hPsi\"); std::complex* hpsi_pointer = std::get(input); if(this->in_place) { syncmem_complex_op()(this->ctx, this->ctx, hpsi_pointer, this->hpsi->get_pointer(), this->hpsi->size()); delete this->hpsi; this->hpsi = new psi::Psi, Device>(hpsi_pointer, *psi_input, 1, n_npwx/psi_input->npol); } hpsi return hpsi_info(this->hpsi, psi::Range(1, 0, 0, n_npwx/psi_input->npol), hpsi_pointer); } std::get() 方法可以从 tuple 容器里提取相应位置的元素（以引用方式）。 3. 线性代数相关操作 遍布 SchmidtOrth、calc_elem、diag_zhegvx、calc_grad、refresh 和 diag_mock 本体，其中存在很多类似于 BLAS 和 LAPACK 数学库中操作（矢量、矩阵）的命名方式，例如 gemm_op、gemv_op 等。同样地，如此组织操作，是为了尽可能支持模板偏特化。举例来讲，gemm 为 general matrix-matrix multiplication，gemv 则为 general matrix-vector multiplication，更多的使用方式见 BLAS quick reference 以及 LAPACK online documentation（https://www.netlib.org/lapack/explore-html/index.html）：BlasQuickReference.pdf &#x1F527;重构信息 Present Gram-Schmidt orthogonalization need to optimize both for numerical accurancy and performance reasons. &#x1F527;重构信息 Interfaces between ABACUS and basic math libraries like BLAS, LAPACK are ill-designed &#x1F616;, see: https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_hsolver/kernels/math_kernel_op.cpp https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_hsolver/kernels/dngvd_op.cpp For a better design and implementation, see Armadillo Linear Algebra library (https://arma.sourceforge.net/): \\armadillo-12.6.3\\include\\armadillo_bits\\mul_gemm.hpp:line 245 Consider carefully about what can be avoided to expose to developers who only care about the use but not the mechanism of those math libraries. &#x1F527;重构信息 On-going plan: interfaces between ABACUS and basic math libraries will be refactorized for heterogeneous programming (GPU support) 4/. 实际对角化过程 &#x1F914;批判性思考 你认为把 math_kernel_ops.cpp 和.h 文件放在目录 source/module_hsolver/kernels/下是合理的吗？如果不是，哪里可能是更好的选择呢？ 5/. diag_mock()循环结束 if (!this->notconv || (nbase + this->notconv > this->nbase_x) || (dav_iter == DiagoIterAssist::PW_DIAG_NMAX)) { ....//omit timer and comments setmem_complex_op()(this->ctx, psi.get_pointer(), 0, n_band * this->dmx); //()(this->ctx, // fortran-stype comments 'N', 'N', this->dim, // m: row of A,C this->n_band, // n: col of B,C nbase, // k: col of A, row of B this->one, basis.get_pointer(), // A dim * nbase this->dim, this->vcc, // B nbase * n_band this->nbase_x, this->zero, psi.get_pointer(), // C dim * n_band this->dmx ); if (!this->notconv || (dav_iter == DiagoIterAssist::PW_DIAG_NMAX)) { ....//omit timer and comments break; } DiagoCG 概览 在 Conjugated Gradient（共轭梯度法，CG）法中，我们也首先进行 band-by-band matrix 的对角化： \\mathbf{C}^{\\mathbf{\\dagger }}\\mathbf{H}(\\mathbf{G}_1,\\mathbf{G}_2)\\mathbf{C}，其中\\mathbf{H}为以 pw 表象的 Hamiltonian 矩阵： H_{ij}=\\langle \\mathbf{G}_i|\\hat{H}|\\mathbf{G}_j\\rangle \\\\ =\\int{e^{-i\\mathbf{G}_i\\cdot \\mathbf{r}}\\hat{H}e^{i\\mathbf{G}_j\\cdot \\mathbf{r}}\\mathrm{d}\\mathbf{r}} \\\\ =\\delta _{ij}\\frac{1}{2}|\\mathbf{G}_i|^2+V\\left( |\\mathbf{G}_i-\\mathbf{G}_j| \\right) psi 存储的即为$\\mathbf{C}$。我们得到 psi 后，使用 CG 方法 line-by-line（band-by-band）进行 CG 法优化能量，同时保持 line 之间正交。 HSolverPW::endDiagh() 在离开对角化之前，我们仍然有一些细节需要注意。首先再次阅读 HSolverPW::solve() 的 k 点循环部分： template void HSolverPW::solve(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, elecstate::ElecState* pes, const std::string method_in, const bool skip_charge) { .... this->initDiagh(); std::vector eigenvalues(pes->ekb.nr * pes->ekb.nc, 0); for (int ik = 0; ik wfc_basis->nks; ++ik) { pHamilt->updateHk(ik); this->updatePsiK(pHamilt, psi, ik); update_precondition(precondition, ik, this->wfc_basis->npwk[ik]); this->hamiltSolvePsiK(pHamilt, psi, eigenvalues.data() + ik * pes->ekb.nc); .... } castmem_2d_2h_op()(cpu_ctx, cpu_ctx, pes->ekb.c, eigenvalues.data(), pes->ekb.nr * pes->ekb.nc); this->endDiagh(); // eigenvalues std::vector 申请内存空间实际为一扁平化二维数组，每个 k 点写入一个批次的本征值数据且平移指针到相应位置，psi 则在每次调用 HSolverPW::updatePsiK() 的时候移动指针，到 psi 扁平化三维数组中对应 k 点位置的能带-基函数起始位置。 k 点循环结束后，将 eigenvalues 的数据赋值给 pes（pointer to elecstate）的 ekb（energies of kpoint-band）数据成员，然后调用 HSolverPW::endDiagh() 函数，删除对角化指针 pdiag: template void HSolverPW::endDiagh() { if(this->method == \"cg\") {....} if(this->method == \"dav\") { delete (DiagoDavid*)this->pdiagh; this->pdiagh = nullptr; } if(DiagoIterAssist::avg_iter > 0.0) { GlobalV::ofs_running::avg_iter / this->wfc_basis->nks ::PW_DIAG_THR::avg_iter = 0.0; } //psi only should be initialed once for PW if(!this->initialed_psi) { this->initialed_psi = true; } } HSolverPW::solve() 函数中最后还调用了 ElecStatePW::psiToRho() 函数，顾名思义该函数将输出新的电荷密度 rho。考虑到这个函数调用了众多子函数，我们将该函数留到下一篇。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 9 下篇：Introduction to ABACUS: Path to PW calculation - Part 11 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-05 17:43:52 "},"develop-path11.html":{"url":"develop-path11.html","title":"Introduction to ABACUS: Path to PW calculation - Part 11","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 11 作者：黄一珂，邮箱：huangyk@aisi.ac.cn；金祖鑫，邮箱：jinzx@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 11 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Relax_Driver::relax_driver() ESolver_KS::Run() ESolver_KS_PW::hamilt2density() HSolverPW::solve(): the rest ElecStatePW::psiToRho() 当我们从 HSolverPW::solve() 中追溯 psiToRho() 函数的定义时，我们发现 ElecStateLCAO 和 ElecStatePW 均有该方法的实现，因此查看 ElecState 基类，发现声明为虚函数。回忆在 ESolver_KS_PW 中，Init()函数我们已经将其指明指向派生类对象，see Introduction to ABACUS: Path to PW calculation - Part 7，即此处也使用了基于多态的实现。 &#x1F914;批判式思考 Polymorphism is an important technique in C++ for reducing code duplication and improving code reuse. Consider if polymorphism used here is necessary, share your opinions and ideas! template void ElecStatePW::psiToRho(const psi::Psi, Device>& psi) { if (!this->init_rho) this->init_rho_data(); this->calculate_weights(); this->calEBand(); for(int is=0; isctx, this->rho[is], 0, this->charge->nrxx); if (get_xc_func_type() == 3) { setmem_var_op()(this->ctx, this->kin_r[is], 0, this->charge->nrxx); } } for (int ik = 0; ik updateRhoK(psi); } if (GlobalV::device_flag == \"gpu\" || GlobalV::precision_flag == \"single\") {....} this->parallelK(); .... } 到目前为止，我们已经很难想起 ElecStatePW::init_rho() 是否被置为 true。我们使用“查找所有引用”，发现其只有在 ElecState::init_rho_data() 中被置为 true，而该函数之前从未被调用过（只有 psiToRho() 和 rhoBandK() 调用该函数），因此我们来到 init_rho_data()（简单起见，我们忽略 nspin=4, meta-GGA 泛函的情况） template void ElecStatePW::init_rho_data() { if (GlobalV::device_flag == \"gpu\" || GlobalV::precision_flag == \"single\") {....} else { this->rho = reinterpret_cast(this->charge->rho); if (get_xc_func_type() == 3) {....} } resmem_complex_op()(this->ctx, this->wfcr, this->basis->nmaxgr, \"ElecSPW::wfcr\"); resmem_complex_op()(this->ctx, this->wfcr_another_spin, this->charge->nrxx, \"ElecSPW::wfcr_a\"); this->init_rho = true; } 我们让 ElecState::rho 和 ElecState::charge::rho 两指针指向同一内存区域，之后重置了 wfcr 和 wfcr_another_spin 的内存空间。ElecState::calculate_weights() 函数根据 smearing 方法，重新计算费米能级，并输出每个(k,b)-pair（或(\\text{n},\\mathbf{k})-pair）的权重。此处代码较为简单但冗长，留给感兴趣的读者自行阅读。 void ElecState::calculate_weights() { ....//omit timer if (this->skip_weights) return; int nbands = this->ekb.nc; int nks = this->ekb.nr; if (!Occupy::use_gaussian_broadening && !Occupy::fixed_occupations) { // [out] ef: efermi // [out] wg: weight of (k,b)-pair, for unoccupied band, wg=0, otherwise it is wk[ik] if (GlobalV::TWO_EFERMI) // nspin = 2, uks case { Occupy::iweights(nks, this->klist->wk, nbands, this->nelec_spin[0], this->ekb, this->eferm.ef_up, this->wg, 0, this->klist->isk); ....// omit the other spin counter part } else {....} // nspin = 1, rks case, set parameter behind wg to -1 } else if (Occupy::use_gaussian_broadening) { // Gaussian smearing corrected efermi, wg and demet // [out] ef: efermi // [out] wg: the same // [out] demet: Delta Energy for METal if (GlobalV::TWO_EFERMI) // nspin = 2, uks case { double demet_up = 0.0; double demet_dw = 0.0; Occupy::gweights(nks, this->klist->wk, nbands, this->nelec_spin[0], Occupy::gaussian_parameter, Occupy::gaussian_type, this->ekb, this->eferm.ef_up, demet_up, this->wg, 0, this->klist->isk); ....// omit the other spin counter part this->f_en.demet = demet_up + demet_dw; } else {....} // nspin = 1, rks case, set parameter behind wg to -1 #ifdef __MPI // qianrui fix a bug on 2021-7-21 Parallel_Reduce::reduce_double_allpool(this->f_en.demet); #endif } else if (Occupy::fixed_occupations) {....} } 之后利用求得的 wg(ik,ib) 计算了 eband 数值：\\text{eband}=\\sum_{\\mathbf{k}, \\text{n}}{w_{\\text{n}\\mathbf{k}}\\epsilon_{\\text{n}\\mathbf{k}}} void ElecState::calEBand() { double eband = 0.0; for (int ik = 0; ik ekb.nr; ++ik) { for (int ibnd = 0; ibnd ekb.nc; ibnd++) { eband += this->ekb(ik, ibnd) * this->wg(ik, ibnd); } } this->f_en.eband = eband; if (GlobalV::KPAR != 1 && GlobalV::ESOLVER_TYPE != \"sdft\") { this->f_en.eband /= GlobalV::NPROC_IN_POOL; #ifdef __MPI Parallel_Reduce::reduce_double_all(this->f_en.eband); #endif } } template void ElecStatePW::updateRhoK(const psi::Psi, Device>& psi) { this->rhoBandK(psi); } template void ElecStatePW::rhoBandK(const psi::Psi, Device>& psi) { .... if (!this->init_rho) this->init_rho_data(); int ik = psi.get_current_k(); int npw = psi.get_current_nbas(); int current_spin = 0; if (GlobalV::NSPIN == 2) current_spin = this->klist->isk[ik]; int nbands = psi.get_nbands(); const double threshold = ModuleBase::threshold_wg * this->wg(ik, 0); if (GlobalV::NSPIN == 4) {....} else { for (int ibnd = 0; ibnd wg(ik, ibnd) basis->recip_to_real(this->ctx, &psi(ibnd,0), this->wfcr, ik); const auto w1 = static_cast(this->wg(ik, ibnd) / get_ucell_omega()); if (w1 != 0.0) { elecstate_pw_op()(this->ctx, current_spin, this->charge->nrxx, w1, this->rho, this->wfcr); } // kinetic energy density, if interested, see source code online: // https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_elecstate/elecstate_pw.cpp#L196 if (get_xc_func_type() == 3) {....} } } } 这里我们将波函数从倒空间变换到了实空间（this->wfcr），然后使用这一量在 this->charge->nrxx 格点上，进行了叠加，存储在 ElecState::rho 里，并且因为 ElecState::rho 和 ElecState::charge::rho 指向同一片内存空间，因此使用 ElecState::charge::rho 访问该内存空间时，值也已经改变。即此处，我们已经根据 scf 结果更新了电荷密度 rho 的数值。 &#x1F914;批判性思考 你认为创建不止一个指针来管理同一片内存区域是否是个好主意？可能存在什么缺点或者隐患？如果不是，你是否有更好的办法？ 离开 HSolverPW::solve() 函数刷新 ElecState::ekb、psi::Psi::psi 之后，来到计算带隙的部分： template void ESolver_KS_PW::hamilt2density(const int istep, const int iter, const double ethr) { if (this->phsol != nullptr) { .... this->phsol->solve(this->p_hamilt, this->kspw_psi[0], this->pelec, GlobalV::KS_SOLVER); if (GlobalV::out_bandgap) { if (!GlobalV::TWO_EFERMI) this->pelec->cal_bandgap(); else this->pelec->cal_bandgap_updw(); } } else {....} // calculate the delta_harris energy according to new charge density. // mohan add 2009-01-23 this->pelec->cal_energies(1); Symmetry_rho srho; for (int is = 0; is pelec->charge), this->pw_rho, GlobalC::Pgrid, this->symm); } // compute magnetization, only for LSDA(spin==2) GlobalC::ucell.magnet.compute_magnetization(this->pelec->charge->nrxx, this->pelec->charge->nxyz, this->pelec->charge->rho, this->pelec->nelec_spin.data()); this->pelec->f_en.deband = this->pelec->cal_delta_eband(); } 因这部分代码非常简单，请自行阅读：cal_bandgap()、cal_bandgap_updw()。 ElecState::cal_energies() void ElecState::cal_energies(const int type) { this->f_en.hartree_energy = get_hartree_energy(); this->f_en.efield = get_etot_efield(); this->f_en.gatefield = get_etot_gatefield(); if (GlobalV::imp_sol) {....} #ifdef __LCAO if (GlobalV::dft_plus_u) {....} #endif #ifdef __DEEPKS if (GlobalV::deepks_scf) {....} #endif if (type == 1) // harris { this->f_en.calculate_harris(); } else // etot { this->f_en.calculate_etot(); } } double ElecState::get_hartree_energy() { return H_Hartree_pw::hartree_energy; } ，H_Hartree_pw::hartree_energy 已经在 PotHartree::cal_v_eff() 所调用的 H_Hartree_pw::v_hartree() 被计算、赋值（see Introduction to ABACUS: Path to PW calculation - Part 9 ）。 Harris and Kohn-Sham energies fenergy::calculate_harris() double fenergy::calculate_harris() { etot_harris = eband + deband_harris + (etxc - etxcc) + ewald_energy + hartree_energy + demet + descf + exx + efield + gatefield + evdw + esol_el + esol_cav + edftu + edeepks_scf; return etot_harris; } fenergy::calculate_etot() double fenergy::calculate_etot() { etot = eband + deband + (etxc - etxcc) + ewald_energy + hartree_energy + demet + descf + exx + efield + gatefield + evdw + esol_el + esol_cav + edftu + edeepks_scf; return etot; } 我们尝试查找左侧函数中所有已经被赋值的项： eband：psiToRho() 中已经计算 deband_harris：当前未计算 etxc, etxcc：当前未计算 demet：psiToRho() 中已经计算 descf：当前未计算 exx：当前未计算 GlobalC::ucell.magnet.compute_magnetization() 该函数源码十分简单，请自行阅读。该函数计算了 tot_magnetization 和 abs_magnetization，（对于 nspin=2 case）分别定义为： tot_magnetization = \\int{d\\mathbf{r}(\\rho^\\alpha(\\mathbf{r})-\\rho^\\beta(\\mathbf{r}))} abs_magnetization = \\int{d\\mathbf{r}(|\\rho^\\alpha(\\mathbf{r})-\\rho^\\beta(\\mathbf{r})|)} nspin = 4 的情况请自行阅读。 ElecState::cal_delta_eband() 我们已经在上篇中解读过该函数（Introduction to ABACUS: Path to PW calculation - Part 10），到目前为止，区别于上一次调用，此次调用时电荷密度 rho 已经改变，因此在代码中： double ElecState::cal_delta_eband() const { double deband0 = 0.0; double deband_aux = 0.0; const double* v_eff = this->pot->get_effective_v(0); const double* v_fixed = this->pot->get_fixed_v(); const double* v_ofk = nullptr; if (get_xc_func_type() == 3 || get_xc_func_type() == 5) { v_ofk = this->pot->get_effective_vofk(0); } for (int ir = 0; ir charge->rhopw->nrxx; ir++) { deband_aux -= this->charge->rho[0][ir] * (v_eff[ir] - v_fixed[ir]); if (get_xc_func_type() == 3 || get_xc_func_type() == 5) { deband_aux -= this->charge->kin_r[0][ir] * v_ofk[ir]; } } if (GlobalV::NSPIN == 2) { v_eff = this->pot->get_effective_v(1); v_ofk = this->pot->get_effective_vofk(1); for (int ir = 0; ir charge->rhopw->nrxx; ir++) { deband_aux -= this->charge->rho[1][ir] * (v_eff[ir] - v_fixed[ir]); if (get_xc_func_type() == 3 || get_xc_func_type() == 5) { deband_aux -= this->charge->kin_r[1][ir] * v_ofk[ir]; } } } else if (GlobalV::NSPIN == 4) {....} #ifdef __MPI MPI_Allreduce(&deband_aux, &deband0, 1, MPI_DOUBLE, MPI_SUM, POOL_WORLD); #else deband0 = deband_aux; #endif deband0 *= this->omega / this->charge->rhopw->nxyz; deband0 -= 2 * this->f_en.exx; return deband0; } 凡是涉及 charge->rho 的项其最终计算结果均会有所差别。 Charge_Mixing::get_drho() get_drho() 函数拥有良好的注释，可以帮助读者理解函数所执行内容。 nspin=1 时密度的变化量为： \\mathrm{drho}=\\left( \\frac{1}{2}\\Omega _{\\mathrm{cell}} \\right) \\left( 4\\pi e^2 \\right) \\sum_{\\mathbf{G}\\ne 0}{\\frac{\\Delta \\rho \\left( -\\mathbf{G} \\right) \\Delta \\rho \\left( \\mathbf{G} \\right)}{\\left( \\frac{2\\pi}{|a_0|}|\\mathbf{G}| \\right) ^2}} nspin=2: s=\\left( 4\\pi e^2 \\right) f_{\\Gamma}\\left( \\frac{1}{2}\\Omega _{\\mathrm{cell}} \\right) \\left\\{ \\sum_{\\mathbf{G}\\ne 0}{\\frac{\\left[ \\Delta \\rho ^{\\alpha}\\left( -\\mathbf{G} \\right) +\\Delta \\rho ^{\\beta}\\left( -\\mathbf{G} \\right) \\right] \\left[ \\Delta \\rho ^{\\alpha}\\left( \\mathbf{G} \\right) +\\Delta \\rho ^{\\beta}\\left( \\mathbf{G} \\right) \\right]}{\\left( \\frac{2\\pi}{|a_0|}|\\mathbf{G}| \\right) ^2}+\\frac{\\left[ \\Delta \\rho ^{\\alpha}\\left( 0 \\right) +\\Delta \\rho ^{\\beta}\\left( 0 \\right) \\right] \\left[ \\Delta \\rho ^{\\alpha}\\left( 0 \\right) +\\Delta \\rho ^{\\beta}\\left( 0 \\right) \\right]}{\\left( 2\\pi \\right) ^2}+}\\sum_{\\mathbf{G}\\ne 0}{\\frac{\\left[ \\Delta \\rho ^{\\alpha}\\left( -\\mathbf{G} \\right) -\\Delta \\rho ^{\\beta}\\left( -\\mathbf{G} \\right) \\right] \\left[ \\Delta \\rho ^{\\alpha}\\left( \\mathbf{G} \\right) -\\Delta \\rho ^{\\beta}\\left( \\mathbf{G} \\right) \\right]}{\\left( 2\\pi \\right) ^2}} \\right\\} 关于 drho 的讨论可参考 Ewald summation 简介。get_drho() 计算了密度的变化量，为判断波函数收敛提供参考。 HSolverPW::cal_hsolerror() template FPTYPE HSolverPW::cal_hsolerror() { return this->diag_ethr * static_cast(std::max(1.0, GlobalV::nelec)); } ，而 diag_ethr 在 HSolverPW::set_diagethr() 函数中被设置为 1E-2（见 Introduction to ABACUS: Path to PW calculation - Part 10）。若无法小于 drho，则重置 diag_ethr 后再次进行对角化、计算 drho，然后计算 hsolerror 值。 Charge_Mixing::auto_set() 从 ESolver_KS::Run() 函数中，esolver_ks_pw.cpp 第 277 行可以知道，判断 scf 是否收敛的标准实际判断电荷密度： this->conv_elec = (drho scf_thr); 但如果仍然有 drho ，则不进行 charge mixing 操作，否则进行 charge mixing： if (drho conv_elec) { if (drho pelec->cal_bandgap(); bandgap_for_autoset = this->pelec->bandgap; } else { this->pelec->cal_bandgap_updw(); bandgap_for_autoset = std::min(this->pelec->bandgap_up, this->pelec->bandgap_dw); } p_chgmix->auto_set(bandgap_for_autoset, GlobalC::ucell); } //conv_elec = this->estate.mix_rho(); p_chgmix->mix_rho(iter, pelec->charge); //----------charge mixing done----------- } auto_set() 函数则为 charge mixing 设置默认值（如果 auto_set 的 flag 被设置为 true）： Charge_Mixing::mix_rho() Mixing Charge mixing 是一种加快 SCF 收敛的技术，其混合 SCF 过程中一定步数范围内的电荷密度，作为下一步电荷密度的实际使用数值。 Broyden 和 Kerker mixing 现在常见的 charge mixing 方法有 Broyden、Kerker、Pulay 等，其中 Broyden 和 Kerker mixing 方法的原理可见 VASP wiki（link）。 Pulay mixing Pulay mixing 则使用 DIIS（Direct inversion in the iterative subspace）方法计算 mixing 系数，考虑到 DIIS 在不仅 charge mixing，在其他优化方法中也经常使用，我们对 DIIS 的原理进行简要介绍。 在 VASP 的 SCF（Link），Quantum ESPRESSO（Link）、CP2K（Link）、Gaussian（Link）中都可以看到 DIIS 算法，其核心为求解如下矩阵的解\\{c_i\\}： \\left( \\begin{matrix} 0& -1& -1& \\cdots& -1\\\\ -1& B_{11}& B_{12}& \\cdots& \\,\\,\\\\ \\cdots& \\,\\,& \\,\\,& \\,\\,& \\,\\,\\\\ \\,\\,& \\cdots& \\,\\,& B_{ij}& \\,\\,\\\\ \\cdots& \\,\\,& \\,\\,& \\,\\,& \\,\\,\\\\ \\end{matrix} \\right) \\left( \\begin{array}{c} -\\lambda\\\\ c_1\\\\ \\cdots\\\\ c_2\\\\ \\cdots\\\\ \\end{array} \\right) =\\left( \\begin{array}{c} -1\\\\ 0\\\\ \\cdots\\\\ 0\\\\ \\cdots\\\\ \\end{array} \\right) ， 或写成非矩阵形式则为二次型的导数为 0 条件，亦即最小二乘法： \\lambda+\\sum_{j=1}^N{c_jB_{ij}}=0$, $\\sum_{i=1}^N{c_i}=1$，$\\leftarrow\\frac{1}{2}\\sum_{i,j=1}^N{c_i c_jB_{ij}}+\\lambda(\\sum_{i=1}^N{c_i}-1)=f^\\text{DIIS}(\\{c_i\\}) ，其中B_{ij}=\\langle\\mathbf{e}_i|\\mathbf{e}_j\\rangle$，或记$|\\mathbf{e}\\rangle=\\sum_{i=1}^N{c_i|\\mathbf{e}_i\\rangle}，则 f^\\text{DIIS}=\\langle\\mathbf{e}|\\mathbf{e}\\rangle+\\lambda(\\sum^N_{i=1}{c_i}-1) CDIIS 因此在以上 DIIS 框架下，Pulay 提出 error vector$|\\mathbf{e}\\rangle$可以具有的形式为（example implementation in pyscf: link）： |\\mathbf{e}\\rangle\\equiv\\sum^N_{i=1}{(\\mathbf{FDS-SDF})}=\\sum^N_{i=1}{c_i(\\mathbf{F}\\mathbf{D}_i\\mathbf{S}-\\mathbf{S}\\mathbf{D}_i\\mathbf{F})} EDIIS EDIIS 在 DIIS 基础上混合了能量项，其 working function 变为： f^{\\mathrm{EDIIS}}=\\sum_{i=1}^N{c_iE\\left( \\mathbf{D}_i \\right)}-\\frac{1}{2}\\sum_{i.j=1}^N{c_ic_j\\mathrm{Tr}\\left[ \\left( \\mathbf{F}_i-\\mathbf{F}_j \\right) \\cdot \\left( \\mathbf{D}_i-\\mathbf{D}_j \\right) \\right]} GEDIIS 自 Gaussian 09 发布以来，对于几何优化任务，Gaussian 的默认策略调整为 GEDIIS。GEDIIS 中需要用最小二乘法达成的最小化函数构造方式如下： f^\\text{GEDIIS} =\\sum_{i=1}^N{c_iE\\left( \\mathbf{R}_i \\right)}-\\frac{1}{2}\\sum_{i.j=1}^N{c_ic_j\\left( \\mathbf{g}_i-\\mathbf{g}_j \\right) \\left( \\mathbf{R}_i-\\mathbf{R}_j \\right)} 组合系数仍然要满足$\\sum_{i=1}^N{c_i}=1$条件，$\\mathbf{g}_i$为第 i 步的梯度。 ABACUS 实现 图 1. mixing方法的通用框架设计 实际上，并非仅有 charge density 一个物理量可以进行 mixing，其他物理量，诸如波函数、Hamiltonian 矩阵、密度矩阵和自旋密度等都可以进行 mixing。实际 mixing 过程中 mixing dimension 通常在 10-20，即需要存储 10-20 个 SCF 迭代步的数据。为了在支持异构计算的同时减少 CPU-GPU 数据交换，对数据存储同样有异构化需求，因此使用了 ABACUS 中支持异构数据存储的 Tensor container。在 mixing 具体操作上，采用了继承方式： ESolver_KS::updatepot() template void ESolver_KS_PW::updatepot(const int istep, const int iter) { if (!this->conv_elec) { if (GlobalV::NSPIN == 4) {....} this->pelec->pot->update_from_charge(this->pelec->charge, &GlobalC::ucell); this->pelec->f_en.descf = this->pelec->cal_delta_escf(); } else { this->pelec->cal_converged(); } } Not converged case Potential::update_from_charge() void Potential::update_from_charge(const Charge* chg, const UnitCell* ucell) { ModuleBase::TITLE(\"Potential\", \"update_from_charge\"); ModuleBase::timer::tick(\"Potential\", \"update_from_charge\"); if (!this->fixed_done) { this->cal_fixed_v(this->v_effective_fixed.data()); this->fixed_done = true; } this->cal_v_eff(chg, ucell, this->v_effective); ....// omit GPU, single float point support and timer } ElecState::cal_delta_escf() /// @brief calculate descf double ElecState::cal_delta_escf() const { ModuleBase::TITLE(\"energy\", \"delta_escf\"); double descf = 0.0; // now rho1 is \"mixed\" charge density // and rho1_save is \"output\" charge density // because in \"deband\" the energy is calculated from \"output\" charge density, // so here is the correction. // only potential related with charge is used here for energy correction // on the fly calculate it here by v_effective - v_fixed const double* v_eff = this->pot->get_effective_v(0); const double* v_fixed = this->pot->get_fixed_v(); const double* v_ofk = nullptr; if (get_xc_func_type() == 3 || get_xc_func_type() == 5) { v_ofk = this->pot->get_effective_vofk(0); } for (int ir = 0; ir charge->rhopw->nrxx; ir++) { descf -= (this->charge->rho[0][ir] - this->charge->rho_save[0][ir]) * (v_eff[ir] - v_fixed[ir]); if (get_xc_func_type() == 3 || get_xc_func_type() == 5) {....} } if (GlobalV::NSPIN == 2) { v_eff = this->pot->get_effective_v(1); if (get_xc_func_type() == 3 || get_xc_func_type() == 5) {....} for (int ir = 0; ir charge->rhopw->nrxx; ir++) { descf -= (this->charge->rho[1][ir] - this->charge->rho_save[1][ir]) * (v_eff[ir] - v_fixed[ir]); if (get_xc_func_type() == 3 || get_xc_func_type() == 5) { descf -= (this->charge->kin_r[1][ir] - this->charge->kin_r_save[1][ir]) * v_ofk[ir]; } } } if (GlobalV::NSPIN == 4) {....} #ifdef __MPI Parallel_Reduce::reduce_double_pool(descf); #endif descf *= this->omega / this->charge->rhopw->nxyz; return descf; } Converged case ElecState::cal_converged() /// @brief calculation if converged void ElecState::cal_converged() { this->pot->get_vnew(this->charge, this->vnew); this->vnew_exist = true; this->f_en.descf = 0.0; } Potential::get_vnew() void Potential::get_vnew(const Charge* chg, ModuleBase::matrix& vnew) { ModuleBase::TITLE(\"Potential\", \"get_vnew\"); vnew.create(this->v_effective.nr, this->v_effective.nc); vnew = this->v_effective; this->update_from_charge(chg, this->ucell_); //(used later for scf correction to the forces ) for (int iter = 0; iter v_effective.c[iter] - vnew.c[iter]; } } ESolver_KS::eachiterfinish() template void ESolver_KS_PW::eachiterfinish(const int iter) { // print_eigenvalue(GlobalV::ofs_running); this->pelec->cal_energies(2); // We output it for restarting the scf. ....// omit ofstream output of demanded properties such as electron density and wfc, see this function on Github } 此时我们不再计算 Harris functional 而是 Kohn-Sham functional. （我们省略了 ESolver_KS::printiter() 函数，即 scf 过程中的输出。关于该函数的实现细节，请自行阅读：link） ESolver_KS::do_after_converge() 我们假设经过许多轮 scf 后，密度已经达到收敛标准，则到达这一函数。ESolver_KS 中声明该函数为 virtual namespace ModuleESolver { template class ESolver_KS : public ESolver_FP { public: .... protected: .... virtual bool do_after_converge(int& iter){return true;} template void ESolver_KS::Run(const int istep, UnitCell& ucell) { if (!(GlobalV::CALCULATION == \"scf\" || GlobalV::CALCULATION == \"md\" || GlobalV::CALCULATION == \"relax\" || GlobalV::CALCULATION == \"cell-relax\")) {....} else { .... for (int iter = 1; iter maxniter; ++iter) { .... if (this->conv_elec) { this->niter = iter; bool stop = this->do_after_converge(iter); if(stop) break; } } .... ，但在 ESolver_KS_PW 中则实际并无该函数的定义，但对于 LCAO 基组，则确实重新定义了这一函数。 ESolver_KS::afterscf() 该函数进行了数个性质的输出。 template void ESolver_KS_PW::afterscf(const int istep) { this->create_Output_Potential(istep).write(); // save charge difference into files for charge extrapolation if (GlobalV::CALCULATION != \"scf\") { this->CE.save_files(istep, GlobalC::ucell, #ifdef __MPI this->pw_big, #endif this->pelec->charge, &this->sf); } if (GlobalV::out_chg) { for (int is = 0; is create_Output_Rho(is, istep).write(); if (XC_Functional::get_func_type() == 3 || XC_Functional::get_func_type() == 5) { this->create_Output_Kin(is, istep).write(); } } } if (this->wf.out_wfc_pw == 1 || this->wf.out_wfc_pw == 2) { std::stringstream ssw; ssw psi[0], this->kv, this->pw_wfc); } ModuleIO::output_convergence_after_scf(this->conv_elec, this->pelec->f_en.etot); ModuleIO::output_efermi(this->conv_elec, this->pelec->eferm.ef); if (GlobalV::OUT_LEVEL != \"m\") { this->pelec->print_eigenvalue(GlobalV::ofs_running); } if (this->device == psi::GpuDevice) { castmem_2d_d2h_op()(this->psi[0].get_device(), this->kspw_psi[0].get_device(), this->psi[0].get_pointer() - this->psi[0].get_psi_bias(), this->kspw_psi[0].get_pointer() - this->kspw_psi[0].get_psi_bias(), this->psi[0].size()); } } 结语 至此，我们结束了 ESolver_KS::Run() 函数的全部内容，返回 Relax_Driver::relax_driver() 函数。考虑到我们关注的是 pw-scf 任务，因此并不对原子坐标和晶胞参数进行 relax，所以 relax_driver() 函数也在 scf 收敛后退出，到达 ESolver::postprocess()（但该函数为虚函数，因此到达 ESolver_KS_PW::postprocess()）。 在该函数中，主要对电子态、DOS、能带性质、实空间波函数等进行输出，在 esolver_ks_pw.cpp 的第 737 行，则进行了平面波和球 Bessel 函数的 overlap 积分输出： if (winput::out_spillage psi[0], this->sf, this->kv, this->pw_wfc); ModuleBase::GlobalFunc::DONE(GlobalV::ofs_running, \"BASIS OVERLAP (Q and S) GENERATION.\"); } Q 和 S 矩阵将用于 SIAB（Systematically improvable optimized atomic basis sets）程序，进行数值原子轨道生成的依据。生成数值原子轨道后，则可以在使用数值原子轨道为基组的基础上，使用 ABACUS 的基于数值原子轨道（线性组合原子轨道 LCAO，basis_type lcao）方法进行模拟，这将是我们下一个部分，Introduction to ABACUS: Path to LCAO calculation 系列的起点。 ESolver_KS_PW::postprocess() 对于计算电导率的情况还可以调用 KG 方法进行计算，但对 KG 的解读已经超出了本部分的讨论范围。 &#x1F914;“家庭作业” For now we are trying to make all ABACUS output look well-organized, you may try to participate in practical ABACUS developing starting from formatting those output information. With the newly merged Formatter library, you browse the source code and find somewhere to improve. Submit your pull request after local testing, do not hesititate! Instruction of Formatter library: ABACUS formatter 库使用说明书 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 10 下篇：Introduction to ABACUS: Path to PW calculation - Summary Final 游园惊梦：Introduction to ABACUS: Path to PW calculation - Part 1 下个章节：Introduction to ABACUS: Path to LCAO calculation - Part 1 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-05 12:20:29 "},"develop-sm2.html":{"url":"develop-sm2.html","title":"Introduction to ABACUS: Path to PW calculation - Summary Final","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Summary Final 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Summary Final &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Flow：ABACUS 里的工作流 回忆我们的起点，从 main() 函数出发，经过 MPI 初始化后到达 Driver，然后到 Driver_run()。是 Driver_run() 唤起了整个程序的实际运行部分，其实迄今为止我们所看到的所有“故事”，都发生在 Driver_run() 的 ESolver::init()，以及 Relax_Driver::run()。 我们同样也拥有更低层级的 driver，比如 ESolver_KS::Run() 函数，实际上 ESolver 的 Run() 函数只关心 SCF，即只关心“求得能量”，尽管有另一个相似命名的模块，HSolver，其关注的范围其实更小：只关注 Hamiltonian 矩阵的对角化。 因此我们可以画出一个分层级的 workflow，在不同 workflow 上引导的则是 driver： 另有 Run_md 和 Relax_Driver 是平行关系，但由于我们目前仍未正式涉及 MD 的相关代码，因此不在上图中画出。 Interface：串联模块的组织模式 Inteface 设计的必要性 遗憾的是，GlobalV 和 GlobalC 虽然提供了“参数上云、用时下载”这一概念并方便了对待模拟体系的描述相关参数传递和热点函数调用，但对于单元测试来讲却并非好的设计，尤其对于 GlobalC。我们可能在编写单元测试（以确定模块功能正常运作）时，会遇到对过多变量进行初始化的问题，例如我们只想使用 UnitCell GlobalC::ucell，include GlobalC 的头文件后，却发现了诸多的“undefined reference to Parallel_Kpoints”等问题。 从设计上来讲，这是发生了类间耦合，尽管这种耦合可能在设计之初未被预计到。因此为了能够尽可能大地减少基于 GlobalC 的类间耦合，更加提倡不使用 GlobalC，而是从具体的某个类被定义的地方设计接口（指针进行调用），如对于一个类 illustrate_interface 的函数 illustrative_f，我们如果需要使用 UnitCell GlobalC::ucell，不写成： void illustrate_interface::illustrative_f() { .... std::cout 而是在 illustrate_interface 类中创建一个 interface： class illustrate_interface { private: UnitCell* p_ucell; }; 该 interface 可以在构造函数中被指定，也可以使用相应 setter 函数。之后对 illustrative_f 函数的编写就成为： void illustrate_interface::illustrative_f() { .... std::cout p_ucell 如此一来使得实际所使用的 GlobalC 中类（比如 UnitCell）和其他类解耦开。 （单元测试）尽情 mock 你想要使用的类 假设你想要在单元测试中使用一些函数，但你 include 实现那个函数的 cpp 文件后发现出现了很多棘手的 undefined reference to xxx，应该怎么办？又或者在你 include 的类中有其他的类对象作为成员，然后编译器提示报错 undefined reference to [class]::[class]()，怎么办？ 除了可以尝试使用 gmock 这个 googletest 提供的函数框架外，第二种思路只需要记住一件事：因为你只 include 了头文件，所以你可以实现当中的任何函数，而非必须包含进来它原本的实现（即所对应的原本的cpp文件）。 如果类 Parallel_Grid 对你无关紧要，但是确实在某个类或者命名空间中出现了这个类对象的声明，那么你可以在单元测试 cpp 文件中对它的构造函数和析构函数进行定义： Parallel_Grid::parallel_grid(){ } Parallel_Grid::~parallel_grid(){ } 然后避免再和原本的 cpp 文件一同进行编译，即在 CMakeLists.txt 的 SOURCE 中或 LIBS 中认真查看是否还包含该类的原始定义。如果有所遗漏，则会出现 multiple definition of xxx(), ..., first defined here ... 的编译报错，即同一签名函数拥有多重定义。 &#x1F914;思考时间 Read unittest module_io/test/bessel_basis_test.cpp and module_io/test/CMakeLists.txt, try to understand dependencies and how they are eliminated by redefinition of those functions whose declarations are included. 层级与功能：设计理念的思考 相较于 GlobalC，GlobalV 则是更成熟/成功的一个类，其部分原因为保持了功能划分意义上的单纯性：data-carrier。 在实际编程过程中，除了将类进行明确的功能区分外，还可以按照类的实际存储数据类型和函数的功能与密度进行二次划分，例如对于 ESolver 和 Relax_Driver（或 Driver 类），他们本身并不涉及到直接和被模拟体系相关的数据存储，即 ESolver 等类是程序流程控制的实现。 另一种类是我们之前介绍过的 ModulePW::PW_Basis_K 和 PW_Basis，其存储了平面波的数量和实空间、倒空间分发信息，以及 psi::Psi 类，存储了平面波基波函数的相关信息，并且基于这种类的二次划分，即该类被称为“数据载体（data carrier）”类，psi::Psi 进行了异构化支持，用于在 GPU 和 CPU 进行异构计算，同理，Charge_Mixing 存储数据的类也是 data-carrier。 当然在第一性原理软件中出现最多的还是直接和功能相关，即“功能类”。最基本地，我们有 module_relax，module_hsolver 等。这些类只提供在整个模拟流程中的具体实现方法，本身并不（应该）存储大量数据，而只应对所使用方法等信息有所基本描述即可。 因此可以按照上述方法将现有主要类按照如下关系进行划分： 。前文提到过关于接口设计的相关方法，然而如果接口以及链接接口的场所（即发生链接的函数所述类）不进行精心设计，则仍然无法保证程序具有清晰结构，从而为程序主体的运行带来隐患，单元测试的编写带来困难，“单元编译”变得更加难以实现。 举例对于 Hamilt 类，实际上提供 Hamiltonian 和相关算符，则其必然按照层级从上往下依次从 ESolver 和 Hamilt，Operator 类进行初始化，之后返回 ESolver，执行下一项动作，而不是在其他地方进行 Hamilt 对象初始化，然后将可能的数据的类在 Hamilt 进行直接链接，这无疑加重了类间耦合关系。 效率与正确性：并行与异构化编程 minimize data exchange 由于 OMP 和 MPI 的默认内存共享机制不同，MPI 可能会需要在 processor（进程）间收发数据。然而频繁进行数据的收发会带来明显的时间运行成本，因此合理设计 MPI processor 之间收发的具体数据，最小化数据传输规模，同样是并行编程的一个重要考虑方面。 对于异构编程同样如此。在 Charge_Mixing 类中，由于电荷密度、动能密度和密度矩阵的数据存储规模较大，频繁在 CPU 和 GPU 之间进行数据交换过于浪费时间，因此三个量的存储也进行异构化编程，具体实现为 container::Tensor 类。关于该类的实现，请自行阅读代码（link）。 全局单例（singleton） OMP 的粒度为线程（thread），线程间共享内存，因此为避免共享内存的各线程同时创建变量，并且顺序不同地进行读写，造成预期之外的结果时，可以使用全局单例模式进行对象的创建，以下方式称为 Mayers' Singleton Pattern： #include struct singleton_t { static singleton_t& instance() { static singleton_t instance; return instance; } // instance singleton_t(const singleton_t &) = delete; singleton_t& operator = (const singleton_t &) = delete; private: singleton_t() {} ~singleton_t() {} public: void out(){ printf(\"out\\n\"); } }; // struct singleton_t int main() { singleton_t::instance().out(); return 0; } 该类中，拷贝构造函数和默认构造函数均被删除或隐藏，亦无法使用“=”运算符进行对象的传递。 &#x1F914;“家庭作业” Read function Atom::bcast_atom(), write a code to support distribution of 3-layered std::vector (e.g.: std::vector>>) Only a little bit challenging :) 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 11 下篇：&#x1F6A7;（施工中） Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-10-05 12:29:52 "},"develop-addinp.html":{"url":"develop-addinp.html","title":"如何在 ABACUS 中新增一个输入参数（截至 v3.5.3）","keywords":"","body":"如何在 ABACUS 中新增一个输入参数（截至 v3.5.3） 作者：周巍青，邮箱：zhouwq@aisi.ac.cn 单位：北京科学智能研究院（AISI） 最后更新日期：2024/2/29 如果遇到本文档无法解决的问题，欢迎给 ABACUS 提出 Issues，我们将持续更新这个文档 在 input 类中申明和定义 1.1 声明 路径：source/module_io/input.h 首先现在input.h中添加相关输入参数的定义，如 nelec_delta： //========================================================== // electrons / spin //========================================================== std::string dft_functional; // input DFT functional. double xc_temperature; // only relevant if finite temperature functional is used int nspin; // LDA ; LSDA ; non-linear spin double nupdown = 0.0; double nelec; // total number of electrons double nelec_delta; // change in the total number of electrons int lmaxmax; 1.2 设置初始值 路径：source/module_io/input.cpp 接下来你需要在 Input::Default(void) 和 Input::Default_2(void) 函数里对参数进行初始化，其中： Input::Default(void)——定义单个变量的初始值 Input::Default_2(void)——根据部分参数的值，对一些有关联的参数重新赋值，如 nelec_delta： //---------------------------------------------------------- // electrons / spin //---------------------------------------------------------- dft_functional = \"default\"; xc_temperature = 0.0; nspin = 1; nelec = 0.0; nelec_delta = 0.0; lmaxmax = 2; 1.3 读取 路径：source/module_io/input.cpp 在 Input::Read() 中定义从 INPUT 文件中读取相应的参数，例如： else if (strcmp(\"nelec_delta\", word) == 0) { read_value(ifs, nelec_delta); } 1.4 MPI 广播 路径：source/module_io/input.cpp 读取完之后，需要定义如何在 Input::Bcast() 将读取的参数广播到所有的节点，原因是 ABACUS 程序从一个进程读入参数，之后通过 MPI 的 Bcast 函数广播到其它的进程。例如： Parallel_Common::bcast_double(nelec_delta); 注意这里你需要根据参数的类型，使用不同的语句： Parallel_Common::bcast_bool(out_wannier_wvfn_formatted); Parallel_Common::bcast_string(dft_functional); Parallel_Common::bcast_double(xc_temperature); Parallel_Common::bcast_int(nspin); 1.5 输出 路径：source/module_io/write_input.cpp ABACUS 会在 Input::Print(const std::string &fn) 中做参数的输出，你也需要在这个函数中进行添加： ModuleBase::GlobalFunc::OUTP(ofs, \"nelec_delta\", nelec_delta, \"change in number of total electrons\"); 1.6 添加测试 路径： source/module_io/test/input_test_para.cpp source/module_io/test/write_input_test.cpp 1.6.1 参数默认值和 MPI 广播的测试 TEST_F(InputParaTest, Bcast) 既测试了初始值的设定，也同样测试了 Bcast 的有效性，你也要将新增参数加入： EXPECT_DOUBLE_EQ(INPUT.nelec_delta, 0.0); 这里同样需要考虑不同的数据类型： EXPECT_TRUE(INPUT.out_wannier_mmn); EXPECT_FALSE(INPUT.out_wannier_unk); EXPECT_DOUBLE_EQ(INPUT.nelec, 0.0); EXPECT_EQ(INPUT.basis_type, \"pw\"); 1.6.2 参数输出的测试 TEST_F(write_input, General1) 测试了 ABACUS 参数输出的正确性，例如： EXPECT_THAT(output, testing::HasSubstr(\"nelec 0 #input number of electrons\")); 这里一定要注意空格和对齐。 将 input 成员转换为全局变量 参数参与计算一般会先转换为全局变量 GlobalV，再通过传参赋值给负责计算的类（但是注意将来我们会逐步弃用 GlobalV，所以这部分将来可能会变化）。 2.1 声明 路径：source/module_base/global_variable.h 在 GlobalV 这个命名空间中申明新增的参数，例如： extern double nelec_delta; 2.2 设置初始值 路径：source/module_base/global_variable.cpp 为 GlobalV::var 设置初始值，例如： double nelec_delta = 0; 2.3 利用 Input 类的成员为 GlobalV 中成员赋值 路径：source/module_io/input_conv.cpp 在 Input_Conv::Convert(void) 中为 Global 的参数赋值，例如： GlobalV::nelec = INPUT.nelec; 注意：Input类一个全局类，只要调用了头文件即可使用。 2.4 添加测试 路径：source/module_io/test/input_conv_test.cpp 在 TEST_F(InputConvTest, Conv) 测试这一转换是否正确，例如： EXPECT_EQ(GlobalV::nelec_delta,0); 添加文档 路径：docs/advanced/input_files/input-main.md 每个新参数的 PR必须包含相应的文档，否则不会被接收。请在 input-main.md 中添加参数描述。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-02-29 11:54:53 "},"develop-design.html":{"url":"develop-design.html","title":"C++ 程序设计的一些想法","keywords":"","body":"C++ 程序设计的一些想法 作者：金祖鑫，邮箱 jinzx@aisi.ac.cn 单位：北京科学智能研究院（AISI） 最后更新日期：2024 年 3 月 5 日 欢迎提出建议，本文将持续更新 内存管理 C++ 语言的设计理念之一是给开发者最大程度的信任与自由。这也意味着很多因疏忽导致的漏洞并不会在语法层面被阻止，因而也不会被编译器过滤。在一个复杂的程序中，内存管理是最常见的问题之一。比如，以下情况在实践中时有发生： 通过 new 为某指针申请了内存，在该指针生命周期结束前既没有其他指针接管，也没有 delete【内存泄漏】 A, B 两指针指向同一对象，A delete 后 B 继续访问【悬空指针（dangling pointer）】 这些问题无法被编译器过滤，很多时候也不会导致程序运行停止。然而，如果一段会泄漏内存的代码被反复执行，泄漏的内存量积累到一定程度就可能导致内存不足进而程序中断；被 delete 的内存块在被操作系统回收前依然可以访问【回收前访问是未定义行为 (undefind behavior)；回收后访问会 segmentation fault】：这片内存既可能保留原有数据不变，也可能已被挪作他用，写上了新的数据。这些问题往往构成巨大隐患。此外，还有一些会导致程序立即中断的内存问题，比如重复 delete、访问 nullptr 等。这些问题虽容易发现，也会耗费开发者不少精力。 C++ 社区与标准委员会很早就意识到了这些问题。出于“信任与自由”这一理念以及对过往代码的兼容性，语言并没有往“编译期确保内存安全”这一方向发展。此外，出于“零开销”（zero overhead）原则，也没有引入垃圾回收机制。时至今日，内存问题依然困扰大量 C++ 开发者。不过，自 Stroustrup 提出\"Resource Acquisition Is Initiallization\" (RAII) 的资源管理理念以来，截至 C++11，借由智能指针等工具的引入，整个语言已具备了实现方便、可靠的内存管理的条件。简而言之，C++ 给愿意自觉遵守 RAII 的开发者足够的工具以便捷、安全地管理内存，同时也不阻止开发者以完全自由、“后果自负”的方式进行开发。 RAII 原则 RAII 中的 R 并不单指内存，也可以指文件、线程或其他广义的资源。字面上 RAII 仅指一个对象的初始化需要与其资源获取绑定，但其完整的含义其实是“对象持有的资源有效期与对象的生命周期完全绑定”。以内存为例，这种“绑定”并不是指类的设计者给使用者提供一个用来释放内存的 public 函数，而是指类要做到从设计上就保证无论使用者如何使用，对象管理的内存有效期都不超过其生命周期。【异常处理不在本文的考虑范围内】 最常见的违背 RAII 原则的对象是裸指针。裸指针作为一个对象，其本身的生命周期并不与其指向的资源绑定。当然，这并不意味着使用裸指针与 RAII 概念互斥。当裸指针作为类的成员时，只要通过合适的设计，也可以让这个类满足 RAII。实际上，C++ 标准库容器均符合 RAII，而内部实现均使用了裸指针。 读者可能会有疑问：既然底层都是一样的裸指针，RAII 这个概念有什么意义？表面上 RAII 对单个类的设计来说似乎不值一提，但在复杂的程序中却有难以忽视的价值：对于非派生的类，如果其成员变量都满足 RAII，则这个类自动满足 RAII（析构函数可以直接写“=default”）。对于派生类，只要成员变量与基类满足 RAII，基类有虚析构函数，则这个类也自动满足 RAII。如此一来，即使一个模块由几十、上百个组件构成，开发者在内存安全上付出的精力也将止于那些最基本的、真正需要使用裸指针的组件。考虑到标准库已经提供了很多基本的数据结构，如果开发者正确使用，需要手动管理内存的场合并不多。 【注：标准库容器没有采用虚析构函数，所以一般不继承标准库容器】 从另一个角度来看，RAII 其实点出了一项程序设计的基本原则：面对复杂的资源调度需求，开发者应当在设计时对独立的、能够“自我管理”的概念进行提炼，以这些概念整体——而非这些概念背后具体的资源细节——为零件搭建更为复杂的对象。 所有权 虽然 RAII 确立了对象生命周期与其所管理资源间的基本原则，一个重要问题仍未解决：当对“指针”这一概念的需求不可避免，如何确保内存安全？具体来说，若资源在不同对象间有传递、共享等交互需求，该由什么机制来明确一片资源的管理（比如释放）由哪个对象负责？这个问题实际上引出了“所有权”的概念。 考虑以下一个简化的例子： class Engine {/* a lot of stuff */}; class Car { public: Car(): engine_(nullptr) {} ~Car() { delete engine_; } void install(Engine* new_engine) { delete engine_; engine_ = new_engine; } private: Engine* engine_; }; 从概念上，一辆车可能有一台引擎，也可能处于引擎被拆下的状态。若 Engine 类占用很多空间不便复制，似乎成员使用指针，用 nullptr 和非 nullptr 代表不同状态是一种合理的选择。 【另一种可能的选择是全部存对象然后配合 move 使用。这样虽然能避免复制，但是会要求对象拥有移动构造/赋值函数。此外，这种设计下“汽车引擎被卸下”这一状态也需额外处理：要么增加一个 bool 成员用来标记，要么规定 Engine 存在一个\"null\"状态，两者似乎都不如使用指针自然】 上述代码看似无懈可击，却有一个潜在的问题：install 函数拿到了一个 Engine 的裸指针，这个指针背后的对象生命周期由谁控制？从逻辑来看，当 Car 装上 engine 后，就应当由 Car 来管理 engine 的生命周期。但是，若有粗心的开发者写下以下代码： void installer(Car* car) { Engine engine; car.install(&engine); // bad! should be car.install(new Engine); } 程序依然能编译通过，甚至可能运行。在上述函数中，Engine 对象的生命周期在函数结束时也将结束，但 Car 对象对此完全没有察觉，因此内部 engine_成员将变成悬空指针。该问题不仅在编译阶段无法被过滤，即使在运行期，由于访问悬空指针是未定义行为，也不一定能稳定复现。 尽管上面的例子非常浅显，类似的情况在更复杂的流程中却不一定容易识别。在复杂程序中，变量在开发者设想中的生命周期与实际情况不匹配是内存问题的一大来源。实践中，以下情况并不罕见： 对象 x 原本由对象 A 创建、使用、释放。需求新增后另一个对象 B 需要同 A 共享 x，开发者直接将 A 中 x 的指针复制给了 B。然而 B 的生命周期长于 A，在 A 析构后 B 中存放的 x 指针成为了悬空指针； 多个开发者协作完成某工作，初步讨论后决定某对象 a 由开发者 X 创建，开发者 Y 释放。程序几经迭代后 a 生命周期发生变化，Y 负责的部分已不适合释放 a，但开发者们并未重新明确内存释放的责任，代码合并后产生了内存泄漏。 不难发现，如果能在代码中明确“所有权”这一概念，类似的问题将大大减少。在基于裸指针的对象操作中，“所有权”并不存在于语法层面，只存在于开发者的心中：任意相同类型的指针都可以指向同一片内存，开发者实际上是依据自己对程序逻辑的理解决定哪个指针在哪一步 delete。尽管修复内存问题往往只是增改一两行的工作量，定位问题所消耗的时间与精力却通常不成比例。究其原因，裸指针本身携带的信息过于匮乏，也不主动承担任何管理功能，内存管理的成本必须由开发者通过阅读代码、文档、举行讨论等方式支付。 智能指针 C++11 引入的智能指针正是针对“所有权”所提出的工具。三种智能指针分别对应以下含义： 【注：auto_ptr 在 C++17 中已被废除，此处不再介绍】 unique_ptr: 专属的所有权； shared_ptr：与其他 shared_ptr 共享的所有权； weak_ptr：对 shared_ptr 所管理资源的“访问权”；本身并不具有所有权。 unique_ptr 独有其所指向的资源，相应负有全权管理职责：当一个 unique_ptr 的生命周期结束或被 reset 时，其管理对象的析构函数会被自动调用。此外，unique_ptr 的\"=\"运算符是移动(move)而非拷贝：对于 p1, p2 两个 unique_ptr，运行 \"p1 = p2;\" 这条命令的后果是(1) p1 原先的对象被释放；(2) 原先 p2 所管理的对象交由 p1 管理，(3) p2 变成空指针。这种设计保证了 unique_ptr 对其所属资源的专属性。unique_ptr 也可通过调用 release()释放这种专属性：返回一个裸指针的同时自身变为空指针。 shared_ptr 与其他指向同一处的 shared_ptr 共同拥有资源。与裸指针相似的是一个 shared_ptr 可以通过\"=\"赋值给另一个 shared_ptr，这时两个 shared_ptr 会指向同一份资源。与裸指针不同的是 shared_ptr 内部有自动计数，在复制时计数加一，在 reset 或生命周期结束时计数减一，计数到零时自动调用析构函数释放资源。 weak_ptr 辅助 shared_ptr 的使用，以“观察者”（不影响计数）的方式指向其他 shared_ptr 的资源。使用 weak_ptr 前需调用 lock()以转化成 shared_ptr。如其他 shared_ptr 依然有效，lock()后将会得到一个非空的 shared_ptr，否则 lock()的结果是一个空的 shared_ptr。 值得注意的是 unique_ptr 与 shared_ptr 都会自动调用析构函数，因此只要原对象满足 RAII，与智能指针结合后将得到一个满足 RAII 的指针，在绝大多数场合可视作裸指针的安全替代。回到先前 Car 与 Engine 的例子中。一种增加程序安全性的方法是采用 unique_ptr 明确 Engine 的所有权转移： class Car { public: Car() = default; // engine_ defaults to nullptr ~Car() = default; // no need to delete void install(std::unique_ptr new_engine) { engine_ = new_engine; } private: std::unique_ptr engine_; }; 如此一来，install()的函数签名将给其他开发者足够的提示： void installer(Car* car) { std::unique_ptr engine; engine = std::unique_ptr(new Engine); // or, in c++14, engine = std::make_unique(); car.install(engine); } 在上述代码中，engine 作为一个被 uniqueptr 管理的对象，在作为 install 函数的参数时即完成了所有权的传递【注意到参数类型不包含引用】，在 install 函数内部进一步传递给了 car 的成员变量 engine。这些信息由语法本身直接提供。 借助智能指针，标准库容器与多态也能完美结合成满足 RAII 的多态容器。比如考虑如下两个容器： std::vector std::vector> 虽然 std::vector 会自动调用成员的析构函数，但在成员是指针时只会释放指针本身，而不会触及指针指向的对象。因此第一个容器不满足 RAII，释放时需要手动 delete。第二个容器经由 unique_ptr 的析构将自动调用 BaseClass 的析构函数，因而释放时无需额外代码。 【更多关于智能指针的讨论与用法可参考 Scott Meyers 的 Effective Modern C++ 以及 Herb Sutter 的博客： https://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/ https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/ 】 注意事项 需要注意的是，智能指针只有正确使用才能实现安全的内存管理；在 C++ 自由的语法下有足够可以让智能指针出错的用法。例如，一个常见的错误是用裸指针来初始化智能指针： int* raw = new int[100]; std::unique_ptr p(raw); // bad! should be std::unique_ptr p(new int[100]) 上述代码虽然“合法”，但完全破坏了 unique_ptr 的本意。若用户手动 delete raw，在智能指针 p 结束生命周期时会出现重复 delete 的错误。一般而言，智能指针只能管理从一开始就由智能指针管理的内存；将普通创建的对象的指针用来初始化智能指针会引起严重的内存问题。有时人们在设计类时会特意设采用如下模式： class Test { public: static std::shared_ptr create() { std::shared_ptr ptr(new Test); return ptr; } private: Test(); }; 通过将构造函数设置为 private，Test 类无法正常创建或者 new 对象，只能通过 create 函数获得由智能指针管理的对象。但即使如此，用户依然可以在调用 create 得到智能指针管理的对象后再通过 get 得到裸指针： std::shared_ptr ptr = Test::create(); Test* bad = ptr.get(); // bad practice, but legal delete bad; // will cause error when ptr expires 上述例子只是说明单纯看到智能指针并不意味着代码的内存安全。事实上，几乎没什么工具能做到在 C++ 语法的自由度下保证不会被用坏。但反过来，即使不使用智能指针，若开发者群体能够自觉遵守一定的规范，代码也可以具有很高的安全性。归根结底，内存的安全管理在实践中并不单取决于一两个工具，更重要的往往是开发者群体的共识。 面向对象的设计 封装、内聚与耦合 在面向对象的程序设计中经常出现“封装”这个概念。很多时候，当一个类大致符合以下情况： 包含一系列相互关联的成员变量与函数 一些成员变量有访问限制 我们即会认为做了“封装”。尽管大多数开发者都会写出符合上述条件的代码，但在程序不断演化、代码量逐渐增大时还是十分容易陷入程序结构日益复杂的困境，以至于在进一步开发前不得不重构。 当然，代码的复杂化是功能增多所不可避免的代价，在软件的持续发展中一定次数的重构不可避免。然而，一个并不鲜见的情况是代码在重新设计后不仅比最早的代码更为精简，功能还更为强大。有时我们会意识到，一些需求从一开始就存在更简洁、自然的设计；一部分重构工作在设计之初就有机会避免。诚然，这种想法有事后诸葛之嫌：人们无法预测未来所有的需求，因而也无从设计一个一劳永逸的框架。但是，“不存在一劳永逸的设计”并不能作为所有重构的借口。若我们回顾过去重构的经历，其实不难发现一些高度相似或反复出现的困境。若将一些困境与封装的概念结合起来加以推敲，可以发现至少一部分重构的需求其实与封装的选择密不可分。对于这个因素导致的重构，或许是在今后的开发中较为容易避免且应当避免的。 封装选择的影响 在设计类或模块时一个不可回避的问题是，应当包含哪些成员与哪些 public 函数？这个问题同时蕴含了其反问题：不应该包含哪些成员与 public 函数？对这两个问题的忽视是导致代码结构不合理地复杂的常见成因之一。以下情况在实际代码中并不罕见： 单一概念所对应的变量同时是多个类的成员 几个高度关联的变量被分别存放在不同类或模块里 一个类有大量（比如几十个）成员变量 1 与 2 的后果都是使用者每次更新一个变量都需要相应修改多个对象。如果这些关联变量位于不同模块，就可能出现两个模块间双向的数据传输。对使用者而言，这种设计不仅增加了理解程序的成本，还造成了一组对象中修改其中一个就必须同步给其他几个的局面。若使用者有所疏忽，写出的程序就可能出错。最糟糕的情况是未正确同步的变量在当前代码流程下未被使用，测试也没能覆盖，而在日后某次新增需求时才被触发。此时可能代码已迭代多轮，故障排查成本极高。 将高度关联的变量分散在各处固然有隐患，可若走向另一极端，将众多变量不假思索地装进一个类里，亦会产生不良的后果。一个拥有大量成员变量的对象往往功能众多，或被多处访问、修改。如果类的维护者选择对所有成员的所有可能情况都负起责任，那他的任务就不仅是几个高度关联变量组的组内同步，还需要负责组间的协调。若这些关联变量组之间是串联关系，工作量尚且只是线性；若这些变量组之间存在灵活的耦合，工作量就会呈指数上升。一种不算少见的情况是，类的设计者原本计划了一个成员众多、功能强大的类，但在开发过程中因精力有限而逐渐放弃对所有计划功能的全权负责，选择将一部分成员的修改权开放给使用者。此时，使用者就不得不追踪并理清其关心的部分成员在整个程序流程中的变化——这对于一个被多处访问、修改的对象是十分繁重且容易出错的任务。 以上讨论其实只指向了一个众所周知的事实：仅在字面上遵循封装往往并不能减轻多少开发者的负担，因而也称不上是好的设计。好的设计需要以“高内聚(high cohesion)，低耦合(low coupling)”为目标，直面“应该封装什么”这个问题。 概念与对象的状态 在尝试回答这个问题前，我们需将之前的例子与面向对象编程中“状态”这一概念结合起来。一个对象的状态通常被定义成这个对象所有成员变量的值；一个程序在某一时刻所有对象内所有成员的值定义了这个程序在此刻的状态。当开发者构思某个功能的实现时，一方面需要理清各个量在概念上的演化，另一方面需要让程序中的实际对象在状态上与概念中的对象对齐。 从这个角度，概念中的对象演化对应了一组关联变量的全体同步；关联变量的不完全同步则不对应任何有意义的概念。如果在程序中一个概念被分散到多个对象，则开发者需要付出“从大量无意义的状态中找到正确状态”的成本。将修改成员变量的权限开放则等于告诉使用者这个类有无数可能的状态，使用者需要自己摸索找到正确的状态。如果没有从设计上确保概念与对象的状态锁定，为使程序正确地在状态间运行，所有欠缺的工作只能由开发者承担。 反过来，如果一个类能做到“状态”与概念严格绑定，其复杂度就可大大降低。以“状态”的视角进行开发，不同开发者的责任分工也得以明确： 设计者需根据需求与程序流程定义出一些细粒度的“状态”，将那些与“状态”的定义最契合的变量打包成类，将不同“状态”间的切换操作定义为 public 函数； 维护者需要理解设计者对状态的定义，同时根据新的需求调整，同时保证类在任何 non-const public 接口调用下只能处于某个预设的状态； 使用者在理解这个类所有可能状态的基础上以黑箱的方式使用，将精力专注于工作流的搭建。 当然，以上的讨论可能过于宽泛或者抽象，也不能涵盖所有的问题。但不可否认的是，仅仅在字面上做到封装对构建复杂软件而言是不够的；开发者值得从更细致的角度进行分析后做出选择（例如不同设计下的耦合强度）。此外，如“高内聚，低耦合”等基本原则也应是开发者不断追求的目标。对于一个类而言，或许下面的要求不算过分： 包含一组且只包含一组高度关联的成员变量 负责修改成员变量的函数应设计成一次性完成所有相关成员变量的同步； 修改成员的操作只能经由采用上述设计的函数完成。 抽象与解耦 在开发 DFT 软件时，类的设计者会很自然地借鉴物理与化学概念，甚至将一些概念直接翻译成类。从程序设计的角度，这种思路下的类一般天然与概念中的类契合，因而往往能满足“高内聚，低耦合”的要求。对于一些具有独特数据结构的量来说，这种做法无可指摘。然而需注意的是，对于一些不同概念的物理量，其数据结构与数学操作也可能存在相当大的共性；即使对于一些整体结构和功能较为独特的量，其部分成员和操作也可能相当常见。当这些情况发生时，基于物理概念的类的设计可能需要一定的调整。 比如，数值原子轨道与赝势的非局域投影子当然是截然不同的物理概念，但两者在数学上都是【数值径向函数】x【球谐函数】的形式，且在 LCAO 计算中需要的数学操作基本相同。基于这些原因，较之于分别定义“数值原子轨道径向函数类”和“赝势投影子径向函数类”，抽象出一个“数值径向函数类”，然后将原子轨道与投影子当作这个类的不同具体对象的做法似乎是更理想的设计。此外，在科学计算中恐怕最为普遍的抽象是对线性代数对象的抽象。C++ 社区内各种线性代数库不胜枚举，熟练使用这些库往往能显著加速开发。 抽象并不局限于对数学概念的提炼。从程序设计角度，有一些类（或者一些类的大部分成员变量）实际上可视作“异质容器” （即存放不同类型变量的容器），其本身并不包含太多操作。遗憾的是，截至 C++11，标准库并不直接提供符合这个概念的工具。【标准库容器配合 boost 的 variant 或 any 可以实现异质容器；C++ 标准库直到 17 才引入 std::variant/any】 除了降低重复代码，抽象对于程序设计的另一大帮助是解耦。若 A 与 B 模块间的接口直接使用 B 模块内的类型，A 模块的编译与测试将无法独立于 B 模块存在。若能将接口替换为更为一般、抽象的对象（比如线性代数对象或者一些标准库容器），A 对 B 模块的依赖就能被去除。 宏的使用 MPI 当前 module_base 中 MPI 相关函数（parallel_commons/reduce/global)使用宏的方式基本是放在函数外，即当MPI 未定义时这些 MPI 相关的函数完全不会出现在预处理后的源文件里。这样固然逻辑清晰，但也使得外部每一处 MPI 函数的调用亦需被MPI 宏包裹，比如 // module_basis/module_nao/atomic_radials.cpp #ifdef __MPI Parallel_Common::bcast_int(lmax_); Parallel_Common::bcast_int(nzeta_max_); // the rest bcasts are omitted #endif if (rank != 0) { nzeta_ = new int[lmax_ + 1]; index_map_ = new int[(lmax_ + 1) * nzeta_max_]; } #ifdef __MPI Parallel_Common::bcast_int(nzeta_, lmax_ + 1); Parallel_Common::bcast_int(index_map_, (lmax_ + 1) * nzeta_max_); #endif 在以上例子中我们需要 bcast 数组 nzeta与 index_map。由于这些数组的大小仅为 rank-0 所知，这个信息需要首先被 bcast，其余 rank 在得知大小后申请内存，随后才能 bcast 数组。这个过程中 MPI 函数的调用分为了两段。如果 MPI 函数被集中调用，则尚且只需在头尾分别加上#ifdef 与#endif；如果有间隔地使用 MPI 函数，就需要重复这些宏指令，一定程度上影响了代码的观感。另外，由于程序中使用 MPI 的地方众多，所有文件中重复的#ifdef __MPI ... #endif 数量亦不可小觑。 一种可选的替代方案是只把函数定义的函数体用宏包裹： // parallel_commons.h #ifdef __MPI #include #endif namespace Parallel_Commons { void bcast_int(int &object); // the rest are omitted } // parallel_commons.cpp void Parallel_Common::bcast_int(int &object){ #ifdef __MPI MPI_Bcast(&object, 1, MPI_INT, 0, MPI_COMM_WORLD); #endif } // test.cpp void test() { int i = 5; Parallel_Common::bcast_int(&i); // no need to be wrapped in __MPI } 如此一来，无论MPI 是否被定义，外部都能使用这些函数，且使用时无需逐块加上#ifdef... #endif。在MPI 未定义时，MPI 函数的函数体为空，编译器在开启-O2 或更高级别优化下会将这些空函数的调用优化掉，由此实现与当前相同的效果。这个方案要求每个 MPI 函数定义时都分别将函数体用宏包裹，一定程度增加了 parallel_common/reduce/global.cpp 三个文件的代码，但方便了外部的使用。 Debug C++ 各个版本的 标准 中均提到与 的行为取决于“NDEBUG”宏：只要编译时加上-DNDEBUG，所有 assert 都会成为空函数。 当前 ABACUS 中一方面存在大量标准定义的 assert，同时也存在自定义的“DEBUG”。虽然新代码中的 assert 被建议使用DEBUG 包裹，但目前依然存在许多旧有的 assert 并没有被__DEBUG 包裹，这种未统一的状态可能会引起一些开发者的困惑。 此外，目前所有 debug 代码依然需要手动用DEBUG 包裹，这与MPI 的情况类似。一种可能的替代方案是 #ifndef __DEBUG_UTILITY_H__ #define __DEBUG_UTILITY_H__ #ifdef __DEBUG // or #ifndef NDEBUG #include #define DEBUG_PRINT_LINE_AND_FILE() std::cout 如此一来，debug 代码可以在开发中被任意使用，而仅在控制 debug 的宏打开时才起具体作用。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-03-06 15:06:07 "},"algorithm-wannier.html":{"url":"algorithm-wannier.html","title":"最大局域化 Wannier 函数方法简介","keywords":"","body":"最大局域化 Wannier 函数方法简介 作者：刘人熙，邮箱：rxliu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/11/09 一、Wannier 函数是什么？ 电子的能量和波函数是电子结构计算中最关心的物理量之一，了解电子的这两个性质，就能进一步了解电子乃至原子体系的更多性质。 在周期性势场中，电子波函数满足布洛赫定理（Bloch Theorem），该定理指出，当电子处于满足 V(\\mathbf{r}+\\mathbf{R})=V(\\mathbf{r}) 的周期性势场V(\\mathbf{r})下时，电子的本征波函数\\psi_{n\\mathbf{k}}(\\mathbf{r})满足公式\\psi_{n\\mathbf{k}}(\\mathbf{r})=e^{i\\mathbf{k}\\cdot\\mathbf{r}}u_{n\\mathbf{k}}(\\mathbf{r})， 其中u_{n\\mathbf{k}}(\\mathbf{r})是另一个周期性函数，满足 u_{n\\mathbf{k}}(\\mathbf{r})=u_{n\\mathbf{k}}(\\mathbf{r}+\\mathbf{R})，这里的\\mathbf{R}代表晶格矢量。 图 1 左列展示了一维情况下一些布洛赫波函数的形态，即通常情况下，电子波函数在实空间中是非局域的。 事实上，电子波函数的模平方代表电子出现的概率密度，能被实验验证。在计算中，可以发现电子波函数有一个可调节的“相位因子“，这个随机的相位因子可以导致计算出来的电子波函数在实空间的局域程度不同。因此，长期以来，人们一直在探索什么形式的电子波函数适合描述例如共价键这样的物理性质，Wannier 函数就是常用的一种方法。 Wannier 函数就是一种周期性势场中的电子波函数表示方法，早在 1937 年，Gregory H. Wannier 最早定义了周期性势场中的波函数可以写成： |\\mathbf{R}n\\rangle=\\frac{V}{(2\\pi)^3}\\int_{BZ}d\\mathbf{k}e^{-i\\mathbf{k}\\cdot\\mathbf{R}}|\\psi_{n\\mathbf{k}}\\rangle 这里的 V 代表晶格体积。从公式直观上看，这相当于在第一布里渊区中对电子波函数做傅立叶变换，也就是对各个本征态波函数\\psi_{n\\mathbf{k}}按照e^{-i\\mathbf{k}\\cdot\\mathbf{R}}的权重做加权平均，把各个本征态“折叠”到\\mathbf{R}晶格中，实现局域化。得到的波函数|\\mathbf{R}n\\rangle被称作 Wannier 函数，一维的图示如图 1 右列。 图 1. 左列：不同k点对应的布洛赫波函数；右列：不同晶格中的Wannier函数。 易于验证 Wannier 函数是正交归一的，布洛赫波函数可以通过逆傅立叶变换从 Wannier 函数得到： |\\psi_{n\\mathbf{k}}\\rangle=\\sum_{\\mathbf{R}}e^{i\\mathbf{k}\\cdot\\mathbf{R}}|\\mathbf{R}n\\rangle 于是对于同一个能带的子空间来说，布洛赫波函数和 Wannier 函数都可以构成电子波函数的完备表示，也就是 P_n= \\sum_{\\mathbf{R}}|\\mathbf{R}n\\rangle\\langle\\mathbf{R}n|=\\sum_{\\mathbf{k}}|\\psi_{n\\mathbf{k}}\\rangle\\langle\\psi_{n\\mathbf{k}}|。 二、最大局域化 Wannier 函数 2.1 Wannier 函数的不唯一性 Wannier 的局域化定义简单直接，深受学界欢迎，但是它存在随规范变化因而不唯一的问题。这种不唯一性来源于布洛赫波的不唯一性，对于非简并的n\\mathbf{k}态的本征波函数\\psi_{n\\mathbf{k}}，规范变换后的\\psi_{n\\mathbf{k}}e^{i\\phi(\\mathbf{k})}（\\phi(\\mathbf{k})为实数）同样是本征态，二者之间只差一个相位因子。但是这样一来，布洛赫波中的u_{n\\mathbf{k}}分量就变成了u_{n\\mathbf{k}}e^{i\\phi(\\mathbf{k})}，Wannier 函数就变成了\\frac{V}{(2\\pi)^3}\\int_{BZ}d\\mathbf{k}e^{-i\\mathbf{k}\\cdot\\mathbf{R}+i\\phi(\\mathbf{k})}|\\psi_{n\\mathbf{k}}\\rangle，得到的 Wannier 函数就完全不一样了。 在简并情况下，比如说 J 个能带构成一组互相相交的能带，和其他能带不相交，这时这 J 个能带的本征波函数做幺正变换，依然可以构成本征波函数，也就是 |\\tilde{\\psi}_{n\\mathbf{k}}\\rangle=\\sum_{m}U_{mn}^{\\mathbf{k}}|\\psi_{m\\mathbf{k}}\\rangle 依然是本征态，他们可以张成对应于这 J 个能带的同一个线性空间，该线性空间的投影算符可以写作 P_{\\mathbf{k}}=\\sum_{n=1}^{J}|\\psi_{n\\mathbf{k}}\\rangle\\langle\\psi_{n\\mathbf{k}}|=\\sum_{m=1}^{J}|\\tilde\\psi_{m\\mathbf{k}}\\rangle\\langle\\tilde\\psi_{m\\mathbf{k}}|。 第二个等号具体证明如下： \\sum_{m=1}^{J}|\\tilde\\psi_{m\\mathbf{k}}\\rangle\\langle\\tilde\\psi_{m\\mathbf{k}}|=\\sum_{m=1}^{J}\\sum_{pq}^{J}U_{mp}^{\\mathbf{k}}|\\psi_{p\\mathbf{k}}\\rangle U^{\\mathbf{k}*}_{qm}\\langle\\psi_{q\\mathbf{k}}| =\\sum_{pq}^{J}\\sum_{m=1}^{J}U^{\\mathbf{k}*}_{qm}U_{mp}^{\\mathbf{k}}|\\psi_{p\\mathbf{k}}\\rangle\\langle\\psi_{q\\mathbf{k}}|=\\sum_{pq}^{J}\\delta_{pq}|\\psi_{p\\mathbf{k}}\\rangle\\langle\\psi_{q\\mathbf{k}}|=\\sum_{p=1}^{J}|\\psi_{p\\mathbf{k}}\\rangle\\langle\\psi_{p\\mathbf{k}}| 也就是说一组或者一个孤立的能带的投影算符是不随规范变换的。 这时不同规范下的 Wannier 函数的变换会更为复杂，Wannier 函数也存在不唯一确定的问题。 所以是否可以选取一个给定的规范，可以在一个系统上给出唯一的一组 Wannier 函数，满足我们在第一部分中提出的两个动机呢？这个简单的问题并没有在固体物理建立的最初几十年里有一个完整的解答。 2.2 独立的能带的 Wannier 函数的 spread 函数 直到 1997 年，Nicola Marzari 和 David Vanderbilt 在文献[1]提出，可以针对一组孤立的 J 个能带（也可以是单独一个孤立的能带），要求 Wannier 函数在晶格内的 spread 最小，以此作为规范，所谓的 spread 就是在 Wannier 函数上位置 r 的方差 \\Omega=\\sum_{n}\\langle\\mathbf{0}n|\\mathbf{r}^2|\\mathbf{0}n\\rangle-|\\langle\\mathbf{0}n|\\mathbf{r}|\\mathbf{0}n\\rangle|^2. Marzari 和 Vanderbilt 进一步发现这个 spread 函数可以分为规范不变和随规范变换的两个部分，并且给出了最小化 spread 函数的稳定的数值算法。 具体来说，规范不变的部分是： \\Omega_{I}=\\sum_{n}\\left[\\langle\\mathbf{0}n|\\mathbf{r}^2|\\mathbf{0}n\\rangle-\\sum_{\\mathbf{R}m}|\\langle\\mathbf{R}m|\\mathbf{r}|\\mathbf{0}n\\rangle|^2\\right]， 规范变换的部分是 \\tilde\\Omega=\\sum_{n}\\sum_{\\mathbf{R}m\\neq\\mathbf{0}n}|\\langle\\mathbf{R}m|\\mathbf{r}|\\mathbf{0}n\\rangle|^2， 规范不变的部分可以写作： \\Omega_I=\\sum_{n\\alpha}\\left[\\langle\\mathbf{0}n|r_\\alpha^2|\\mathbf{0}n\\rangle-\\sum_{\\mathbf{R}m}\\langle\\mathbf{0}n|r_\\alpha|\\mathbf{R}m\\rangle\\langle\\mathbf{R}m|r_\\alpha|\\mathbf{0}n\\rangle\\right] =\\sum_{n\\alpha}\\left[\\langle\\mathbf{0}n|r_\\alpha^2|\\mathbf{0}n\\rangle-\\sum_{m}\\langle\\mathbf{0}n|r_{\\alpha}P_{m}r_\\alpha|\\mathbf{0}n\\rangle \\right] =\\sum_{n\\alpha}\\langle\\mathbf{0}n|r_{\\alpha}(1-\\sum_{m}P_{m})r_\\alpha|\\mathbf{0}n\\rangle =\\sum_{n\\alpha}\\langle \\mathbf{0}n|r_{\\alpha}Qr_\\alpha|\\mathbf{0}n\\rangle 上式中最后一个等号使用了定义 P=\\sum_m P_m=\\sum_{\\mathbf{k}m}|\\psi_{m\\mathbf{k}}\\rangle\\langle\\psi_{m\\mathbf{k}}|， Q=1-P， 因为 P 和 Q 算符是考虑的这组孤立能带上的投影矩阵和互补矩阵，所以它们是不随规范变换的，这一点已经在上文证明过。 \\Omega_I可以进一步写成 \\Omega_I=\\sum_{n\\alpha}\\langle\\mathbf{0}n|\\sum_{m}|\\mathbf{0}m\\rangle\\langle \\mathbf{0}m|r_\\alpha Qr_\\alpha|\\mathbf{0}n\\rangle=Tr_{c}(Pr_\\alpha Qr_\\alpha) 这里的角标 c 表示对单个晶格（cell）求迹，也就是只对能带指标求迹。可以看到\\Omega_{I}只和P, Q有关，是规范不变的。我们还可以进一步证明规范不变的部分是非负的，具体来说，\\Omega_{I}可以进一步写作Tr_{c}\\left[(Pr_\\alpha Q)(P r_\\alpha Q)^{\\dagger}\\right]， 这显然是非负的，使用投影矩阵满足 P^2=P, P^\\dagger =P 的性质不难证明该等式。 在布洛赫表象下，Wannier 函数的\\mathbf{r}和\\mathbf{r}^2的均值可以表示为： \\langle\\mathbf{R}n|\\mathbf{r}|\\mathbf{0}m\\rangle=i\\frac{V}{(2\\pi)^2}\\int d\\mathbf{k}e^{i\\mathbf{k}\\cdot\\mathbf{R}}\\langle u_{n\\mathbf{k}}|\\nabla_{\\mathbf{k}}|u_{m\\mathbf{k}}\\rangle, \\langle\\mathbf{R}n|\\mathbf{r}^2|\\mathbf{0}m\\rangle=-\\frac{V}{(2\\pi)^2}\\int d\\mathbf{k}e^{i\\mathbf{k}\\cdot\\mathbf{R}}\\langle u_{n\\mathbf{k}}|\\nabla^2_{\\mathbf{k}}|u_{m\\mathbf{k}}\\rangle 这里直接引用了文献[2]的结果。 这里对 k 的散度在 DFT 中，可以近似表示为相邻的 k 点的波函数之间的差分，具体来说就是： \\nabla f(\\mathbf{k}) = \\sum_{\\mathbf{b}}\\mathbf{b}\\omega_b[f(\\mathbf{k}+\\mathbf{b})-f(\\mathbf{k})]+O(b^2), 这里的\\mathbf{b}是\\mathbf{k}指向相邻 k 点的向量，\\omega_b是一个量纲为b^{-2}的常数权重参数，所以 spread 函数和他的导数都可以表示为布洛赫波函数中的周期性分量之间的内积，也就是 M_{mn}^{\\mathbf{k}, \\mathbf{b}}=\\langle u_{m\\mathbf{k}}|u_{n,\\mathbf{k+b}}\\rangle， 换句话说，密度泛函理论软件只需要提供M_{mn}^{\\mathbf{k,b}}这个物理量，就可以通过优化得出最局域化的 Wannier 函数。 经过一系列推导，可以得到\\Omega_I在布洛赫表象下的表达式： \\Omega_I=\\frac{1}{N}\\sum_{\\mathbf{k,b}}\\omega_b \\left(J-\\sum_{mn}|M_{mn}^{(\\mathbf{k, b})}|^2\\right)=\\frac{1}{N}\\sum_{\\mathbf{k,b}}\\omega_b \\mathrm{Tr}(P^{(\\mathbf{k})}Q^{(\\mathbf{k+b})}) 这里的P^{(\\mathbf{k})}=\\sum_{n}|u_{n\\mathbf{k}}\\rangle\\langle u_{n\\mathbf{k}}|，Q^{(\\mathbf{k})}=1-P^{(\\mathbf{k})}，J是能带数。 考虑到Tr(AB)=||A-B||^2/2，可以看到规范不变的 spread 函数衡量的是每个 k 点与其相邻 k 点上布洛赫波函数张成的线性空间的差别，可以看作是不同 k 点上的线性空间之间的“溢出函数” (spilage function)。换句话说，如果整个布里渊区内的 k 点上，布洛赫波函数张成的空间都一模一样，那么Tr(P^{\\mathbf{k}}Q^{(\\mathbf{k+b})})就是 0，规范不变部分的 spread 函数会直接消失，达到最小值。实际上，\\Omega_I可以看作是这组孤立能带的本征态构成的线性空间的一个本征性质，所以不会随这个线性空间内的表象变换而变化。 在实际的计算中，spread 函数是作为一个整体优化的，但\\Omega_I部分其实不会随优化改变，是一个固定的值。 2.3 纠缠能带的 Wannier 函数的 Spread 函数 2.2 部分简要叙述了对于一组孤立的能带，如何定义 spread 函数、如何将 spread 函数划分为规范不变和随规范变换的部分，以及 spread 函数在布洛赫表象下的表示。上述定义和划分在简并能带的情况是否依然成立呢？答案是肯定的，2001 年，Ivo Souza、Nicola Marzari 和 David Vanderbilt 共同在文献[3]提出了在一组纠缠的能带中抽取部分能带，对其 Wannier 函数做最大局域化的方法。Souza 等人提出了这样一个案例：对铜金属而言，其壳层电子 (3d^{10}4s^1)既包含 d 轨道电子也包含 s 轨道电子，直觉上说，d 轨道电子比较局域化，对应于能带中的窄带；s 轨道电子比较接近自由电子，对应于能带中的宽带。但实际上 s 轨道和 d 轨道发生了杂化，他们的能带是重叠在一起的，难以将 s 和 d 的能带、Wannier 函数区分开。这时，我们可以通过最大局域化 Wannier 函数的方式实现以上目的。 具体的做法是这样的，首先选取一个能量区间（energy window），这个区间包含 d 轨道的能带，也可以包含 s 轨道的能带。对于这个区间内的 k 点，如果只有 d 轨道的能带，就什么都不做；如果既含有 d 轨道也含有 s 轨道，就对这个 k 点的 d 轨道对应的\\Omega_I做最小化。这相当于在 s 和 d 轨道的本征态构成的线性空间里优化 d 轨道构成的子空间S(\\mathbf{k})，使该子空间与其他 k 点上的 d 轨道空间尽可能接近。完成这一步优化后，再按照优化独立能带的 Wannier 函数的办法优化\\tilde\\Omega。 完成优化后，可以通过 Slater-Koster 方法做内插值得到任意 k 点上的能带，从而实现对纠缠能带的解耦，在这个例子里就是可以把 d 轨道对应的能带和 s 轨道对应的能带分开，让他们各自长得像窄带和宽带。具体的做法可以参看文献[3] III F 部分和 IV 部分。 2.4 优化 Wannier 函数的 Spread 函数 在优化 spread 函数时，如果考虑的是纠缠能带中的一部分能带，就需要先优化\\Omega_I，再优化\\tilde\\Omega；如果考虑的是孤立能带，直接优化\\tilde\\Omega。 2.4.1 通过自洽迭代方法优化\\Omega_I 对于纠缠的能带中需要局域化的布洛赫波函数，需要优化的 spread 函数\\Omega_I=\\frac{1}{N_{kp}}\\sum_{\\mathbf{k, b}}\\omega_b \\sum_{m=1}^N \\left[1-\\sum_{n=1}^N |M_{mn}^{(\\mathbf{k, b})}|^2\\right]，其中N是考虑的能带数量，例如在铜的例子中，N=5。因为\\Omega_I是对整个布里渊区求和的，各个 k 点耦合在一起，所以需要自洽迭代地对\\Omega_I做优化。具体来说，在第 i 轮迭代，要求|u^{(i)}_{n\\mathbf{k}}\\rangle, n=1...N正交归一，同时u_{n\\mathbf{k}}^{(i)}可以使\\Omega_I^{(i)}达到极小，运用拉格朗日乘子法，写出变分方程： \\frac{\\delta\\Omega_{I}^{(i)}}{\\delta u^{(i)*}_{n\\mathbf{k}}}+\\sum_{n=1}^N \\Lambda^{(i)}_{nm, \\mathbf{k}}\\frac{\\delta}{\\delta u_{m\\mathbf{k}}^{(i)*}}[\\langle u_{m\\mathbf{k}}^{(i)}|u_{n\\mathbf{k}}^{(i)}\\rangle-\\delta_{mn}]=0 经过一系列线性代数操作（详细步骤在文献[3]III C 部分），得到最后的特征方程： \\left[\\sum_{\\mathbf{b}}\\omega_b \\hat{P}_{\\mathbf{k+b}}^{(i-1)}\\right]|u_{m\\mathbf{k}}^{(i)}\\rangle=\\lambda_{m\\mathbf{k}}^{(i)}|u_{m\\mathbf{k}}^{(i)}\\rangle 其中的\\hat{P}_ {\\mathbf{k+b}}^{(i-1)}是\\mathbf{k+b}上的投影算符\\hat{P}^{(i-1)}_ {\\mathbf{k+b}}=\\sum_{n=1}^{N}|u_{n\\mathbf{k+b}}^{(i-1)}\\rangle\\langle u_{n\\mathbf{k+b}}^{(i-1)}|。如果迭代不稳定，可以采用类似 charge mixing 的方法，线性混合前后两步迭代的\\hat{P}_ {\\mathbf{k+b}}，即[\\hat{P}^{(i)}_ {\\mathbf{k+b}}]_ {in}=\\alpha\\hat{P}_ {\\mathbf{k+b}}^{(i-1)}+(1-\\alpha)[\\hat{P}_ {\\mathbf{k+b}}^{(i-1)}]_ {in}，这里的[\\hat{P}^{(i)}_ {\\mathbf{k+b}}]_ {in}表示第 i 步迭代输入的投影算符，\\hat{P}_{\\mathbf{k+b}}^{(i-1)}表示第 i-1 步输出的投影算符。 在实际计算中，需要在特定的基组上把投影算符展开为矩阵做对角化，在这里选择的是选取的能量区间内原始的布洛赫函数u_{n\\mathbf{k}}（这是必要的，因为优化算法本身不保证每次迭代得到的P_{\\mathbf{k}}^{(i)}仍然落在原始布洛赫函数张成的线性空间里，这里选取基底相当于把新得到的投影算符投影到这个空间里，保证每次迭代得到的布洛赫函数仍在原始的线性空间范围内），所以最终需要对角化的矩阵是Z_{mn}^{(i)}(\\mathbf{k})=\\langle u_{m\\mathbf{k}}|\\sum_{\\mathbf{b}}\\omega_b[\\hat{P}^{(i)}_{\\mathbf{k+b}}]_{in}|u_{n\\mathbf{k}}\\rangle，这是一个大小为N\\times N的厄米矩阵。每次自洽迭代中，需要对每个 k 点对角化Z_{mn}^{(i)}(\\mathbf{k})，得到u_{n\\mathbf{k}}^{(i)}；计算新的投影矩阵，进入下一次迭代。 最后还存在一个初始值Z_{mn}^{(0)}(\\mathbf{k})如何选取的问题，这实际上是在选取初始的子空间S(\\mathbf{k})。这里固然可以选择原始的布洛赫波函数u_{n\\mathbf{k}}构成子空间，但是也可以有意地选择子空间使得其 Wannier 表象更接近我们的直觉认知。比如我们认为 Wannier 函数可能接近于一组名为g_n(\\mathbf{r}), n=1...N的实空间基函数，那么就可以把每个 k 点上的布洛赫波函数投影到这组基函数上：|\\phi_{n\\mathbf{k}}\\rangle=\\sum_{m=1}^{N_{win}}A_{mn}^{(\\mathbf{k})}|u_{m\\mathbf{k}}\\rangle，其中A_{mn}^{(\\mathbf{k})}=\\langle u_{m\\mathbf{k}}|g_{n}\\rangle，N_{win}是能量区间中总能带数。这样的投影轨道还不满足布洛赫波函数正交归一的要求，所以需要对其做正交归一化使其成为新的布洛赫波函数：|u_{n\\mathbf{k}}^{(0)}\\rangle=\\sum_{m=1}^{N}(S^{-1/2})_{mn}|\\phi_{m\\mathbf{k}}\\rangle=\\sum_{m=1}^{N_{win}^{\\mathbf{k}}}(AS^{-1/2})_{mn}|u_{m\\mathbf{k}}\\rangle 其中的重叠矩阵S_{mn}=S_{mn}^{\\mathbf{k}}=\\langle\\phi_{m\\mathbf{k}}|\\phi_{n\\mathbf{k}}\\rangle=(A^{\\dagger}A)_{mn}，这样就可以通过实空间中布洛赫波函数在一组预想的基函数上的投影给出来投影矩阵P_{k}的初猜，从而开始自洽迭代优化。 2.4.2 通过梯度下降方法优化\\tilde \\Omega 获得每个 k 点上需要考虑的布洛赫波函数张成的线性空间S(\\mathbf{k})（也是获得每个 k 点上的投影矩阵P_{\\mathbf{k}}）之后，就可以通过梯度下降法寻找使得 spread 函数最小的规范变换。这里的梯度下降不是对u_{n\\mathbf{k}}做任意的梯度下降，因为需要满足新的u_{n\\mathbf{k}}和原来的u_{n\\mathbf{k}}之间的规范变换关系（幺正变换）。具体的做法是一次对布洛赫波函数做一个微小的转动U_{mn}^{(\\mathbf{k})}=\\delta_{mn}+dW_{mn}^{(\\mathbf{k})}，其中dW_{mn}^{(\\mathbf{k})}=-dW_{mn}^{(\\mathbf{k})\\dagger}是一个反厄米矩阵，从而满足U_{mn}^{(\\mathbf{k})}是幺正的。经过一些推导（详细推导参考文献[1]的 IV B 部分），可以获得 spread 函数的梯度： G^{(\\mathbf{k})}=\\frac{d\\Omega}{dW^{(\\mathbf{k})}}=4\\sum_{\\mathbf{b}}\\omega_b (\\mathcal{A}[R^{(\\mathbf{k,b})}]-\\mathcal{S}[T^{(\\mathbf{k,b})}]) 其中R^{(\\mathbf{k,b})}=M_{mn}^{(\\mathbf{k, b})}M_{nn}^{(\\mathbf{k, b})*}, T_{mn}^{(\\mathbf{k,b})}=\\frac{M_{mn}^{(\\mathbf{k,b})}}{M_{nn}^{(\\mathbf{k,b})}}\\cdot(\\mathrm{Im} \\ln{M_{nn}^{(\\mathbf{k,b})}}+\\mathbf{b}\\cdot\\overline{\\mathbf{r}_n}), \\overline{\\mathbf{r}_n}=-\\frac{1}{N}\\sum_{(\\mathbf{k,b})}\\omega_{b}\\mathbf{b}\\mathrm{Im}\\ln{M_{nn}}^{(\\mathbf{k,b})} 在实际计算中，梯度下降的步长被设置为固定的\\epsilon=\\alpha/4\\omega，其中\\omega=\\sum_{b}\\omega_b，这样微扰矩阵\\Delta W^{(\\mathbf{k})}写作\\Delta W^{(\\mathbf{k})}=\\frac{\\alpha}{\\omega}\\sum_{\\mathbf{b}}\\omega_b (\\mathcal{A}[R^{(\\mathbf{k,b})}]-\\mathcal{S}[T^{(\\mathbf{k,b})}])，因为这个矩阵是反厄米的，所以波函数可以直接按照u_{n\\mathbf{k}}\\to e^{\\Delta W^{(\\mathbf{k})}}u_{n\\mathbf{k}}变换，进入下一次迭代。这时 spread 函数的变化是d\\Omega=-\\frac{\\alpha}{4\\omega}\\sum_{\\mathbf{k}}||G^{(\\mathbf{k})}||^2。 三、参考文献 Nicola Marzari and David Vanderbilt, Maximally localized generalized Wannier functions for composite energy bands, Phys. Rev. B 56, 12847 (1997). (提出最大局域化 Wannier 函数方法的文献) Blount, E. I., Solid State Phys. 13, 305 (1962). (关于 Bloch 状态的诸多基础性质的讨论，最大局域化中\\langle n\\mathbf{R}|\\mathbf{r}|m\\mathbf{0}\\rangle在布洛赫表象下的表达式来源于此) Ivo Souza, Nicola Marzari, and David Vanderbilt, Maximally localized generalized Wannier functions for entangled energy bands, Phys. Rev. B 65, 035109 (2001). (从纠缠能带中解耦出部分能带，做最大局域化 Wannier 函数的文献) Arash A. Mostofi, Jonathan R. Yates, Young-Su Lee, Ivo Souza, David Vanderbilt, Nicola Marzari, wannier90: A tool for obtaining maximally-localised Wannier functions, Comput. Phys. Commun., 178, 9, 685 (2008). (Wannier90 软件的初始文献) Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-11-10 11:05:17 "},"algorithm-mix.html":{"url":"algorithm-mix.html","title":"电荷密度混合算法介绍","keywords":"","body":"电荷密度混合算法介绍 作者：孙亮，邮箱：l.sun@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/11/09 一、背景 做基于 Kohn-Sham Density Functional Theory（KSDFT）的第一性原理计算的过程就是求解 Kohn-Sham (KS)方程 [-\\frac{1}{2}\\nabla^2+V_{\\rm{eff}}(r)]\\psi_i^\\sigma(r)=\\varepsilon_i^\\sigma\\psi_i^\\sigma(r),V_{\\rm{eff}}(r)=V_{\\rm ext}(r)+V_{\\rm{H}}(r)+V_{\\rm{xc}}(r) 的过程。由于其中 V_{\\rm{H}}(r)=\\int{\\frac{\\rho(r')}{|r-r'|}dr'},V_{\\rm{xc}}(r) = \\frac{\\delta E_{\\rm{xc}}[\\rho]}{\\delta\\rho(r)} 均依赖于电荷密度\\rho(r)，KS 方程无法直接求解，只能采取迭代的方法，也就是自洽场迭代法（scf, self-consistent field）。其流程可以概括为 \\cdots \\rightarrow \\rho^{i-1} \\rightarrow V_{\\rm{eff}}^{i-1} \\rightarrow \\rho^{i} \\rightarrow V_{\\rm{eff}}^{i} \\rightarrow \\rho^{i+1} \\rightarrow \\cdots 上述过程也可以看作一个不动点问题：\\rho = f(\\rho)，f代表从\\rho^{i-1}到\\rho^i的映射。 我们常常采用电荷密度混合（charge mixing）方法来提升 scf 迭代过程的稳定性和收敛效率，引入 charge mixing 方法后，scf 流程可概括为 \\cdots \\rightarrow \\rho_{\\rm{in}}^{i-1} \\rightarrow V_{\\rm{eff}}^{i-1} \\rightarrow \\rho_{\\rm{out}}^{i-1}  \\stackrel{CM}{\\longrightarrow} \\rho_{\\rm{in}}^{i} \\rightarrow V_{\\rm{eff}}^{i} \\rightarrow \\rho_{\\rm{out}}^{i} \\stackrel{CM}{\\longrightarrow} \\rho_{\\rm{in}}^{i+1} \\rightarrow \\cdots 其中CM表示 charge mixing 方法，它将前几步的电荷密度以一定的比例混合，得到下一步输入f映射的电荷密度\\rho_{\\rm{in}}。 下面我们将介绍几种常用的 charge mixing 方法：plain mixing, Pulay mixing, 以及Broyden mixing方法。这三种算法均已实现在 ABACUS 中。 为了方便，下文中我们统一采用狄拉克符号，比如电荷密度记为|\\rho\\rangle。 二、算法介绍 我们一般定义|F^{i}\\rangle = |\\rho^{i}_ {\\rm{out}}\\rangle - |\\rho^{i}_{\\rm{in}}\\rangle为残差，当它的模\\langle F^{i}|F^{i}\\rangle = 0时，迭代达到收敛。实际计算中，无法真正做到模为零，一般设置一个阈值\\Delta来判断是否收敛。 值得一提的是，下面的推导中，我们都以电荷密度作为变量，但这些算法都适用于 charge mixing 过程中其它量的混合，比如动能密度等。它们也不仅适用于电荷密度混合，也可用于其它的优化问题。 1. Plain mixing Plain mixing，也称 simple mixing，其思路是将|\\rho^{i}_ {\\rm{in}}\\rangle和|\\rho^{i}_ {\\rm{out}}\\rangle做线性组合，得到下一步的|\\rho^{i+1}_{\\rm{in}}\\rangle，为了保证混合前后电子数不变，混合的公式为 |\\rho^{i+1}_{\\rm{in}}\\rangle = (1-\\beta)|\\rho^{i}_{\\rm{in}}\\rangle + \\beta|\\rho^{i}_{\\rm{out}}\\rangle = |\\rho^{i}_{\\rm{in}}\\rangle + \\beta(|\\rho^{i}_{\\rm{out}}\\rangle - |\\rho^{i}_{\\rm{in}}\\rangle) = |\\rho^{i}_{\\rm{in}}\\rangle + \\beta|F^{i}\\rangle, 其中\\beta为 mixing 的步长，可以取 0 到 1 间的实数，\\beta越小，则迭代越稳定，但收敛所需的步数可能越多。（见第三部分，介绍 ABACUS 里面的相关参数） 一般而言，plain mixing 收敛较慢，不在实际计算中采用。 2. Pulay mixing Pulay mixing[1]也叫 direct inversion of the iterative sub-space (DIIS) method，其思路是用前n步的电荷密度\\{|\\rho^{i-n+1}_ {\\rm{in}}\\rangle, \\cdots, |\\rho^{i-1}_ {\\rm{in}}\\rangle, |\\rho^{i}_ {\\rm{in}}\\rangle\\}做线性组合，在此线性空间中找到一个“最佳”的电荷密度|\\rho^i_{\\rm{opt}}\\rangle，使得\\langle F^{i}_ {\\rm{opt}}|F^{i}_ {\\rm{opt}}\\rangle取极小值，再由|\\rho^i_{\\rm{opt}}\\rangle和|F^i_{\\rm{opt}}\\rangle线性组合得到下一步的|\\rho^{i+1}_{\\rm{in}}\\rangle。 下面我们首先给出算法流程，然后进行相应的推导。 2.1 算法流程 需要存储前n步迭代的\\{|\\rho^{i-n+1}_ {\\rm{in}}\\rangle, \\cdots, |\\rho^{i-1}_ {\\rm{in}}\\rangle, |\\rho^{i}_{\\rm{in}}\\rangle\\}和\\{|F^{i-n+1}\\rangle, \\cdots, |F^{i-1}\\rangle, |F^{i}\\rangle\\}， 计算大小为n \\times n的矩阵A,A_{jk} = \\langle F^{i-n+j}|F^{i-n+k}\\rangle； 计算逆矩阵A^{-1}； 计算混合系数\\alpha_j = \\frac{\\sum_k^n{A^{-1}_ {jk}}}{\\sum_{l}^{n}{\\sum_k^n{A^{-1}_{lk}}}}； 更新密度|\\rho^{i+1}_ {\\rm{in}}\\rangle = \\sum_{j=1}^{n}{\\alpha_j \\left(|\\rho^{i-n+j}_{\\rm{in}}\\rangle + \\beta |F^{i-n+j}\\rangle \\right)}，\\beta为 mixing 的步长。 2.2 算法推导 为了记号方便，我们将参与线性组合的前n步电荷密度\\{|\\rho^{i-n+1}_ {\\rm{in}}\\rangle, \\cdots, |\\rho^{i-1}_ {\\rm{in}}\\rangle, |\\rho^{i}_ {\\rm{in}}\\rangle\\}重新标记为\\{|\\rho^{1}_ {\\rm{in}}\\rangle, \\cdots, |\\rho^{n-1}_ {\\rm{in}}\\rangle, |\\rho^{n}_{\\rm{in}}\\rangle\\}。 首先我们定义|\\rho^i_{\\rm{opt}}\\rangle = \\sum_{j=1}^{n}{\\alpha_j |\\rho^j_{\\rm{in}}\\rangle}，为了保证电子数守恒，要求\\sum_{j=1}^{n}{\\alpha_j} = 1。 为了找到最佳的\\{\\alpha_j\\}组合，使得\\langle F^{i}_ {\\rm{opt}}|F^{i}_ {\\rm{opt}}\\rangle取极小值，同时满足\\sum_{j=1}^{n}{\\alpha_j} = 1的条件，我们采用拉格朗日乘子法，定义 L=\\langle F^{i}_{\\rm{opt}}|F^{i}_{\\rm{opt}}\\rangle - \\lambda \\left( \\sum_{j=1}^{n}{\\alpha_j} - 1 \\right). 进一步假设F_{\\rm{opt}}^i[\\rho^{i}_ {\\rm{opt}}] = F_{\\rm{opt}}^i[\\sum_{j=1}^{n}{\\alpha_j \\rho^{i}_ {\\rm{in}}}] = \\sum_{j=1}^{n}{\\alpha_j F^{j}[\\rho^{j}_ {\\rm{in}}]}，即|F_{\\rm{opt}}^i\\rangle = \\sum_{j=1}^{n}{\\alpha_j |F^{j}\\rangle}，上式变为 \\begin{aligned} L &= \\sum_{j=1}^{n}{\\sum_{k=1}^{n}{\\alpha_j \\langle F^j|F^k\\rangle\\alpha_k}} - \\lambda \\left( \\sum_{j=1}^{n}{\\alpha_j} - 1 \\right)\\\\ & = \\sum_{j=1}^{n}{\\sum_{k=1}^{n}{\\alpha_j A_{jk}\\alpha_k}} - \\lambda \\left( \\sum_{j=1}^{n}{\\alpha_j} - 1 \\right). \\end{aligned} 上面我们定义了A_{jk} = \\langle F^j|F^k\\rangle，它满足A_{jk} = A_{kj}。 于是有 \\frac{\\partial L}{\\partial\\alpha_j} = 2\\sum_{k=1}^n{A_{jk}\\alpha_k} - \\lambda = 0 \\longrightarrow 2\\sum_{k=1}^n{A_{jk}\\alpha_k} = \\lambda, 两边同乘A^{-1}_{lj}并对j求和，有 2\\sum_{j=1}^n\\sum_{k=1}^n{A^{-1}_{lj}A_{jk}\\alpha_k} = \\lambda \\sum_{j=1}^n{A^{-1}_{lj}} \\longrightarrow 2\\sum_{k=1}^n{\\delta_{lk}\\alpha_k} = 2\\alpha_l = \\lambda \\sum_{j=1}^n{A^{-1}_{lj}}. 由\\sum_{l=1}^{n}{\\alpha_l} = 1，有\\frac{1}{2}\\lambda\\sum_{l=1}^{n}{\\sum_{j=1}^n{A^{-1}_ {lj}}} = 1，因此\\lambda = \\frac{2}{\\sum_{l}^{n}{\\sum_{j}^n{A^{-1}_{lj}}}}. 代回上式，我们得到最佳混合比例 \\alpha_l = \\frac{\\sum_j^n{A^{-1}_{lj}}}{\\sum_{k}^{n}{\\sum_j^n{A^{-1}_{kj}}}}. 最终，我们得到由前n步电荷密度线性组合可以得到的“最佳”电荷密度|\\rho^i_{\\rm{opt}}\\rangle = \\sum_{j=1}^{n}{\\alpha_j |\\rho^j_{\\rm{in}}\\rangle}，相应的残差|F_{\\rm{opt}}^i\\rangle = \\sum_{j=1}^{n}{\\alpha_j |F^{j}\\rangle}，其中的系数\\alpha_j = \\frac{\\sum_k^n{A^{-1}_ {jk}}}{\\sum_{l}^{n}{\\sum_k^n{A^{-1}_{lk}}}}. 因此下一次迭代的初始电荷密度 \\begin{aligned} |\\rho^{i+1}_{\\rm{in}}\\rangle  & = |\\rho^{i}_{\\rm{opt}}\\rangle + \\beta|F^{i}_{\\rm{opt}}\\rangle\\\\ & = \\sum_{j=1}^{n}{\\alpha_j |\\rho^j_{\\rm{in}}\\rangle} + \\beta \\sum_{j=1}^{n}{\\alpha_j |F^{j}\\rangle}\\\\ & = \\sum_{j=1}^{n}{\\alpha_j \\left(|\\rho^j_{\\rm{in}}\\rangle + \\beta |F^{j}\\rangle \\right)}. \\end{aligned} 3. Broyden mixing Broyden mixing 是拟牛顿法的一种，它的思路是对|F\\rangle的雅可比矩阵的逆进行近似，从而采用牛顿法进行迭代。 在其发展过程中，曾出现过不同的形式，这里我们介绍的是 1988 年 Johnson 提出的 Simplified modified Broyden method[2]，它兼具收敛速度快与内存消耗少的优势，也是 ABACUS 默认采用的 mixing 方法。 我们先给出算法流程，再进行推导，以下推导参考了文献[3]。 3.1 算法流程 首先我们定义|\\Delta\\rho^{i}_ {\\rm{in}}\\rangle = |\\rho^{i}_ {\\rm{in}}\\rangle - |\\rho^{i-1}_{\\rm{in}}\\rangle，|\\Delta F^{i}\\rangle = |F^{i}\\rangle - |F^{i-1}\\rangle。 需要存储前n步迭代的\\{|\\Delta\\rho^{i-n+1}_ {\\rm{in}}\\rangle, |\\Delta\\rho^{i-n+2}_ {\\rm{in}}\\rangle, \\cdots, |\\Delta\\rho^{i}_{\\rm{in}}\\rangle\\}和\\{|\\Delta F^{i-n+1}\\rangle, |\\Delta F^{i-n+2}\\rangle, \\cdots, |\\Delta F^{i}\\rangle\\}， 计算大小为n \\times n的矩阵B,B_{jk}=\\langle\\Delta F^{i-n+j}|\\Delta F^{i-n+k}\\rangle； 计算逆矩阵B^{-1}； 计算混合系数\\alpha_j=-\\sum_{k=1}^{n}{B^{-1}_{jk}\\langle\\Delta F^{i-n+k}|F^{i}\\rangle}； 更新密度|\\rho^{i+1}_ {\\rm{in}}\\rangle = |\\rho^{i}_ {\\rm{in}}\\rangle + \\beta|F^{i}\\rangle + \\sum_{j=1}^{n}\\alpha_{j}\\left(|\\Delta\\rho^{i-n+j}_{\\rm{in}}\\rangle + \\beta|\\Delta F^{i-n+j}\\rangle\\right)，\\beta为 mixing 的步长。 3.2 算法推导 3.2.1 牛顿法 我们首先介绍牛顿法，对于 charge mixing 中的不动点问题\\rho = f(\\rho)，可以改写为 |F\\rangle = |\\rho_{\\rm{out}}\\rangle - |\\rho_{\\rm{in}}\\rangle = 0，这里|\\rho_{\\rm{out}}\\rangle = f(|\\rho_{\\rm{in}}\\rangle)。 假设|F'\\rangle=F[\\rho']=0，且|F\\rangle在|\\rho'\\rangle附近足够光滑，选|\\rho'\\rangle附近的|\\rho_0\\rangle作为出发点，做泰勒展开，有 |F'\\rangle=|F_0\\rangle+J_0(|\\rho'\\rangle-|\\rho_0\\rangle)+\\cdots=0, 其中J_0=\\frac{\\partial F}{\\partial\\rho}|_{\\rho=\\rho_0}为雅可比矩阵，做线性近似后，有 |\\rho'\\rangle=|\\rho_0\\rangle - J_0^{-1}|F_0\\rangle, 由此得到牛顿法的迭代公式 |\\rho^{i+1}_{\\rm{in}}\\rangle=|\\rho^{i}_{\\rm{in}}\\rangle - J_i^{-1}|F^{i}\\rangle, 此公式中出现了雅可比矩阵的逆，精确求解将极为耗时，因此一般通过求解线性方程组来得到它： 记C_i=J^{-1}_i，由|F^{i-1}\\rangle=|F^{i}\\rangle+J_i(|\\rho^{i-1}_ {\\rm{in}}\\rangle-|\\rho^{i}_{\\rm{in}}\\rangle)，有C_i|\\Delta F^{i}\\rangle=|\\Delta\\rho^{i}_{\\rm{in}}\\rangle。 综上，牛顿法的完整迭代公式为 |\\rho^{i+1}_{\\rm{in}}\\rangle=|\\rho^{i}_{\\rm{in}}\\rangle - C_i|F^{i}\\rangle,C_i|\\Delta F^{i}\\rangle=|\\Delta\\rho^{i}_{\\rm{in}}\\rangle. 牛顿法中，需要先求出矩阵C_i，在 charge mixing 的应用场景中，C_i的大小为N\\times N，N为实空间格点数，因此C_i的求解和储存都很不方便。 3.2.2 Broyden 算法 为了克服牛顿法的问题，人们提出了拟牛顿法（quasi-Newton），其基本思路是对C_i进行近似，而不是精确求解。拟牛顿法中，我们一般要求近似的C_i仍然满足C_i|\\Delta F^{i}\\rangle=|\\Delta\\rho^{i}_{\\rm{in}}\\rangle的条件，称为拟牛顿条件。 Simplified modified Broyden method 是拟牛顿法的一种，假设C_{i-1}已知，它通过求解以下优化问题得到C_i： \\min_{C} \\frac{1}{2}\\|C-C_{i-1}\\|^2_{F}, {\\rm{s.t.}}\\ S_{i}=CY_{i}. 其中S_i=(|\\Delta\\rho^{i-n+1}_ {\\rm{in}}\\rangle, |\\Delta\\rho^{i-n+2}_ {\\rm{in}}\\rangle, \\cdots, |\\Delta\\rho^{i}_{\\rm{in}}\\rangle)，Y_i=(|\\Delta F^{i-n+1}\\rangle, |\\Delta F^{i-n+2}\\rangle, \\cdots, |\\Delta F^{i}\\rangle)，均为大小为N\\times n的矩阵，S_{i}=CY_{i}要求C对于前n步的|\\Delta\\rho^{j}_{\\rm{in}}\\rangle和|\\Delta F^{j}\\rangle均满足拟牛顿条件， 我们仍然采用拉格朗日乘子法，定义 L = \\frac{1}{2}\\|C-C'\\|^2_{F} + \\frac{1}{2}u^T\\left(S-CY\\right)^T\\left(S-CY\\right)u, 为了方便，这里我们省去了S_i,Y_i的下标i，并且记C'=C_{i-1}，其中u=(u_1, u_2, \\cdots, u_n)^T为拉格朗日乘子组成的大小为n\\times 1的向量。 将上式展开，有 \\begin{aligned} L =& \\frac{1}{2}\\sum_{j=1}^n\\sum_{k=1}^n\\left(C_{jk}-C'_{jk}\\right)^2\\\\ &+ \\frac{1}{2}\\sum_{j=1}^n\\sum_{k=1}^n{u_j\\left[ \\left(S^TS\\right)_{jk} - 2\\sum_{p=1}^N\\sum_{q=1}^N{S_{pj}C_{pq}Y_{qk}} + \\sum_{p=1}^N\\sum_{q=1}^N\\sum_{l=1}^N{Y_{pj}C_{qp}C_{ql}Y_{lk}} \\right]u_k}, \\end{aligned} 令\\partial L/\\partial{C_{\\mu\\nu}}=0，由上式有 \\frac{\\partial L}{\\partial{C}_{\\mu\\nu}}=C_{\\mu\\nu} - C'_{\\mu\\nu} - \\sum_{j=1}^n\\sum_{k=1}^n{\\left(S_{\\mu j} - \\sum_{l=1}^N{C_{\\mu l}Y_{lj}}\\right)u_ju_kY_{\\nu k}} = 0, 因此 C_{\\mu\\nu} \\approx C'_{\\mu\\nu} + \\sum_{j=1}^n\\sum_{k=1}^n{\\left(S_{\\mu j} - \\sum_{l=1}^N{C'_{\\mu l}Y_{lj}}\\right)u_ju_kY_{\\nu k}}, 注意我们将括号中的C_{\\mu l}近似成了C'_{\\mu l}，上式写成矩阵形式为 C = C'+\\left(S-C' Y\\right)uu^T Y^T, 代入拟牛顿条件S=CY中，要求uu^T = \\left(Y^T Y\\right)^{-1}，因此上述优化问题给出 C_{i} = C_{i-1}+\\left(S_i-C_{i-1} Y_i\\right) \\left(Y_i^T Y_i\\right)^{-1} Y_i^T, 假设C_{i-1}=C_0=-\\beta I，上式变为 C_{i} = -\\beta I + \\left(S_i+\\beta Y_i\\right) \\left(Y_i^T Y_i\\right)^{-1} Y_i^T, 于是迭代公式为 \\begin{aligned} |\\rho^{i+1}_{\\rm{in}}\\rangle &=|\\rho^{i}_{\\rm{in}}\\rangle - C_i|F^{i}\\rangle\\\\ & = |\\rho^{i}_{\\rm{in}}\\rangle - \\left(-\\beta I + \\left(S_i+\\beta Y_i\\right) \\left(Y_i^T Y_i\\right)^{-1} Y_i^T\\right) |F^{i}\\rangle\\\\ & = |\\rho^{i}_{\\rm{in}}\\rangle + \\beta|F^{i}\\rangle - \\left(S_i+\\beta Y_i\\right) \\left(Y_i^T Y_i\\right)^{-1} Y_i^T |F^{i}\\rangle. \\end{aligned} 下面我们将此公式改写成更加清楚的形式，首先令B=Y_i^T Y_i，则B_{jk}=\\langle\\Delta F^{i-n+j}|\\Delta F^{i-n+k}\\rangle，因此 \\begin{aligned} -\\left(Y_i^T Y_i\\right)^{-1} Y_i^T |F^{i}\\rangle &= -B^{-1}\\left(\\langle\\Delta F^{i-n+1}|F^{i}\\rangle, \\langle\\Delta F^{i-n+2}|F^{i}\\rangle, \\cdots, \\langle\\Delta F^{i}|F^{i}\\rangle \\right)^T\\\\ & =\\left(\\alpha_1, \\alpha_2, \\cdots, \\alpha_n \\right)^T, \\end{aligned} 其中\\alpha_j=-\\sum_{k=1}^{n}{B^{-1}_{jk}\\langle\\Delta F^{i-n+j}|F^{i}\\rangle}。 最终 \\begin{aligned} |\\rho^{i+1}_{\\rm{in}}\\rangle  & =  |\\rho^{i}_{\\rm{in}}\\rangle + \\beta|F^{i}\\rangle - \\left(S_i+\\beta Y_i\\right) \\left(Y_i^T Y_i\\right)^{-1} Y_i^T |F^{i}\\rangle\\\\ & = |\\rho^{i}_{\\rm{in}}\\rangle + \\beta|F^{i}\\rangle + \\left(S_i+\\beta Y_i\\right) \\left(\\alpha_1, \\alpha_2, \\cdots, \\alpha_n \\right)^T\\\\ & = |\\rho^{i}_{\\rm{in}}\\rangle + \\beta|F^{i}\\rangle + \\sum_{j=1}^{n}\\alpha_{j}\\left(|\\Delta\\rho^{i-n+j}_{\\rm{in}}\\rangle + \\beta|\\Delta F^{i-n+j}\\rangle\\right). \\end{aligned} 三、ABACUS 相关参数介绍 上述三种算法均已在 ABACUS 中实现，下面我们简要介绍 ABACUS 中 charge mixing 的相关参数，并将它们与上面的公式对应起来，详细文档见链接。 mixing_type：选择 mixing 算法，可选项为 plain, pulay, broyden，分别对应上述三种算法，一般而言，Broyden 算法收敛最快，Pulay 略慢，plain 最慢。默认选项为 broyden。 mixing_beta：对应上述公式中的参数\\beta，\\beta绝对值越小，则收敛过程越稳定，但达到收敛所需的步数可能增多。对于难以收敛的体系，特别是收敛过程中能量出现上下波动的例子，可以尝试减小 mixing_beta。 mixing_ndim：对应上述公式中的参数n，Pulay 和 Broyden 算法会借助过去n步的信息构建下一次迭代的电荷密度，默认值为 8。对于难以收敛的体系，略增大 mixing_ndim 可以增强收敛过程的稳定性。 mixing_gg0：是否采用 Kerker scaling 方法，此方法会在倒空间中给|F\\rangle乘上\\frac{k^2}{k^2+gg0^2}的因子，以抑制混合过程中的高频项，其中k为波矢，gg0由 mixing_gg0 设置。特别是对于难以收敛的金属体系，打开 Kerker 方法可以帮助计算达到收敛。 mixing_tau：是否对动能密度进行混合，适用于使用 meta-GGA 交换关联泛函的场景。 mixing_dftu：是否对密度矩阵进行混合，适用于使用 DFT+U 的场景。 scf_thr：对应于 charge mixing 的收敛判据\\Delta，对于原子轨道基组(LCAO)，默认值为 1e-7，对于平面波基组(PW)，默认值为 1e-9。 scf_thr_type：选择上述公式中内积\\langle f|f\\rangle的定义，以及相应收敛判据的计算方式。 1：\\langle f|g\\rangle = \\iint{\\frac{f(r)g(r')}{|r-r'|}drdr'} = 4\\pi\\int{\\frac{\\mathcal{R}[f^*(k)g(k)]}{k^2}dk}，\\mathcal{R}表示取实部，收敛判据为\\langle\\Delta\\rho|\\Delta\\rho\\rangle ，默认用于 PW 基组； 2：\\langle f|f\\rangle = \\int{f^2(r)dr}，收敛判据为\\int{|\\Delta\\rho|dr} ，默认用于 LCAO 基组。 四、参考文献 [1] Pulay P. Convergence acceleration of iterative sequences. The case of SCF iteration[J]. Chemical Physics Letters, 1980, 73(2): 393-398. [2] Johnson D D. Modified Broyden’s method for accelerating convergence in self-consistent calculations[J]. Physical Review B, 1988, 38(18): 12807. [3] Lin L, Yang C. Elliptic preconditioner for accelerating the self-consistent field iteration in Kohn--Sham density functional theory[J]. SIAM Journal on Scientific Computing, 2013, 35(5): S277-S298. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-11-10 10:06:33 "},"algorithm-delta.html":{"url":"algorithm-delta.html","title":"在 ABACUS 中进行差分测试","keywords":"","body":"在 ABACUS 中进行差分测试 作者：金祖鑫，邮箱：jinzx@aisi.ac.cn；彭星亮，邮箱：pengxl@aisi.ac.cn；周巍青，邮箱：zhouwq@aisi.ac.cn 工作单位：北京科学智能研究院 最后更新时间：2024/3/29 背景 对 DFT（Density Functional Theory）电子结构计算软件而言，数值计算的精度是软件质量的重要一环。纸面上，一个完整的 DFT 计算只包含构建例如哈密顿矩阵、对角化、最优化等寥寥几步，但在代码层面，很多数学操作的数值实现并非如纸上的公式一般平凡：一些基本的数值算法可能无法兼顾性能与精度；开发者可能需要采用专门的算法以同时满足两者，或者将一些控制参数交给用户设置自行权衡。不难想象，在一定计算资源下获得的精度一般受限于算法中精度最薄弱的一环。 从开发者的角度，单元测试固然是一种可将整体精度问题分割后方便逐个分析的有力措施，但在程序模块较多、部分环节不便于单元测试的情况下，集成测试亦是一种有效的检测方法。从使用者的角度，集成测试也能更为直接地反映软件的整体质量。 在 DFT 计算中能量与力的计算占据核心地位。通常能量会在自洽场收敛后依照能量泛函的表达式计算获得，而力的计算则会依赖 Hellmann-Feynman 定理，采用与能量计算不同的路径。由于两者存在密切的关联而在实现上又迥然不同，能量与力的一致性测试往往被视作最基本的数值集成测试。 能量的数值微分 记第 i个原子的坐标 R^i_\\alpha(\\alpha=x,y,z)，其沿 \\alpha方向的受力为 F^i_{\\alpha}，根据定义有 F^{i}_\\alpha(\\mathbf{R}^1,\\ldots,\\mathbf{R}^N) = -\\frac{\\partial}{\\partial{}R_{\\alpha}^{i}} E(\\mathbf{R}^1,\\ldots,\\mathbf{R}^N) 在最低阶的差分近似下 \\frac{\\partial}{\\partial{}R_{\\alpha}^{i}} E(\\mathbf{R}^1,\\ldots,\\mathbf{R}^N) \\approx \\frac{E(\\ldots,\\mathbf{R}^i+\\Delta{}R\\hat{\\mathbf{e}}_{\\alpha},\\ldots) - E(\\ldots,\\mathbf{R}^i-\\Delta{}R\\hat{\\mathbf{e}}_{\\alpha},\\ldots)}{2\\Delta{}R} 其中 \\hat{\\mathbf{e}}_{\\alpha}表示 \\alpha方向的单位向量。 数值微分的步长与误差 差分公式本身作为近似会带来离散化误差。对于上述一阶导的最低阶差分，误差随步长关系为 O((\\Delta{}R)^2)。 【更高阶的差分及相应的误差项可参考 https://en.wikipedia.org/wiki/Finite_difference_coefficient】 虽然离散化误差会随着差分步长的减小而降低，但这并不意味着差分步长越小越好。由于数值计算中的数不可避免地只具有有限的精度，当步长小于一定程度后数值微分的整体误差反而会上升。例如，双精度浮点数有大约 16 位有效数字，这意味着即使对正弦函数这样简单、平滑的函数做数值微分，当步长取到 10^{-16}时只会得到纯粹的噪音。不仅如此，由于浮点数减法在“大数减大数得到小数”情况下存在有效位数丢失，理想的步长应远大于 10^{-16}。 以正弦函数为例，若能进行足够精度的计算，有 \\begin{aligned} \\sin(1+10^{-10}) &= {0.841470984}861926737235108938446263127449290359072...\\\\ \\sin(1-10^{-10}) &= {0.841470984}753866276061480994966255906729317751565...\\\\ \\Delta &= {0.000000000}108060461173627943480007220719972607507...\\\\ &=1.08060461173627943480007220719972607507... × 10^{-10} \\end{aligned} 我们得到 \\sin x在 x=1处的数值差分导数 \\begin{aligned} \\frac{\\sin(1+10^{-10})-\\sin(1-10^{-10})}{2 \\times 10^{-10}} &={0.540302305868139717400}0361035998630375...\\\\ \\cos{}x &={0.540302305868139717400}9366074429766037... \\end{aligned} 与理论上的 \\cos x对比，有 20 位左右的有效数字。然而，在双精度浮点数的运算下， \\begin{aligned} \\sin(1+10^{-10}) &= {0.841470984}86192673\\\\ \\sin(1-10^{-10}) &= {0.841470984}75386628\\\\ \\Delta &= ~~~~~~~~~~~~~~~~~~~~1.080604{494774206614}\\times 10^{-10}\\\\ \\frac{\\sin(1+10^{-10})-\\sin(1-10^{-10})}{2 \\times 10^{-10}} &=  {0.540302}{247387103307} \\end{aligned} 10 位有效数字在两个三角函数值的减法中丢失，由浮点运算规则补齐的位数（蓝色数字）只是一些噪音，最后导致数值微分结果只有 6 位有效数字。 在上述三角函数例子中，浮点运算带来的精度误差主导了最终结果中的误差。事实上，如步长取为 10^{-7}则能获得8-9位有效数字，优于步长为 10^{-10}的情况。但若取为 10^{-3}，则离散化误差将变为主导，最终只能得到约6位有效数字。实践中，为得到尽可能小的数值微分误差，步长的选择应当在离散化误差与精度误差间取得一个均衡。例如，https://en.wikipedia.org/wiki/Numerical_differentiation 中介绍了一个进行前向差分【(f(x+\\Delta{}x)-f(x))/\\Delta{}x】时的推荐步长。当采用不同的差分方案时，最优步长的估计方式也不尽相同。 由于 DFT 的能量源于一个自洽场计算，本身受到 SCF 收敛阈值等参数的影响，因此做数值微分时其精度不应直接视作相应的浮点数精度，而需综合多方面考量。 利用 ABACUS 自动工作流进行差分测试 ABACUS（原子算筹）是一款国产的开源密度泛函理论软件。 在软件中，我们可以直接使用 abacustest 进行原子受力（force）的差分测试。 应用地址（需要 Bohrium 账号获得本文档提供的差分工作流，但实际上差分测试程序也可以自己写）：https://app.bohrium.dp.tech/abacustest?request=GET%3A%2Fapplications%2Fabacustest 以下是该自动工作测试流的使用说明。 1. 准备算例 在进行测试之前，需要自己准备需要进行测试的算例，每个算例需要把 ABACUS 计算需要的所有文件（包括赝势和轨道文件）都放在一个文件中。同时需要额外准备一个 info.txt 文件，用于指定需要进行差分测试的原子以及 xyz 方向，每一行是对一个需要测试的原子的设置，格式为 ... >>> ls Fe #假设你的算例你有一个Fe的算例，并且把计算需要的所有文件已经准备在Fe文件夹中 Fe_gga_7au_100Ry_4s2p2d1f.orb Fe_ONCV_PBE-1.2.upf info.txt INPUT KPT STRU >>> cat Fe/info.txt Fe 1 x y Fe 2 y >>> zip -r fe.zip Fe # 对算例文件夹进行压缩 比如上述设置，表明对第一个 Fe 原子的 x 和 y 方向进行测试，以及对第二个 Fe 原子的 y 方向进行测试。 2. 打开应用登入账号 打开应用地址，填入自己的 bohrium 账号密码进行登入 3. 选择 abacustesst 的模式 点击 Form，并在 Select Sub Model 处选择 Reuse model 4. 上传算例 在 Upload files locally 处，上传准备好的算例压缩包。完成后在页面的最后处点击 Next,进入下一页的设置。 5. 选择 force 差分计算模式 在 Model 处选择 005-finite_diff_force 进行 force 的差分测试 6. 计算细节设置 Predft Command 可以对差分的细节进行设置，此处不填会使用默认值：python prepare.py -d 0.0001 -n 2，其中，-d 定义差分点的步长，单位是 bohr，-n 定义每个正负方向改变的构型数量。 Rundft Image 可以对进行 abacus 计算使用的镜像进行设置，此处不填会使用默认的 abacus 的 intel latest 镜像：registry.dp.tech/deepmodeling/abacus-intel:latest。 Rundft Command 可以设置进行 abcus 计算的命令，此处不填会使用默认值：OMP_NUM_THREADS=1 mpirun -np 16 abacus | tee out.log。需要注意的是测试使用的机型是固定为 ali c32_m64_cpu（此机型的实际物理机为 16，所有使用 16 核并行计算），如果自己设置计算命令时需注意并行的核数。 其他选项不需要额填写。点击页面最后的 Next，再点击 Next 进入最后的计算提交页面 7. 提交计算 在最后的 Review 页面的最后部分，点击 I agree to the terms and conditions 后点击 Submit 进行提交。 8. 查看结果 计算完成后会在页面中显示差分值和解析值的作图结果。 图. 对第一个 Fe 原子的 x 方向的差分测试结果。图最上方的 FD-Ana RMSD 是差分值和解析值得均方差。此算例表明 Fe_1_x force 得解析误差~1.28e-03 eV/A。此测试设置的步长为 0.01，差分点个数为 10（predft_command: python prepare.py -d 0.01 -n 10)，任务地址：https://app.bohrium.dp.tech/abacustest?request=GET%3A%2Fapplications%2Fabacustest%2Fjobs%2Fjob-abacustest-v0.3.97-770b66 ABACUS 能量差分与解析力结果不一致的可能原因及解决方案 原因 1：差分的步长选取过小/SCF 收敛不充分 差分与解析解之间的误差来源于两部分，一部分 SCF 基态与真实基态之间的误差；二是差分操作本身导致的数值误差。前者与 SCF 计算的收敛判据（scf_thr）、k 点采样（kspacing）、平面波基组个数（ecutwfc）等有关；而后者与差分的步长选取有关。具体的讨论可以参考本文第一部分的背景介绍。相关的问题也在 Issue#3645 中被较为详细的讨论。 解决方案 1 SCF 参数不变，重新预估一个合理的差分步长。 解决方案 2 调小 SCF 计算的收敛判据（scf_thr）、k 点采样（kspacing）；增大平面波基组个数（ecutwfc），使得 SCF 的计算更为准确。 原因 2：LCAO 计算中的“egg box effect” 当差分不一致发生在 LCAO（采用数值原子局域轨道）的计算之中时，出现例如 Issue#3685 中展示的周期性波动的时候，那么有可能是因为 LCAO 中格点积分部分导致的“egg box effect”（此效应形容由于格点离散化带来的周期性平移对称性的破缺，原子在空间平移，会产生计算出来的能量和受力的规律性震荡，就像装鸡蛋的鸡蛋盒所呈现出来的形状）。 为了确认这一点，你可以设置 basis_type=lcao_in_pw。因为 LCAO_IN_PW 的计算避开了格点积分，可以帮助确认是否是格点积分导致的数值误差。 解决方案 1 使用 basis_type=lcao_in_pw 避开格点积分。 解决方案 2 加密实空间的格点，减小“egg box effect”误差的量级。 参考文献 Issue #3645 https://github.com/deepmodeling/abacus-develop/issues/3645 Issue #3685 https://github.com/deepmodeling/abacus-develop/issues/3685 Force 差分测试 （LCAO）（这个文档只有飞书有权限才可以浏览） Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-04-03 16:28:21 "},"news.html":{"url":"news.html","title":"ABACUS 新闻稿整理","keywords":"","body":"ABACUS 新闻稿整理 整理人：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 标题 链接 日期 公众号 ABACUS还能干这个？薄膜技术显著增强TaAs中的非线性霍尔效应 网页链接 2024/04/22 深度势能 超算&AI应用周报 \\ ABACUS v3.6.0版本上线超算互联网，助力大原子模型建设 网页链接 2024/04/07 超算互联网 ABACUS软件简单介绍 网页链接 2024/04/06 学术之友 ABACUS 带你领略电子轨道的美妙 网页链接 2024/04/03 NBHub ABACUS 3.6发布——DFT+U算法改进、国产硬件适配助力大原子模型建设 网页链接 2024/04/01 深度势能 ABACUS还能干这个？预测二维铁电材料SnTe中的巨大位移电流效应 网页链接 2024/03/28 深度势能 ABACUS还能干这个？借助AI来描述电子动能 网页链接 2024/03/19 深度势能 ABACUS还能干这个？为数百万度高温物质的DP势提供训练数据 网页链接 2024/01/10 深度势能 涓流汇沧海，积篑成丘山——手动@关注 ABACUS 的您，亲启这封年终回顾 网页链接 2023/12/29 深度势能 ABACUS 3.5发布——更稳定高效的Kohn-Sham方程自洽求解 网页链接 2023/12/29 深度势能 社区人物志 \\ 致力于用电子结构计算改变世界，他是认真的 网页链接 2023/11/30 深度势能 DP还能干这个？深度势能结合DeePKS+ABACUS研究溶液中的质子转移 网页链接 2023/11/22 深度势能 ABACUS 3.4发布：代码重构助力开发者加入，性能提升推动大模型生产 网页链接 2023/10/07 深度势能 当Hackathon遇上ABACUS \\ ABACUS@Hackathon作品合集大揭秘 网页链接 2023/09/24 深度势能 ABACUS计算催化实践@Notebook，快速上手催化理论计算 网页链接 2023/09/20 深度势能 DP+ABACUS还能干这个：钙钛矿氧化物通用力场UniPero 网页链接 2023/09/16 深度势能 ABACUS@Notebooks \\ 边学边练，随时随地运行的 DFT 软件使用教程 网页链接 2023/09/07 深度势能 ABACUS新进展：基于数值原子轨道基的meta-GGA密度泛函的实现 网页链接 2023/09/06 深度势能 ABACUS开发者大会 \\ 聚焦国产密度泛函理论开源软件的进步与挑战 网页链接 2023/08/01 深度势能 ABACUS 3.3 发布：自动化测试工作流赋能高效研发，为代码质量保驾护航 网页链接 2023/07/13 深度势能 LibRI：携手 DeepModeling 社区，助力超越常规 DFT 方法的高阶方法计算 网页链接 2023/05/26 深度势能 ABACUS 3.2 发布：支持 Hefei-NAMD 接口，全面提升代码稳定性和易用性 网页链接 2023/04/01 深度势能 ABACUS 还能干这个？探索准一维材料碳纳米管中的无序超均匀性 网页链接 2023/03/07 深度势能 ABACUS 3.1 发布，支持平面波基组下的 GPU 高效计算，发布固液界面计算新功能 网页链接 2023/01/01 深度势能 探索 AI+DFT 最前线，「原子算筹」ABACUS 3.0 重磅发布！ 网页链接 2022/10/01 深度势能 ABACUS 3.0：共建 AI 辅助的新一代电子结构算法平台 网页链接 2022/10/01 深度势能 ABACUS 新进展：用混合随机密度泛函理论方法模拟极端高温物质电子性质 网页链接 2022/09/20 深度势能 以合作促发展：共建国产密度泛函理论开源软件 ABACUS 网页链接 2022/09/14 深度势能 ABACUS 新进展：能带反折叠（band unfolding）方法及相关应用 网页链接 2022/07/22 深度势能 v2.3 来了！ABACUS 小步快跑，重大升级，更快更稳更好用！ 网页链接 2022/07/01 深度势能 ABACUS 新进展：用密度泛函理论模拟千原子以上半导体电极表面反应 网页链接 2022/06/21 深度势能 DeePKS+ABACUS：构建高精度第一性原理计算与机器学习势函数的桥梁 网页链接 2022/06/13 深度势能 ABACUS 2.2 版本介绍 网页链接 2022/04/08 深度势能 涓流汇沧海，积篑成丘山：一位科学家与 ABACUS 的十五年 网页链接 2021/09/28 深度势能 ABACUS ：携手 DeepModeling，做源自中国、开源开放的 DFT 软件 网页链接 2021/09/22 深度势能 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2024-04-22 20:28:47 "},"contribute.html":{"url":"contribute.html","title":"如何贡献 ABACUS 使用教程","keywords":"","body":"如何贡献ABACUS使用教程 一、明确教程格式 第一行，写作者姓名，单位，联系方式（例如Github ID或者邮箱），如果不愿意透露作者信息，也可以不写 第一部分“介绍”：本文档教程要展示的例子、要教授的内容有哪些，相关知识可以给一些参考文献。 第二部分“准备”：介绍输入文件需要哪些，最好是能够提供输入文件的下载（例如网上github仓库），或者直接贴上输入文件 第三部分“流程”：最好通过图文结合的方式，一步步的介绍每一步的命令，能得到什么结果。 第四部分“结语”：对这个功能使用需要注意的地方，或者可以应用的场景都可以给与相关介绍 二、投稿 写好教程，检查无误后，AISI内部直接把稿件发给陈默涵老师（邮箱mohanchen@pku.edu.cn），或者向DeepModeling社区（deepmodeling@deepmodeling.com）投稿，审核通过后会加入到“ABACUS使用教程汇总” Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2023-08-04 10:08:19 "}}