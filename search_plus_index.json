{"./":{"url":"./","title":"ABACUS 使用教程","keywords":"","body":"ABACUS使用教程 一、介绍 ABACUS（Atomic-orbtial Based Ab-initio Computation at UStc，中文名原子算筹）是国产开源密度泛函理论软件，相关介绍 ABACUS 的新闻可在ABACUS 新闻稿整理查看，以下是一些常用地址： ABACUS 在 DeepModeling 社区中的 GitHub 仓库地址为： https://github.com/deepmodeling/abacus-develop ABACUS 的 Gitee 镜像仓库地址为： https://gitee.com/deepmodeling/abacus-develop ABACUS 网站访问： http://abacus.ustc.edu.cn/ 文档（包括安装方法、输入输出参数介绍、功能介绍、算例介绍、开发者须知等）： https://abacus.deepmodeling.com/en/latest/ 本教程系列旨在帮助新手用户入门了解 ABACUS 的使用。秉着开源软件的理念，本文档是由开源社区的老师同学们贡献所成。如果你也想贡献一份文档，我们十分欢迎，请参考如何贡献ABACUS使用教程。 本教程中标有 Logo的部分可以直接在Bohrium Notebook上打开。 在Bohrium Notebook上快速学习，见快速开始 ABACUS｜自洽 能带 态密度 结构优化；在Bohrium平台上运行大任务，见教程。 二、ABACUS基本操作教程 ABACUS的编译介绍 官方编译教程 GCC 编译 ABACUS 教程 Intel oneAPI 编译 ABACUS 教程 知乎上用户提供的ABACUS 3.0安装教程 编译无MPI的ABACUS 曙光DCU平台编译教程：ABACUS 在曙光 DCU 集群上的编译与使用 ABACUS建模介绍 准备晶胞和原子位置等信息的文件STRU：如何转换STRU的格式 准备赝势： 模守恒赝势生成方法简介 数值原子轨道基组生成教程： 数值原子轨道（一）：ABACUS 中的数值原子轨道命名和使用方法 数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道 数值原子轨道（三）：产生高精度数值原子轨道 Kohn-Sham密度泛函理论 电子自洽迭代 带自旋的体系计算：ABACUS磁性材料计算使用教程 +U计算：ABACUS DFT+U使用教程 结构优化：ABACUS 使用教程｜结构优化 分子动力学：ABACUS 分子动力学使用教程 DeePKS方法（缺） 隐式溶剂计算等相关功能（缺） 随机波函数密度泛函理论：ABACUS 随机波函数DFT方法使用教程 无轨道密度泛函理论：ABACUS 无轨道密度泛函理论方法使用教程 采用ABACUS进行表面计算 偶极修正 外加电场 分析结果 能带计算 如何正确画能带，NSCF读电荷密度 用ABACUS-ASE自动产生能带路径 PDOS计算 ABACUS里怎样做DOS和PDOS计算 和其他软件对接 ABACUS+Phonopy 计算声子谱 ABACUS+ShengBTE 计算晶格热导率 ABACUS+Phono3py 计算晶格热导率 ABACUS+DPGEN 使用教程 ABACUS+LibRI 做杂化泛函计算教程 ABACUS+Candela 使用教程 ABACUS+pyatb 能带反折叠计算 ABACUS+USPEX 接口教程 ABACUS+CINEB教程（缺） ABACUS-ASE做NEB计算 （简单算例） 三、使用经验 有VASP使用背景的用户上手ABACUS教程：ABACUS新人使用的一些注意事项 四、开发者文档 ABACUS 开源项目 C++ 代码规范 ABACUS 注释规范：Doxygen 入门 (c++) Introduction to ABACUS: Path to PW calculation - Part 1 Introduction to ABACUS: Path to PW calculation - Part 2 Introduction to ABACUS: Path to PW calculation - Part 3 "},"abacus-gcc.html":{"url":"abacus-gcc.html","title":"GCC 编译 ABACUS 教程","keywords":"","body":"GCC 编译 ABACUS 教程 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/19 一、介绍：关于 ABACUS ABACUS（原子算筹）软件同时支持两种基矢量，一种是平面波（Plane wave，PW） 基组，一种是 LCAO (Linear combination of atomic orbitals)或者称 NAO(Numerical atomic orbitals)基组。因为两种基组运行依赖的软件库不完全相同，所以我们分开介绍。 实际上，LCAO 基组依赖的软件库比 PW 基组更多，因此如果用户只使用 PW 基组，并不需要将所有依赖的数学库全都下载安装好。 下面介绍，两种基组分别都依赖那些数学库： PW 基组依赖以下 3 个 数学库： BLAS：BLAS（Basic Linear Algebra Subprograms）是一组基本的线性代数库，用于高效执行常见的基础线性代数运算，如矩阵乘法和向量操作。 LAPACK：LAPACK（Linear Algebra Package）是一个开源的数值线性代数库，用于解决线性代数问题，包括矩阵分解、方程组求解和特征值计算等。 FFTW3：FFTW3（Fastest Fourier Transform in the West 3）是一个高性能、开源的快速傅里叶变换（FFT）库，用于高效计算各种傅里叶变换和逆变换。 LCAO 基组依赖以下 6 个 软件库： BLAS LAPACK FFTW3 ScaLAPACK：ScaLAPACK（Scalable LAPACK）是一种并行计算库，构建在 LAPACK 之上，用于解决大规模线性代数问题，特别适用于分布式和并行计算环境。 CEREAL：CEREAL 是一个 C++ 序列化库，用于将 C++ 对象转换为可存储或传输的数据格式，以及将其反序列化回对象。 ELPA：ELPA（Eigenvalue SoLvers for Petaflop-Applications）是一个用于高性能计算的开源库，旨在解决大规模高性能计算中的特征值问题，特别是密集矩阵的特征值问题。（用户编译安装 abacus 的时候大多在这里出现问题） 二、检查当前服务器基础环境： 1. 查看当前系统版本： root@bohrium-11852-1041346:~# lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 20.04.5 LTS Release: 20.04 Codename: focal 2. 检查当前 GCC 编译器版本： root@bohrium-11852-1041346:~# g++ --version g++ (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0 Copyright (C) 2019 Free Software Foundation, Inc. 3. 检查当前环境是否有 git root@bohrium-11852-1041346:~# git --version git version 2.25.1 三、安装 仅支持 PW 基组的 ABACUS 对于仅支持 PW 基组的 ABACUS，我们同时支持两种版本的编译：串行版本和并行版本。 编译这两个版本的主要区别在于是否需要安装 MPI library。 1. 编译串行版本 1.1 安装依赖库。 sudo apt update sudo apt install -y libopenblas-openmp-dev sudo apt install -y liblapack-dev sudo apt install -y libfftw3-dev 1.2 从仓库克隆代码到本地，并进入目录。 git clone https://github.com/deepmodeling/abacus-develop.git cd abacus-develop/ 1.3 开始编译并安装 abacus。 cmake -B build -DENABLE_MPI=OFF cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus_pw_serial 可执行文件。 abacus_pw_serial 就是串行版本的支持平面波基组的 ABACUS。 2. 编译并行版本 2.1 安装依赖库。（同串行，如果已经安装，则不用重复操作） sudo apt update sudo apt install -y libopenblas-openmp-dev sudo apt install -y liblapack-dev sudo apt install -y libfftw3-dev 2.2 安装 MPI library。这里选择更为常用的 open MPI。 sudo apt install -y libopenmpi-dev 2.3 从仓库克隆代码到本地，并进入目录。 git clone https://github.com/deepmodeling/abacus-develop.git cd abacus-develop/ 2.4 开始编译并安装 abacus。 cmake -B build -DENABLE_LCAO=OFF cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus_pw 可执行文件。 abacus_pw 就是并行版本的支持平面波基组的 ABACUS。 四、安装 支持两种基组的 ABACUS 对于同时支持两种基组的 ABACUS，仅可以编译并行版本。并无串行版本。 在本文最初就提到支持 LCAO 基组的 ABACUS 所依赖软件库的更多。 1. 安装 PW 基组依赖的软件库。（同上，如果已经安装，则不用重复操作） sudo apt update sudo apt install -y libopenblas-openmp-dev sudo apt install -y liblapack-dev sudo apt install -y libfftw3-dev 2. 安装 MPI library。这里选择更为常用的 open MPI。（同上，如果已经安装，则不用重复操作） sudo apt install -y libopenmpi-dev 3. 安装 LCAO 基组依赖的 ScaLAPACK 和 CEREAL 软件库。 sudo apt install -y libscalapack-mpi-dev sudo apt install -y libcereal-dev 4. 安装 ELPA 软件库。（一般这里容易出问题） 如果你的系统是 Ubuntu 22.04，那么你可以以很简单的方式成功安装 ELPA： sudo apt install -y libelpa-dev 如果你的系统不是 Ubuntu 22.04，很可惜，你需要稍微辛苦一点来安装 ELPA。但别急，这也并不难！ 手动编译安装 ELPA 可以分为以下几步： 5. 开始编译并安装 abacus。 cmake -B build cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus 可执行文件。 abacus 就是完整版的 ABACUS，它同时支持两种基矢量，而且还是并行版本！ "},"abacus-intel.html":{"url":"abacus-intel.html","title":"Intel oneAPI 编译 ABACUS 教程","keywords":"","body":"Intel oneAPI 编译 ABACUS 教程 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/21 一、前言 非特殊情况，linux 系统会默认安装 GCC（GNU Compiler Collection）编译器套件。因此如果你的机器默认没有 Intel® oneAPI Toolkits，那么建议，你可以直接看上一篇文章：GCC 编译 ABACUS 教程 。 如果您的机器恰好有 Intel® oneAPI Toolkits，那么您也可以使用它来编译 ABACUS。 二、关于 Intel® oneAPI Toolkits Intel® oneAPI Toolkits 分为很多个版本的 Toolkit，这里解释下 Intel® oneAPI Base Toolkit 和 Intel® oneAPI HPC Toolkit 的区别。 简单来说：Intel® oneAPI HPC Toolkit 包含 Intel® oneAPI Base Toolkit。 Intel® oneAPI Base Toolkit 中包含：Intel® oneAPI Math Kernel Library（简称为 MKL），这个软件库里面包含了大量常用的数学库，包括 ABACUS 依赖的 BLAS、LAPACK、FFTW3 和 ScaLAPACK 4 个软件库。 因此使用 Intel oneAPI 来编译 ABACUS，可以省去逐个去安装数学库的过程！ Intel® oneAPI HPC Toolkit 相比于 Intel® oneAPI Base Toolkit 多了一些必要的 Intel 的编译器以及 Intel® MPI Library（ABACUS 想要编译并行版本必须的关键库）。 总结一下，使用 Intel oneAPI 编译 ABACUS，必须确保你的机器中包含 Intel® oneAPI HPC Toolkit。 关于 Intel® oneAPI Toolkits 更详细的信息：https://www.intel.com/content/www/us/en/developer/tools/oneapi/toolkits.html#hpc-kit 三、编译 安装 开启 Intel® oneAPI Toolkits： source /opt/intel/oneapi/setvars.sh 1. 安装 仅支持 PW 基组的 ABACUS 对于仅支持 PW 基组的 ABACUS，我们同时支持两种版本的编译：串行版本和并行版本。 ABACUS 的 PW 基组只依赖：BLAS、LAPACK、FFTW3 三个数学库，而这三个数学库都已经被 Intel® oneAPI Base Toolkit 中包含：Intel® oneAPI Math Kernel Library（简称为 MKL）所包含，因此我们不需要再安装其他的软件库！ 1.1 编译串行版本 CXX=icpx cmake -B build -DENABLE_MPI=OFF cd build && make -j`nproc` 注意，这里必须指定CXX=icpx，不然系统会使用默认的 CXX 编译器。同时这里的 CXX 也不要指定 icpc，icpc 是 Intel® C++ Compiler Classic，会带来一些报错。 可以看到在当前目录下，已经编译成功了 abacus_pw_serial 可执行文件。 abacus_pw_serial 就是串行版本的支持平面波基组的 ABACUS。 1.2 编译并行版本 CXX=icpx cmake -B build -DENABLE_LCAO=OFF cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus_pw 可执行文件。 abacus_pw 就是并行版本的支持平面波基组的 ABACUS。 2. 安装 支持两种基组的 ABACUS 对于同时支持两种基组的 ABACUS，仅可以编译并行版本。并无串行版本。 完整版的 ABACUS 需要依赖更多的软件库：BLAS、LAPACK、FFTW3、ScaLAPACK、CEREAL、ELPA共 6 个。 而前四个数学库（BLAS、LAPACK、FFTW3、ScaLAPACK）都已经被 Intel MKL 所包含，因此我们只需再额外安装CEREAL、ELPA即可。 2.1 安装 CEREAL sudo apt install -y libcereal-dev 2.2 安装 ELPA 如果你的系统是 Ubuntu 22.04，那么你可以以很简单的方式成功安装 ELPA。 sudo apt install -y libelpa-dev 如果你的系统不是 Ubuntu 22.04，很可惜，你需要稍微辛苦一点来安装 ELPA。但别急，这也并不难！ 注意；这里手动编译安装 ELPA 的方法与在 GCC 下编译不太一样，因为要保证 ELPA 和 ABACUS 都是基于 Intel oneAPI 来编译的！ 手动编译安装 ELPA 可以分为以下几步： 下载并进入 ELPA 目录： wget https://elpa.mpcdf.mpg.de/software/tarball-archive/Releases/2021.05.002/elpa-2021.05.002.tar.gz tar xzf elpa-2021.05.002.tar.gz cd elpa-2021.05.002 mkdir build && cd build configure CC=mpiicc CXX=mpiicpc FC=mpiifort ../configure --enable-openmp FCFLAGS=\"-qmkl=cluster\" 编译安装 make -j`nproc` make install ln -s /usr/local/include/elpa_openmp-2021.05.002/elpa /usr/local/include/ 注意：ln -s /usr/local/include/elpa_openmp-2021.05.002/elpa /usr/local/include/ 是非常重要的！（很多用户是这里出的问题！） 2.3 编译安装 ABACUS CXX=icpx cmake -B build cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus 可执行文件。 abacus 就是完整版的 ABACUS，它同时支持两种基矢量，而且还是并行版本！ "},"abacus-dcu.html":{"url":"abacus-dcu.html","title":"ABACUS 在曙光 DCU 集群上的编译与使用","keywords":"","body":"ABACUS 在曙光 DCU 集群上的编译与使用 作者：贾志炜，邮箱：jiazhiwei@stu.pku.edu.cn 审核：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 最后更新时间：2023/07/07 一、介绍 本教程旨在介绍 ABACUS 在 曙光 DCU 计算平台 上的编译与使用。 1. DCU DCU (Deep Computing Unit) 是一款面向人工智能、科学计算的高性能全功能 GPGPU (General-Purpose computing on Graphics Processing Units) 加速卡。 中科海光基于 DCU 硬件提供完整的软件工具链，以 DTK(DCU toolkit)为基础软件层为开发者提供运行、编译、调试和性能分析等功能，并提供多种深度优化的计算加速库。DCU 加速卡支持 ROCm/Hip 并行架构。 曙光计算集群采用 CPU 和 DCU 加速卡（Deep Computing Unit）相结合的异构融合计算体系结构。 2. ABACUS 的异构并行计算 INPUT 文件中 device 参数需设置为 gpu。 目前 GPU/DCU 版本的 ABACUS 仅支持 PW 基组的计算，因此 INPUT 文件中 basis_type 参数仅能设置为 pw。 二、准备 1. 曙光计算平台 用户需要在平台上申请异构计算资源： https://ac.sugon.com/doc/1.0.6/30000/general-handbook/platform/source.html 2. E-shell 曙光计算平台采用 E-shell 来对管理节点进行操作。 可使用网页版或 E-Shell Client。 不可直接运行任务，而是使用 Slurm 调度系统。 采用 modules 工具 来管理环境变量与系统依赖项。许多依赖如编译器版本等可以通过 modules 来处理。 3. slurm Slurm 工作调度工具是面向 Linux 和 Unix 及类似内核的免费和开源工作调度程序，可以方便用户进行作业的提交、管理、监测。 sinfo: 查看系统资源。 squeue: 查看当前作业状态。 salloc: 分配节点的作业提交，用 salloc 申请的节点会在当前终端退出时释放掉。用于程序测试以及中小型任务的提交。 sbatch: 批处理模式的作业提交，需要编写 slurm 作业提交脚本。在 E-shell 的默认目录存有 slurm 脚本模板。在下面的流程中也会介绍提交 ABACUS 任务的脚本案例。 srun: 交互式提交作业命令，有屏幕输出，但容易受网络波动影响，断网或关闭窗口会导致作业中断。 三、流程 1. 配置超算环境 module avail # 列出已有环境 module list # 查看当前已加载环境 module load # 加载环境 module unload # 卸载环境 昆山节点 module purge 1) compiler/devtoolset/7.3.1 2) compiler/rocm/dtk-22.10 3) compiler/cmake/3.17.2 4) mpi/hpcx/2.6.0/gcc-7.3.1 乌镇节点 1) compiler/devtoolset/7.3.1 2) compiler/dtk/23.04 3) compiler/cmake/3.23.1 4) mpi/hpcx/gcc-7.3.1 对于使用其他 DCU 节点（合肥、哈尔滨、西安）的用户，如果 module 中没有找到类似的环境，欢迎在 ABACUS 仓库 提出 issue，我们将尽力协助解决。 2. 编译 ABACUS 依赖软件包 目前按照 DCU 版本已验证的编译方法，有三个数学库需要自行编译。 若曙光平台网络连接不畅，请在软件官网选择合适的软件包，再用曙光平台的 E-File 传送至节点。 FFTW: https://fftw.org/pub/fftw/fftw-3.3.10.tar.gz OpenBLAS: https://github.com/xianyi/OpenBLAS/releases/download/v0.3.21/OpenBLAS-0.3.21.tar.gz ScaLAPACK: https://github.com/Reference-ScaLAPACK/scalapack/archive/refs/tags/v2.2.0.tar.gz 2.1 编译 FFTW tar -zxvf fftw-3.3.10.tar.gz mkdir build ./configure --prefix=/work/home/your_username/fftw-3.3.10/build cd ~/fftw-3.3.10/build make make install FFTW 需要编译单精度版本和双精度版本： cd ~/fftw-3.3.10/build ./configure --prefix=/work/home/your_username/fftw-3.3.10/build --enable-float make make install 2.2 编译 OpenBLAS tar -zxvf OpenBLAS-0.3.23.tar.gz cd OpenBLAS-0.3.23 make USE_OPENMP=1 NO_AVX512=1 FC=\"gfortran -fPIC\" CC=\"gcc -fPIC\" -j8 mkdir build make PREFIX=/work/home/your_username/OpenBLAS-0.3.21/build install 2.3 编译 ScaLAPACK cp SLmake.inc.example SLmake.inc 复制包中提供的 SLmake.inc.example 作为基准，并对 SLmake.inc 的内容作出一部分修改: FC = mpif90 -fPIC CC = mpicc -fPIC BLASLIB = LAPACKLIB = -L/work/home/your_username/OpenBLAS-0.3.21/build/lib -lopenblas make 3. 编译 DCU 版本的 ABACUS git clone https://gitee.com/deepmodeling/abacus-develop # main分支 cd abacus-develop mkdir build cd build CMake 配置： 指定编译器为 clang，关闭 OpenMP、LCAO 计算模块，设定三个数学库的位置，设定 USE_ROCM=ON。 CC=clang CXX=clang++ cmake -B build -DUSE_OPENMP=OFF -DENABLE_LCAO=OFF \\ -DFFTW3_DIR=/work/home/your_username/fftw-3.3.10/build/ \\ -DLAPACK_DIR=/work/home/your_username/OpenBLAS-0.3.21/build/lib \\ -DSCALAPACK_DIR=/work/home/your_username/scalapack-2.2.0/ \\ -DUSE_ROCM=ON Make 编译：make 部分建议不要并行编译。 make 4. 提交任务 salloc（中小型任务与交互性程序测试） salloc -p [队列名] -N 1 -n 32 --gres=dcu:4 ... load text ... salloc: Waiting for resource configuration salloc: Nodes node_num are ready for job # 分配计算节点，可用ssh直接连接 ssh node_num ...交互式进行计算任务 sbatch（大型任务与批量提交） 写一个作业提交脚本，可以参考以下结构： #!/bin/bash #SBATCH --job-name=ABACUS_GPU #SBATCH --partition=kshdnormal #SBATCH --nodes=1 #SBATCH --output=output.log #SBATCH --ntasks-per-node=32 #SBATCH --mail-user=username@email #SBATCH --gres=dcu:4 #dcu个数 #SBATCH --time=01:00:00 #SBATCH --error=error.log #以上的SBATCH信息会由slurm识别 abacus=/work/home/your_username/abacus-develop/build/abacus_pw #设置环境 module purge module load compiler/devtoolset/7.3.1 module load compiler/rocm/dtk-22.10 module load compiler/cmake/3.17.2 module load mpi/hpcx/2.11.0/gcc-7.3.1 #运行脚本 cd your_task_path mpirun -np 4 $abacus sbatch abacus_dcu.slurm 作业已提交，可在“作业管理”中查看。 四、结语 DCU 可以提高 ABACUS 计算性能，也充分利用了 ROCm 并行框架，使得 ABACUS 异构计算能应用在更多的平台上。 "},"abacus-upf.html":{"url":"abacus-upf.html","title":"模守恒赝势生成方法简介","keywords":"","body":"模守恒赝势生成方法简介 作者：陈涛，邮箱：chentao@stu.pku.edu.cn；刘千锐，邮箱：terry_liu@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/30 一、介绍 UPF（unified PP format）是一种类似 XML 格式的文件格式，用于存储赝势及其相关参数。该格式由 Quantum ESPRESSO（QE）团队开发，并已成为许多量子计算软件包的标准格式之一。 ABACUS（截至 v3.2.3）的 Kohn-Sham 密度泛函理论计算主要支持 UPF 格式的模守恒赝势，在使用 ABACUS 过程中，一般可以直接使用网上已经生成好的赝势，常见的下载位置： ABACUS 官网 SG15-ONCV，参考文献：Optimization algorithm for the generation of ONCV pseudopotentials Quantum ESPRESSO 官网中的模守恒赝势 pseudo-dojo 官网（psp8 格式，需要转换） PWmat 官网 但是，在实际计算中，可能这些赝势并不符合当前的需求，这时候就需要自己生成模守恒赝势。可以通过其他格式赝势转换或者利用赝势软件生成两种方式来获得赝势。 注：ABACUS 的无轨道密度泛函理论计算（Orbital-Free Density Functional Theory，简称 OFDFT）需要用到一种特殊的局域势（不包含非局域势），一般采用 BLPS 局域赝势文件而非上文提到的 UPF 文件，如果做 OFDFT 计算的，可以阅读介绍 OFDFT 计算的文档，或者登录 Emily A. Carter 教授主页寻找相关的信息。 二、从其他格式赝势转换 1. 使用 QE upflib 中的 upfconv 进行转换 其支持将 UPF v.1 格式、vdb/van 格式（Vanderbilt US pseudopotential）、cpi/fhi 格式（FHI/abinit）转化成 UPF v.2 格式 path_to_QE/upflib/upfconv.x -u *.upf/UPF/vdb/van/cpi/fhi 注：这里的 path_to_QE 代表下载的 Quantum Espresso 的软件包地址。 注：文件夹 upflib 在 QE 5.x 和 6.x 版本名称为 upftools，在QE 7.x 版本为 upflib。 2. psp8 格式转换 psp8 格式是 ONCVPSP 软件生成的一种赝势格式，在 Abinit 官网（pseudo-dojo）中，其使用的就是 psp8 的格式，目前没有直接将 psp8 格式的赝势直接转换成 UPF 格式的脚本，但可以将 psp8 中输入文件部分摘抄下来，用 ONCVPSP 软件重新生成 UPF 格式的赝势（具体生成见下面 ONCVPSP 的讲解）。 可供参考的批量处理脚本：https://github.com/pipidog/ONCVPSP 三、赝势的生成 下面介绍三个可以生成 UPF 模守恒赝势的软件，分别是 ONCVPSP，Opium，和 ld1.x 1 ONCVPSP 1.1 介绍 ONCVPSP（Optimized Norm-Conservinng Vanderbilt PSeudoPotential）是由 D.R. Hamann 等人提出的优化版模守恒赝势，其有更高的精度与效率。ONCVPSP 依赖 Libxc，支持多种交换关联泛函。 参考文献：Optimized norm-conserving Vanderbilt pseudopotentials。 1.2 安装 1.2.1 安装 Libxc Libxc 网址：Libxc - a library of exchange-correlation functionals for density-functional theory 推荐下载 libxc-4.3.4 然后执行如下命令： cd libxc-4.3.4 ./configure --prefix='PATH/TO/LIBXC' CC=icc FC=ifort make make install 命令执行完毕后即可在 PATH/TO/LIBXC 目录下看到 bin,include 和 lib 三个目录，代表安装成功 1.2.2 安装 oncvpsp 推荐下载 oncvpsp-4.0.1 然后执行 cd oncvpsp-4.0.1，进入文件夹 这时需要修改 make.inc 文件 修改 F77 = ifort, F90 = ifort, CC = icc FFLAGS 删去 -ffast-math LIBS 改为 -qmkl=\"sequential\" LIBS+ 和 FFLAGS 中的地址改为自己的 PATH/TO/LIBXC 具体如下： # System-dependent makefile options for ONCVPSP # This must be carefully edited before executing \"make\" in src # # Copyright （c） 1989-2019 by D. R. Hamann, Mat-Sim Research LLC and Rutgers # University ##### Edit the following lines to correspond to your compilers #### F77 = ifort F90 = ifort CC = icc FCCPP = cpp FLINKER = $（F90） #FCCPPFLAGS = -ansi -DLIBXC_VERSION=301 #Use this for versions 400 ##### Edit the following optimization flags for your system #### FFLAGS = -O3 -funroll-loops CFLAGS = -O3 ##### Edit the following LAPACK and BLAS library paths for your system #### LIBS = -qmkl=\"sequential\" ##### Edit the following for to use libxc if available ##### OBJS_LIBXC = exc_libxc_stub.o # oncvpsp is compatible with libxc # To build oncvpsp with libxc, uncomment the e following lines and edit # the paths to point to your libxc library and include directories # make clean in src before rebuilding after changing this LIBS += -L/PATH/TO/LIBXC/lib -lxcf90 -lxc FFLAGS += -I/PATH/TO/LIBXC/include #LIBS += -L/home/drh/abinit/fallbacks/exports/lib -lxcf90 -lxc #FFLAGS += -I/home/drh/abinit/fallbacks/exports/include OBJS_LIBXC = functionals.o exc_libxc.o 然后执行如下命令： make # 如果make -j报错，可以忽略再make，即可编译成功 安装测试完成后，即可在 src 目录下看到 oncvpsp.x 可以在 ~/.bashrc 中增加如下命令将 oncvpsp.x 加入环境变量，方便直接调用： export PATH=$PATH:/PATH/TO/ONCVPSP/src 1.3 输入文件 输入文件的准备可以参考 PATH_TO_ONCVPSP/doc/32_Ge_annotated.dat，或者参考已知 ONCV 的赝势里面的 部分来写。 这里以铝（Al）为例，输入文件 Al.dat: # ATOM AND REFERENCE CONFIGURATION # atsym, z, nc, nv, iexc psfile Al 13 1 4 4 upf # # n, l, f （nc+nv lines） 1 0 2 2 0 2 2 1 6 3 0 2 3 1 1 # # PSEUDOPOTENTIAL AND OPTIMIZATION # lmax 1 # # l, rc, ep, ncon, nbas, qcut （lmax+1 lines, l's must be in order） 0 1.29163 0 5 8 10.3003 1 2.40653 0 5 8 7.02214 # # LOCAL POTENTIAL # lloc, lpopt, rc（5）, dvloc0 4 5 0.932267 0 # # VANDERBILT-KLEINMAN-BYLANDER PROJECTORs # l, nproj, debl （lmax+1 lines, l's in order） 0 2 0 1 2 0 # # MODEL CORE CHARGE # icmod, fcfact 0 0 # # LOG DERIVATIVE ANALYSIS # epsh1, epsh2, depsh -5.0 3.0 0.02 # # OUTPUT GRID # rlmax, drl 6.0 0.01 # # TEST CONFIGURATIONS # ncnf 0 # nvcnf # n l f 一些可以调整的参数如下： nc：c = core，芯电子层数 nv：v = valence，价电子层数，调整 nc 和 nv 可以改变赝势的价电子数 iexc：生成赝势所用的交换关联泛函，详情可参考 ONCVPSP-4.0.1 目录下 doc 内的 pwscf_exc.txt 文件，常用的如下 iexc==3 .or. iexc==-001009, 'functional=\"PZ\"' iexc==4 .or. iexc==-101130, 'functional=\"PBE\"' psfile：赝势格式，有 upf 和 psp8 两种。ABACUS 支持 upf 的格式 rc: rc 中较小的为赝势的截断半径。在温度较高或密度较大的温稠密体系，通常需要调整赝势的截断半径，推荐小于 0.7 倍维格纳半径，单位为 Bohr；每个 l 对应一个 rc，其中最小的为赝势的截断半径 rc（5）：rc 都要大于等于 rc（5）。例如 Al 的 l=0 的 rc 为 1.29163 Bohr，l=1 的 rc 为 2.40653 Bohr，rc（5） 为 0.932267 Bohr，因此该赝势的截断半径为 1.29163 Bohr。 qcut：通过调整（+-0.1），直到推荐 ECUT 达到最小 dvloc0：通过调整（+-0.5），直到消除赝势的 GHOST 态（可参考文献 Phys. Rev. B 41, 12264 (1990)） 1.4 生成赝势 执行命令： oncvpsp.x Al.out sed -n '//,//p' Al.out > Al.UPF 生成完赝势需要查看 Al.out 文件，确定没有 GHOST 态（可参考文献 Phys. Rev. B 41, 12264 (1990)）： Testing for highly-localized positive-energy ghosts l \\/rc E Basis Diag. E Cutoff 1 0.974041 120.256772 338.98 WARNING - GHOST（+） 如上，出现 WARNING - GHOST 说明有 GHOST，需要调整 dvloc0 （+-0.5）直到消除 GHOST 态 sed 命令是为了从 Al.out 文件中截取赝势文件到 Al.UPF 中 如果同时要画出类似 Phys. Rev. B 88, 085117 (2013) 的图，需要准备输入文件 Al.dat 并执行命令： sh PATH_TO_ONCVPSP/scripts/run.sh Al 可以画出如下的图： 1.5 优化赝势 依次调节不同 l 对应的 qcut（+-0.1），检查对应 ECUT（l） 变化情况，直到 ECUT（l） 达到最小 参考的脚本： !/bin/bash qcut=17 dq=0.1 #遍历l=0的qcut从17到25，间隔为0.1，输出其对应的ECUT while [ `echo \"$qcut test.dat qcut$qcut.out grep -A 5 \"Energy error\" qcut$qcut.out > _tmp.txt E1=`sed -n \"6p\" _tmp.txt | awk '{print $3}'` E2=`sed -n \"13p\" _tmp.txt | awk '{print $3}'` E3=`sed -n \"20p\" _tmp.txt | awk '{print $3}'` E4=`sed -n \"27p\" _tmp.txt | awk '{print $3}'` # echo $qcut $E1 $E2 $E3 $E4 if [ `echo \"$E1>$E2\" | bc` == '1' ] ;then Emax1=$E1 else Emax1=$E2 fi if [ `echo \"$E3>$E4\" | bc` == '1' ];then Emax2=$E3 else Emax2=$E4 fi echo $qcut $Emax1 $Emax2 qcut=`echo \"$qcut+$dq\" | bc` done 不同的 l 都会有对应的能量截断值 ECUT(l)。一般 rc(l) 越小，对应的 ECUT(l) 越大，赝势也就越精确。由于 DFT 计算中的截断能 ECUT 是由赝势中较大的那个 ECUT(l) 决定，如果不同 l 的 ECUT(l) 相差很大，可以适当减小较小的 ECUT（l） 对应 l 的截断半径 rc，使得不同 l 对应的 ECUT(l) 更接近，这样并不会增加赝势计算的 ECUT，却可以提升精度。 这样调完之后如果有 GHOST 态，需要调整 dvloc0 （+-0.5）直到消除 GHOST 态，这个赝势才可使用 2. Opium Opium 软件包可以生成 RRKJ、TM 或 Kerker 径向波函数的赝势，官网有 LDA、GGA 赝势库（但是某些输入文件已经不匹配最新的 4.1 版本，需要稍作修改） 下载 Opium 之后利用 configure 安装： ./configure make 输入文件可以参考官网 LDA、GGA 赝势库，也可以参考 PATH_TO_OPIUM/tests，这里以铝（Al）为例，输入文件 al.param: [Atom] Al 6 100 2.00 -13.0 # reference configuration 200 2.00 -1.4 # reference configuration 210 6.00 -0.4 # reference configuration 300 2.00 -0.1 # reference configuration 310 0.95 -13.0 # reference configuration 320 -1.0 -0.0 # 这条能带是非束缚态，需要将占据数调成负数，官网给错了 [Pseudo] 3 1.85 1.85 1.97 opt [Optinfo] 7.07 10 # rc[a.u.] qc[sqrt（Ry）] Nb 7.07 10 7.07 10 [Configs] 3 # number of valence configurations # 300 2.00 -13.0 # nlm occ eigen（- means auto-generate） 310 1.00 -6.0 320 0.00 -6.0 # 300 1.00 -13.0 310 2.00 -6.0 320 0.00 -6.0 # 300 2.00 -13.0 310 0.00 -6.0 320 0.00 -6.0 [XC] gga [Relativity] srl 这里的参数可以参考官网手册 之后执行 opium al log all #输出在log文件里，依次执行全电子计算、计算赝势、计算非局域势、可移植性测试 opium al log upf #生成al.upf的输出文件 upfconv.x -u al.upf #利用QE的upflib将UPFv.1转化成UPFv.2格式 3. ld1.x QE 的 atomic 模块中的 ld1.x 支持生成赝势。其不仅可以生成模守恒赝势、还支持超软赝势、PAW 方法，支持全相对论、标量（非）相对论赝势（rel, non-rel/sca-rel），其径向波函数支持 TM（更稳定）与 RRKJ 两种方法，支持交换关联近似 7 类 LDA（ pz）,GGA（pbe, pbesol, revpbe, bp, wc, pw91。 下载好 QE 软件后，可以直接安装： ./configure make ld1 3.1 pslibrary 赝势库 推荐 ld1.x 生成其自带的 pslibrary 赝势库，下载好 pslibrary.1.0.0.tar.gz，解压，进入文件夹，修改 QE_path 文件，指定 QE 的路径。然后打开 make_ps 文件，解锁相应赝势： # These two files generate PAW and US PPs for all elements. These are # high accuracy - high kinetic energy cut-off PPs. # . ../paw_ps_high.job #默认打开的 . ../us_ps_high.job # # These two files generate additional PAW and US PPs for some elements. # These are less accurate PP than the previous one but require # lower kinetic energy cut-off or have less projectors or less semicore # states. # . ../paw_ps_low.job . ../us_ps_low.job # Uncomment the following line to generate the old pslibrary 0.3.1 PPs. # 打开下面的注释，可以解锁其余赝势 # #. ../paw_ps_collection.job #可以打开注释 #. ../us_ps_collection.job #可以打开注释 # Uncomment the following line to generate the NC-PPs. Be very careful # these PPs are completely untested. # 虽然可以生成，但其也提示该赝势的准确性并不能保证 # #. ../nc_ps_collection.job #可以打开注释 下面运行 ./make_all_ps 就能看到在一个个生成赝势库里的赝势： Making Ac.pz-spfn-kjpaw_psl.1.0.0.in ... Done Making Ac.pz-spfn-rrkjus_psl.1.0.0.in ... Done Making Ag.pz-n-kjpaw_psl.1.0.0.in ... Done Making Ag.pz-n-rrkjus_psl.1.0.0.in ... Done Making Ag.pz-spn-kjpaw_psl.1.0.0.in ... Done Making Ag.pz-spn-rrkjus_psl.1.0.0.in ... Done Making Al.pz-n-kjpaw_psl.1.0.0.in ... Done Making Al.pz-n-rrkjus_psl.1.0.0.in ... Done Making Al.pz-nl-kjpaw_psl.1.0.0.in ... Done Making Al.pz-nl-rrkjus_psl.1.0.0.in ... Done 如果不想生成所有的元素的赝势，则可以修改 make_ps 的 element，例如： element='C Si Ge' 3.2 生成自己的赝势 参数的详细解释见 PATH_TO_QE/atomic/Doc/INPUT_LD1.html 或线上的文档（不是最新的，建议前者），输入文件可以参考 pslibrary 赝势库的例子。 这里就简单给个 Al（铝）的例子，准备输入文件 al.in： &input title='Al', zed=13.0, rel=1, config='[Ne] 3s2 3p1 3d-2.0 4f-2.0', iswitch=3, dft='PBE' / &inputp pseudotype=2, file_pseudopw='Al.pbe-n-nc.UPF', #输入赝势 lloc=2, nlcc=.true., tm=.true. / 3 3S 1 0 2.00 0.00 2.60 2.60 0.0 3P 2 1 1.00 0.00 2.60 2.60 0.0 3D 3 2 0.00 0.10 2.60 2.60 0.0 运行 ld1.x 即可生成 Al.pbe-n-nc.UPF 模守恒赝势。 四、结尾 ABACUS 使用的是模守恒赝势，基于模守恒赝势还可以产生数值原子轨道，进行基于数值原子轨道的高效率密度泛函理论计算。有些情况下，网上提供的赝势不能满足需求，这个时候赝势的生成需要对赝势理论有比较深入的了解之后，才能调整好相关参数，生成质量较好的赝势。此外，生成之后，应该经过较为充分的测试，才能保证赝势的可移植性和正确性。如果大家有任何问题，欢迎发 email 至文档开头的邮箱。 "},"abacus-nac1.html":{"url":"abacus-nac1.html","title":"数值原子轨道（一）：ABACUS 中的数值原子轨道命名和使用方法","keywords":"","body":"数值原子轨道（一）：ABACUS 中的数值原子轨道命名和使用方法 作者：梁馨元，邮箱：2201111875@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/07/18 一、数值原子轨道的背景知识 1. 数值原子轨道 对电子结构的求解可以在不同的表象下进行，电子的波函数以及势函数也可以在不同基矢量下表示，常用的有平面波和局域轨道等。LCAO（Linear Combination of Atomic Orbitals）方法就是通过局域的原子轨道来求解量子力学问题。其中局域轨道的选取方式有多种，例如高斯轨道（Gaussian type Orbitals，GTOs 或 Gaussians）、数值原子轨道（Numerical Atomic Orbitals）、万尼尔函数（Wannier Functions）等。 2. 数值原子轨道作为基矢量的优点 数值原子轨道作为基矢量有几个优点：第一，基矢量个数相比于一些常用的基矢量（例如平面波和实空间网格）大幅度降低；第二，数值原子轨道是局域的，空间上可以严格截断，采用数值原子轨道来构建体系的哈密顿量的效率可以达到线性标度的时间复杂度。 3. 构造数值原子轨道基组的几种方案 构造精度高、可系统提升数量、可移植性好的原子轨道基组颇有挑战，因此也有多种方案被提出。例如，Junquera 等人提出在一维薛定谔方程中加入不同形式的约束势场，从而求解出具有严格截断的数值原子轨道[1]。Ozaki 在 OpenMX 软件中采用变分的方法来优化局域轨道的形状，从而得出一组最优的数值原子轨道[2]。Volker 等人提出在一个大的局域轨道基组中挑选最合适的局域轨道组成不同等级的基组轨道，该方案用于全电子密度泛函理论软件 FHI-aims 中[3]。Chen 等人提出利用前人提出的溢出函数（Spillage function）[4-5]来构造可系统提高数量的数值原子轨道，其中每个轨道都由一组球贝塞尔函数作为基矢量展开，该轨道被用在 ABACUS（原子算筹）软件中[6]。 二、数值原子轨道的命名方法 1. 数值原子轨道的组成 数值原子轨道（Numerical Atomic Orbitals，简称 NAO）是目前在 ABACUS 程序中支持的一种基矢量。从数学形式上来看，数值原子轨道可以分解为径向函数 flζ 和球谐函数 Ylm 的乘积。 \\phi_{l m \\zeta}(\\mathbf{r})=f_{l \\zeta}(r) Y_{l m}(\\hat{r}), 其中 l 是角量子数，m 是磁量子数，ζ 代表了每个角量子数上对应的多个径向轨道，实际计算中通常采用多于 1 个轨道来增加基矢量的完备性。 2. 数值原子轨道的命名方法 数值原子轨道有一套常用的命名方案用来表示选取的基组大小，早期该命名方案在 SIESTA 软件中被采用[7][8][9][10]，后来在 OpenMX、FHI-aims 和 ABACUS 中也采取这套命名方案。具体来说是，对于每个被电子占据的角量子数 l，若采用 1 条径向轨道，则称该基组为 Single-ζ 轨道，简称 SZ 轨道基组。若采用 2 条径向轨道，则称该基组为 Double-ζ 轨道，简称 DZ 轨道基组。 目前，在许多赝势结合数值原子轨道的程序里，通常会在 DZ 轨道的基础上引入 1 条极化（polar）的径向轨道，即角量子数更高的轨道，来组成 DZP（Double-ζ valence orbitals plus SZ polarization） 轨道基组。此外，还有基组数量更大的 TZDP（Triple-ζ valence orbitals plus DZ polarization） 轨道等。 3. 数值原子轨道基组的个数 数值原子轨道基组的具体个数除了取决于轨道类别（比如 SZ、DZP、TZDP）外，也取决于元素种类、所选取的赝势。 轨道类别：比如对于 O 元素的赝势而言，一般将两个 1s 电子作为核内电子，在构造赝势的时候只考虑它的外层 6 个价电子部分 2s、2p 轨道，则该 O 赝势下的电子的极化轨道为 d 轨道。故它的 SZ（Single-ζ）轨道包含 1 组 s 轨道、1 组 p 轨道，共 1*1+1*3=4 个轨道；DZP 轨道包含 2 组 s 轨道、2 组 p 轨道、1 组 d 轨道，共包含 2*1+2*3+1*5=13 个轨道；TZDP 轨道包含 3 组 s 轨道、3 组 p 轨道、2 组 d 轨道，共包含 3*1+3*3+2*5=22 个轨道。 元素种类：比如同为 DZP 轨道，对于 H 元素（1 个价电子）即为 2 组 s 轨道、1 组 p 轨道（p 轨道也是 H 的极化轨道），共包含 2*1+1*3=5 个轨道。对于 O 元素即为 2 组 s 轨道、2 组 p 轨道、1 组 d 轨道，共包含 2*1+2*3+1*5=13 个轨道。 赝势：比如对于 Fe 元素而言，同为 DZP 轨道。若选取的赝势为，[Ne]3s^23p^64s^23d^6，即[Ne]=1s^22s^22p^6部分为芯电子，3s^23p^64s^23d^6部分为 16 个价电子，则 DZP 轨道包含 2*2 套 s 轨道（3s 和 4s）、2 套 p 轨道（3p）、2 套 d 轨道（3d）、1 套 f 轨道（极化轨道），即每个原子的 DZP 数值原子轨道个数为 2*2*1+2*3+2*5+1*7=27 个轨道。若选取的赝势为[Ar]4s^23d^6，则 DZP 轨道包含 2 套 s 轨道、2 套 d 轨道、1 套 p 轨道，共 2*1+2*5+1*3=15 个轨道。 三、ABACUS 中数值原子轨道的使用方法 1. ABACUS 中的数值原子轨道文件 ABACUS 提供了已经生成好的数值原子轨道库打包文件供下载（官网下载链接），对于绝大多数计算任务，这些数值原子轨道是经过精度和可靠性验证，可以直接使用的。这些轨道文件的开头提供了关于该轨道的重要信息。以 O_gga_7au_100Ry_2s2p1d.orb 轨道文件为例，首先文件名包含的信息有：氧元素（o），GGA 泛函（gga），数值原子轨道截断半径（7au，即 7 Bohr），推荐能量截断值（100 Ry），数值原子轨道个数（2s2p1d，2 个 s 的径向轨道，2 个 p 的径向轨道，1 个 d 的径向轨道）。值得注意的三个点是： ABACUS 里用到的模守恒赝势和轨道是需要匹配的。因为不同的赝势可能有不同的价电子，而数值原子轨道是用来描述这些价电子的，如果赝势的价电子多，则相应的默认数值原子轨道基组数量也会增多。 推荐用户直接使用轨道文件包含的能量截断值做计算。ABACUS 里的数值原子轨道在生成时，是尽量的去匹配平面波输出的波函数，从而优化得到的。而平面波计算是有一个能量截断值的，因此为了尽可能的保证 LCAO 的精度，我们建议直接使用推荐的能量截断值，而不需要真正做计算的时候做体系能量随着能量截断值变化的收敛性测试。当你在 LCAO 计算时改变能量截断值时候，其实只是改变了平面波的个数，这些平面波是用来做一些数值计算的，本质上并没有改变基矢量的个数，而基矢量的个数增加是靠改变基组大小，例如 DZP 到 TZDP 来实现的。 特殊情况可以自己生成数值原子轨道。如果用户有自己特殊的赝势，或者对目前提供的原子轨道的参数或者个数感觉不满意，例如对于导带的描述能力较差，也可以自己生成数值原子轨道，具体生成的方法可以参考这个系列文档的第二和第三篇。 打开以上提到的氧的数值原子轨道文件，文件的开头如下： --------------------------------------------------------------------------- Element O Energy Cutoff(Ry) 100 Radius Cutoff(a.u.) 7 Lmax 2 Number of Sorbital--> 2 Number of Porbital--> 2 Number of Dorbital--> 1 --------------------------------------------------------------------------- SUMMARY END 这里包括元素种类（Element），生成轨道时指定的截断能量值（Energy Cutoff）、截断半径（Radius Cutoff），最大角量子数（Lmax）及各角量子数轨道的个数（Number of * orbital，*为 S、P、D 等轨道角动量）。根据这些信息可以知道该轨道的类别，比如该举例文件即包含 O 的 DZP 轨道。 上述 ABACUS 提供的数值原子轨道文件中，在取名中即包含文件开头的重要信息，包括各角量子数的轨道个数。由这些轨道的文件名即可判断轨道类型。 轨道文件中包含的后续内容为不同类型、不同角量子数（L）的多个径向数值原子轨道（即不同 N）的具体数据，目前轨道是存在均匀格点上的，之后有可能也会支持非均匀格点。 2. 如何选择数值原子轨道文件 用户需要根据精度要求，选择数值原子轨道合适的截断能量值、截断半径及轨道类型。截断能量值、截断半径越大，轨道类型提升（SZ、DZP、TZDP），精度越高，结果更接近平面波。注意对于不同元素，要达到同样的精度，以上数值设置并不一定相同。 3. 如何修改数值原子轨道文件的设置，获得低精度轨道类型文件 在 ABACUS 中生成数值原子轨道文件时，可以设置同时生成多种精度的轨道文件，即设置 SIAB_INPUT 文件中的参数 Save Orbitals，详见篇目（三）。 如果已有一份数值原子轨道文件，但希望直接用此文件进行低精度计算，比如希望使用 DZP 轨道文件进行 SZ 计算。可以修改文件开头的信息实现，具体是 Lmax 及各角量子数轨道个数，将这些参数调整到低精度计算对应的数值。文件的后续内容不需要做更改。 比如对于 O 元素而言，DZP 轨道文件参数如 3.1 所示，若要进行 SZ 基矢量的计算，则将 Lmax 设置为 1，Number of Sorbital/Porbital/Dorbital=1/1/0 即可。 四、参考文献 [1] J. Junquera, Ó. Paz, D. Sánchez-Portal, and E. Artacho, Numerical Atomic Orbitals for Linear-Scaling Calculations, Phys. Rev. B, 64, 235111 (2001). [2] T. Ozaki, Variationally Optimized Atomic Orbitals for Large-Scale Electronic Structures, Phys. Rev. B, 67, 155108 (2003). [3] V. Blum, R. Gehrke, F. Hanke, P. Havu, V. Havu, X. Ren, K. Reuter, and M. Scheffler, Ab Initio Molecular Simulations with Numeric Atom-Centered Orbitals, Comput. Phys. Commun., 180, 2175 (2009). [4] M. Chen, G.-C. Guo, and L. He, Systematically Improvable Optimized Atomic Basis Sets for Ab Initio Calculations, J. Phys.: Condens. Matter, 22, 445501 (2010). [5] M. Chen, G.-C. Guo, and L. He, Electronic Structure Interpolation via Atomic Orbitals, J. Phys.: Condens. Matter, 23, 325501 (2011). [6] Liu Xiao-Hui et al., Introduction to first-principles simulation package ABACUS based on systematically improvable atomic orbitals, Acta Phys. Sin., 64, 187104 (2015). [7] Sánchez‐Portal D, Ordejon P, Artacho E, et al. Density‐functional method for very large systems with LCAO basis sets, J. International Journal of Quantum Chemistry, 65, 453-461 (1997). [8] Artacho E, Sánchez‐Portal D, Ordejón P, et al. Linear‐scaling ab‐initio calculations for large and complex systems, J. Physica Status Solidi (b), 215, 809-817 (1999). [9] Junquera J, Paz Ó, Sánchez-Portal D, et al. Numerical atomic orbitals for linear-scaling calculations, J. Physical Review B, 64, 235111 (2001). [10] Soler J M, Artacho E, Gale J D, et al. The SIESTA method for ab initio order-N materials simulation, J. Phys.: Condens. Matter, 14, 2475 (2002). "},"abacus-nac2.html":{"url":"abacus-nac2.html","title":"数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道","keywords":"","body":"数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/15 在Bohrium Notebook上快速学习： 一、ABACUS 中的数值原子轨道背景知识 1. 数值原子轨道 ABACUS 中的三维数值原子轨道[1]：可以分解为径向部分与角向球谐函数的乘积，即 \\phi_\\mu(\\mathbf{r})=f_{\\mu, l}(\\mathbf{r}) Y_{l m}(\\hat{r}), 其中 \\mu=\\{\\alpha,i,\\xi,l,m\\}，\\alpha是原子种类的指标，i是每个原子种类对应的原子个数的指标，\\xi是角动量l对应的径向函数的个数，m是磁量子数。 径向部分函数：第 \\mu个轨道的径向部分函数可以写为球贝塞尔函数的线性组合(可参考文献[1]) f_{\\mu l}(\\mathbf{r})= \\begin{cases}\\sum_q c_{\\mu q} j_l(q r), & r 其中 j_l(q r)是波矢为q的球贝塞尔函数，r_c是径向部分的截断半径，满足关系j_l(q r_c)=0。q的个数由能量截断值决定（以下会介绍）。在实际计算里，通过用户指定每种元素的数值原子轨道截断半径和能量截断值来确定需要用到多少个球贝塞尔函数。组合系数 c_{\\mu q}是可优化的量，决定了数值原子轨道的形状。 2. 参考体系 参考系统：在ABACUS中构造某个元素对应的数值原子轨道的最普遍方式是为每个元素选取一组参考体系做平面波计算（可以是单k点也可以是多k点），得到这些参考体系的电子波函数，然后通过最小化自定义的一个溢出函数（下面会介绍）来优化c_{\\mu q}系数。换句话说，我们需要选定一组参考系统，生成数值原子轨道基组，并期望它们有良好的迁移性，以便可以在更一般的情况下使用。 Dimer（二聚体）：我们发现二聚体是较为合适的参考系统。具体来说，推荐选择的是若干个不同键长的二聚体（dimer），有时也可选择三聚体（trimer）或四聚体。对同一个元素，我们通常选择几个键长不同的二聚体（例如5-6个），这些键长覆盖二聚体稳定键长附近能量区间，通常可以取与最稳定能量差别为1-2个eV的能量曲线上的点。 周期性体系：数值原子轨道还有一些特殊用途，例如能带插值。面对这种场景，可以选择一系列带多个k点的周期性体系，此时参考态中的每个原子构型就对应了不同k点指标和不同能带指标的波函数，这些波函数会被用于最小化溢出函数来生成数值原子轨道，可以参考文献[2]。 3. 溢出函数 溢出函数（英文为spillage）：由给定参考体系的多个电子波函数与生成的数值原子轨道之间的差别来定义。换个角度理解，溢出函数的大小反映的是由一组“精确”波函数所张成的希尔伯特空间与局域轨道所张成的空间的差别。溢出函数定义如下： \\mathcal{S}=\\frac{1}{N_n} \\sum_{n=1}^{N_n}\\left\\langle\\Psi_n|1-\\hat{P}| \\Psi_n\\right\\rangle, 其中\\Psi_n表示平面波基组下的本征态，N_n是选定的参考电子态的个数，\\hat{P}是由所有原子轨道张成的投影子 \\hat{P}=\\sum_{\\mu v}\\left|\\phi_\\mu\\right\\rangle S_{\\mu v}^{-1}\\left\\langle\\phi_v\\right| \\text, 其中S_{\\mu v}=\\left\\langle\\phi_\\mu \\mid \\phi_v\\right\\rangle是局域轨道\\phi_\\mu与\\phi_v之间的重叠矩阵，投影子用到了重叠矩阵的逆。 轨道正交：事实上，如果我们有了给定的数值原子轨道，我们可以在此基础上再次定义新的溢出函数来得到一组新的数值原子轨道，这也是为什么该算法可以系统性的增加数值原子轨道的原因。定义的方式也比较直接，可以将|\\Psi_n\\rangle和已有原子轨道形成的投影子\\hat{P}正交，公式为 |\\Psi_n^{new}\\rangle=（1-\\hat{P}）|\\Psi_n\\rangle, 这个公式里，左边的波函数经过正交已经不包含原子轨道的成分，这样可以再次作为新的参考体系波函数生成新的数值原子轨道，以上算法已经被实现在SIAB这个程序里。 最小化溢出函数：优化原子轨道时，最终溢出函数值定义为选定的几个二聚体的平均溢出函数值。溢出函数可以用来评估获得的原子轨道基组的质量，溢出函数越小，则原子轨道所张成的空间越接近于参考态波函数。在ABACUS中，通过最小化溢出函数的方式来优化c_{\\mu q}，该系数决定了原子轨道的径向函数的形状。这种方法的好处在于 轨道形状可调：可以由球贝塞尔函数基组的线性组合自动生成，而不需要任何先决条件，因此原则上可获得完全优化的原子轨道。 基组数量可调：可以用统一的方式系统的增加轨道数量，包括增加径向轨道的数量（multi-ζ）和增加更高角动量的轨道（极化轨道）两种方式。为此，我们可以首先生成具有给定角动量的轨道，然后更高级的轨道可以使用相同的程序生成，但是此时只需最小化剩余的希尔伯特空间中的溢出函数，该空间与所有先前生成的原子轨道所张成的空间正交。 参考系统可调：通过选择参考系统及对应能级，可以提高原子轨道基组在不同环境的可迁移性。例如，对于涉及到激发态能级的计算，往往需要在生成数值原子轨道的时候，考虑这组轨道对于非占据态能级的拟合能力，这个时候可以在生成参考体系的时候加入一定数量的非占据能级。 4. 模拟退火算法SA（Simulated Annealing） 我们首先介绍模拟退火法Simulated Annealing（SA）来最小化溢出函数[1]，从而优化球贝塞尔函数的系数c_{\\mu q}。在模拟退火算法中我们用的是Metropolis的算法，需要设置一个初始温度，并且指定温度下降的方式。代码部分我们之后会介绍，这里先简要介绍一下算法。 初始系数：如果没有特别指定，一开始的系数c_{\\mu q}是随机产生的， 每一步SA会更新其中一个系数，当溢出函数被改变的数值在允许接收的范围内时，参数c_{\\mu q}会被更新。 优化过程：当要优化的所有轨道的所有参数c_{\\mu q}都被更新过一次之后，我们称为一步优化。 我们发现大约在每个温度行走500 ~ 1000步就已经足够产生好的原子轨道。最开始的温度我们一般取为1.0e-5，事实上我们发现即便初始温度取得更小，最后的结果也是不错的。 在每一步优化之后，我们将温度乘上一个比率，来达到降温的目的从而得到新的温度，这个参数我们一般取为0.5~0.8，最后的温度一般降到1.0e-9~1.0e-12。接收的概率可以控制在0.2~0.4范围内。 能量截断值：这里的能量截断值实际上是能量截断值，我们知道每个平面波 e^{i\\mathbf{q}\\cdot\\mathbf{r}}都对应一个二阶求导后的动能q^2/2。同样的，每个球贝塞尔函数 j_l(q r)也有一个对应的动能是 q^2/2。在平面波计算里我们通过能量截断值来控制平面波的数量，从而控制计算精度。在生成数值原子轨道的时候，我们也通过能量截断值来控制球贝塞尔函数的个数，从而控制生成的数值原子轨道的精度。 对于ABACUS的平面波计算和产生球贝塞尔函数 j_l(q r)个数的计算，我们建议采用同样的能量截断值，该截断值取得越高，基矢量个数越多同时基组也越完备。对于采用赝势的平面波计算，15~30个球贝塞尔函数已经足够得到质量比较高的数值原子轨道。 数值原子轨道的二阶可导：除了以上操作之外，还有一个需要注意到的地方。为了使数值原子轨道的动能积分是良定义的，需要使原子轨道的二阶导数连续。这可以通过将原子轨道的径向部分乘以一个平滑函数g(r)来实现 g(r)=1-\\exp \\left[-\\frac{\\left(r-r_{\\mathrm{c}}\\right)^2}{2 \\sigma^2}\\right], 该径向轨道会在数值原子轨道的截断值以内起作用，使其在截断值处2阶连续，超过阶段半径之后就严格截断。在我们的测试中，我们发现参数\\sigma对轨道的质量影响不大，所以我们一般固定\\sigma为常数0.1。 数值原子轨道动能和再次使用模拟退火算法：如果仅仅最小化溢出函数值，原子轨道的径向部分经常会出现震荡，原因是震荡有时候有利于溢出函数的值尽可能的低，但震荡厉害的函数往往动能高，可移植性较差。因此，为了去除这些实际上非物理的震荡，在算法中我们还定义了原子轨道的动能： T_{\\mu}=\\sum_{q} c_{\\mu q}^{2} q^{2} / 2+\\kappa, 并再次通过模拟退火算法最小化原子轨道的动能，其中\\kappa则是模拟退火的一个惩罚函数： \\kappa=\\left\\{\\begin{array}{ll} 0, & \\mathcal{S} / \\mathcal{S}_{0}-1\\Delta \\end{array}\\right., 这里\\mathcal{S}\\_{0}是在优化动能之前所得到的数值原子轨道算出来的溢出函数的值，而\\mathcal{S}则是当前在参数c_{\\mu q}下面的溢出函数的值。我们发现参数取\\Delta=0.002~0.005足够使得原子轨道平滑了。轨道动能也是通过同样的模拟退火算法得到，经过动能优化之后，轨道的形状会变平滑，同时溢出函数的值也会相比没有动能优化的轨道会有一点点增加，但是对精度的影响是很小的。 优化动能用的模拟退火算法几乎和优化溢出函数一样，除了一点点参数的区别。 目标函数选择的是所有轨道中最大的动能，而不是像溢出函数一样取平均值。对于每个轨道来说，温度是不一样的，因为每个轨道会有一个不同的动能，在这步动能优化中，我们发现结果对初始的温度不敏感，但最终达到的温度必须取得足够小。实际中我们发现只需要100~200步，动能就可以下降得很快。 所以一般来说优化动能的步数就取得比优化溢出函数要少。 二、ABACUS中产生数值原子轨道的具体流程 注：本文档介绍的是模拟退火算法SA，不适用于基于Pytorch的PyTorch-Gradient方法，关于这两个算法，可以参考本数值原子轨道中文文档系列的第三篇文档。 1. 平面波计算 简化计算量：前文我们提到的溢出函数公式，如果把投影子\\hat{P}带进公式，则可以发现我们不需要在计算溢出函数的时候显示的包含任何基矢量（例如平面波）的操作。实际上，我们只需要先算好数值原子轨道|\\phi_\\mu\\rangle和电子波函数|\\Psi_i\\rangle的重叠矩阵（Overlap Matrix）\\langle \\Psi_i|\\phi_\\mu\\rangle并存下来，以及数值原子轨道之间的重叠矩阵\\langle \\phi_\\mu|\\phi_\\nu\\rangle存下来就可以算溢出函数了。更进一步，我们意识到数值原子轨道|\\phi_\\mu\\rangle的径向部分在程序里是写成了球贝塞尔函数的线性组合，根据线性叠加的原理，我们只需要计算球贝塞尔函数和电子波函数的内积，以及球贝塞尔函数之间的内积，并把这些结果存下来，就可以优化系数c_{\\mu q}了！注意这里指标i遍历体系的所有电子态，包括所有的k点以及能带对应的电子波函数。 换句话说，只需要存储线性代数里的内积结果而不是每个波函数在基矢量下的展开系数就可以优化我们想要的系数，因此数值原子轨道的优化过程可以极大提速！ 采用ABACUS做平面波计算： 因此，第一步我们先调用ABACUS主程序，计算出以上overlap矩阵，首先需要准备INPUT文件如下： INPUT_PARAMETERS suffix H pseudo_dir /home/liuyu/github/abacus-develop/tests/PP_ORB wannier_card INPUTw calculation scf ks_solver dav nspin 1 lmaxmax 1 symmetry 0 nbands 10 ecutwfc 100 scf_thr 1.0e-7 scf_nmax 1000 smearing_method gauss smearing_sigma 0.01 mixing_type pulay mixing_beta 0.4 mixing_ndim 8 printe 1 bessel_nao_ecut 100 // same as ecutwfc bessel_nao_rcut 6 // rcut 如上所示，该INPUT与平常的平面波计算相比，只有3个参数（已标红）需要注意： wannier_card：指定wannier相关参数的输入文件名INPUTw bessel_nao_ecut：球贝塞尔函数的截断能，根据公式\\sqrt{E_{cut}} \\times r_{cut} / \\pi来决定求贝塞尔函数的数量 bessel_nao_rcut：数值原子轨道的截断半径r_{cut} 此外，我们还需要准备输入文件 INPUTw 如下（将来计划会把 INPUTw 文件去掉，把参数加入 INPUT 里）： WANNIER_PARAMETERS out_spillage 2 // output overlap spillage_outdir OUT.H // could be the same as OUT.${suffix} 通过 ABACUS 做平面波基矢量计算可以计算出： 1）电子波函数|\\Psi_i\\rangle和球贝塞尔函数 j_l(q r)之间的 overlap\\langle \\Psi_i|j_l(q r)\\rangle； 2）球贝塞尔函数之间的 overlap\\langle j_{l_2}(q_2 r)|j_{l_1}(q_1 r)\\rangle； 3）电子波函数|\\Psi_i\\rangle之间的 overlap\\langle \\Psi_i|\\Psi_i\\rangle。 这些输出将存在文件 OUT.${suffix}/orb_matrix.0.dat 中，而这个文件将被读入进行数值原子轨道的生成。 2. 编译 SIAB SIAB 的全称是 Systematically Improvable Atomic orbital Basis generator based on spillage formula，目前是包含在 ABACUS 软件里的一个独立程序，可用来读入以上 ABACUS 产生的数据文件并且生成数值原子轨道，具体编译方法如下： 拉取 deepmodeling/abacus-develop 仓库（github 和 gitee 二选一即可，国内建议用 gitee） # github仓库 $ git clone -b develop https://github.com/deepmodeling/abacus-develop.git # gitee仓库 $ git clone -b develop https://gitee.com/deepmodeling/abacus-develop.git 编译 SIAB 模拟退火（SA）方法生成数值原子轨道的代码在 SIAB 文件夹里，采用 C++ 编写，目前 Makefile 仅支持 intel 编译器。 SIAB 程序有串行（make s）和并行（make p）两种版本，一般情况下串行版本即可满足使用需求。 $ cd abacus-develop/tools/SIAB/SimulatedAnnealing/source $ make clean $ make s 编译成功后，在目录 abacus-develop/tools/SIAB/SimulatedAnnealing/source 下可以看到生成数值原子轨道的可执行程序 SIA_s.exe，这里 s 代表编译串行版(serial)。此外，对于并行版本，SIAB 还可以结合 MPI 编译并行版，通过命令 make p 指令得到 SIA_p.exe 可执行程序，这里 p 代表 parallel，但注意并行版只对某些特定算法进行并行，之后对代码进行一个更好整理之后我们会给出并行版的教程。 3. 运行例子 进入 tests_s 目录，可以看到 H-6-0.6.15.dat 文件，这是用来生成数值原子轨道所需要准备的输入文件，从 ABACUS 的平面波自洽迭代计算后获得，现在该文件已经改名为 OUT.${suffix}/orb_matrix.0.dat。 此外，还有一个输入文件 INPUT 如下： 1 // bool: calculate the spillage. 1/0 0 // bool: restart or not. 1/0 1 // bool: output the file. 1/0 1 // integer: number of structures. H-6-0.6.15.dat // Each structure's file name occupies one line 1 // integer: number of k points (for parallel version) 1 // integer: number of pools (for parallel version) 15 // can be ignored now 2 // The way to calculate spillage, 2 means averaged spillage 1.0e-8 // real: start temperature for minimizing spillage 0.5 // real: cooling rate for the temperature in minimizing spillage 2 // integer: number of temperatures (spillage) 500 // integer: number of steps per temperature (spillage) 1.0e-2 // real: starting temperature for the kinetic energy 0.8 // real: cooling rate for temperature in minimizing kinetic energy 1 // integer: number of temperatures (kinetic) 100 // integer: number of steps per temperature (kinetic) 0.05 // real: delta kappa for kinetic energy 49 // integer: selectly output information every n steps 100 // integer: change accept rate every n steps, can be ignored now 0.4 // real: acceptance rate (high), can be ignored now 0.2 // real: acceptance rate (low), can be ignored now 50 // real: max allowed kinetic energy (Rydberg) 0.01 // real: 'dr' for the 1d r grid to compute kinetic energy 1 // integer: 1: Kin 2: Ecut, can be ignored now 1 // bool: to control the number of bands 1 // int, the start band index(>0). 1 // int, the end band index( 2 // Number of levels. # label / na / skip / lmax / each L / 01 2 new 1 1 1 01 2 new 1 1 1 01 2 new 1 1 1 0.01 //dr(a.u.) of uniform mesh. Attention!!dr will affect kinetic energy minmized largely. -6 //xmin 1 //zed, chosen as valence charge. 0.01 //dx 6.0 //xmax 0 // print out the C4, this section can be ignored now 2 ./FILE/Si-S.ORBITAL 0 ./FILE/Si-P.ORBITAL 1 0 // for tests, can be ignored now 14.0 // rcut, only useful for test program 0.01 // dr, for simpson integral 2 // test eigenvalue index 2 // lmax C4：代表 4 个重要参数：\\alpha,\\xi,l,nq，\\alpha是原子种类的指标，\\xi是角动量l对应的径向函数的个数，nq 是对应的球贝塞尔函数的个数。 该输入文件包含 SIAB 程序需要读取的一系列参数，基本上重要参数的说明都有列上去，一些可忽略的参数可以先不用设置，之后我们会推出更详细的关于此输入文件的说明文档。 准备好该输入文件后，可以通过如下命令执行 SIAB 程序： $ ~/abacus-develop/tools/SIAB/SimulatedAnnealing/source/SIA_s.exe 运行完毕后，可以得到一系列输出文件，其中 ORBITAL_1U.dat 则是我们需要的数值原子轨道文件。我们可以通过文件的前几行获取关键信息：这是 H 原子的轨道文件，平面波截断能为 100 Ry，截断半径为 6 Bohr，最大角动量为 1，角动量 s 和 p 的径向函数的个数都为 2，即 2 条 s 轨道和 6 条 p 轨道，共 8 条轨道。为了体现这些关键信息，在使用轨道的时候我们建议重命名该文件为 H_gga_100Ry_6au_2s2p.orb。 --------------------------------------------------------------------------- Element H Energy Cutoff(Ry) 100 Radius Cutoff(a.u.) 6 Lmax 1 Number of Sorbital--> 2 Number of Porbital--> 2 --------------------------------------------------------------------------- SUMMARY END 三、ABACUS 中数值原子轨道的生成脚本 我们需要采用平面波计算不同键长的二聚体，并且存在不同层级的轨道，因此也可以通过一个脚本来实现自动化整个流程：abacus-develop/tools/SIAB/Generate_Orbital_AllInOne.sh。该脚本需要读入一个输入文件 ORBITAL_INPUT 如下： #1.exe_dir #-------------------------------------------------------------------------------- EXE_mpi mpirun -np 4 EXE_pw /home/liuyu/github/abacus-develop/build/abacus EXE_orbital /home/liuyu/github/abacus-develop/tools/SIAB/SimulatedAnnealing/source/SIA_s.exe #-------------------------------------------------------------------------------- #( In this part, the direction of the two used exe is provided ) #2.electronic calculatation #-------------------------------------------------------------------------------- targets 14_Si_60 # element ref_bands 4 6 # reference bands nbands 8 12 # num of bands for calculate Ecut 60 # cutoff energy (in Ry) Rcut 6 7 # cutoff radius (in a.u.) Pseudo_dir /home/liuyu/github/abacus-develop/tests/PP_ORB Pseudo Si_ONCV_PBE-1.0.upf smearing_sigma 0.01 # energy range for gauss smearing (in Ry) #-------------------------------------------------------------------------------- #( In this part , some parameters of calculating are given ) #3.structure information #-------------------------------------------------------------------------------- #the Bond Length list for each STRU BLSTRU1 1.8 2.0 BLSTRU2 2.4 # if skip the orbital optimization for each STRU (1:skip, 0:not skip). SkipSTRU 0 0 # set the objective structure list to fit for orbital optimization ListSTRU dimer trimer #-------------------------------------------------------------------------------- #(In this part, it gives us the bond length of the reference system(in angstrom) ) #4.orbital calculatation #-------------------------------------------------------------------------------- maxL 2 # the max angular momentum Level 2 3 # num of levels to generate orbitals( 该输入文件主要分为 5 个部分： 1. exe_dir EXE_mpi：MPI 并行计算命令，这里我们采用的是 4 核 MPI 并行进行 dimer（或者 trimer）的平面波计算。 EXE_pw：ABACUS 可执行程序的绝对路径。 EXE_orbital：数值原子轨道生成程序 SIA_s.exe 的绝对路径。 2. electronic calculatation targets：可以任取，一般格式是${原子序数}_${元素名}_${截断能}。 ref_bands：参考体系的能带数，取值为电子总数的一半。注意这里有多个取值，原因是我们选择了多组参考构型，既有 dimer，也有 trimer。 nbands：平面波计算中的实际能带数，必须大于 ref_bands，以保证包含非占据态。同理，由于多组参考构型，nbands 也有多个取值。 Ecut：平面波截断能，单位为 Ry。 Rcut：数值原子轨道的截断半径，单位为 Bohr。这里的多个取值表明，采用相同的一套参数，生成多个不同截断半径的数值原子轨道文件，根据第一部分的基础知识，截断半径会极大地影响数值原子轨道的质量，因此该参数可以帮助我们一次性生成多个不同截断半径的数值原子轨道文件。 Pseudo_dir：平面波计算采用的赝势文件所在文件夹的绝对路径。 Pseudo：平面波计算采用的赝势文件名。 smearing_sigma：平面波计算采用 Gaussian smearing 的展宽，单位为 Ry，一般取 0.01 即可。 3. structure information BLSTRU1：第一组参考构型的键长，单位为埃。如上所示，第一组参考构型包含两个构型，键长分别为 1.8 和 2.0 埃。 BLSTRU2：第二组参考构型的键长，单位为埃。如上所示，第二组参考构型包含一个构型，键长为 2.4 埃。 以此类推，可以存在 BLSTRU3、BLSTRU4 等等。 SkipSTRU：是否跳过该组参考构型的优化，一般而言，都取为 0 即可。 ListSTRU：指定 BLSTRU1、BLSTRU2 等等参考体系的具体构型，这里说明 BLSTRU1 是 dimer，BLSTRU2 是 trimer。如果取值缺省（第一个不可缺省），则默认为 dimer。 4. orbital calculatation maxL：最大角动量。 Level1：根据上文可知，轨道可以分为多个层级，这里 level1 是 SZ 层级，最大角动量为 1，角动量 s 和 p 的径向函数的个数为 1 和 1，即 1 条 s 轨道和 3 条 p 轨道。 Level2：同上，这里 level2 的最大角动量为 2，角动量 s，p 和 d 的径向函数的个数为 1，1 和 1，即 1 条 s 轨道，3 条 p 轨道和 5 条 d 轨道。level1 和 level2 合在一起，是 DZP 层级。 Level3：同 Level2。 Level：BLSTRU1 和 BLSTRU2 分别负责一部分轨道的生成，Level 的 2 个取值对应的是 BLSTRU1 和 BLSTRU2 的 endlevel，即 BLSTRU1 用于 level1 和 level2 轨道的生成，BLSTRU2 用于 level3 轨道的生成。 5. Metropolis parameters 如注释所说，这部分参数实际上大多数情况下不需要改变。 Start_tem_S：优化 Spillage 的初始温度，更高的初始温度可以搜索更大的温度范围。 Start_tem_K：优化动能的初始温度，更高的初始温度可以搜索更大的温度范围。 Step_S：优化 Spillage 的步数。 Step_K：优化动能的步数。 Delta_kappa：模拟退火的惩罚函数\\kappa所用的参数\\Delta。 准备好以上输入文件后，通过以下命令即可开始生成轨道： $ ~/abacus-develop/tools/SIAB/Generate_Orbital_AllInOne.sh ORBITAL_INPUT 四、ABACUS 中数值原子轨道的测试流程 在生成轨道之后，为了保证基于数值原子轨道基组的第一性原理计算拥有与平面波基组相当的精度，我们需要针对该元素的一些常见的晶体结构做一些验证性计算。 以 Al 元素为例，我们可以选择 simple cubic（sc），body center cubic（bcc），face center cubic（fcc）和 hexagonal close-packed（hcp）这 4 种常见的晶体结构，采用平面波（Plane wave）基组和数值原子轨道基组计算这些晶体结构的平衡晶格常数、体弹性模量等基态性质，评估两种基组之间的误差随着截断半径、最大角动量以及轨道数量的收敛趋势，选择合适的数值原子轨道文件。例如以下就是用 ABACUS 的平面波和数值原子轨道 DZP 计算的铝的四种体相材料的体积-能量曲线，来自文献[1]。从图中可以看到，DZP 轨道描述不同体相的铝的相对能量还是精度较高的。细心的读者会发现纵坐标给出的是绝对能量，因为两种基矢量采用了相同的赝势，但左图给出的能量更低，这是因为平面波更加完备，所以根据 Honhenberg-Kohn 定理，体系总能量的密度泛函可以在更完备的基矢量下得到更好的收敛，即总能量更低。一般来说，平面波得到的总能量比 DZP 轨道小一些，大概在 0.1-0.2 eV/atom，是比较合理的。如果采用了同样的赝势，但两种基矢量给出的能量差别远远大于这个数值，则要检查一下是不是数值原子轨道产生出了问题。最后，大家有任何问题，欢迎写邮件到文档开头邮箱。 五、参考文献 [1] M. Chen, G.-C. Guo, and L. He, Systematically Improvable Optimized Atomic Basis Sets for Ab Initio Calculations, J. Phys.: Condens. Matter 22, 445501 (2010). [2] M. Chen, G.-C. Guo, and L. He, Electronic Structure Interpolation via Atomic Orbitals, J. Phys.: Condens. Matter 23, 325501 (2011). "},"abacus-nac3.html":{"url":"abacus-nac3.html","title":"数值原子轨道（三）：产生高精度数值原子轨道","keywords":"","body":"数值原子轨道（三）：产生高精度数值原子轨道 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：林霈泽，邮箱：linpeize@sslab.org.cn 最后更新时间：2023/06/20 在Bohrium Notebook上快速学习： 一、PTG（PyTorch Gradient）方法 这篇文档是数值原子轨道系列的第三篇文档，除了第二篇文档提到的模拟退火算法之外，还可以使用 Pytorch 中的自动微分算法来最小化溢出函数。首先定义损失函数如下，并可以证明它与溢出函数是等价的： \\Delta \\mathrm{PSI} \\stackrel{\\text { def }}{=} \\frac{1}{N_n} \\sum_{n=1}^{N_m} \\|\\left|\\Psi_n\\right\\rangle-\\left|\\tilde{\\Psi}_n\\right\\rangle \\|^2, 其中 \\left|\\tilde{\\Psi}_n\\right\\rangle \\stackrel{\\text { def }}{=} \\hat{P}\\left|\\Psi_n\\right\\rangle, 且\\hat{P}是由所有原子轨道张成的投影子，即\\hat{P}=\\sum_{\\mu v}\\left|\\phi_\\mu\\right\\rangle S_{\\mu v}^{-1}\\left\\langle\\phi_v\\right| \\text {}。由 \\hat{P}^2=\\hat{P}及 \\left\\langle\\Psi_n|\\Psi_n\\right\\rangle=\\delta_{mn}可知，此处的损失函数\\Delta \\mathrm{PSI}与溢出函数是等价的。 二、PTG_dpsi（PyTorch Gradient with dpsi）方法 为了增加局域轨道做电子结构计算时的精度，损失函数的定义还可以被拓展，即在其中加入波函数的梯度，将总的损失函数定义为： \\Delta \\mathrm{PSI} \\stackrel{\\text { def }}{=} \\frac{1}{N_n} \\sum_{n=1}^{N_m} [\\|\\left|\\Psi_n\\right\\rangle-\\left|\\tilde{\\Psi}_n\\right\\rangle \\|^2+\\|\\left|\\nabla\\Psi_n\\right\\rangle-\\left|\\nabla\\tilde{\\Psi}_n\\right\\rangle \\|^2]. 由于投影波函数\\left|\\tilde{\\Psi}_{n}\\right\\rangle是数值原子轨道的线性组合： \\left|\\tilde{\\Psi}_{n}\\right\\rangle=\\sum_{\\mu} a_{\\mu n}\\left|\\phi_{\\mu}\\right\\rangle, 其中系数的表达式为 a_{\\mu n}=\\sum_{\\nu} S_{\\mu \\nu}^{-1}\\left\\langle\\phi_{\\nu} \\mid \\Psi_{n}\\right\\rangle. 那么投影波函数的梯度可以表示为数值原子轨道梯度的线性组合： \\left|\\nabla \\tilde{\\Psi}_{n}\\right\\rangle=\\sum_{\\mu} a_{\\mu n}\\left|\\nabla \\phi_{\\mu}\\right\\rangle. 因此，损失函数的梯度项可以转化为： \\begin{array}{l} \\|\\left|\\nabla \\Psi_{n}\\right\\rangle-\\left|\\nabla \\tilde{\\Psi}_{n}\\right\\rangle \\|^{2} \\\\ =\\left\\langle\\nabla \\Psi_{n} \\mid \\nabla \\Psi_{n}\\right\\rangle-\\sum_{\\mu} a_{\\mu n}\\left\\langle\\nabla \\Psi_{n} \\mid \\nabla \\phi_{\\mu}\\right\\rangle \\\\ -\\sum_{\\nu} a_{v n}^{*}\\left\\langle\\nabla \\phi_{v} \\mid \\nabla \\Psi_{n}\\right\\rangle+\\sum_{\\mu \\nu} a_{\\mu n} a_{v n}^{*}\\left\\langle\\nabla \\phi_{v} \\mid \\nabla \\phi_{\\mu}\\right\\rangle. \\end{array} 根据经验，使用这个算法生成的双重-ζ + 极化(DZP)基组，精度与模拟退火法或 PTG 法生成的三重-ζ + 双极化(TZDP)甚至四倍-ζ + 三重极化(QZTP)基组相当。 在平面波计算中，除了数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道 提到的 overlap 输出文件 OUT.${suffix}/orb_matrix.0.dat 之外，overlap 输出文件 OUT.${suffix}/orb_matrix.1.dat 同样会作为生成轨道的输入文件之一，该文件保存与波函数梯度相关的如下 overlap 项： 1）电子波函数梯度|\\nabla \\Psi_i\\rangle和局域轨道梯度|\\nabla \\phi_\\mu\\rangle的 overlap，也就是电子波函数梯度|\\nabla \\Psi_i\\rangle以及球贝塞尔函数梯度\\nabla j_l(q r)之间的 overlap\\langle \\nabla \\Psi_i|\\nabla j_l(q r)\\rangle； 2）球贝塞尔函数梯度\\nabla j_l(q r)之间的 overlap\\langle \\nabla j_{l_2}(q_2 r)|\\nabla j_{l_1}(q_1 r)\\rangle； 3）电子波函数梯度|\\nabla \\Psi_i\\rangle之间的 overlap\\langle \\nabla \\Psi_i|\\nabla \\Psi_i\\rangle。 三、安装 Pytorch PTG 和 PTG_dpsi 方法采用 python 语言，无需编译，但是依赖 pytorch 包，下面介绍利用 conda 安装 pytorch 的方法： # 确定conda版本 $ conda -V conda 4.8.3 # 确定python3版本 $ python3 -V Python 3.5.2 # 创建python环境 $ conda create -n pytorch python=3.5 # 激活环境（每次使用pytorch需要激活该环境） $ source activate pytorch # 安装pytorch $ conda install pytorch torchvision torchaudio cpuonly -c pytorch # 安装依赖库 $ pip3 install --user scipy numpy $ pip3 install --user torch_optimizer # 退出python环境（使用完毕后） $ source deactivate 四、产生高精度数值原子轨道流程 首先下载 PTG_dpsi 仓库 # github仓库 git clone -b main https://github.com/abacusmodeling/ABACUS-orbitals 接着准备输入文件 SIAB_INPUT #-------------------------------------------------------------------------------- #1. CMD & ENV EXE_mpi mpirun -np 4 EXE_pw /home/liuyu/github/abacus-develop/build/abacus EXE_opt /home/liuyu/github/ABACUS-orbitals/SIAB/opt_orb_pytorch_dpsi/main.py #-------------------------------------------------------------------------------- #2. Electronic calculatation element Si # Element Name Ecut 100 # in Ry Rcut 6 7 # in Bohr Pseudo_dir /home/liuyu/github/abacus-develop/tests/PP_ORB Pseudo_name Si_ONCV_PBE-1.0.upf sigma 0.01 # energy range for gauss smearing (in Ry) #-------------------------------------------------------------------------------- #3. Reference structure related parameters for PW calculation #For the built-in structure types (including 'dimer', 'trimer' and 'tetramer'): #STRU Name #STRU Type #nbands #MaxL #nspin #Bond Length list STRU1 dimer 8 2 1 1.8 2.0 2.3 2.8 3.8 STRU2 trimer 10 2 1 1.9 2.1 2.6 #-------------------------------------------------------------------------------- #4. SIAB calculatation max_steps 200 # Orbital configure and reference target for each level #LevelIndex #Ref STRU Name #Ref Bands #InputOrb #OrbitalConf Level1 STRU1 4 none 1s1p Level2 STRU1 4 fix 2s2p1d Level3 STRU2 6 fix 3s3p2d #-------------------------------------------------------------------------------- #5. Save Orbitals #Index #LevelNum #OrbitalType Save1 Level1 SZ Save2 Level2 DZP Save3 Level3 TZDP 该输入文件同样包含 5 个部分： 1. CMD & ENV EXE_mpi：MPI 并行计算命令，这里我们采用的是 4 核 MPI 并行进行 dimer（或者 trimer）的平面波计算。 EXE_pw：ABACUS 可执行程序的绝对路径。 EXE_opt：数值原子轨道生成程序 PTG_dpsi 的绝对路径。 2. Electronic calculatation element：元素名。 Ecut：平面波截断能，单位为 Ry。 Rcut：数值原子轨道的截断半径，单位为 Bohr。这里的多个取值表明，采用相同的一套参数，生成多个不同截断半径的数值原子轨道文件，根据第一部分的基础知识，截断半径会极大地影响数值原子轨道的质量，因此该参数可以帮助我们一次性生成多个不同截断半径的数值原子轨道文件。 Pseudo_dir：平面波计算采用的赝势文件所在文件夹的绝对路径。 Pseudo：平面波计算采用的赝势文件名。 sigma：平面波计算采用 Gaussian smearing 的展宽，单位为 Ry，一般取 0.01 即可。 3. Reference structure related parameters for PW calculation STRU Name：参考构型组别 STRU1、STRU2、STRU3...... STRU Type：参考体系构型，一般可取 dimer，trimer，tetramer。 nbands：平面波计算中的实际能带数，必须保证包含非占据态。 MaxL：最大角动量。 nspin：自旋量子数。 Bond Length list：键长取值列表，单位为埃。以 STRU1 为例，这一组共有 5 个不同键长的 dimer 作为生成轨道的参考构型。 4. SIAB calculatation max_steps：优化步数 LevelIndex：轨道分层的 index，取 Level1、Level2、Level3...... Ref STRU Name：该层级的轨道采用哪一组参考构型生成。以上面的输入参数为例，Level1 和 Level2 的轨道采用 STRU1 组别的 dimer 参考构型生成，Level3 的轨道采用 STRU2 组别的 trimerr 参考构型生成。 Ref Bands：拟合参考体系的能带数，若输入“auto”则自动拟合所有基态。 InputOrb：是否在已有的轨道基础上生成新轨道，一般 Level1 设为 none，即没有旧轨道；Level2 一般以 Level1 生成的轨道为基础继续生成轨道，Level3 往后同理。 OrbitalConf：轨道的具体配置，这里 Level1 是 SZ 层级，Level2 是 DZP 层级，Level3 是 TZDP 层级，实际上还可以继续设置更高层级的轨道。 5. Save Orbitals Index：取值 Save1、Save2、Save3...... LevelNum：将特定 Level 的轨道保存到一个轨道文件中。以上面的输入参数为例，分别将 Level1、Level2、Level3 对应的轨道保存到单独的轨道文件中。 OrbitalType：即保存的轨道文件中，该轨道基组所属的层级。以上面的输入参数为例，分别为 SZ、DZP、TDZP。 准备好输入参数文件 SIAB_INPUT 后，运行如下命令即可开始生成轨道： $ python3 ~/github/ABACUS-orbitals/SIAB/SIAB.py SIAB_INPUT 程序正常结束后，轨道会分别保存在 Orbital_Si_SZ、Orbital_Si_DZP、Orbital_Si_TZDP 中，并自动命名成标准格式（如 Si_gga_6au_100Ry_2s2p1d.orb）。 五、参考文献 [1] Peize Lin, Xinguo Ren and Lixin He, Strategy for constructing compact numerical atomic orbital basis sets by incorporating the gradients of reference wavefunctions, Phys. Rev. B 103, 235131 (2021). "},"abacus-md.html":{"url":"abacus-md.html","title":"ABACUS 分子动力学使用教程","keywords":"","body":"ABACUS 分子动力学使用教程 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/14 在Bohrium Notebook上快速学习： 一、分子动力学方法简介 分子动力学（Molecular Dynamics，简称 MD）：一种模拟原子体系随时间运动的方法，被广泛的用来研究与原子运动路径相关的一些基本过程，如相变、扩散、化学反应等等。本教程旨在介绍 ABACUS 中的分子动力学功能，分子动力学模拟重要的一件事情是如何选取精度和效率的平衡，其中精度高低主要取决于势函数的准确程度，而效率主要受限于求出每个原子的能量和受力的计算量。 经典分子动力学（Classical MD，简称 CMD）：通过构建描述原子间相互作用的势函数，获得每个原子的受力（受力等于能量对原子位置的导数），再通过积分运动方程来获得每个原子的下一时刻位置，从而获得随时间演化的粒子位置和速度。当系统处在一定的密度、温度和压强等物理条件限制下，可以结合统计物理的方法计算物质的性质。具体来说，采取某个系综后，对粒子位置和速度采样，之后统计出体系的热力学宏观性质。 从头算分子动力学（ab initio molecular dynamics，简称 AIMD）：也称为第一性原理的分子动力学方法（first-principles molecular dynamics，简称 FPMD），该方法采用的是第一性原理方法（例如密度泛函理论）来计算体系的势能面，因此计算量相比于经典分子动力学方法要昂贵很多。 ABACUS 的分子动力学功能：支持第一性原理分子动力学 FPMD 方法，也支持经典的 Lennard-Jones（LJ 对势）的分子动力学模拟。此外，ABACUS 还支持深度势能分子动力学（Deep Potential Molecular Dynamics，简称 DPMD）方法，此时需要编译 DeePMD-kit 软件包并在编译原子算筹软件时进行动态库的链接。 二、文档和算例下载地址 ABACUS 里关于分子动力学方法的线上文档地址为：http://abacus.deepmodeling.com/en/latest/advanced/md.html ABACUS 里关于分子动力学参数的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#molecular-dynamics ABACUS 的 MD 算例下载地址为（国内 gitee）： https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/md 可以采用的下载命令是： git clone https://gitee.com/mcresearch/abacus-user-guide.git 之后进入 /abacus-user-guide/examples/md 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/md 注：算例仓库里面包含 1_AIMD，2_LJMD（采用 Lennard-Jones 经典势做 MD），3_DPMD（采用深度势能方法做 MD）和 4_FIRE（采用 FIRE 算法做结构优化）四个目录。 注：以上算例要在 ABACUS v3.2.1 版本及以上可以运行成功，并且我们强烈建议下载使用 ABACUS 最新版本！ 1. 第一性原理分子动力学（AIMD） 进入 1_AIMD 目录，该目录提供了 8 个输入文件，使用的时候将 INPUT_* 复制为 INPUT 即可（INPUT_* 代表从 INPUT_0 到 INPUT_7 共 8 个不同的 INPUT 文件，对应 8 种不同的 MD 算法）。该算例采用 8 原子的金刚石结构 Si，晶格结构放在 STRU 文件里，布里渊区的 k 点采样放在 KPT 文件里。 8 个 INPUT 文件对应的 MD 方法如下： INPUT_0：采用 NVE 微正则系综 INPUT_1：采用 NVT 正则系综 INPUT_2：采用 Langevin 热库 INPUT_3：采用 Anderson 热库，NVT 系综 INPUT_4：采用 MSST 方法 INPUT_5：采用 Berendsen 热库，NVT 系综 INPUT_6：采用 rescaling 方法，NVT 系综 INPUT_7：采用 rescale_v 方法，NVT 系综 以 INPUT_0 为例： INPUT_PARAMETERS #Parameters (1.General) suffix Si_nve calculation md nbands 20 symmetry 0 pseudo_dir ../../../tests/PP_ORB orbital_dir ../../../tests/PP_ORB #Parameters (2.Iteration) ecutwfc 30 scf_thr 1e-5 scf_nmax 100 #Parameters (3.Basis) basis_type lcao ks_solver genelpa gamma_only 1 #Parameters (4.Smearing) smearing_method gaussian smearing_sigma 0.001 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 chg_extrap second-order #Parameters (6.MD) md_type nve md_nstep 10 md_dt 1 md_tfirst 300 这些参数在 ABACUS 线上文档中均有说明，在这里再进行简单概述： calculation：设置 ABACUS 计算类型，做分子动力学模拟请设置为 md。 esolver_type：给定原子位置进行系统能量的计算，默认 Kohn-Sham 密度泛函理论（ksdft），还可以设置 LJ 势（lj）或者深度势能（dp）。理论上来说，所有的 esolver_type 都可以用于 MD 计算。 chg_extrap：电荷外插法，在 relax 和 md 计算中可用于优化电荷密度初始化，加速电子迭代收敛，MD 中可以设置为 second-order。 md_type：MD 算法种类，默认是正则系统 nvt，这里的例子选择的是 nve，即 NVE 微正则系综。 md_nstep：MD 模拟的总步数。 md_dt：MD 计算每一步的时间步长（单位是 fs），与 md_nstep 共同决定 MD 总时长。 md_tfirst：MD 系统的初始温度（单位是 K）。 2. Lennard-Jones 势函数 进入 2_LJMD 目录，ABACUS 软件包中提供了一个采用 Lennard-Jones（LJ）经典势函数进行 MD 模拟的算例，该算例采用 LJ 对势作为能量求解器来做经典分子动力学，初始结构是边长 20 埃的正方体盒子中的 256 个无序 He 原子。 2.1 LJ 对势 LJ 对势的解析形式如下：u^{ij}表示原子 i 与原子 j 之间的相互作用能，r^{ij}表示这两个原子之间的距离，\\epsilon，\\sigma和r_{cut}则是 LJ 势需要的 3 个参数。LJ 势只考虑截断半径r_{cut}内的近邻原子 j 对中心原子 i 的能量贡献。 \\begin{array}{c} u^{i j}=4 \\varepsilon\\left[\\left(\\frac{\\sigma}{r_{i j}}\\right)^{12}-\\left(\\frac{\\sigma}{r_{i j}}\\right)^{6}\\right] \\\\ \\boldsymbol{F}_{i}=-\\nabla_{i} U=\\sum_{j} 4 \\varepsilon\\left[12\\left(\\frac{\\sigma}{r_{i j}}\\right)^{12}-6\\left(\\frac{\\sigma}{r_{i j}}\\right)^{6}\\right] \\frac{\\boldsymbol{r}_{i}-\\boldsymbol{r}_{j}}{r_{i j}^{2}} H\\left(r_{c u t}-r_{i j}\\right) \\end{array} \\\\ H(x)=\\left\\{\\begin{array}{l} 0\\ \\ \\ \\ (x0) \\end{array}\\right.\\\\ 2.2 STRU LJMD 是经典分子动力学，不需要提供 KPT，赝势和轨道文件，STRU 的前面几部分如下： ATOMIC_SPECIES He 4.0026 LATTICE_CONSTANT 1.889727 LATTICE_VECTORS 20 0 0 0 20 0 0 0 20 ATOMIC_POSITIONS Cartesian He #label 0 #magnetism 256 #number of atoms ATOMIC_SPECIES：不需要提供赝势信息 NUMERICAL_ORBITAL：不需要添加轨道信息 2.3 INPUT INPUT 文件中的参数也需要做少量修改： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md pseudo_dir ../../PP_ORB #Parameters (esolver) esolver_type lj lj_rcut 8.5 lj_epsilon 0.01032 lj_sigma 3.405 cal_force 1 cal_stress 1 #Parameters (MD) md_nstep 5 md_type nve md_dt 1 md_tfirst 300 init_vel 1 esolver_type：指定为 lj 就可以做 Lennard-Jones 经典势函数。 lj_rcut：LJ 对势的参数，即截断半径r_{cut}。 lj_epsilon：LJ 对势的参数，即\\epsilon。 lj_sigma：LJ 对势的参数，即\\sigma。 init_vel：读取 STRU 中的原子速度信息，原子单位制。 3. 深度势能（Deep Potential） ABACUS 软件包中提供了一个 DPMD 的算例，进入 3_DPMD 目录。该算例采用 DP 模型（DeePMD-kit 产生的深度势能模型）作为能量求解器来做基于机器学习的分子动力学，初始结构是 864 个无序铝原子。 3.1 DP 模型 DeePMD-kit 是一种基于机器学习的分子动力学模拟方法，该方法是通过使用第一性原理计算数据对深度神经网络模型进行训练，从而得到通用的多体势能模型（DP 模型）。 3.2 编译方式 ABACUS 采用 DP 模型做 MD 计算需要编译与 DeePMD-kit 的接口，cmake 以及 makefile 编译方式可以参考 ABACUS 线上文档。 3.3 INPUT 文件设置 DPMD 是经典分子动力学，不需要提供 KPT，赝势和轨道文件 INPUT 文件中的参数需要做少量修改： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md esolver_type dp pot_file ../../PP_ORB/Al-SCAN.pb cal_force 1 cal_stress 1 md_nstep 3 md_type msst md_dt 1 md_tfirst 200 md_dumpfreq 1 md_restartfreq 1 msst_qmass 200 msst_vel 0.028 msst_vis 0.3 init_vel 1 esolver_type：设置为 dp pot_file：DP 模型文件路径 md_dumpfreq：MD 输出文件 MD_dump 中原子以及晶胞信息的输出频率 md_restartfreq：结构文件 STRU_MD_${istep} 的输出频率，MD 续算文件 Restart_md.dat 的更新频率 3.4 STRU 文件的设置 首先，我们可以通过如下命令确定 DP 势文件中是否存在关键字“type_map”： $ strings Al-SCAN.pb | grep type_map {\"model\": {\"type_map\": [\"Al\"], \"descriptor\": {\"type\": \"se_e2_a\", \"sel\": [150], \"rcut_smth\": 0.5, \"rcut\": 6.0, \"neuron\": [25, 50, 100], \"resnet_dt\": false, \"axis_neuron\": 16, \"seed\": 1, \"activation_function\": \"tanh\", \"type_one_side\": false, \"precision\": \"default\", \"trainable\": true, \"exclude_types\": [], \"set_davg_zero\": false}, \"fitting_net\": {\"neuron\": [240, 240, 240], \"resnet_dt\": true, \"seed\": 1, \"type\": \"ener\", \"numb_fparam\": 0, \"numb_aparam\": 0, \"activation_function\": \"tanh\", \"precision\": \"default\", \"trainable\": true, \"rcond\": 0.001, \"atom_ener\": []}, \"data_stat_nbatch\": 10, \"data_stat_protect\": 0.01}, \"learning_rate\": {\"type\": \"exp\", \"decay_steps\": 5000, \"start_lr\": 0.001, \"stop_lr\": 3.51e-08, \"scale_by_worker\": \"linear\"}, \"loss\": {\"type\": \"ener\", \"start_pref_e\": 0.02, \"limit_pref_e\": 1, \"start_pref_f\": 1000, \"limit_pref_f\": 1, \"start_pref_v\": 0, \"limit_pref_v\": 0, \"start_pref_ae\": 0.0, \"limit_pref_ae\": 0.0, \"start_pref_pf\": 0.0, \"limit_pref_pf\": 0.0, \"enable_atom_ener_coeff\": false}, \"training\": {\"training_data\": {\"systems\": [\"../deepmd_data/\"], \"batch_size\": \"auto\", \"set_prefix\": \"set\", \"auto_prob\": \"prob_sys_size\", \"sys_probs\": null}, \"validation_data\": {\"systems\": [\"../deepmd_validation\"], \"batch_size\": 1, \"numb_btch\": 3, \"set_prefix\": \"set\", \"auto_prob\": \"prob_sys_size\", \"sys_probs\": null}, \"numb_steps\": 1000000, \"seed\": 10, \"disp_file\": \"lcurve.out\", \"disp_freq\": 100, \"save_freq\": 1000, \"save_ckpt\": \"model.ckpt\", \"disp_training\": true, \"time_training\": true, \"profiling\": false, \"profiling_file\": \"timeline.json\", \"enable_profiler\": false, \"tensorboard\": false, \"tensorboard_log_dir\": \"log\", \"tensorboard_freq\": 1}} 如果存在关键字 type_map，那么 ABACUS 会自动匹配 STRU 和 DP 势文件中的原子种类顺序。 否则，STRU 中的原子种类以及顺序必须与 DP 势文件中的原子种类以及顺序一致。 例如，如果我们用 Al-Cu-Mg 三元合金的 DP 势文件来跑 Al-Mg 二元合金的 MD，那么 STRU 应该如下所示： ATOMIC_SPECIES Al 26.982 Cu 63.546 Mg 24.305 LATTICE_CONSTANT 1.889727000000 LATTICE_VECTORS 4.0 0.0 0.0 0.0 4.0 0.0 0.0 0.0 4.0 ATOMIC_POSITIONS Cartesian Al 0 2 0.0 0.0 0.0 0.5 0.5 0.0 Cu 0 0 Mg 0 2 0.5 0.0 0.5 0.0 0.5 0.5 注：在这个例子中，即使 Cu 原子的数量为 0，也必须在 STRU 中给出 Cu 原子相关信息。 三、MD 输出和续算功能 1. MD 输出文件 ABACUS 的 MD 模拟会产生 3 类输出文件：结构文件 STRU_MD_${istep}，续算文件 Restart_md.dat，信息文件 MD_dump。 1.1 结构文件 STRU_MD_${istep} 参数 md_restartfreq 控制 OUT.${suffix}/STRU/文件夹中结构文件STRU_MD_${istep}的输出频率，该文件格式与输入结构文件 STRU 相同，主要用于 MD 续算。这里 istep 代表离子步，从 0 开始计数。 1.2 续算文件 Restart_md.dat 参数 md_restartfreq 控制 OUT.${suffix}/Restart_md.dat 的更新频率，用于 MD 续算。 1.3 信息文件 MD_dump 参数 md_dumpfreq 控制 OUT.${suffix}/MD_dump 文件的追加输出频率，该文件输出每 md_dumpfreq 步的 MD 信息，包括 MD 步数，晶格常数，晶格矢量，晶格维里，原子编号，原子位置，原子受力，原子速度。其中，晶格维里，原子受力，原子速度可以通过输入参数 dump_virial，dump_force，dump_vel 控制是否输出。 MDSTEP: 0 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 123.045275146001 -3.807535058112 -13.541439282961 -3.807535058112 124.421300186299 24.047959743672 -13.541439282961 24.047959743672 125.016024430342 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 0.000000000000 0.000000000000 0.000000000000 -0.885362725233 0.500467424348 0.150239620206 -0.003506076235 0.000412570794 0.000094403053 1 Si 1.300822817264 1.376389287977 1.354798867769 0.885362725233 -0.500467424348 -0.150239620206 0.003506076235 -0.000412570794 -0.000094403053 MDSTEP: 1 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 123.051574098220 -2.465332696362 -10.608474638302 -2.465332696362 123.587154919736 16.307187552709 -10.608474638302 16.307187552709 123.960669810770 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.389827754452 2.701629481339 2.699621723525 -0.602062173578 0.391990779819 0.096323485153 -0.010548689866 0.004659227844 0.001267888485 1 Si 1.308600113700 1.373562332082 1.353979669688 0.602062173578 -0.391990779819 -0.096323485153 0.010548689866 -0.004659227844 -0.001267888485 MDSTEP: 2 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 122.953007762375 -0.240072876170 -4.211946086929 -0.240072876170 122.930693852071 3.378536464243 -4.211946086929 3.378536464243 122.992607262385 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.376757913710 2.708010452044 2.701308224779 -0.124946902346 0.155367961328 0.009378252255 -0.012739769308 0.006644009927 0.001613591879 1 Si 1.321669954442 1.367181361377 1.352293168434 0.124946902346 -0.155367961328 -0.009378252255 0.012739769308 -0.006644009927 -0.001613591879 MDSTEP: 3 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 122.881221914392 1.206247195689 2.345023988024 1.206247195689 123.110079832453 -8.436042066928 2.345023988024 -8.436042066928 123.123976300784 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.364727401370 2.714719749381 2.702800880457 0.310711926370 -0.086233730382 -0.043760493686 -0.009222308089 0.005510922784 0.001122226311 1 Si 1.333700466782 1.360472064040 1.350800512757 -0.310711926370 0.086233730382 0.043760493686 0.009222308089 -0.005510922784 -0.001122226311 2 MD 续算功能 如果 ABACUS 运行达到指定的 MD 步数，或者计算中断，可以通过 MD 续算功能继续之前的 MD 计算。 以上一个 INPUT 文件为例： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md pseudo_dir ../../PP_ORB esolver_type dp pot_file ../../PP_ORB/Al-SCAN.pb cal_force 1 cal_stress 1 md_nstep 3 md_type msst md_dt 1 md_tfirst 200 md_dumpfreq 1 md_restartfreq 1 md_restart 1 msst_qmass 200 msst_vel 0.028 msst_vis 0.3 init_vel 1 md_restart：控制续算的开关，在 MD 续算时将这个参数设为 1，其他参数不变。当 md_restart 设为 1，ABACUS 会读取${read_file_dir}/Restart_md.dat文件，从中获取当前MD步数istep以及续算所需的其他参数如恒温器以及恒压器的信息，根据istep从OUT.${suffix}/STRU/ 文件夹中读取相应的结构文件 STRU_MD_${istep}，之后就可以进行 MD 续算了。 四、MD 后处理 目前主流的可视化软件如 VESTA、VMD、OVITO 并不支持 ABACUS 的文件格式，因此我们需要通过一些后处理软件实现 ABACUS 的 STRU、MD_dump 文件与常用文件格式的转化。我们比较推荐的后处理软件有： 1 ASE 官网：https://wiki.fysik.dtu.dk/ase/ 用法参考 ABACUS 线上文档：http://abacus.deepmodeling.com/en/latest/advanced/interface/ase.html 2 dpdata github 网址：https://github.com/deepmodeling/dpdata gitee 网址：https://gitee.com/deepmodeling/dpdata 3 案例 现在我们用 LJMD 算例来演示如何采用dpdata+OVITO的方式在 MD 计算完成后制作分子动力学轨迹动画。 3.1 MD 计算 下载案例文件 $ git clone https://gitee.com/mcresearch/abacus-user-guide 进入 LJMD 文件夹 $ cd abacus-user-guide/examples/md/2_LJMD 修改 INPUT 参数，把 md_nstep 改为 100 INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md pseudo_dir ../../PP_ORB #Parameters (esolver) esolver_type lj lj_rcut 8.5 lj_epsilon 0.01032 lj_sigma 3.405 cal_force 1 cal_stress 1 #Parameters (MD) md_nstep 100 md_type nve md_dt 1 md_tfirst 300 init_vel 1 运行 abacus $ abacus 3.2 dpdata 转化格式 安装 dpdata $ git clone https://github.com/deepmodeling/dpdata.git dpdata $ cd dpdata $ pip install . 运行 dpdata，将 MD_dump 文件转化为 GROMACS 的 gro 格式的文件 data.gro $ python3 >>> import dpdata >>> data = dpdata.LabeledSystem(\"./\", fmt=\"abacus/md\") >>> data.to_gro(\"data.gro\") 3.3 OVITO 制作动画 打开 OVITO，点击左上角 load file，选择上一步的 data.gro 文件 右上角 rendering settings 点击 Render active viewport 即可保存动画文件 五、特殊的 MD 方法 1. Fast Inertial Relaxation Engine ABACUS 中实现了一种特殊的基于 MD 的 Fast Inertial Relaxation Engine (FIRE)结构优化方法，该算法比共轭梯度法的标准实现快得多，具有额外的速度修改和自适应时间步长，具有优异的优化效率。 以上面提供的 4_FIRE 算例为例，我们可以介绍一下所需的参数如下： INPUT_PARAMETERS #Parameters (1.General) suffix Si_fire calculation md nbands 6 symmetry 0 pseudo_dir ../../PP_ORB orbital_dir ../../PP_ORB #Parameters (2.Iteration) ecutwfc 30 scf_thr 1e-8 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method gaussian smearing_sigma 0.001 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 chg_extrap second-order #Parameters (6.MD) md_type fire md_nstep 100 md_dt 1 md_tfirst 300 force_thr_ev 0.001 calculation：FIRE 算法是基于 MD 方法的，因此需要将 calculation 设为 md md_type：采用 FIRE 算法，需要设为 fire md_tfirst：MD 需要离子速度，因此需要通过设置初始温度来随机生成离子速度，或者在 STRU 文件中手动设置初始速度 force_thr_ev：离子受力的收敛阈值，当离子受力的每个分量均小于该阈值或者 MD 运行至最大步数时，MD 终止 "},"abacus-sdft.html":{"url":"abacus-sdft.html","title":"ABACUS 随机波函数DFT方法使用教程","keywords":"","body":"ABACUS 随机波函数 DFT 方法使用教程 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/07/11 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍 ABACUS 中随机波函数密度泛函理论（Stochastic Density Functional Theory，以下简称 SDFT）计算功能。目前 ABACUS 使用 SDFT 主要聚焦在高温高压物质的模拟，特别是温稠密物质（Warm Dense Matter，简称 WDM）。在进行温稠密物质计算时（温度高达数十到上千 eV， 1 eV=11604.5 K），传统的 Kohn-Sham 密度泛函理论（KSDFT）需要用到极大数量的占据态电子波函数导致计算困难，而 SDFT 使用随机波函数轨道，可以有效地避开对角化哈密顿矩阵这个问题，应用于高温计算。关于 ABACUS 中实现 SDFT 算法的细节可以参考 Qianrui Liu and Mohan Chen*, \"Plane-wave-based stochastic-deterministic density functional theory for extended systems,\" Phys. Rev. B, 106, 125132 (2022)。本教程中将会展示如何在 ABACUS 计算中使用 SDFT 功能，此外还会介绍混合随机波函数密度泛函理论方法使用（mixed stochastic-deterministic DFT，简称 MDFT），即在 SDFT 计算中，混入一部分的低能 Kohn-Sham 轨道，从而加速结果收敛。 二、软件和算例准备 ABACUS 的软件包（3.2.0 版本）中提供了一个 SDFT 的算例，可以从 Gitee 上下载。可以在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载后解压，之后进入/abacus-user-guide/examples/stochastic 文件夹。算例中有三个文件夹，pw_Si2、pw_md_Al 和 186_PW_SDOS_10D10S。 三、采用 SDFT 进行电子自洽迭代计算 pw_Si2文件夹：这是一个电子温度为 0.6 Ry（约 8.16 eV）的 2 个原子的金刚石结构硅（Si）的电子自洽迭代（Self Consistent Field，简称 SCF）算例，包含布里渊区 K 点的 KPT 文件和包含原子位置的 STRU 文件与传统的 KSDFT 计算并无区别，主要的不同在于输入文件 INPUT，注意目前 SDFT 仅支持 smearing_method 为 fd。INPUT 文件如下： INPUT_PARAMETERS #Parameters (General) calculation scf esolver_type sdft pseudo_dir ../../PP_ORB nbands 4 nbands_sto 64 nche_sto 100 method_sto 1 #Parameters (Accuracy) ecutwfc 50 scf_nmax 20 symmetry 1 #Parameters (Smearing) smearing_method fd smearing_sigma 0.6 以上参数在 ABACUS 的线上文档中均有详细说明，这里再进行简单概述： calculation设置为 scf，代表进行电子自洽迭代计算（self-consistent field）。 esolver_type是选择系统总能量求解方法的，默认为 ksdft（Kohn-Sham density functiona theory），这里需要设置为 sdft 才会使用 SDFT 或者 MDFT 进行计算。 nbands是使用的 Kohn-Sham 轨道的数目（也叫 determinstic orbitals，是通过严格对角化矩阵计算出来的）。如果 nbands 设置为 0，且 nbands_sto（随机轨道数目，这里设成 64）不为 0，则会进行 SDFT 计算；如果 nbands>0，且 nbands_sto>0，则会进行混合 KS 电子轨道和随机轨道（stochastic orbitals）的 MDFT 计算。注意：一般 nbands 设置为能量低于费米能级对应的能带数，计算效率会比较高。 nbands_sto是使用随机波函数（stochastic orbitals）轨道数目，原则上取得越大则随机误差越小，但计算效率也会相应降低。 判断随机波函数个数是否足够的一个经验法则是：测试能量误差。实际计算中，一般可以采用10 个左右不同的随机数种子（可以参考 seed_sto 参数设置随机数种子，下面有介绍）生成的相同数目的随机波函数轨道进行 SDFT 计算，得到系统能量并求得相应误差，增加随机波函数轨道数目直到控制能量误差小于万分之一即可。 当 nbands_sto 设为 0 时， 程序会自动转成 KSDFT 进行计算（ABACUS 3.2.2 版本以后）。 nche_sto是将电子体系的哈密顿量进行切比雪夫展开的阶数，这个数取得越大则用到的切比雪夫展开阶数越多，相应的计算精度也会越高但效率会降低。大致关系为与温度成反比，温度越高，阶数可以取得越小；ecut（正比关系）越大，阶数越大；推荐使用的 nche_sto 的大小是使得输出文件 running_scf.log 中的 Chebyshev Precision 小于 1e-8。 method_sto是进行 SDFT 计算使用的方法：1 代表消耗内存较少但稍慢的方法，2 代表更快但需要更大内存的方法，默认是 2。 此外还有如下参数可能会用到： seed_sto：生成随机轨道的随机种子。默认是 0，代表随时间随机生成；若要控制使用相同的随机种子，可以设置一个大于 1 的整数。 bndpar：将所有并行的进程分成 bndpar 个组，计算所用随机轨道将平均分布在每个组中，可以提高并行效率，默认为 1。值得注意的是，这个参数并不是越大越好，并且不如 K 点并行（kpar参数）有效，实际计算中应该优先使用 K 点并行，然后测试不同大小的 bndpar，确定最佳的 bndpar。 平面波能量截断值 ecut 的测试：由于随机误差的出现，SDFT 的 ecut 的测试与传统的 KSDFT 稍有区别，但是原理是类似的。在确定好 nbands_sto 后，就可以测试 ecut 了。与测试 nbands_sto 类似，在不同的 ecut，需要采用 10 个左右不同的随机种子生成的相同数目的随机波函数轨道进行 SDFT 计算，然后取平均能量。由于温稠密物质能量一般都比较高，因此只要控制相邻二个 ecut（相差为 10 Ry）对应的平均能量差小于一定标准即可（例如万分之一）。 注 1：在这个例子里我们提供的赝势是 Si.pz-vbc.UPF 文件，这个文件包含 4 个硅的价电子。事实上，当温度特别高的时候，一般的赝势可能会面临可移植性差的问题，例如高温会使得内壳层电离。这个时候，要选择合理的赝势进行计算，甚至可能需要自己造一个新的赝势，目前 ABACUS 3.2.0 支持的是模守恒的赝势。 注 2：ABACUS 的 SDFT 和 MDFT 支持多个 k 点采样，因此可以在 KPT 文件里设置不同的 k 点个数，在某些性质的计算里，要注意计算性质随着 k 点的收敛。 四、采用 SDFT 进行分子动力学模拟 pw_md_Al 文件夹：这是一个电子温度为 7.35 Ry（约 100 eV）、包含 16 个铝（Al）原子的结构，我们对其进行分子动力学（Molecular Dynamics，简称 MD）的模拟。INPUT 文件如下： INPUT_PARAMETERS #Parameters (General) calculation md esolver_type sdft pseudo_dir ../../PP_ORB nbands 0 nbands_sto 64 nche_sto 20 method_sto 2 #Parameters (Accuracy) ecutwfc 50 scf_nmax 20 scf_thr 1e-6 symmetry 1 #Parameters (Smearing) smearing_method fd smearing_sigma 7.34986072 #Parameters (MD) md_tfirst 1160400 md_dt 0.2 md_nstep 10 注意要进行分子动力学模拟，calculation 参数需设置为 md。esolver_type 需设置为 sdft，才能进行 SDFT 的计算。这里 nbands 设置为 0，nbands_sto 设置为 64，代表仅仅使用随机轨道而没有 KS 轨道的 SDFT 计算。 五、采用 SDFT 计算态密度 186_PW_SDOS_10D10S 文件夹：采用 SDFT 还可以计算给定体系的态密度（Density of States，简称 DOS）。例如，186_PW_SDOS_10D10S 是一个 1 个 Si 原子的算例，电子温度约为0.6 Ry（约 8.16 eV）。如下所示： INPUT_PARAMETERS #Parameters (1.General) suffix autotest calculation scf esolver_type sdft method_sto 2 nbands 10 nbands_sto 10 nche_sto 120 emax_sto 0 emin_sto 0 seed_sto 20000 pseudo_dir ../../PP_ORB symmetry 1 kpar 1 bndpar 2 #Parameters (2.Iteration) ecutwfc 20 scf_thr 1e-6 scf_nmax 20 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method fd smearing_sigma 0.6 #Parameters (5.Mixing) mixing_type broyden mixing_beta 0.4 out_dos 1 dos_emin_ev -20 dos_emax_ev 100 dos_edelta_ev 0.1 dos_sigma 4 dos_nche 240 npart_sto 2 以上参数在 ABACUS 的线上文档中均有说明，这里再进行简单概述： out_dos：需要设置为 1，才能输出能态密度。 dos_emin_ev：能态密度的能量最小范围，单位 eV。 dos_emax_ev：能态密度的能量最大范围，单位 eV。 dos_edelta_ev：控制输出DOS时的能量间隔，单位 eV。 dos_sigma：能态密度的高斯展宽的因子，单位 eV。 dos_nche：计算能态密度时切比雪夫展开阶数，默认为 100。 npart_sto：当使用 method_sto＝2 运行例如 DOS 的 SDFT 后处理时，将控制使用内存大小为正常的 1/npart_sto，防止内存不够导致无法计算，默认为 1。 注：态密度的输出文件是 OUT 文件夹下的 DOS1_smearing.dat。 六、结尾 总体来讲，随机波函数密度泛函理论方法（SDFT 或者 MDFT）的使用与 KSDFT 并无太大的区别，直接运行 ABACUS 程序即可，但是对一些关键参数的选取会影响精度和效率（例如 nbands, nbands_sto, nche_sto, method_sto, kpar, bnd_par）。对于极端高温计算（>10 eV），使用 SDFT 可以大大提高计算速度，是比普通的 KSDFT 更好的选择。如果大家使用有问题，欢迎写信联系（见上）。 "},"abacus-ofdft.html":{"url":"abacus-ofdft.html","title":"ABACUS 无轨道密度泛函理论方法使用教程","keywords":"","body":"ABACUS 无轨道密度泛函理论方法使用教程 作者：孙亮，邮箱：l.sun@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/07/19 在Bohrium Notebook上快速学习： 一、无轨道密度泛函理论背景知识 无轨道密度泛函理论(Orbital free density functional theory, OFDFT)是一种第一性原理模拟方法，相比于 Kohn Sham DFT (KSDFT)，它的优势之一在于O(N\\ln N)的算法复杂度，这使得 OFDFT 可以用于上万原子甚至更大体系的电子基态计算，或者大体系、长时间的第一性原理分子动力学等。 目前，OFDFT 已被应用于简单金属、合金、半导体、小分子、温稠密物质等体系。 1. 无轨道密度泛函理论 在 OFDFT 的框架下，体系的总能量泛函可以写为 E_{\\rm{OF}}[\\rho] = T_{\\rm{s}}[\\rho] + E_{\\rm{ext}}[\\rho] + E_{\\rm{H}}[\\rho] + E_{\\rm{xc}}[\\rho] + E_{\\rm{II}}. 依次为无相互作用动能T_{\\rm{s}}[\\rho]，电子-离子相互作用能E_{\\rm{ext}}[\\rho]，电子-电子相互作用能E_{\\rm{H}}[\\rho]，交换关联能E_{\\rm{xc}}[\\rho]，离子-离子相互作用能E_{\\rm{II}}，其中\\rho为电荷密度。 为了在粒子数守恒的条件下求解其极小值，利用拉格朗日乘子法，定义 L=E_{OF}[\\rho]-\\mu(\\int{\\rho(r)dr}-N), 可以证明，这里的乘子\\mu就是无相互作用体系中最高占据态的能量，即化学势。为了保证密度处处为正，一般对\\sqrt\\rho进行优化，因此求L对\\sqrt\\rho的导数，为了方便，定义\\phi(r) = \\sqrt {\\rho(r)}，则有 \\frac{\\delta L}{\\delta \\phi}=\\frac{ \\delta E_{OF}[ \\rho ] }{ \\delta \\phi }-2\\mu\\phi=0 \\rightarrow V(r)\\phi(r)=\\mu\\phi(r). \\ \\ \\ \\ \\ \\ \\ \\ (*) 其中V(r)=\\frac{ \\delta E_{OF}[ \\rho ] }{ \\delta \\rho(r) }为势能。这就是 OFDFT 求解的方程，一般用共轭梯度（CG）法、截断牛顿（TN）法或 L-BFGS 等优化算法求解。目前 ABACUS 中实现了 TN 法和两种 CG 法（Polak-Ribire 形式和 Hager-Zhang 形式），默认采用 TN 法。 ABACUS 基于平面波基矢量，实现了上述流程，可以进行基于 OFDFT 的自洽计算，分子动力学计算，以及结构弛豫。 2. 动能泛函 OFDFT 的精度高度依赖于动能泛函（kinetic energy density functional, 简称 KEDF）的精度，目前 ABACUS 中实现了 Thomas-Fermi (TF) [1], von Weizsäcker (vW) [2], TFλvW [3], Wang-Teter (WT) [4], Luo-Karasiev-Trickey (LKT) [5]共五种动能泛函。 下面我们对这些泛函做简单介绍，并且介绍在 ABACUS 的 INPUT 文件中如何设置相关的参数。 2.1 Thomas-Fermi KEDF 设置 INPUT 文件中的 of_kinetic tf 参数 T_{\\rm{TF}}=\\frac{3}{10}(3\\pi^2)^{2/3}\\int{\\rho^{5/3}(r)dr}, 对均匀电子气精确成立，可用于极高温体系，比如处于温稠密状态的金属。 可通过 of_tf_weight 调整其权重，默认为 1。 2.2 von Weizsäcker KEDF 设置 of_kinetic vw T_{\\rm{vW}}=-\\frac{1}{2}\\int{\\sqrt{\\rho(r)} \\nabla^2 \\sqrt{\\rho(r)}dr}, 对单电子、双电子体系（只有一条轨道）严格成立，一般不单独使用。 可通过 of_vw_weight 调整其权重，默认为 1。 2.3 TFλvW KEDF 设置 of_kinetic tf+ T=T_\\text{TF}+\\lambda T_\\text{vW}, 当\\lambda=\\frac{1}{9}时就是TF KEDF的二阶梯度展开，一般\\lambda=\\frac{1}{5}时表现最好。 参数\\lambda可通过of_vw_weight设置，默认为1。 2.4 Wang-Teter KEDF 设置of_kinetic wt T_{\\rm{WT}} = \\frac{3}{10}(3\\pi^2)^{2/3} \\iint{\\rho ^{\\alpha}(r)W(r - r'){\\rho ^{\\beta}}(r') drdr'} + T_{\\rm{vW}} + T_{\\rm{TF}}, 基于 Lindhard 响应函数推导，在简单金属 Li、Mg、Al 中有着不错的表现。是 ABACUS 默认采用的 KEDF。 参数\\alpha,\\beta可通过 of_wt_alpha 和 of_wt_beta 设置，默认值均为\\frac{5}{6}。 2.5 Luo-Karasiev-Trickey KEDF 设置 of_kinetic lkt T_{\\rm{LKT}}= \\int{\\tau_{\\rm{TF}}\\frac{1}{\\cosh as}dr} + T_{\\rm{vW}}, s=\\frac{1}{2(3\\pi^2)^{1/3}}\\frac{|\\nabla\\rho|}{\\rho^{4/3}}. 可用于简单金属和半导体，计算效率较高，但在简单金属中精度低于 WT KEDF。 参数 a 可通过 of_lkt_a 设置，默认值为 1.3。 3. 局域赝势 由于 OFDFT 中舍弃了单电子轨道，无法采用常用的非局域赝势，如模守恒赝势，而必须采用局域赝势。 目前 ABACUS 支持 BLPS (bulk-derived local pseudopotential)。 下载地址： https://github.com/EACcodes/local-pseudopotentials实空间赝势：ABINIT, ABACUS； 倒空间赝势：PROFESS。赝势生成(需要和 ABINIT 7.0.5 结合)：https://github.com/EACcodes/BLPSGenerator覆盖 Li, Mg, Al, Si, P, Ga, As, In, Sb 九种元素 使用 BLPS 时，需要在 ABACUS 里调整的参数有： INPUT 中：pseudo_rcut 16 STRU 中：赝势种类设置为 blps，比如 Al 26.98 al.lda.lps blps 二、ABACUS 中进行 OFDFT 计算的具体流程 1. 自洽计算 1.1 示例 下面是输入文件的示例： INPUT 文件记录 OFDFT 计算所需主要参数 INPUT_PARAMETERS #Parameters (1.General) suffix example calculation scf esolver_type ofdft symmetry 1 pseudo_dir ../../PP_ORB/ pseudo_rcut 16 nspin 1 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 50 #Parameters (3.Basis) basis_type pw #OFDFT of_kinetic wt of_method tn STRU 文件记录元素种类、质量、赝势，晶格矢量，原子坐标等信息 ATOMIC_SPECIES Al 26.98 al.lda.lps blps LATTICE_CONSTANT 7.50241114482312 // add lattice constant LATTICE_VECTORS 0.000000000000 0.500000000000 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 0.500000000000 0.000000000000 ATOMIC_POSITIONS Direct Al 0 1 0.000000000000 0.000000000000 0.000000000000 1 1 1 KPT 文件（因为 OFDFT 没有电子波函数，所以不需要布里渊区的多个 k 点，Gamma 点就可以） K_POINTS 0 Gamma 1 1 1 0 0 0 如上所示，与 KSDFT 的自洽计算相比，OFDFT 自洽计算的输入文件有以下几个区别： INPUT 不需要设置 smearing 和 charge mixing 相关参数，如果设置了也没有关系，这些参数不会影响 OFDFT 计算； 将 esolver_type 设置为 ofdft； 将 pseudo_rcut 设置为 16，以适配 BLPS 赝势。 STRU 将赝势种类设置为 blps。 做完以上调整后，即可使用默认参数进行 OFDFT 的自洽计算。 下面列举一些其它的重要参数： of_kinetic：用于选择动能泛函，可选项有 tf, vw, tf+, wt, lkt，默认值为 wt，具体介绍见 1.2 节； of_method：用于选择优化方法，可选项有 tn, cg1, cg2，分别对应截断牛顿法和两种 CG 法（Polak-Ribire 形式和 Hager-Zhang 形式），默认为 tn。一般而言，效率上 tn > cg2 > cg1； of_full_pw：做快速傅里叶变换（FFT）时，是否使用全部的平面波，默认为 True。建议打开，可以保证计算的稳定性和精度； of_full_pw_dim：控制 FFT 维数的奇偶性，可选项有 0, 1, 2，分别表示可奇可偶，保证为奇数，保证为偶数，默认为 0。FFT 维数为偶数时，可能导致微小的误差，但一般来说可以忽略。需要注意的是，如果打开了 nbspline，则需要设置 of_full_pw_dim 1，否则会导致计算不稳定。 1.2 注意事项 目前 ABACUS 的 OFDFT 模块并不是十分完善，使用时请注意以下几个注意事项： 目前 OFDFT 不支持 gamma only，因此使用 OFDFT 功能时请关闭 gamma_only； 目前 OFDFT 只支持自旋简并，即 nspin 1 的计算； 如果使用 PBE 泛函，建议用 dft_functional XC_GGA_X_PBE+XC_GGA_C_PBE 调用 Libxc 中的 PBE，否则可能导致计算不稳定。 2. 分子动力学与结构弛豫 ABACUS 中支持使用 OFDFT 作为能量、力和应力的求解器，进行分子动力学模拟与结构弛豫。 与使用 KSDFT 进行分子动力学或结构弛豫相比，使用 OFDFT 时，不需要对 MD，relax，或 cell-relax 相关参数进行修改，只需要按照 2.1 中的方式，将能量、力和应力的求解器替换为 OFDFT。 下面是几个实际的 INPUT 例子： 2.1 分子动力学（MD） INPUT_PARAMETERS #Parameters (1.General) suffix test calculation md esolver_type ofdft pseudo_dir ../../PP_ORB pseudo_rcut 16 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #OFDFT of_kinetic wt of_method tn of_full_pw_dim 1 #Parameters (3.Basis) basis_type pw md_restart 0 md_type nvt md_nstep 2 md_dt 0.25 md_tfirst 58022.52706 md_dumpfreq 10 md_tfreq 1.08 md_tchain 1 nbspline 10 2.2 原子结构弛豫（relax） INPUT_PARAMETERS #Parameters (1.General) suffix test calculation relax esolver_type ofdft pseudo_dir ../../PP_ORB pseudo_rcut 16 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #OFDFT of_kinetic wt of_method tn #Parameters (3.Basis) basis_type pw relax_nmax 50 2.3 晶格弛豫（cell-relax） INPUT_PARAMETERS #Parameters (1.General) suffix test calculation cell-relax esolver_type ofdft pseudo_dir ../../PP_ORB pseudo_rcut 16 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #OFDFT of_kinetic wt of_method tn #Parameters (3.Basis) basis_type pw relax_nmax 50 三、参考文献 [1] Fermi E. Statistical method to determine some properties of atoms[J]. Rend. Accad. Naz. Lincei, 1927, 6(602-607): 5. [2] Weizsäcker C F. Zur theorie der kernmassen[J]. Zeitschrift für Physik, 1935, 96(7-8): 431-458. [3] Berk A. Lower-bound energy functionals and their application to diatomic systems[J]. Physical Review A, 1983, 28(4): 1908. [4] Wang L W, Teter M P. Kinetic-energy functional of the electron density[J]. Physical Review B, 1992, 45(23): 13196. [5] Luo K, Karasiev V V, Trickey S B. A simple generalized gradient approximation for the noninteracting kinetic energy density functional[J]. Physical Review B, 2018, 98(4): 041111. "},"abacus-surface2.html":{"url":"abacus-surface2.html","title":"采用 ABACUS 进行表面计算（二）：偶极修正","keywords":"","body":"采用 ABACUS 进行表面计算（二）：偶极修正 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/08/28 一、偶极修正介绍（Dipole Correction） 偶极矩（Dipole Moment）是一个矢量，由正、负电荷中心距离和其所带电量乘积得到，方向规定为正电中心指向负电中心，采用原子建模表面时，往往表面会产生偶极矩。 ABACUS 在 xyz 三个方向都采用周期性边界条件（Periodic Boundary Conditions），当使用密度泛函理论（Density Functional Theory，简称 DFT）进行表面体系的电子结构计算时常采用超胞（Supercell）近似，这时所研究的体系在真空方向会出现两个表面。当两个表面不对称时（例如在某表面进行吸附原子计算），这两个表面的电荷密度分布就会不同，这个时候两个表面的偶极密度不同且表面附近的静电势（Electrostatic Potential）会呈现不同的值。然而，周期性边界条件的存在会强制使得静电势也要满足周期性边界条件，这个时候周期性边界条件的存在相当于制造了一个非物理的人造电场（Artificial Electric Field）。 通常情况下，降低这个人造电场的方法是加大真空层的厚度，使得相邻的超胞之间没有相互作用，但这往往要大幅增加密度泛函理论的计算量。因此，为了消除周期性边界条件对表面偶极矩带来的影响，我们可以采用偶极修正（Dipole Correction）的方法，通过引入另外一个外电场来抵消这个人造电场，但注意引入的外电场需要存在于真空中（其位置是程序输入参数的一部分）才不至于影响所要研究的表面体系。经过修正后，人造电场将被抵消，真空电势则维持不变。 ABACUS 中实现了偶极修正功能[1]，可以有效的加速静电势收敛，避免超胞的真空取得太长，从而可以降低计算量。该修正功能主要体现在 Hartree 项的处理上，并且存在相应的原子受力的修正，可以用于平面波（Plane-Wave）基组和数值原子轨道（Numerical Atomic Orbitals）基组计算，但注意该功能只能用于带真空层的表面体系。 二、文档与算例 ABACUS 里关于偶极修正的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/scf/advanced.html#dipole-correction ABACUS 里关于偶极修正参数的线上文档地址为：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#electric-field-and-dipole-correction ABACUS 的偶极修正算例下载地址为（gitee）： https://gitee.com/MCresearch/abacus-user-guide/tree/master/examples/dipole_correction/H2O 可以采用的下载命令是： git clone https://gitee.com/MCresearch/abacus-user-guide 之后进入 /abacus-user-guide/examples/``dipole_correction/H2O/ 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/dipole_correction/H2O 三、偶极修正输入参数介绍 INPUT_PARAMETERS #Parameters (1.General) suffix H2O calculation scf nbands 6 symmetry 0 pseudo_dir ../../PP_ORB #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method fixed #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.7 #Parameters (6.Dipole correction) efield_flag 1 dip_cor_flag 1 efield_pos_max 0.0 efield_pos_dec 0.1 efield_amp 0.00 #Parameters (7.Output) out_pot 2 以算例提供的 INPUT 文件为例，使用偶极修正方法只需添加如下参数即可： efield_flag：类型是 Bool，指定外加电场的开(1)或者关(0)，默认值为 0，注意应用偶极修正功能时，efield_flag 必须设为 true dip_cor_flag：类型是 Bool，指定偶极修正的开(1)或者关(0)，默认值为 0 efield_dir：类型是 Int，外加电场方向，可取 0，1，2 分别表示 x，y，z 方向，默认值为 2 efield_pos_max：类型是 Real，锯齿状电势最大值所在分数坐标，范围[0,1)，默认值为 0.5 efield_pos_dec：类型是 Real，锯齿状电势从最大值到最小值的长度（同样以分数坐标为度量），默认值为 0.1，范围[0,1)。以图1为例，0.5 是最大值，0.6 是最小值，那么 0.5 ~ 0.6 的区域必须放置在没有原子的真空层中 efield_amp：类型是 Real，电场强度，默认值为 0，单位为 a.u.，其中 1 a.u. = 51.4220632*10^10 V/m。在偶极修正时需要设为 0，不为 0 则说明同时添加了外加电场和偶极修正 四、预期结果 如图2所示，一个水分子位于超胞（尺寸为 3\\times3\\times18 Å^3）的中部（即位于9 Å），那么按照上一部分的说明，锯齿应该放在没有原子的真空处，因此我们将电势的最大值所在的位置设为 efield_pos_max 设为 0.0，之后设置电势从最大值到最小值的长度，即将 efield_pos_dec 设为 0.1（在这个例子是 1.8 Å），如此锯齿即位于 0.0~0.1 的区域。 为了验证结果的正确性，我们可以画出静电势沿 Z 轴（c 方向）的变化如图3所示。在水分子上方（9-18 Å）和下方（0-9 Å）的真空层中，静电势在很长一段区间保持常数不变，出现了两个平台，这说明我们的偶极修正功能使用无误。静电势计算和作图方法请参考静电势和功函数计算文档。 五、参考文献 [1] Phys. Rev. B 59, 12301 (1999), https://doi.org/10.1103/PhysRevB.59.12301 "},"abacus-surface5.html":{"url":"abacus-surface5.html","title":"采用 ABACUS 进行表面计算（五）：外加电场","keywords":"","body":"采用 ABACUS 进行表面计算（五）：外加电场 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/08/28 一、介绍 电场是电荷及变化磁场周围空间里存在的一种特殊物质。这种物质与通常的实物不同，它虽然不是由分子原子所构成的，但它却是客观存在的特殊物质，具有通常物质所具有的力和能量等客观属性。许多材料在外加电场作用下会表现出不同寻常的性质，例如：铁电体在外加电场的作用下会产生电极化，也可以通过施加的电场来控制磁性和自发极化，因此在信息储存和传输中有广泛应用；二维材料（如石墨烯）在外加电场下表现出不同的电子性质和可控制的物理性质，这种特性使其具有在电子学领域的广泛应用前景。在电子结构计算中，周期性边界条件下对体系施加电场较为容易，而施加磁场则困难很多。 因此，外加电场是密度泛函理论（Density Functional Theory，简称 DFT）软件中可以被实现且重要的功能。ABACUS 中实现了在表面体系中外加恒定电场的功能[1]。注意，在 ABACUS 中，外加电场功能存在相应的原子受力的修正，可以用于平面波（Plane-Wave）基组和数值原子轨道（Numerical Atomic Orbitals）基组计算，但注意该功能只能用于带真空层的表面体系。 本教程中将会展示如何在 ABACUS 计算中使用加电场功能，为使得这个教程较为有趣，我们举一个半金属二维材料 nanoribbon（见图 1）加电场产生半金属的例子来讲解如何给体系添加电场，该 DFT 的计算工作曾发在 2006 年的 Nature 杂志上，具体可参考文献[2]。在这个教程里，我们使用的是数值原子轨道基矢量（Numerical Atomic Orbitals），碳和氢的轨道半径都是 8 a.u.，但实际上也可以使用平面波基矢量，只是前者效率更高所以在这里采用。我们还会使用到电子的自洽场（self-consistent field，简称 SCF）计算，非自洽计算（non-self-consistent field，简称 NSCF），自旋非极化和极化计算等概念。在不考虑自旋时（即设置 nspin=1 时），计算出的能带图中没有带隙，为金属；考虑自旋之后，带隙打开，成为半导体；在自旋极化基础上，外加恒定电场之后，其中一个自旋表现为半导体，另一个自旋则为金属。 二、软件和算例准备 ABACUS 里关于外加电场的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/scf/advanced.html#external-electric-field ABACUS 里关于外加电场参数的线上文档地址为：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#electric-field-and-dipole-correction ABACUS 的外加电场算例下载地址为（gitee）： https://gitee.com/MCresearch/abacus-user-guide/tree/master/examples/electric_field/ 可以采用的下载命令是： git clone https://gitee.com/MCresearch/abacus-user-guide 下载后解压，之后进入 /abacus-user-guide/examples/``electric_field 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide 三、采用加电场进行二维材料的能带计算 该算例中含有六个文件夹，解释如下： 1_unspin_scf：做非自旋极化（INPUT 文件中的 nspin 设为 1）的自洽场迭代 SCF 计算（INPUT 文件中的 calculation 设为 scf），输出自洽迭代之后的电子密度（将 INPUT 中的 out_chg 设为 1），注意二维材料的 KPT 文件，因为超胞大小是 102.459512146645 Å^3，所以对应的布里渊区 k 点取的是 1101，因为实空间周期长度小的方向对应的布里渊区大，所以需要取更多 k 点得到收敛结果。 2_unspin_band： 采用非自洽计算 NSCF（INPUT 文件中的 calculation 设为 nscf），读入上一个步骤输出的电荷密度（INPUT 文件中的 init_chg 设为 file），从而可以读入体系的基态电荷密度进行能带计算。 3_spin_scf：同 1_unspin_scf 的计算，只是把 nspin 设为 2。 4_spin_band：同 2_unspin_band 的计算，只是把 nspin 设为 2。 5_spin_elec_scf：同 3_spin_scf 的计算，只是又外加了电场的参数。 6_spin_elec_band：同 4_spin_band 的计算，只是又外加了电场的参数。 以下是算例 5 的输入文件（包含电场参数）： INPUT_PARAMETERS #Parameters (General) suffix nanoribbon calculation scf nbands 70 nspin 2 pseudo_dir ../../PP_ORB orbital_dir ../../PP_ORB #Parameters (Basis) basis_type lcao #Parameters (Accuracy) ecutwfc 100 scf_thr 1e-6 scf_nmax 200 #Parameters (Smearing) smearing_method gaussian smearing_sigma 0.001 #Parameters (Charge mixing) mixing_type pulay mixing_beta 0.1 mixing_ndim 20 mixing_gg0 1.5 #Parameters (Efield) efield_flag 1 efield_dir 2 efield_amp 0.0019440124 efield_pos_max 0.95 efield_pos_dec 0.10 以算例提供的 INPUT 文件为例，使用外加电场功能只需添加如下参数即可： efield_flag：类型是 Bool，指定外加电场的开(1)或者关(0)，默认值为 0 efield_dir：类型是 Int，外加电场方向，可取 0，1，2 分别表示 x，y，z 方向，默认值为 2 efield_pos_max：类型是 Real，锯齿状电势最大值所在分数坐标，范围[0,1)，默认值为 0.5 efield_pos_dec：类型是 Real，锯齿状电势从最大值到最小值的长度（同样以分数坐标为度量），默认值为 0.1，范围[0,1)。以图2为例，0.5 是最大值，0.6 是最小值，那么 0.5 ~ 0.6 的区域必须放置在没有原子的真空层中，注意这个例子设置的是 0.95 到 0.10 为电场区间。 efield_amp：类型是 Real，电场强度，默认值为 0，单位为 a.u.，其中 1 a.u. = 51.4220632*10^10 V/m 以上参数的使用方法在采用 ABACUS 进行表面计算（二）：偶极修正中有更详细的说明。 四、预期计算结果 运行完算例 2_unspin_band 后会通过非自洽计算得到体系非自旋极化能带图，横坐标是对二维材料布里渊区取 k 点，从 Gamma 点（坐标为 0 0 0）取到\\pi点（坐标为 0 0.5 0），取了 100 个 k 点算出来的能带图；纵坐标是能级，将费米面设置为 0，取了费米面附近 2 eV 的能量区间画出能带。以下两张图是同样取法。 运行完算例 4_spin_band 后会得到非自洽计算得到的自旋极化能带图（图 3）。 运行完算例 6_spin_elec_band 后会得到自旋极化加电场的能带图（图 4），注意这里所加的电场为 0.1 V/Å，由输入文件 INPUT 中的 efield_amp 设置，但 efield_amp 的单位是 a.u.，需要换算。 五、参考文献 [1] Phys. Rev. B 59, 12301 (1999), https://doi.org/10.1103/PhysRevB.59.12301 [2] Nature 444, 347–349 (2006), https://doi.org/10.1038/nature05180 "},"abacus-phonopy.html":{"url":"abacus-phonopy.html","title":"ABACUS+Phonopy 计算声子谱","keywords":"","body":"ABACUS+Phonopy 计算声子谱 作者：赵天琦，邮箱：zhaotq13@tsinghua.org.cn；陈涛，邮箱：chentao@stu.pku.edu.cn 审核：刘建川，邮箱：liujianchuan2013@163.com 最后更新时间：2023/08/14 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍采用 ABACUS（基于 ABACUS 3.2.2 版本）做密度泛函理论计算，并且结合 Phonopy 软件计算声子谱的流程。此外，本教程还用到 gnuplot 来绘图。 首先推荐大家阅读以下文档中的详细说明： ABACUS 官方文档：Phonopy - ABACUS documentation Phonopy 相关文档：ABACUS & phonopy calculation — Phonopy v.2.19.1 Gnuplot 主页：gnuplot homepage 二、准备 我们以 FCC Al 这个简单例子来演示使用 有限位移方法 来结合 ABACUS 和 Phonopy 计算声子谱。 1. 下载并安装 Phonopy git clone https://github.com/phonopy/phonopy.git cd phonopy python3 setup.py install 2. 下载 FCC Al 例子 可以从 Gitee 上下载。可以在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载后解压，之后进入 abacus-user-guide/examples/interface_Phonopy 文件夹 三、流程 1. 使用 ABACUS 优化结构 这里我们已经给出一个已经优化好的 FCC Al 结构 ABACUS 中的结构文件名为 STRU： ATOMIC_SPECIES Al 26.982 Al_ONCV_PBE-1.0.upf upf201 NUMERICAL_ORBITAL Al_gga_7au_100Ry_4s4p1d.orb LATTICE_CONSTANT 1.88972612546 LATTICE_VECTORS 4.03459549706 0 0 #latvec1 0 4.03459549706 0 #latvec2 0 0 4.03459549706 #latvec3 ATOMIC_POSITIONS Direct Al #label 0 #magnetism 4 #number of atoms 0 0 0 m 0 0 0 0.5 0.5 0 m 0 0 0 0.5 0 0.5 m 0 0 0 0 0.5 0.5 m 0 0 0 2. 用 Phonopy 产生需要计算的超胞及相应微扰构型 这里我们使用 有限位移方法 计算声子谱，因此需要对晶格进行扩胞并对原子位置进行微扰。执行如下命令即可生成 222 的扩胞并产生微扰结构： phonopy -d --dim=\"2 2 2\" --abacus 这一步 phonopy 会根据晶格对称性自动产生相应个数的微扰结构。由于 FCC 的晶格对称性较强，因此这个例子只产生一个微扰结构：STRU-001。这里类似 K 点的对称性分析，晶体结构对称性越强，所需的微扰结构就越少，对称性稍差的体系一般会产生多个微扰结构。 经验性设置：1）扩胞越大，计算结果越精确，但是计算量也会上升，一般来说扩胞三个方向的 cell 长度均在 10-20 Å 是比较合适的；2）对于优化后的晶胞（复杂体系），原子位置可能不处于高对称点上，phonopy 可能计算存在一定的误差，可以使用 Matertial Studio 等软件把对称性加回去之后，再做上述步骤，这样能够得到准确的声子谱数据（保证计算出来的声子谱满足体系的对称性特征）。 3. 产生 FORCE_SET 文件 接着用 ABACUS 计算原子受力，其中需要注意的是 calculation 需要设置为 scf，并且设置 cal_force 为 1，因为这一步目的是输出原子受力。 小技巧：即为了计算不同的微扰结构的受力，可以在 INPUT 里添加关键字 stru_file 来指定 STRU 文件的路径和文件名：stru_file ./STRU-001 INPUT 内容如下： INPUT_PARAMETERS #Parameters (1.General) suffix Al-fcc calculation scf esolver_type ksdft symmetry 1 pseudo_dir ./psp orbital_dir ./psp cal_stress 1 cal_force 1 stru_file STRU-001 #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-7 scf_nmax 50 #Parameters (3.Basis) basis_type lcao gamma_only 0 #Parameters (4.Smearing) smearing_method mp smearing_sigma 0.015 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.7 mixing_gg0 1.5 算完之后用以下命令产生 FORCE_SET 文件： phonopy -f ./disp-001/OUT/running_scf.log ./disp-002/OUT/running_scf.log ... 即要指定所有微扰构型算完之后的 running_scf.log 文件位置。如果运行有错，需要首先检查是否所有构型都已正常结束，且其中有力输出（可以找“FORCE”来确认）。 4. 设置 band.conf 文件计算得到声子谱 执行如下命令： phonopy -p band.conf --abacus band.conf 内容如下： ATOM_NAME = Al DIM = 2 2 2 MESH = 8 8 8 PRIMITIVE_AXES = 0 1/2 1/2 1/2 0 1/2 1/2 1/2 0 BAND = 1 1 1 1/2 1/2 1 3/8 3/8 3/4 0 0 0 1/2 1/2 1/2 BAND_POINTS = 101 BAND_CONNECTION = .TRUE. 这一步结束之后会有 band.yaml 文件输出 以上参数在 Phonopy 的线上文档中均有详细说明，这里再进行简单概述： ATOM_NAME：指定结构文件中的元素种类。 DIM：扩胞的大小，需要跟 3.2 用Phonopy产生需要计算的超胞及相应微扰构型 中的“dim”一致。 MESH：q 点的采样网格。‘8 8 8’意味着采用 888 的 q 点网格，默认以（0，0，0）为中心。 PRIMITIVE_AXES：输入晶胞到目标原胞的转换矩阵，并将根据原胞基矢量作为声子计算的坐标系。这里是 FCC 的原胞转换矩阵。 BAND：采样能带的 q 点路径。不同晶格的高对称点不同，具体可以使用 SeeK-path，自动生成 q 点路径。 BAND_POINTS：给出了包括能带路径末端的采样点的数量。 BAND_CONNECTION：在能带交叉处辅助连接能带。 5. 绘制声子谱 本教程使用 gnuplot 绘制声子谱，在 Ubuntu 上 gnuplot 的安装如下： sudo apt-get install gnuplot 用如下命令输出 gnuplot 格式的声子谱，并使用 gnuplot 绘制声子谱并存为 Al-FCC_plot.png： phonopy-bandplot --gnuplot > pho.dat gnuplot plot_pho.gp plot_pho.gp 内容如下： set terminal pngcairo size 1920, 1080 font 'Arial, 36' ## 格式，大小和字体 set output \"Al-FCC_plot.png\" ###输出的文件名 set ylabel 'Frequency (THz)' set ytics 2 unset key x1 = 0.13115990 x2 = 0.17753200 x3 = 0.31664810 xmax = 0.43023590 ymin = 0 ymax = 12 set xrange [0:xmax] set yrange [ymin:ymax] set xtics (\"{/Symbol G}\" 0, \"X\" x1, \"K\" x2, \"{/Symbol G}\" x3, \"L\" xmax) set arrow 1 nohead from x1,ymin to x1,ymax lt 2 set arrow 2 nohead from x2,ymin to x2,ymax lt 2 set arrow 3 nohead from x3,ymin to x3,ymax lt 2 plot 'pho.dat' using 1:($2) w l lw 3 FCC Al 的声子谱： 也可使用 Origin 绘图，pho.dat 的第一列就是上图的横轴（K 点路径），其中高对称 K 点位置见 pho.dat 的第二行，第二列就是上图的纵轴（声子频率，单位 THz）。 "},"abacus-shengbte.html":{"url":"abacus-shengbte.html","title":"ABACUS+ShengBTE 计算晶格热导率","keywords":"","body":"ABACUS+ShengBTE 计算晶格热导率 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/15 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍采用 ABACUS（基于 ABACUS 3.2.0 版本）做密度泛函理论计算，并且结合 ShengBTE 软件计算晶格的热导率的流程。其中，整个计算过程中还用到了：1）采用 Phonopy 程序来计算二阶力常数，2）采用 ASE 程序进行原子结构的转换，3）采用 ShengBTE 的 thirdorder 程序计算三阶力常数，4）最后使用 ShengBTE 来计算材料的晶格热导率。 上述提到了一些需要结合的外部软件，这里推荐大家阅读这些软件的相关文档和说明： ShengBTE：https://bitbucket.org/sousaw/shengbte/src/master/ phonopy：http://abacus.deepmodeling.com/en/latest/advanced/interface/phonopy.html ASE：http://abacus.deepmodeling.com/en/latest/advanced/interface/ase.html thirdorder: https://bitbucket.org/sousaw/thirdorder/src/master/ 二、准备 ABACUS 的软件包中提供了一个 ABACUS+ShengBTE 计算晶格热导率的算例，可以从 Gitee 上下载。算例中包含采用数值原子轨道的 LCAO（Linear Combination of Atomic Orbitals）和采用平面波基矢量的 PW（Plane Wave，平面波）两个文件夹。每个文件夹下分别又包含了 2nd、3rd 和 shengbte 这三个文件夹，分别保存了使用 phonopy 计算二阶力常数（2nd）、thirdorder 计算三阶力常数（3rd）和 ShengBTE 计算晶格热导率（shengbte）的相关文件。 三、流程 以 LCAO 文件夹为例，我们这里提供的测试案例是包含 2 个原子的金刚石结构 Si 结构，采用的模守恒赝势是 Si_ONCV_PBE-1.0.upf，以及原子轨道文件采用的是 Si_gga_7au_100Ry_2s2p1d.orb（GGA 泛函，7 au 截断半径，100 Ry 能量截断，以及包含 2s2p1d 的 DZP 轨道）。 1. 计算二阶力常数 要计算二阶力常数，除了 ABACUS 之外，还需要结合 Phonopy 和 ASE。首先，进入 2nd 文件夹。 1.1 结构优化 做晶格热导率计算之前要先对模拟的材料体系的进行原子构型的优化。下面是采用 ABACUS 做结构优化（relax）后得到的原子构型文件 STRU。在这个例子里，为了简单起见，结构优化过程采用的是 2*2*2 的布里渊区 k 点采样，平面波的能量截断值 ecut（LCAO 里面也用到了平面波基矢量）为 100 Ry，注意实际计算中应该要采用更收敛的 k 点采样。 ATOMIC_SPECIES Si 28.0855 Si_ONCV_PBE-1.0.upf NUMERICAL_ORBITAL Si_gga_7au_100Ry_2s2p1d.orb LATTICE_CONSTANT 1.88972612546 LATTICE_VECTORS 0 2.81594778072 2.81594778072 #latvec1 2.81594778072 0 2.81594778072 #latvec2 2.81594778072 2.81594778072 0 #latvec3 ATOMIC_POSITIONS Direct # direct coordinate Si #label 0 #magnetism 2 #number of atoms 0.875 0.875 0.875 m 0 0 0 0.125 0.125 0.125 m 0 0 0 注意：第一行 Si 的质量 28.0855 在计算中不起作用。 1.2 计算二阶力常数 调用 Phonopy 软件产生需要计算的超胞及相应微扰的多个原子构型，命令如下： phonopy setting.conf --abacus -d 其中 setting.conf 文件的内容为： DIM = 2 2 2 ATOM_NAME = Si 这里我们采用的 Si 的例子只需要产生 1 个微扰构型 STRU-001 即可，对所有微扰构型（这里 Si 的例子只有 1 个）进行 SCF 计算（SCF 代表 Self-consistent field，这里代表进行密度泛函理论的电子迭代自洽计算）获得原子受力，算完之后用以下命令产生 FORCE_SET 文件： phonopy -f OUT.DIA-50/running_scf.log 小技巧：在 ABACUS 的输入文件 INPUT 中可以设置变量 stru_file，该变量对应的原子构型文件为 STRU-001 则 ABACUS 可以直接读取该结构文件。 下一步，设置 band.conf 文件计算得到声子谱以及二阶力常数： phonopy -p band.conf --abacus 这里出现的 band.conf 文件，其内容如下（具体参数含义可以查看 Phonopy 说明文档）： ATOM_NAME = Si DIM = 2 2 2 MESH = 8 8 8 PRIMITIVE_AXES = 1 0 0 0 1 0 0 0 1 BAND = 0.0 0.0 0.0 0.5 0.0 0.5 0.625 0.25 0.625, 0.375 0.375 0.75 00 0.0 0.0 0.5 0.5 0.5 BAND_POINTS = 101 BAND_CONNECTION = .TRUE. FORCE_CONSTANTS = WRITE FULL_FORCE_CONSTANTS = .TRUE. 这一步结束之后，Phonopy 软件会产生 band.yaml（用于绘制声子谱）和 FORCE_CONSTANTS 文件。其中，FORCE_CONSTANTS 文件包含的数据即为二阶力常数，注意这里务必设置 FULL_FORCE_CONSTANTS = .TRUE.，输出全部的二阶力常数，否则 ShengBTE 读取数据会报错。 此外，可以使用如下命令输出 gnuplot 格式的声子谱，用于绘制声子谱： phonopy-bandplot --gnuplot > pho.dat 1.3 后处理 注意 ShengBTE 软件要求 FORCE_CONSTANTS_2ND 文件里数据的单位为 eV/Å^2，但是 ABACUS 结合 phonopy 计算的 FORCE_CONSTANTS 单位为 eV/(Å*au)，其中 au 是原子单位制，1 au=0.52918 Å。可以使用 2nd 目录下提供的 au2si.py 脚本进行单位转换，生成 FORCE_CONSTANTS_2ND 文件，命令如下： python au2si.py 在 shengbte 文件夹中提供了 FORCE_CONSTANTS_2ND 文件供参考计算结果。 2. 计算三阶力常数 要计算三阶力常数，需要结合 thirdorder 程序，计算后输出三阶力常数文件 FORCE_CONSTANTS_3RD。但是，thirdorder 目前只支持读取 VASP 和 QE 的输入输出文件。因此，这里我们是通过将 ABACUS 的结构文件和输出受力分别转换为 POSCAR 和 vasprun.xml 来使用 thirdorder，请先进入 3rd 文件夹，具体步骤将在以下叙述。 2.1 获得微扰构型 首先将 ABACUS 软件进行结构优化（relax）后的 STRU 文件转化为 POSCAR（目录下已给出转化过的 POSCAR，或者需要自己动手进行这个转换）。 之后，运行 thirdorder_vasp 程序，产生微扰过后的一系列原子构型文件 3RD.POSCAR.*，例如这个例子一共产生了 40 个构型： thirdorder_vasp.py sow 2 2 2 -2 运行 pos2stru.py，将上述 POSCAR 转化为 STRU 文件，注意该脚本里调用了 ASE 软件包的函数（需提前安装好 ASE）： python pos2stru.py 注意：这里不能调用 dpdata 软件进行转化。因为 dpdata 会强制将晶格改为下三角矩阵，相当于旋转了晶格，会导致原子间受力方向也相应旋转，从而发生错误。 2.2 计算微扰构型的原子受力 可以参考目录下 run_stru.sh 使用脚本批量产生 SCF-* 文件夹并提交计算，这里需要采用 ABACUS 对 40 个原子构型分别进行 SCF 计算，会有些耗时。建议每个 SCF 单独在 SCF-* 文件夹内运行，这里的 INPUT 中的scf_thr 需要至少小到1e-8才能得到收敛的结果。 计算完成后，运行 aba2vasp.py，将 ABACUS 计算的原子受力包装成 vasprun.xml 格式，放置在每个 SCF-* 文件夹中，命令如下： python aba2vasp.py vasprun.xml 格式示意： 1.865e-05 -0.04644196 -0.00153852 -1.77e-05 -0.00037715 -0.00149635 1.973e-05 0.002213 -0.00149461 -1.976e-05 0.00065303 -0.0014804 8.31e-06 -0.0003306 -0.00024288 -8.25e-06 -0.00038306 -0.00025385 1.071e-05 0.00060621 -0.00025797 -1.05e-05 -0.00014553 -0.00027532 0.00668053 0.00645634 -0.04642593 -0.00668085 0.00645595 -0.00040122 -0.00650454 0.00628877 -0.00025123 0.00650504 0.00628892 -0.00028948 -0.00039591 2.479e-05 0.00223371 0.00039608 2.426e-05 0.0006732 0.0003264 3.122e-05 0.00052874 -0.00032589 3.415e-05 -0.00023577 -2.908e-05 -0.00832477 0.00635709 3.737e-05 -0.00125057 -7.444e-05 -2.582e-05 0.00656076 0.00636285 2.566e-05 -0.00049974 -6.661e-05 -5.431e-05 0.00502637 0.00639077 4.553e-05 -0.00180978 0.0001325 -3.609e-05 -0.00676473 0.00638092 3.806e-05 5.503e-05 0.00012759 -0.00670704 0.00646596 0.01310437 0.00670119 3.673e-05 0.00602948 0.00036366 0.00627899 -0.00657272 -0.00036508 2.288e-05 0.00026009 0.00648649 0.0064463 -0.00036521 -0.00648098 1.594e-05 0.00671469 -0.00034493 0.00630074 0.00662932 0.00034331 4.157e-05 -0.0002028 最后执行如下命令： find SCF-* -name vasprun.xml|sort -n|thirdorder_vasp.py reap 2 2 2 -2 即可得到三阶力常数文件 FORCE_CONSTANTS_3RD。在 shengbte 文件夹中提供了 FORCE_CONSTANTS_3rd 文件供参考计算结果。 3. 运行 ShengBTE 得到晶格热导率 进入 shengbte 文件夹，里面已经准备好 CONTROL（ShengBTE 的参数文件）、FORCE_CONSTANTS_2ND（二阶力常数文件）、FORCE_CONSTANTS_3RD（三阶力常数文件）这三个文件，使用如下命令运行 ShengBTE 即可得到晶格热导率，其中 Ref 文件夹中给出了计算结果供参考： mpirun -n 10 ShengBTE 四、结尾 对于 ABACUS 中使用平面波（PW）来做 ShengBTE 的计算也是采用以上类似的流程，但要注意使用平面波时，计算三阶力常数的 INPUT 中scf_thr 需要至少小到1e-12。通过计算结果可以发现，PW 和 LCAO 基组计算出的 Si 的晶格热导率是接近的，300 K 下均在 100 W/(m K) 左右，而实验中 Si 在 300 K 的热导率在 150 W/(m K) 附近。这是因为作为教学例子，这里使用的是 2*2*2 的扩胞以及 2*2*2 的 K 点，导致计算结果偏小，实际科研中需要测试扩胞的大小以及 K 点的采样方案来达到收敛的结果。以上就是 ABACUS(3.2.0)+ShengBTE 计算晶格热导率的全部流程，如果有什么问题，欢迎通过邮件联系。 "},"abacus-dpgen.html":{"url":"abacus-dpgen.html","title":"ABACUS+DPGEN 使用教程","keywords":"","body":"ABACUS+DPGEN 使用教程 作者：刘建川，邮箱：liujianchuan2013@163.com 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/15 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍结合 ABACUS（中文名原子算筹，这里基于 ABACUS 3.2.0 版本）和 DPGEN 软件结合生成机器学习 DP 势，这里 ABACUS 扮演了提供第一性原理训练数据的作用。本教程以碳化硅（SiC）材料为案例，并且教大家使用 DPGEN autotest 功能，计算 SiC 的 Equation of State (EOS)和弹性常数等性质。先介绍主要软件和计算平台： DPGEN软件：是一个结合第一性原理软件来自动产生训练数据标签的软件，如果不熟悉 DPGEN 的读者，这里可以推荐大家先阅读 DPGEN 的相关原理文档和说明，熟悉这部分的读者可以跳过： https://docs.deepmodeling.com/projects/dpgen/en/latest/ https://bohrium-doc.dp.tech/docs/software/DP-GEN https://bohrium-doc.dp.tech/docs/software/DP-GEN_init https://bohrium-doc.dp.tech/docs/software/DP-GEN_autotest https://www.sciencedirect.com/science/article/pii/S001046552030045X?via%3Dihub 计算平台：由于本案例通过 Bohrium 平台教学，所以所用到的 machine.json 文件仅限于 Bohrium 平台使用，如需在其他平台上使用，可参考下面网址，修改 machine.json 文件： https://docs.deepmodeling.com/projects/dpgen/en/latest/run/example-of-machine.html 二、准备 1. 案例下载地址 本教程用到的所有输入文件，均可点击这里下载。 (https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/abacus-dpgen) 此外，在 Linux 下可以采用的下载命令是： git clone https://gitee.com/mcresearch/abacus-user-guide.git 之后进入 /abacus-user-guide/examples/md 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/md 下载完之后，应该可以看到三个文件夹： init，run，以及 auto-test init 文件夹：包含用于 dpgen init_bulk 步骤所需的输入文件，用户可参考其设置自己的体系参数。 run 文件夹：包含用于 dpgen run 步骤所需的输入文件，用户可参考其设置自己的体系参数。 auto-test 文件夹：包含用于计算弹性常数等性质的输入文件，用户可参考其设置自己的体系参数。 2. 安装相关软件 这里默认读者已经安装好了 ABACUS 软件，本算例中 ABACUS 计算采用的是数值原子轨道的 LCAO（Linear Combination of Atomic Orbitals）方法，因为一般来说 LCAO 会比平面波效率更高，此外读者也可以把密度泛函理论计算部分改成平面波基矢量（后续会讲到）。 开始之前，请务必安装/更新 dpgen 和 dpdata（用来转换数据）到最新版本： 1. 安装/更新 dpdata pip install --user git+``https://gitee.com/deepmodeling/dpdata.git@devel 2. 安装/更新 dpgen pip install --user git+``https://gitee.com/deepmodeling/dpgen.git@devel 三、结合 DPGEN 生成 DP 数据的流程 DPGEN 使用流程如下，接下来我们将一一展开介绍： 1. 准备赝势和数值原子轨道文件 本例子所需文件有： 模守恒赝势文件，格式为*.upf，也可以使用其他 ABACUS 支持的赝势格式，注意 ABACUS 目前不支持 PAW 方法或者超软赝势。 数值原子轨道文件，格式为*.orb，注意这里的数值原子轨道文件要和赝势文件匹配，也就是数值原子轨道是由指定赝势产生的，关于如何生成数值原子轨道，我们会提供中文教程。 注：在 ABACUS 官网上可以下载到赝势和数值原子轨道文件： http://abacus.ustc.edu.cn/pseudo/list.htm 本例采用的赝势和轨道是： C 的 PBE 模守恒 ONCV 模守恒赝势：C_ONCV_PBE-1.0.upf Si 的 PBE 模守恒 ONCV 模守恒赝势：Si_ONCV_PBE-1.0.upf C 的 PBE 模守恒 ONCV 赝势对应的数值原子轨道：C_gga_9au_100Ry_3s3p2d.orb Si 的 PBE 模守恒 ONCV 赝势对应的数值原子轨道：Si_gga_9au_100Ry_3s3p2d.orb 注：如果是使用平面波基矢量来做密度泛函理论计算，则不需要提供数值原子轨道文件，结合 DPGEN 使用的流程是一致的（仅需要删除调用轨道文件的输入参数即可）。如果采用其他 ABACUS 支持的赝势文件，可自行生成轨道文件（请参考本教程系列的其它相关中文教程）. 注：这里 C_gga_9au_100Ry_3s3p2d.orb 的意思是 C 元素、采用 GGA 泛函、轨道截断半径是 9 a.u.（轨道截断半径越大，则 ABACUS 所需求解 Kohn-Sham 方程的时间会越长，而且这个时间对于轨道半径极其敏感，推荐可以测试不同轨道半径，选取合适的、截断半径小的轨道可以加速计算），100 Ry 是推荐的平面波截断值（哪怕用了数值原子轨道，程序里还是会用平面波来做某些物理量的计算，比如模守恒赝势的局域赝势部分），3s3p2d 表示 3 个 s 径向轨道、3 个 p 轨道、2 个 d 轨道。 2. 准备原子体系的结构文件 本步骤所需的描述原子结构的文件有： *.cif 可以从多个渠道下载所需体系的结构文件，本案例主要从 materials project 网站下载 cif 文件，使用的 SiC 对应多个原子构型，主要有 3C、2H、4H、6H 四个构型，采用哪些构型取决于用户所研究的体系和性质，一般可选取所关心的物质温度和压强区间内可能出现的结构。本案例主要采用3C 和 2H构型来演示。 3C-SiC：https://materialsproject.org/materials/mp-8062?formula=SiC 2H-SiC: https://materialsproject.org/materials/mp-7140?_skip=15&formula=SiC 4H-SiC: https://materialsproject.org/materials/mp-11714?formula=SiC 6H-SiC: https://materialsproject.org/materials/mp-7631?formula=SiC 得到了 cif 之后，可以使用下列方法把 cif 转换成 STRU 文件： 1. 安装 ASE-ABACUS 接口： git clone https://gitlab.com/1041176461/ase-abacus.git cd ase-abacus python3 setup.py install 2. 设置环境变量（可选） ABACUS 支持两种基组：平面波（PW）和数值原子轨道（LCAO）。赝势和轨道文件的存放路径可以通过环境变量设置，分别为：ABACUS_PP_PATH 和 ABACUS_ORBITAL_PATH,设置方法如下： PP=${HOME}/pseudopotentials ORB=${HOME}/orbitals export ABACUS_PP_PATH=${PP} export ABACUS_ORBITAL_PATH=${ORB} PW 计算只需要设置 ABACUS_PP_PATH 。 LCAO 需要两个都设置：ABACUS_PP_PATH and ABACUS_ORBITAL_PATH 。 3. CIF 转 STRU from ase.io import read, write from pathlib import Path cs_dir = './' cs_vasp = Path(cs_dir, 'SiC.cif') # 修改为自己的cif文件名 cs_atoms = read(cs_vasp, format='cif') cs_stru = Path(cs_dir, 'STRU') pp = {'Si':'Si_ONCV_PBE-1.0.upf','C':'C_ONCV_PBE-1.0.upf'} # 修改为所对应的赝势文件名 basis = {'Si':'Si_gga_9au_100Ry_3s3p2d.orb','C':'C_gga_9au_100Ry_3s3p2d.orb'} # 修改为所对应的轨道文件名 write(cs_stru, cs_atoms, format='abacus', pp=pp, basis=basis) 运行上述 python 脚本，把 cif 转成 ABACUS 所需的 STRU 文件。 3. 产生初始训练数据 本步骤所需文件有： 原子结构文件：STRU 数值原子轨道文件：*.orb 赝势文件：*.upf 布里渊区 k 点采样：KPT 提交任务的文件：machine.json DPGEN 的输入参数文件：param.json 为每一个构型新建一个名为 init 的文件夹。进入该文件夹后，为每个构型都新建一个单独的文件夹，之后单独运行 dpgen init_bulk 命令，用于产生接下来的 dpgen run 步骤的初始数据集。本案例所提供的初始原子构型为 3C 和 2H 结构，并把赝势文件、轨道文件、STRU 文件放入对应的文件夹里。按照下面链接的案例准备适合自己机器的 machine.json 文件，并分别放入 3C 和 2H 文件夹。 https://docs.deepmodeling.com/projects/dpgen/en/latest/run/example-of-machine.html 本教程所用到的文件可以从 Gitee 下载，修改为符合自己的配置即可。 接下来准备 param.jsion 文件，本步骤最关键的设置也是 param.json 文件设置，案例如下： { \"init_fp_style\": \"ABACUS\", \"stages\": [1,2,3,4], \"cell_type\": \"diamond\", \"super_cell\": [1, 1, 1], \"elements\": [\"Si\",\"C\"], \"from_poscar\": true, \"from_poscar_path\": \"./STRU\", \"potcars\": [\"Si_ONCV_PBE-1.0.upf\",\"C_ONCV_PBE-1.0.upf\"], \"orb_files\": [\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C_gga_9au_100Ry_3s3p2d.orb\"], \"relax_incar\": \"./INPUT_rlx\", \"md_incar\" : \"./INPUT_md\", \"relax_kpt\": \"./KPT\", \"md_kpt\": \"./KPT\", \"md_nstep\": 10, \"scale\": [0.99,1.00,1.01], \"skip_relax\": false, \"pert_numb\": 10, \"pert_box\": 0.03, \"pert_atom\": 0.01, \"deepgen_templ\": \"../generator/template/\", \"coll_ndata\": 5000, \"_comment\": \"that's all\" } init_fp_style 关键字需设置为 ABACUS，如果 from_poscar 为 true，则会读取 from_poscar_path 指定的 STRU 文件，且 cell_type 关键字失效。super_cell 用于括胞，推荐直接使用括胞之后的 STRU 文件，则 super_cell 设置为[1, 1, 1]。括胞一般根据需求而定，使得三个方向的 cell 长度约为 6 埃以上（经验性的）。其中还用到了 *.``upf 和 *.``orb 文件，修改为自己所计算的体系即可。 init_bulk 的基本操作流程分为以下 4 个顺序步骤： 生成初始(平衡)结构：输出文件存储在 00.place_ele。 产生 MD 起始构象：放缩扰动 00.place_ele 中的结构，输出文件存储在 01.scale_pert。 执行 AIMD：取 01.scale_pert 起始构象调用 vasp 执行少步数 AIMD，输出文件存储在 02.md。 整理初始数据：调用 dpdata 提取 02.md 中 AIMD 各 snapshots 的数据作为初始数据，输出文件存储在 02.md。 param.json 中将使用 stages 关键词的取值 1~4 控制以上 4 步的执行，操作中，各步骤(2, 3, 4 在所需前一步输出文件存在的前提下)可独立执行。 其他具体参数含义可参考 dpgen 官网： https://docs.deepmodeling.com/projects/dpgen/en/latest/init/init-bulk-jdata.html 另外，还需准备两个 ABACUS 输入文件 INPUT_rlx 和 INPUT_md。 INPUT_rlx 主要用于优化所下载的结构，如下： INPUT_PARAMETERS #Parameters (1.General) suffix ABACUS calculation cell-relax #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type lcao #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.002 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 cal_stress 1 INPUT_md 主要用于产生一定数量的 AIMD 轨迹，用于 DPGEN 迭代的输出数据，如下： INPUT_PARAMETERS #Parameters (1.General) suffix ABACUS calculation md #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type lcao #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.002 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 cal_stress 1 #MD chg_extrap second-order md_type 2 md_tfirst 300 md_tlast 300 md_nstep 10 md_tfirst 10 md_tfreq 0.5 注：ABACUS 的 MD 关键字在此 3.2.0新版本有所更改，如果是使用的最新版本，请严格参考手册设置关键字，如md_type在新版本里改为了nvt、npt等形式，而不再用数字（如：2）等： 此外，还需准备一个存放布里渊区 k 点的文件，名为 KPT： K_POINTS 0 Gamma 4 4 4 0 0 0 也可在 INPUT 文件里直接指定 kspacing 参数（注意该参数可选 1 维或者 3 维，如果是表面系统可选 3 维因为真空方向不需要太多 k 点）。 用户可自行根据所研究体系，设置、更改上述参数。 所有以上输入文件准备完毕后，采用如下命令分别对 3C 和 2H 结构运行 dpgen： nohup dpgen init_bulk param.json machine.json 1>log 2>err& 上述命令采用后台提交 dpgen，等所有计算完成之后，dpgen 会自动收集训练 DP 势所需的数据，且转换为 DeePMD-kit 的数据格式，保存在 ./STRU.01x01x01/02.md/sys-0036-0036/deepmd 目录里。 4. 进行数据采样的迭代 run主流程包含一系列迭代，各迭代会根据所选系综在给定的温度、压力或体积等条件下进行 DPMD 采样与筛选，实现同步学习，所有迭代希望能够有效覆盖训练可靠模型所需的势能面上样本空间。每个迭代依次：基于init 准备的初始训练数据与之前迭代积累的训练数据|训练多个新的模型->使用当前的模型进行DPMD采样，根据模型间预测偏差(model-deviation)|挑选候选 snapshot 构象->将本轮候选 snapshot 构象进行第一性原理标定并加入数据集|扩展数据集 。 以上每个迭代中包含的 3 个步骤分别被命名为 00.train，01.model_devi，02.fp，细节如下： 00.train: 使用 init 准备的初始训练数据与之前迭代积累的训练数据，调用 DeepMD-kit 训练多个 (默认 4 个) 模型。模型间的唯一区别来自于初始化神经网络时使用不同的随机数种子。 01.model_devi: 指代 model-deviation。 调用 LAMMPS 使用 00.train 的 1 个模型进行 MD 模拟。对于任一 MD 中 snapshot，模型间预测偏差越大意味着当前模型系综对该 snapshot 构象的精度越低，通过引入模型偏差作为误差判据并设定上下限, 挑选出有希望有效改进模型对 PES 整体预测精度的 snapshot 构象，作为准备加入训练数据集的候选构象。 02.fp: 调用 ABACUS 对 01.model_devi 选取的候选构象进行第一性原理定标(单点计算)，并调用 dpdata 收集整理所得数据加入到训练数据集中。 run 执行后，相关文件即存储在....../iter.*(迭代序号)/步骤文件夹内。以上每个迭代中的每个步骤在实现中被分解为 3 个阶段。以 00.train 为例，3 阶段分别对应: 0：make_train ，为训练任务准备脚本；1： run_train，依据机器配置上传文件并执行训练任务；2：post_train，收集整理分析训练任务的结果。01.model_devi 与 02.fp 的实现步骤与之类似，分别使用 3，4，5 及 6，7，8 来标记其阶段。 用输出文件record.dpgen来记录进程已经执行过及当前正在执行的阶段。如进程中断后需要续算，DP-GEN将根据此文件的记录来自动恢复run主进程。用户也可根据需求手动修改record.dpgen中的记录，来控制接下来将执行哪一阶段的任务：例如，删除最后一阶段(可能未执行完成即中断)的记录，并从前一个已完成阶段后恢复任务。可以通过查看record.dpgen文件监控当前任务的执行阶段。 本步骤所需文件有： STRU *.orb *.upf machine.json （可以直接用 dpgen init bulk 里的） param.json dpgen init bulk 产生的初始训练数据 主要步骤如下： 1. 新建一个文件夹，命名为：run，并进入此目录里 2. 在 run 文件夹里面新建 init_conf 和 init_data 文件夹，用于存放 dpgen init bulk 产生的构型和初始训练数据 3. 为了区分不同构型和初始训练数据，在 init_conf 和 init_data 文件夹里新建名为 3C 和 2H 的两个文件夹 4. 拷贝 dpgen init bulk 产生的构型和初始训练数据至 init_conf 和 init_data 文件夹里，如： cp -rf yourPath/init/3C/STRU.01x01x01/02.md/sys-0032-0032 yourPath/run/init_conf/3C cp -rf yourPath/init/2H/STRU.01x01x01/02.md/sys-0036-0036 yourPath/run/init_conf/2H cp -rf yourPath/init/3C/STRU.01x01x01/02.md/sys-0032-0032/deepmd/* yourPath/run/init_data/3C cp -rf yourPath/init/2H/STRU.01x01x01/02.md/sys-0036-0036/deepmd/* yourPath/run/init_data/2H 5. 拷贝 machine.json、*.orb 和 *.upf 文件到 run 文件夹 6. 新建一个 param.json 文件，如下案例： { \"type_map\": [\"Si\",\"C\"], \"mass_map\": [28.085,12.011], \"init_data_prefix\": \"./init_data\", \"init_data_sys\": [ \"3C\", \"2H\" ], \"sys_format\":\"abacus/stru\", \"sys_configs_prefix\": \"./init_conf\", \"sys_configs\": [ [\"3C/sys-0032-0032/scale-1.000/00****/STRU\"], [\"2H/sys-0036-0036/scale-1.000/00****/STRU\"] ], \"_comment\": \" that's all \", \"numb_models\": 4, \"default_training_param\": { \"model\": { \"type_map\": [\"Si\",\"C\"], \"descriptor\": { \"type\": \"se_e2_a\", \"sel\": \"auto\", \"rcut_smth\": 0.5, \"rcut\": 6.0, \"neuron\": [25, 50, 100], \"resnet_dt\": true, \"axis_neuron\": 12, \"seed\": 1 }, \"fitting_net\": { \"neuron\": [240, 240, 240], \"resnet_dt\": false, \"seed\": 1 } }, \"learning_rate\": { \"type\": \"exp\", \"start_lr\": 0.001, \"stop_lr\": 3.5e-8, \"decay_steps\": 2000 }, \"loss\": { \"start_pref_e\": 0.02, \"limit_pref_e\": 2, \"start_pref_f\": 1000, \"limit_pref_f\": 1, \"start_pref_v\": 0.0, \"limit_pref_v\": 0.0 }, \"training\": { \"stop_batch\": 400000, \"disp_file\": \"lcurve.out\", \"disp_freq\": 100, \"numb_test\": 10, \"save_freq\": 1000, \"save_ckpt\": \"model.ckpt\", \"disp_training\": true, \"time_training\": true, \"profiling\": false, \"profiling_file\": \"timeline.json\", \"_comment\": \"that's all\" } }, \"model_devi_dt\": 0.002, \"model_devi_skip\": 1000, \"model_devi_f_trust_lo\": 0.05, \"model_devi_f_trust_hi\": 0.10, \"model_devi_clean_traj\": true, \"model_devi_merge_traj\": true, \"model_devi_jobs\": [ {\"sys_idx\": [0,1], \"temps\":[50, 250, 450, 650], \"press\": [0, 100, 1000, 5000, 10000, 20000, 50000], \"trj_freq\": 10, \"nsteps\": 3000, \"ensemble\": \"npt-tri\", \"_idx\": \"01\"}, {\"sys_idx\": [0,1], \"temps\":[50, 250, 450, 650], \"press\": [0, 100, 1000, 5000, 10000, 20000, 50000], \"trj_freq\": 10, \"nsteps\": 3000, \"ensemble\": \"npt-tri\", \"_idx\": \"02\"} ], \"fp_style\": \"abacus\", \"shuffle_poscar\": false, \"fp_task_max\": 100, \"fp_task_min\": 5, \"fp_accurate_threshold\": 0.999, \"fp_accurate_soft_threshold\": 0.998, \"fp_pp_path\": \"./\", \"fp_pp_files\": [\"Si_ONCV_PBE-1.0.upf\",\"C_ONCV_PBE-1.0.upf\"], \"fp_orb_files\": [\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C_gga_9au_100Ry_3s3p2d.orb\"], \"user_fp_params\":{ \"ntype\": 2, \"symmetry\": 0, \"basis_type\": \"lcao\", \"ecutwfc\": 100, \"scf_thr\": 1e-6, \"scf_nmax\": 100, \"smearing_method\": \"gauss\", \"smearing_sigma\": 0.002, \"mixing_type\": \"pulay\", \"mixing_beta\": 0.3, \"cal_force\": 1, \"cal_stress\": 1, \"kspacing\": 0.08 } } type_map: 用列表方式设置了体系元素，注意顺序要和 STRU 结构文件里一致 mass_map: 记录了对应的原子质量，和 type_map 对应 init_data_prefix：指定初始训练集的位置所在目录，如：./init_data init_data_sys：定位到初始训练集的具体目录，用列表调用多个，即：./init_data/2H sys_format：指定为 ABACUS 计算的结构，即：abacus/stru sys_configs_prefix：指定探索步所需调用的结构目录，如：./init_conf sys_configs：指定具体的某个构型的目录，用列表调用多个，即：./init_conf/3C/sys-0032-0032/scale-1.000/00****/STRU。其中 00为通配符，dpgen 会遍历 00所有文件夹的 STRU 文件 model_devi_f_trust_lo 和 model_devi_f_trust_hi：可由“init 数据” 中力绝对值的平均值，然后取该值的 20%-50%，设置成 trust level 的上下限。可通过以下 python 脚本计算：（注意指定初始数据位置） import dpdata import numpy as np do06=dpdata.Labeledsystem(\"./\"，\"deepmd/raw\") forces = np.absolute(d006[\"forces\"]) af = np.average(forces) f_trust_lo = af*0.2 f_trust_hi = af*0.5 print(f_trust_lo,f_trust_hi) 如果体系温度升高后力的幅度变大，trust level 也要增大设置 model_devi_jobs 里面每一行代表一轮，每轮设置参数为 LAMMPS 进行 MD 模拟的参数 fp_style 指定，使用 ABACUS 进行 SCF 计算 user_fp_params 里面记录 ABACUS 做 SCF 所需的参数 其他参数含义见：https://docs.deepmodeling.com/projects/dpgen/en/latest/run/index.html 1. 准备好所有输入文件之后，运行命令： nohup dpgen run param.json machine.json 1>log 2>err& 为后台提交，等待迭代计算完成即可。 2. 实时监测每轮的 accurate 数据，在 dpgen.log 文件里有记录 1）模型精度是判断每个迭代中的训练是否收敛的重要指标。 2）掌握训练策略有利于快速迭代和收敛。 3）经验性：一般体系在 5-8 轮迭代内会上升到 80% 以上，若没有提升，如下方法排查： a. 检查是否是探索步已经崩溃了，收集了许多不合理的结构 b. 检查train的loss是否是收敛 c. dp test查看fp数据是否偏差很大，或者有不合理的情况 d. 检查是否是温度设置过高而导致的结构变形严重 e. 及时调整trust level，体系温度升高后力的幅度变大，trust level也要增大设置 3. 一些经验 探索步已经崩溃的解决方案 原因：DPMD 跑崩的情况一般发生在 训练温度 高于 熔点，而这个温区的结构是从“有序”到“无序态”的 ，其构型易变，采样空间增大，导致训练难度增加。DPMD 跑崩表明当前势函数对这类构型描述较差，大概率是因为前期数据集中这类构型采集的较少；特别是无序态结构的原子距离变小。 策略：在熔点附近的 参数设置需要平滑缓慢对待，增加“MD 轨迹保存频率”；缩短“MD 模拟步数”或降低“MD 步长”，增加迭代次数，其 DP 训练势函数稳定后再延长 MD 模拟步数。 ABACUS 收敛性测试 对每种体系一定要先做各个参数的收敛性测试，特别是：K 点、能量截断，也可测试 scf_thr 降低计算量。另外，对于赝势文件也一定要做性质测试，看是否能够正确描述目标体系的性质 每隔几轮做一次 dp test 初始数据得到后，第一轮生成了 dp 势之后，一定要检查 trian 步骤收敛情况和做 dp test。dp test 用如下命令： dp test -m frozen_model.pb -s ./collect_data -n 2000 -d out.out frozen_model.pb 为生成的 4 个模型中的某一个，2000 为 collect_data 里面单个结构的总数。out.out 会生成 out.e.out out.f.out out.f.out 三个偏差数据文件，用于作图判断模型优劣屏幕会输出每个构型力、能量等误差平均值，也可用*.out 文件做出 DP 和 DFT 偏差图，如： 经验性的，力的精度在 1e-2 量级，能量精度在 5e-3 量级，说明模型比较好。 四、计算材料 EOS 和弹性常数的流程 本例子里提供了一个 auto-test 文件夹，进入之后可以结合 DPGEN 的 auto-test 命令计算材料 EOS、弹性常数的流程 auto-test 的详细流程，可以从如下网页教程查阅： https://bohrium-doc.dp.tech/docs/software/DP-GEN_autotest 这里贴上如何使用 ABACUS 来计算材料 EOS、弹性常数的相关输入文件 relaxation.json： { \"structures\": [\"conf\"], \"interaction\": { \"type\": \"abacus\", \"incar\": \"./INPUT\", \"potcar_prefix\":\"./\", \"potcars\": {\"Si\": \"Si_ONCV_PBE-1.0.upf\",\"C\": \"C_ONCV_PBE-1.0.upf\"}, \"orb_files\": {\"Si\":\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C\":\"C_gga_9au_100Ry_3s3p2d.orb\"} }, \"relaxation\": { \"cal_type\": \"relaxation\", \"cal_setting\":{ \"input_prop\": \"./INPUT\" } } } property.json： { \"structures\": [\"conf\"], \"interaction\": { \"type\": \"abacus\", \"incar\": \"./INPUT\", \"potcar_prefix\":\"./\", \"potcars\": {\"Si\": \"Si_ONCV_PBE-1.0.upf\",\"C\": \"C_ONCV_PBE-1.0.upf\"}, \"orb_files\": {\"Si\":\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C\":\"C_gga_9au_100Ry_3s3p2d.orb\"} }, \"properties\": [ { \"type\": \"eos\", \"vol_start\": 0.9, \"vol_end\": 1.1, \"vol_step\": 0.02 }, { \"type\": \"elastic\", \"norm_deform\": 1e-2, \"shear_deform\": 1e-2 } ] } INPUT： INPUT_PARAMETERS calculation cell-relax symmetry 0 basis_type lcao ecutwfc 100.0 scf_thr 1.0e-06 scf_nmax 100 smearing_method gauss smearing_sigma 0.002 mixing_type pulay mixing_beta 0.3 cal_force 1 cal_stress 1 kspacing 0.10 在当前目录建立一个 conf 文件夹，把 STRU 文件放进去，依次运行下面命令： dpgen autotest make relaxation.json nohup dpgen autotest run relaxation.json machine.json & dpgen autotest post relaxation.json dpgen autotest make property.json nohup dpgen autotest run property.json machine.json & dpgen autotest post property.json 计算完成之后，会在 conf/elastic_00/result.out 文件里记录弹性常数、模量等信息，conf/eos_00/result.out 里记录 EOS 等数据。 以上即为采用 ABACUS 3.2.0 和 DPGEN 软件结合的介绍，若有任何问题，欢迎给我们反馈。 "},"abacus-libri.html":{"url":"abacus-libri.html","title":"ABACUS+LibRI 做杂化泛函计算教程","keywords":"","body":"ABACUS+LibRI 做杂化泛函计算教程 作者：梁馨元，邮箱：2201111875@stu.pku.edu.cn 审核：林霈泽，邮箱：linpeize@sslab.org.cn 最后更新时间：2023/08/21 在Bohrium Notebook上快速学习： 一、介绍 杂化泛函（Hybrid Functional）是指在密度泛函理论框架中的交换关联项里面加入一部分的 Hartree Fock (简称 HF)的精确交换能。开源密度泛函理论软件 ABACUS 可以结合另一款国产开源软件 LibRI 软件进行杂化密度泛函计算，目前仅支持在数值原子轨道基组下使用该功能。可以通过 dft_functional 参数指定所使用的杂化泛函类型，如可以选择 hf (Hartree-Fock), pbe0(PBE0), hse(HSE06)以及 scan0 杂化泛函。本教程以 HSE 杂化泛函为例，介绍如何在 ABACUS 里调用 LibRI 做杂化泛函自洽迭代、求力和应力以及结构优化。 注 1：使用 ABACUS+LibRI 做杂化泛函计算时，最大并行核数是N_a^4N_K^3，其中N_a是原子个数，N_k是 k 点个数。计算资源超出时可以运行，但会造成浪费。 注 2：使用 ABACUS+LibRI 做杂化泛函计算时，因为内存消耗比较大，推荐给定计算资源的前提下，先尽量使用 OpenMP 多线程并行，再考虑使用 MPI 多进程并行。 二、杂化泛函的使用 1. ABACUS 编译准备 如果要在 ABACUS 中使用杂化泛函进行计算，需要在编译 ABACUS 的时候也编译 Libxc、LibRI 和 LibComm 三个软件包，具体请见线上文档 Advanced Installation Options ‒ ABACUS documentation。 注意在链接 LibRI、LibComm 时如果报错未定义的引用等，可以先注意检查 ABACUS 源代码下 deps 文件夹下是否包含 LibRI、LibComm 两个文件夹。如果未包含这两个文件夹，或文件夹中无内容，在本地Github仓库中可以尝试如下两条语句，以获取这两个子仓库内容： git submodule init git submodule update --remote --recursive 2. 采用杂化泛函进行电子自洽迭代计算 本教程在 Gitee 上准备了一个硅晶体使用杂化泛函做自洽计算（SCF）的例子（Gitee 的下载链接），以下是 INPUT 文件及相关的参数。由 dft_functional 设置为 hse 可知，该例子使用的杂化泛函为 HSE 泛函。KPT 文件取的是 444 的布里渊区 k 点。 INPUT_PARAMETERS calculation scf basis_type lcao ntype 1 nbands 8 ecutwfc 60.0 scf_nmax 100 dft_functional hse scf_thr 1e-7 杂化泛函相关的完整参数列表及解释见 Full List of INPUT Keywords / exact-exchange ‒ ABACUS documentation。这里再进行简单概述： 泛函相关参数： exx_hybrid_alpha：杂化泛函中加入的 HF 精确交换能（Fock 交换能）的比例α，即有E_x=αE_{x}^{HF}+(1-α)E_{x}^{LDA/GGA}。如果 dft_functional 设置为 hf，则默认值为1。目前其他杂化泛函的默认值是0.25。但是，如果是 SCAN0 泛函，有的文献取的是 0.1，所以需要根据你想取的值进行设定[1]。 exx_hse_omega：为 HSE 泛函中的区间分割参数（range-separation parameter）\\omega，即有\\frac{1}{r}=\\frac{erfc({\\omega}r)}{r}+\\frac{erf({\\omega}r)}{r}。默认值为0.11（bohr^{-1}），此时为 HSE06 泛函[2]。 exx_lambda：在 basis_type 设置为 lcao_in_pw 的情况下，用于补偿使用 lcao_in_pw 方法评估精确交换能时 G=0 处的发散点。默认值为0.3。 exx_real_number：该参数设定为 True 时，强制 LibRI 使用 double 数据类型，当设定为 False 时，强制 LibRI 使用 complex 数据类型。当gamma_only=1 时，默认为 True，gamma_only=0 时默认为 False。 循环相关参数： exx_separate_loop：ABACUS 提供了两种迭代方法来评估精确交换能E_{exx}。当 exx_separate_loop 设置为False时：采用单层循环，即先进行 GGA 循环，然后进行 Hybrid 循环，在该过程中，使用电子迭代来更新E_{exx}对应的哈密顿量H_{exx}。当 exx_separate_loop 设置为True时：采用双层循环，在内层循环中，进行自洽迭代并更新密度矩阵，在外层循环中，根据在内层循环中收敛的密度矩阵来计算H_{exx}。默认值为 True，即采用双层循环计算。单层循环有利于难以自洽收敛的体系达到收敛，但会显著增加内存消耗。 exx_hybrid_step：在 exx_separate_loop 设置为 True 的情况下，外层循环的最大迭代步数。默认值为100。 exx_mixing_beta：在 exx_separate_loop 设置为 True 的情况下，内层循环每次迭代时，密度矩阵混合的 mixing_beta 取值，默认为1.0。 exx_pca_threshold：为了加速四中心积分\\langle ik\\vert\\ jl\\rangle的计算，ABACUS 采用 LRI 方法，将原子轨道的乘积在辅助基函数(ABF)的基础上展开，即\\Phi_i\\Phi_j \\approx \\sum_aC_{ij}^aP_a，并利用 PCA 减小辅助基函数(ABF)的大小(即P_a个数)。阈值越大，ABF 的数目越少，计算速度越快，计算精度越低。一个相对安全的值是1e-4，也是默认值。 exx_ccp_rmesh_times：此参数决定计算 Columb 势所需的截断半径比原子轨道的截断半径大多少倍。对于 HSE 泛函，设置为 1 就足够了。但是对于 PBE0，必须使用一个大得多的数字。当使用 HSE 泛函时，默认值为1.5，其他情况下默认值为5。 张量筛选相关参数： 针对杂化泛函计算过程中的物理量进行筛选可以加速计算。具体来说，exx_c_threshold、exx_v_threshold、exx_dm_threshold、exx_c_grad_threshold、exx_v_grad_threshold 分别是针对C_{ij}^a、V_{ab}=\\langle P_a\\vert\\ P_b\\rangle、密度矩阵、\\nabla C_{ij}^a、\\nabla V_{ab}。阈值越大，筛掉的张量越多，计算速度越快，计算精度越低。具体请查看完整 INPUT 参数文档。 Cauchy-Schwartz 不等式相关参数： exx_cauchy_threshold：在实际中，Fock 交换矩阵是稀疏的，利用 Cauchy-Schwartz 不等式，我们可以在进行显式求值之前找到每个矩阵元素的上界。小于 exx_cauchy_threshold 的值将被截断。阈值越大，筛掉的张量越多，计算速度越快，精度越低。一个相对安全的值是1e-7，也是默认值。不等式算法参见参考文献[3]。 exx_cauchy_force_threshold、exx_cauchy_stress_threshold与exx_cauchy_threshold类似，区别在于它们分别针对的是求力、应力计算中的 Fock 交换矩阵元。 opt_orb 相关参数：当dft_functional设置为 opt_orb 时使用，opt_orb 参考文献[4]。本功能仅用于生成 opt 辅助基组，不进行杂化泛函计算。 exx_opt_orb_lmax：球贝塞尔函数的最大角动量 L 值，opt-ABF 的径向部分用球贝塞尔函数的线性组合生成。 exx_opt_orb_ecut：球贝塞尔函数展开的截断，在优化 opt-ABF 的时候采用的是球贝塞尔函数基组。 exx_opt_orb_tolerence：解球贝塞尔函数零点时的阈值。 3. 杂化泛函计算代价 杂化泛函的计算精度高，与此同时它的计算代价也比较高。在 ABACUS 的输入参数文件 INPUT 中，若 exx_separate_loop 参数设为 True（默认），仅在 SCF 步骤中就涉及两层循环。每次内层循环完成，外层循环往前推进一步时，屏幕输出 Updating EXX and rerun SCF。 一次 SCF 需要的时间至少是以上两个循环涉及的单次电子迭代时间之和。对于单次电子迭代所需时间，在此提出一些已有的经验。以一步电子迭代的时间为衡量尺标，使用 DZP 基组，CPU 型号为 Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz，使用 4 核计算一个水分子为 0.6s 左右，使用 14 个核计算 32 个水分子为 0.8s 左右，使用 14 个核计算 64 个水需要 1.9s 左右。 若将 exx_separate_loop 参数设为 False，即使用单层循环时，首先会进行 GGA 迭代直到自洽收敛，然后屏幕输出 Entering 2nd SCF, where EXX is updated，进行 Hybrid 迭代，此时每进行一次电子步得到新的密度后，都会更新一次精确交换能。以一步电子迭代 + 更新精确交换能的时间为衡量尺标，使用 DZP 基组，CPU 型号为 Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz，使用 4 核计算一个水分子为 0.7s 左右，使用 14 个核计算 32 个水分子为 115s 左右，使用 14 个核计算 64 个水需要 330s 左右。对于更大的体系，如 2048 个 Si 原子的晶体，使用 DZP 基组，CPU 型号为 Intel(R) Xeon(R) Silver 4310 CPU @ 2.10GHz，用一个节点（56 核）算时，PBE 下一步电子迭代大概需要 380s，而 HSE 一步电子迭代 + 更新精确交换能大概需要 1680s。 在进行杂化泛函计算时推荐尽量使用多线程计算（OpenMP），此时内存开销相对较小，计算速度相对较快。 三、使用杂化泛函做结构优化 1. 数据准备 在 Gitee 上我们准备了一个简单的使用杂化泛函做结构优化的例子。该例子是在 LCAO 基组下，使用 HSE 泛函，优化单个水分子的结构。文件夹中 log.ref 是使用 3.2.1 版本的 ABACUS 软件包，v0.1.0 版本的 LibRI 和 LibComm 计算所得的屏幕输出。 2. 输入文件 准备计算所需的 INPUT 文件、STRU 文件、KPT 文件，以及 H、O 原子对应的数值原子轨道文件。其中 INPUT 文件如下。注意该文件中指明了计算类型为 relax，即不对晶胞做优化（cell relax），只对原子位置做优化（relax）。更多结构优化类型请看文档 Geometry Optimization ‒ ABACUS documentation。 INPUT_PARAMETERS calculation relax basis_type lcao ntype 2 ecutwfc 60.000000 scf_nmax 100 gamma_only 1 dft_functional hse relax_nmax 100 scf_thr 1e-6 force_thr_ev 1e-2 在该例子中，结构优化包括多个离子步，每个离子步中都要做一次 SCF。由 INPUT 文件可知，SCF 收敛的标准由 scf_thr=1e-6 指定，或达到 SCF 的最大步数 scf_nmax=100，并计算受力。根据上一个离子步计算得到的受力，计算下一个离子步的原子位置，计算收敛的标准此时为 force_thr_ev=1e-2，或达到离子步的最大步数 relax_nmax=100。STRU 文件如下，可见在结构弛豫步骤中，三个原子都可以移动。 ATOMIC_SPECIES O 16.00 O_ONCV_PBE-1.0.upf H 1.00 H_ONCV_PBE-1.0.upf LATTICE_CONSTANT 1 LATTICE_VECTORS 28 0 0 0 28 0 0 0 28 ATOMIC_POSITIONS Direct O #label 0 #magnetism 1 #number of atoms 0.677639488918 0.5227809096584 0.232500040128 m 1 1 1 H #label 0 #magnetism 2 #number of atoms 0.641808457616 0.5785821615863 0.228644198512 m 1 1 1 0.708889637644 0.5204300746076 0.175087721492 m 1 1 1 NUMERICAL_ORBITAL O_gga_6au_60Ry_2s2p1d.orb H_gga_6au_60Ry_2s1p.orb 3. 结果 结构弛豫（relax）后的原子结构可见 OUT.ABACUS/STRU_ION_D。由输出文件可知，即使该例子中采用了相对稳定的构型，且 scf_thr 仅设为 1e-6，使用 HSE 做结构弛豫的计算代价仍然很高，使用 6 个核（Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz）计算需要 5 分钟左右。 四、参考文献 [1] Staroverov V N, Scuseria G E, Tao J, et al. Comparative assessment of a new nonempirical density functional: Molecules and hydrogen-bonded complexes[J]. The Journal of chemical physics, 2003, 119(23): 12129-12137. [2] Aliaksandr V. Krukau, Oleg A. Vydrov, Artur F. Izmaylov, Gustavo E. Scuseria; Influence of the exchange screening parameter on the performance of screened hybrid functionals. J. Chem. Phys. 14 December 2006; 125 (22): 224106. [3] Lin P, Ren X, He L. Efficient hybrid density functional calculations for large periodic systems using numerical atomic orbitals. Journal of Chemical Theory and Computation, 2021, 17(1): 222–239. [4] Lin P, Ren X, He L. Accuracy of localized resolution of the identity in periodic hybrid functional calculations with numerical atomic orbitals[J]. The Journal of Physical Chemistry Letters, 2020, 11(8): 3082-3088. "},"abacus-candela.html":{"url":"abacus-candela.html","title":"ABACUS+Candela 使用教程","keywords":"","body":"ABACUS+Candela 使用教程 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/08/23 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍采用 Candela 分析 ABACUS（基于 3.2.4 版本）分子动力学轨迹，计算径向分布函数（Radial Distribution Function，简称 RDF），静态结构因子（Static Structure Factor，简称 SSF），离子-离子动态结构因子（Ion-ion Dynamic Structure Factor，简称 DSF）以及均方差位移（Mean Square Displacement，简称 MSD）流程。 上述性质的具体描述可以参考：Qianrui Liu et al 2020 J. Phys.: Condens. Matter 32 144002，径向分布函数（RDF）见文中公式（12），静态结构因子（SSF）见公式（13），离子-离子动态结构因子（DSF）见公式（15，16，17）以及均方差位移（MSD）见公式（18）。 Candela 全称 Collection of ANalysis DEsigned for Large-scale Atomic simulations，目前支持分析 QE、ABACUS、LAMMPS 和 VASP 的分子动力学轨迹，Github 主页：https://github.com/MCresearch/Candela 二、准备 1. 下载并安装 Candela git clone https://github.com/MCresearch/Candela.git cd Candela make -j4 #使用intel oneapi编译器 若使用 Intel Oneapi 编译器，按照上述流程操作，在编译完成后即可在 bin 目录下看到 candela 可执行文件 若使用其他编译器，需要按照 Candela 目录下 Makefile.vars 修改相应的 CXX 2 下载例子 可以从 Gitee 上下载。在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载完成后解压，之后进入 abacus-user-guide/examples/candela 文件夹 算例中包含 RDF、SSF、DSF、MSD 四个文件夹和 MD_dump 文件。其中 MD_dump 是 32 原子的铝的 MD 轨迹 三、流程 1 计算径向分布函数 进入 RDF 文件夹，INPUT 文件即为 Candela 的输入文件，具体如下： calculation pdf geo_in_type ABACUS geo_directory ../MD_dump geo_1 0 geo_2 100 geo_interval 2 geo_ignore 50 geo_out Al_rdf.txt ntype 1 natom 32 rcut 2.3 dr 0.01 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 pdf（Pair Distribution Function）即计算径向分布函数 geo_in_type：读取的 MD 轨迹的格式，目前支持分析 pw.x（QE2），cp.x（QE），ABACUS（ABACUS）、LAMMPS（LAMMPS）和 VASP（VASP） geo_directory：MD 轨迹的位置 geo_1：MD 轨迹起始的索引 geo_2：MD 轨迹结束的索引 geo_interval：Candela 读取 MD 轨迹的间隔 geo_ignore：需要跳过的 MD 轨迹帧数 geo_out：输出的文件名，默认为 result.dat ntype：原子种类 natom：原子数 rcut：计算 RDF 的截断半径，一般取晶格的一半，单位为 Angstrom dr：计算 RDF 的 r 的间隔，单位为 Angstrom 执行如下命令： mpirun -n 2 candela 即可得到 RDF，输出到 Al_rdf.txt，其中第一列为 r，单位为 Angstrom，第二列即为对应的 RDF，第三列为对第二列积分的结果。 2 静态结构因子 进入 SSF 文件夹，INPUT 文件具体如下： calculation ssf geo_in_type ABACUS geo_directory ../MD_dump geo_1 0 geo_2 100 geo_interval 2 geo_ignore 50 ssf_out Al_ssf.txt ntype 1 natom 32 struf_dgx 1.32656 struf_dgy 1.32656 struf_dgz 1.32656 struf_ng 6 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 ssf，即计算静态结构因子 ssf_out：输出的文件名 struf_dgx：倒空间中的间隔，一般取 2\\pi/a，其中a为x方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} struf_dgy：一般取 2\\pi/b，其中b为y方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} struf_dgz：一般取 2\\pi/c，其中c为z方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} struf_ng：上述倒空间中的间隔的数量 执行如下命令： mpirun -n 2 candela 即可得到 SSF，输出到 Al_ssf.txt（原始的计算结果）以及 sm-Al_ssf.txt（平滑的计算结果），其中第一列为 q，单位为\\mathrm{Angstrom^{-1}}，第二列即为对应的 SSF。 3 离子-离子动态结构因子 进入 DSF 文件夹，离子-离子动态结构因子需要对中间散射函数（Intermediate Scattering Function）进行傅里叶变换得到，因此需要先计算中间散射函数，INPUT 文件具体如下： calculation isf2 geo_in_type ABACUS geo_directory ../MD_dump geo_1 50 geo_2 100 geo_interval 1 isf_outfile isf.txt ntype 1 natom 32 isf_nt1 11 isf_nt2 40 dt_snapshots 0.00006 isf_target_q 2.65 isf_dgx 1.32656 isf_dgy 1.32656 isf_dgz 1.32656 isf_ngx 6 isf_ngy 6 isf_ngz 6 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 isf2，即计算中间散射函数 isf_outfile：输出的文件名 isf_nt1：中间散射函数的时间长度 isf_nt2：用于平均中间散射函数的时间长度，注意需要控制 interval*(nt1+nt2) dt_snapshots：MD 轨迹每一帧之间的时间步长，单位为 ps isf_target_q：中间散射函数计算的目标 q，单位为\\mathrm{Angstrom^{-1}} isf_dgx：倒空间中的间隔，一般取 2\\pi/a，其中a为x方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} isf_dgy：一般取 2\\pi/b，其中b为y方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} isf_dgz：一般取 2\\pi/c，其中c为z方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} isf_ngx：上述倒空间中 x 方向的间隔的数量 isf_ngy：上述倒空间中 y 方向的间隔的数量 isf_ngz：上述倒空间中 z 方向的间隔的数量 执行如下命令： mpirun -n 2 candela 即可得到 ISF，输出到 isf.txt，其中第一列为时间，单位为 ps，第二列即为对应的 ISF。 接着执行如下命令得到离子-离子动态结构因子，其中PathtoCandela指的是Candela的下载目录： python PathtoCandela/examples/e3_dsf/onedsf.py 0.00006 0.0006 其中第一个参数 0.00006 = dt_snapshots * geo_interval，为 ISF 的时间步长，单位为 ps；第二个参数 0.0006，为对 ISF 做傅里叶变换的总时长，单位为 ps。这里 onedsf.py 默认读取 isf.txt，并输出到 dsf.txt，其中第一列为\\hbar \\omega，单位为 meV，第二列即为对应的 DSF。 4 均方差位移 进入 MSD 文件夹，INPUT 文件具体如下： calculation msd_multiple geo_in_type ABACUS geo_directory ../MD_dump geo_1 0 geo_2 100 geo_interval 1 geo_ignore 50 ntype 1 natom 32 msd_n 2 msd_t0 0.003 msd_t 0.0015 msd_dt0 0.0015 msd_dt 0.00006 msd_natom 32 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 msd_multiple，即计算均方差位移 msd_n：计算均方差位移的段数，目的是将 MD 轨迹分成若干段，分别计算均方差位移 msd_t0：计算均方差位移的起始时间，单位为 ps msd_t：每段均方差位移的时长，单位为 ps msd_dt0：两段均方差位移起始位置的间隔，单位为 ps。若设置等于 msd_t，则每段均方差位移之间的时间距离为 0 msd_dt：获取的 MD 轨迹每一帧之间的时间步长（等于geo_interval * dt，其中 dt 为 MD 轨迹每一帧之间的时间步长），单位为 ps msd_natom：需要设置为计算的原子数 执行如下命令： mpirun -n 2 candela 即可得到 MSD，输出到 MSD_each.txt 和 MSD_total.txt。其中 MSD_each.txt 第一列为时间，单位为 ps，第二列到最后一列即为对应的每段的 MSD，单位为\\mathrm{Angstrom^{2}}；MSD_total.txt 第一列为时间，单位为 ps，第二列为平均的每段的 MSD，单位为\\mathrm{Angstrom^{2}}。 "},"abacus-uspex.html":{"url":"abacus-uspex.html","title":"ABACUS+USPEX 接口教程","keywords":"","body":"ABACUS+USPEX 接口教程 作者：柳向阳，邮箱：xiangyangliu@mail.ustc.edu.cn；郭晓庆，邮箱：xiaoqing.guo@mail.nwpu.edu.cn 审核：牛海洋，邮箱：haiyang.niu@nwpu.edu.cn；陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/14 一、背景介绍 近年来，随着高性能计算机的快速发展，晶体结构预测算法已然成为计算材料学的核心研究手段之一，极大地促进了新材料设计与研发的进程。Artem R.Oganov 教授课题组开发的进化类晶体结构预测算法 USPEX 是当前主流的全局搜索类算法之一。软件自 2004 年发布以来，该算法已被广泛应用于科研人员的研究工作中。晶体结构预测算法的主要作用是生成结构以及控制结构的演进，结构预测的效率及可靠性除却算法本身的影响外还对结构弛豫软件有极强的依赖性。ABACUS（原子算筹）作为一款国产开源密度泛函理论软件，同时兼具高精度和高效率，可适用于从小体系到上千原子体系的电子结构优化、原子结构弛豫、分子动力学等计算。因此实现晶体结构预测算法 USPEX（https://uspex-team.org/en）和第一性原理软件 ABACUS 的结合会给广大研究人员在结构预测研究中带来便利。 本教程旨在为大家提供一个 USPEX-ABACUS 接口的实现教程，方便大家程序配置。本教程以单质硅（Si）的结构预测为例, 介绍了该接口使用所需的输入文件和参数设置。 如需了解更多关于 USPEX 的使用信息，请参考 USPEX 官方文档：USPEX Documentation ‒ USPEX 二、接口介绍 当前发行的 USPEX 提供了分别以 matlab 和 python 为核心编程语言的两个版本，前者的版本编号为 USPEX-vXX（如 USPEX_v10.5），后者的版本编号为 USPEX-YEAR-XX（如 USPEX 2023.0.2），需要注意的是当前只有 python 版本可以自定义外部接口。该教程中的接口是在 USPEX 2023.0.2 和 ABACUS 3.3.0 版本进行编写测试的，如发生版本变更引起的异常，根据报错再行修改。 首先通过 USPEX 官网（USPEX 下载 ‒ USPEX）下载 USPEX 2023.0.2 软件（注册后即可免费下载），解压后根据所使用的 python 版本，选择软件压缩包进行安装，例如 pip install uspex-2023.0.2-cp310-cp310-linux_x86_64.whl。 注：若系统提示需要安装虚拟环境，可以在 USPEX 2023.0.2 目录下激活虚拟环境后重新进行安装。 python -m venv tutorial-env source tutorial-env/bin/activate 该接口共包含三个文件 (1) USPEX/components.py（对接口进行注册） (2) USPEX/Stages/Interfaces/ASEInterfacesAdapter.py（完成 ASE 接口中的读 read 和写 write 功能） (3) USPEX/Stages/Interfaces/ABACUS_Interface.py（接口实体，主要功能是准备 Abacus 的输入文件和读取 Abacus 的计算结果） 注：以上路径中 USPEX 为主目录。 上述文件可在 Github 仓库下载：https://github.com/gxq1219/Interface_USPEX-ABACUS/tree/master 安装完成后将以上文件复制到对应的路径下，并且需要手动添加环境变量，例如:export PATH=python3.10/site-packages/USPEX:$PATH，然后将 USPEX 2023.0.2 目录下的 random_cell 复制到设置的环境变量路径下。 该接口需要安装 ase-abacus 版本的 ase 库，测试版本为 ase-3.23.0b1 安装 ase-abacus 接口 git clone https://gitlab.com/1041176461/ase-abacus.git cd ase-abacus python3 setup.py install 此次测试是在 QSUB 任务管理系统下进行测试，如果更换任务管理系统，应修改 USPEX 输入文件 input.uspex 中的 taskManager 和 TM，此外需修改 USPEX/Stages/TaskManager 中所选任务管理方式中对任务队列状态识别的方式，如在 QSUB.py 文件中应根据所使用平台修改 def _parseJobID 中的内容识别出提交任务的 ID，以及下文的 def isReady 和 def isExist 等函数。 QSUB.py 示例（第 56 行的函数，根据自己超算平台修改，功能是执行 qsub sub.sh 后从屏幕输出的文本中提取出 jobID）： \"\"\" USPEX.Stages.TaskManagers.QSUB ============================== \"\"\" import logging from os.path import join as pj logger = logging.getLogger(__name__) class QSUB: shortname = 'QSUB' _RUNSCRIPT = 'jobscript' def __init__(self, header : str, connector): \"\"\" :param header: description of params of TaskManager :param connector: for remote submission \"\"\" self.connector = connector self.header = header def _prepareSubmission(self, COMMAND_EXEC : str, JOB_NAME : str, inputFile : str, outputFile : str, errorFile : str) -> str: \"\"\" Preparing jobscript for submission :param commandExec: :param jobName: :return: jobscript as string \"\"\" content = '' for line in self.header.split('\\n'): if ' -N ' in line: logger.info('Job name found in HEADER will be overwritten') elif ' -o ' in line: logger.info('Output file name found in HEADER will be overwritten') elif ' -e ' in line: logger.info('Error file name found in HEADER will be overwritten') else: content += line + '\\n' content += f'#PBS -N {JOB_NAME}\\n' content += f'#PBS -o {outputFile}\\n' content += f'#PBS -e {errorFile}\\n' content += f'cd $PBS_O_WORKDIR\\n' content += f'\\n{COMMAND_EXEC}\\n' return ''.join(content) async def submit(self, command: str, jobname: str, input: str, output: str, error: str, calcFolder : str) -> int: content = self._prepareSubmission(command, jobname, input, output, error) with open(pj(calcFolder, self._RUNSCRIPT), 'wt') as f: f.write(content) await self.connector.sync_l2r(pj(calcFolder, self._RUNSCRIPT)) returncode, out, err = await self.connector.execute(f'qsub {self._RUNSCRIPT}', cwd=calcFolder) logger.debug(f'process returned code {returncode}') if returncode != 0: logger.error(err) logger.error(out) jobID = self._parseJobID(out, err) logger.info(f\"Job ID is {jobID}\") return jobID def _parseJobID(self, output : str, error : str) -> int: \"\"\" :param output: :param error: :return: jobID \"\"\" if '.mgmt' in output: tmp = output.index('.mgmt') return int(output[:tmp]) elif 'job' in output: tmp = output.index('job') + 4 return int(output[tmp:]) elif 'comput100' in output: tmp = output.index('comput100')-1 return int(output[:tmp]) else: return int(output) async def isReady(self, jobID): returncode, out, err = await self.connector.execute(f'qstat {jobID}') return not (' R ' in out or ' Q ' in out) async def isExist(self, jobID): returncode, out, err = await self.connector.execute(f'qstat {jobID}') return len(out) > 0 async def kill(self, jobID): returncode, out, err = await self.connector.execute(f'qdel {jobID}') #logger.info(f'Process with jobID={jobID} killed.') 三、流程（以 Si 为例） 1. 准备 USPEX 的输入文件 input.uspex { optimizer: { type: GlobalOptimizer target: { type: Atomistic conditions: {externalPressure: 0.00001} compositionSpace: {symbols: [Si] blocks: [[4]]} } optType: enthalpy selection: { type: USPEXClassic popSize: 4 initialPopSize: 4 bestFrac: 0.6 optType: (aging enthalpy) fractions: { heredity: (0.4 0.7 0.5) softmodemutation: (0.2 0.5 0.3) randSym: (0.05 0.5 0.1) randTop: (0.05 0.5 0.1) } } } stages: [abacus1 abacus2 abacus3 abacus4 abacus5] numParallelCalcs: 4 numGenerations: 25 stopCrit: 10 } #define abacus1 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.20, taskManager: TM} #define abacus2 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.16, taskManager: TM} #define abacus3 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.12, taskManager: TM} #define abacus4 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.08, taskManager: TM} #define abacus5 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.05, taskManager: TM} #define TM { type : QSUB, header:\"#PBS -S /bin/bash #PBS -N single #PBS -l nodes=1:ppn=16 #PBS -j oe #PBS -V\" } 注意：ABACUS在任务提交时，应注意指定OMP_NUM_THREADS，防止内存不足引起计算错误 2. 准备 Specific 文件夹 所需文件：INPUT_X（使用ABACUS弛豫）、ATOMIC_SPECIES、NUMERICAL_ORBITAL以及轨道和赝势文件。 INPUT 文件内容和个数由用户自行设置（需要与 input.uspex 中 stages 对应），具体可参考 uspex 官方文档。 需要注意的是：INPUT 的 suffix 需指定为 USPEX； 需给出 ATOMIC_SPECIES 和 NUMERICAL_ORBITAL 两个文件指定所使用的 upf 文件和 orb 文件。 ATOMIC_SPECIES 内容：元素符号 质量 赝势文件名 NUMERICAL_ORBITAL 内容：元素符号 轨道文件名 3. 根据计算实际需求添加 Seeds 结构（可选，非必须） 4. 提交运算 nohup ./uspex-sub.sh >> log & ### content of uspex-sub.sh #!/bin/sh while true;do data >> log uspex -r >> log sleep 300 ### Users can adjust this value to manipulate the frequency of the call to uspex. done 5. 计算结果 如果程序可以正常提交任务，log文件中会打印如下内容： 2023-08-09 16:52:47,115 - USPEX.Optimizers.Target - INFO - Following utilities was not initialized: ['PowderSpectrumAnalyzer', 'SingleCrystalSpectrumAnalyzer']. 2023-08-09 16:52:47,115 - USPEX.Optimizers.Target - INFO - Permutation does not work when number of symbols in calculation is 1. 2023-08-09 16:52:47,123 - USPEX.Stages.GenerationController - INFO - Calculation initialized from input parameters. 2023-08-09 16:52:47,441 - USPEX.Selection.USPEXClassic - INFO - System 0 successfully created by RandSym operator. 2023-08-09 16:52:47,866 - USPEX.Selection.USPEXClassic - INFO - System 1 successfully created by RandSym operator. 2023-08-09 16:52:48,638 - USPEX.Selection.USPEXClassic - INFO - System 2 successfully created by RandSym operator. 2023-08-09 16:52:48,767 - USPEX.Selection.USPEXClassic - INFO - System 3 successfully created by RandSym operator. 2023-08-09 16:52:48,788 - USPEX.Stages.Executor - INFO - System 0 with tag 1 will be submitted now. 2023-08-09 16:52:48,788 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,792 - USPEX.Stages.Executor - INFO - System 1 with tag 1 will be submitted now. 2023-08-09 16:52:48,792 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,796 - USPEX.Stages.Executor - INFO - System 2 with tag 1 will be submitted now. 2023-08-09 16:52:48,797 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,801 - USPEX.Stages.Executor - INFO - System 3 with tag 1 will be submitted now. 2023-08-09 16:52:48,801 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,812 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37768 2023-08-09 16:52:48,818 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37769 2023-08-09 16:52:48,822 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37770 2023-08-09 16:52:48,825 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37771 如果程序可以正常输出结果，在 results1/Individuals 中会打印相关的信息，示例如下： +----+------------------+-------------+---------------+--------------+---------------+-----------------+---------------+--------------+ | ID | Origin | Composition | Enthalpy (eV) | Volume (A^3) | SYMMETRY (N) | Structure order | Average order | Quasientropy | +----+------------------+-------------+---------------+--------------+---------------+-----------------+---------------+--------------+ | 0 | RandSym | Si: 4 | -425.452 | 59.320 | P6/mmm (191) | 0.334 | 0.334 | -0.000 | | 2 | RandSym | Si: 4 | -418.078 | 59.320 | I4/mmm (139) | 0.287 | 0.287 | -0.000 | | 3 | RandSym | Si: 4 | -425.038 | 59.320 | P4_332 (212) | 0.392 | 0.392 | -0.000 | | 4 | Softmodemutation | Si: 4 | -428.592 | 59.320 | I4/mmm (139) | 0.325 | 0.325 | 0.000 | | 5 | Softmodemutation | Si: 4 | -428.592 | 59.320 | I4/mmm (139) | 0.325 | 0.325 | 0.000 | | 6 | Heredity | Si: 4 | -427.892 | 59.320 | P2_1/m (11) | 0.202 | 0.215 | 0.077 | | 8 | Softmodemutation | Si: 4 | -427.882 | 59.320 | P2_1/m (11) | 0.201 | 0.215 | 0.076 | | 9 | Softmodemutation | Si: 4 | -427.887 | 59.320 | P2_1/m (11) | 0.202 | 0.215 | 0.075 | | 10 | Heredity | Si: 4 | -428.645 | 59.320 | Cmce (64) | 0.261 | 0.261 | 0.000 | | 11 | Softmodemutation | Si: 4 | -428.644 | 59.320 | Cmce (64) | 0.261 | 0.261 | 0.000 | | 12 | Softmodemutation | Si: 4 | -428.645 | 59.320 | Cmce (64) | 0.261 | 0.261 | 0.001 | | 14 | Heredity | Si: 4 | -428.628 | 59.320 | Cmce (64) | 0.263 | 0.263 | 0.000 | | 15 | Heredity | Si: 4 | -428.928 | 59.320 | Cmcm (63) | 0.291 | 0.291 | 0.000 | | 16 | Heredity | Si: 4 | -428.949 | 59.320 | P2_1/m (11) | 0.283 | 0.284 | 0.006 | | 17 | RandSym | Si: 4 | -422.987 | 59.320 | C2/m (12) | 0.250 | 0.250 | 0.000 | | 19 | Softmodemutation | Si: 4 | -428.927 | 59.320 | Cmcm (63) | 0.291 | 0.291 | 0.000 | | 20 | Softmodemutation | Si: 4 | -428.928 | 59.320 | Cmcm (63) | 0.290 | 0.290 | 0.000 | | 21 | Heredity | Si: 4 | -428.926 | 59.320 | Cmcm (63) | 0.290 | 0.290 | 0.000 | 四、结语 建议大家在使用前，首先选择小体系进行测试；此外大家也可根据自己的实际需要对接口文件进行修改扩充，有相关问题可通过邮件方式沟通。 "},"develop-C++.html":{"url":"develop-C++.html","title":"ABACUS 开源项目 C++ 代码规范","keywords":"","body":"ABACUS 开源项目 C++ 代码规范 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/04 ABACUS（Atomic-orbtial Based Ab-initio Computation at UStc，中文名原子算筹）是国产开源密度泛函理论软件，相关介绍 ABACUS 的新闻可在 ABACUS 新闻稿整理查看。此文档用于给 ABACUS 开发者提供代码编程规范方面的建议。 前言 让任何开发者都可以快速读懂别人的代码，这点对于 ABACUS 项目很重要。此外，使代码易于管理的方法之一是加强代码一致性，这需要从代码规范开始着手。 一、命名约定 1. 普通变量的命名统一是小写，并使用下划线命名法 以下是四种命名方法：下划线命名法、匈牙利命名法、驼峰式命名法、帕斯卡命名法 string table_name; // 下划线命名法（推荐） - 用下划线区分单词（推荐使用） string sTableName; // 匈牙利命名法 - 前缀字母用变量类型缩写，单词首字母大写 string tableName; // 驼峰命名法 - 混合大小写（不推荐使用） string TableName; // 帕斯卡命名法 - 每个单词首字母大写（不推荐使用) 下划线命名法：推荐使用 匈牙利命名法：目前 ABACUS 中有些变量（例如指针），首字母为数据类型（指针为 p），可以考虑用这种方式命名，但不推荐用大写字母 驼峰命名法/帕斯卡命名法：目前 ABACUS 大部分的代码不是用这种命名方式的，为了代码风格统一，所以不推荐使用 2. 函数命名 建议使用下划线命名法且所有字母全部小写，建议小于 18 个字符 void calculate_area() { // function body } 3. private 的类数据成员在最后以下划线结尾 private 的类数据成员和普通变量的命名方式一样，但要在最后以下划线结尾，以区分自己是 private 的类数据成员。 class TableInfo { ... private: string table_name_; // 好 - 后加下划线 string tablename_; // 好 static Pool* pool_; // 好 }; 4. 只有全局变量用全大写命名 在 ABACUS 中，例如 NBANDS（能带数），NLOCAL（局域轨道数目）这种全大写的变量名是全局变量，其它的不建议用大写字母给变量命名。另外，ABACUS 将通过重构或者删除的方式逐步淘汰全局变量，因此不建议增加新的全局变量。 二、关于头文件 1. 只有在真正需要使用某个库/头文件时才 #include 它们 不需要的 #include 删除。 2. #include避免使用快捷目录 . (当前目录) 或 .. (上级目录) 项目内头文件应按照项目源代码目录的树结构排列，避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录)。例如 source/module_hsolver/diago_cg.h 文件是这样引用 module_base 的头文件： #include \"diagh.h\" #include \"module_base/complexmatrix.h\" 3. #include 顺序（clang-format 可以自动） 使用标准的头文件包含顺序，这样可以可增强可读性，避免隐藏依赖。 foo.cpp 中包含头文件的次序如下： 与源文件对应的头文件：dir2/foo2.h（这种优先的顺序排序保证当 dir2/foo2.h 遗漏某些必要的库时， dir/foo.cpp 的构建会立刻中止） C 系统文件 C++ 系统文件 其他库的 .h 文件 本项目内 .h 文件 4. 头文件需要 #define 保护 #ifndef FOO_BAR_BAZ_H_ #define FOO_BAR_BAZ_H_ ... #endif // FOO_BAR_BAZ_H_ 5. 避免使用前置声明 使用 #include 包含需要的头文件，尽量避免使用前置声明（见以下例子解释什么是前置声明）。 // 什么是前置声明？ // MyClassB.h // Bad: Overuse of forward declarations class MyClassB; class MyClassA { public: void DoSomething(MyClassB* obj_b); }; void MyClassA::DoSomething(MyClassB* obj_b) { // ... } 在这段代码中，MyClassB 被声明为一个类，但没有给出其定义。这被称为前置声明（Forward Declaration），它告诉编译器 MyClassB 是一个存在的类，但不提供该类的详细信息。 6. 当函数只有 10 行甚至更少时，才将其定义为内联函数 只有当函数只有 10 行甚至更少时才将其定义为内联函数（关键字 inline）。 三、关于类（Class） 1. 先声明类的成员变量，再声类的成员函数 2. 将public 部分放在最前，之后是protected数据，最后是private 3. 不使用运算符重载 若要使用，建议提交 issue 讨论 4. 什么时候用 struct？ 只有数据成员、没有成员函数时可以用 struct 5. 类型转换使用static_cast<>() 建议使用 C++ 的类型转换，如 static_cast<>()。 不要使用 int y = (int)x 或 int y = int(x) 等转换方式。 用 static_cast 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时。 用 const_cast 去掉 const 限定符。 用 reinterpret_cast 指针类型和整型或其它指针之间进行不安全的相互转换。 仅在你对所做一切了然于心时使用。 6. 继承采用 public 继承 如果你想使用私有继承，你应该替换成把基类的实例作为成员对象的方式去定义类。 7. 不过度使用实现继承，可以考虑组合 例如，如下案例： class Engine { public: void start() { /* 启动引擎 */ } }; class Car { public: Car(const std::string& n, Engine& e) : name_(n), engine_(e) {} void drive() { engine_.start(); std::cout 四、关于函数（Function） 1. 函数传参：不变参数用 const 和 & 函数的输入参数与输出参数: 在一个函数中，不变的量，我们可以看作是函数的输入参数；变化的量，我们可以看作是函数的输出参数。 在输入参数中可以选择 const T* （指向常量对象的指针，不能通过这个指针来修改其指向的对象的值。然而，你可以改变指针本身的值）。 也可以使用 const T& （不能通过这个引用来修改其引用的对象的值，在其生命周期内不能重新引用另一个对象）。 所以，建议使用 const T&，若要使用 const T*，则应给出相应的理由，否则会使读者感到迷惑。 void Foo(const string &in, string *out); // 输入参数：in （const + 引用&） // 输出参数：out（指针变量） 2. 函数传参：会变的参数用指针 什么是引用参数: 在 C 中, 如果函数需要修改输入变量的值, 参数必须为指针, 如 int foo(int *pval)。 在 C++ 中, 函数还可以声明为引用参数: int foo(int &val)。 引用参数在语法上是值变量却拥有指针的语义（变量可以被改变！）。 3. 每个函数不超过 50 行 建议编写简短，凝练的函数，有特殊情况的除外。 4. 函数返回值（return 的值）多使用值返回和引用返回，避免使用指针返回 五、关于作用域 1. 变量要初始化 无初始化的变量可能会引起结果不稳定（例如出现随机数），因此建议养成习惯，对所有变量的值要初始化，见下面的例子： int i; i = f(); // 坏——初始化和声明分离 int j = f(); // 好——初始化时声明 vector v; // 坏——初始化和声明分离 v.push_back(1); v.push_back(2); vector v = {1, 2}; // 好——初始化时声明 2. 将局部变量置于最小作用域 在 if, while 和 for 语句中： 变量不是对象，则变量应当在内部声明与初始化，这样子这些变量的作用域就被限制在这些语句中了，举例而言： while (const char* p = strchr(str, '/')) { str = p + 1; } 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数。这会导致效率降低。建议将构造函数调用次数减少以提高程序效率。 Foo f; // 构造函数和析构函数只调用 1 次 for (int i = 0; i 3. 仅在局部作用域使用using namespace 使用 using namespace 语句来引入命名空间中的所有名称可能会导致名称冲突。因此，建议在需要时使用它并仅在局部作用域内使用（例如只在调用的时候使用）。 // 建议不在程序开头使用，而是在具体用到std库的函数内使用该语句 using namespace std; 4. 用全局函数要加命名空间 以下是两种建议的方式，或者用类，或者用 namespace // 类的静态成员函数 class MyMath { public: static int add(int a, int b) { return a + b; } static int sub(int a, int b) { return a - b; } }; // or // 命名空间内的非成员函数 namespace my_math { int add(int a, int b) { return a + b; } int sub(int a, int b) { return a - b; } } 5. 优先使用命名空间的非成员函数 能使用命名空间的非成员函数，就不用类的静态成员函数。 // 使用命名空间内的非成员函数 namespace my_math { int add(int a, int b) { return a + b; } int sub(int a, int b) { return a - b; } } int main() { int x = 3, y = 5; int z = my_math::add(x, y); // 调用 my_math 命名空间中的函数 return 0; } // 不要使用类的静态成员函数模拟命名空间 class MyMath { public: static int add(int a, int b) { return a + b; } static int sub(int a, int b) { return a - b; } }; int main() { int x = 3, y = 5; int z = MyMath::add(x, y); // 调用 MyMath 静态方法 return 0; } 六、其他 C++ 特性 1. 每个代码文件不超过 500 行 太长的代码阅读理解和维护的成本都太高，因此不建议一个文件太长。如果有文件超过 500 行，建议重构，把对象进一步的划分。 2. 禁止用 C++11 之后版本的语法 目前的主要考虑是用新语法会使得编译器编译成功的概率降低，另外提高开发者的开发门槛。因此，我们规定不能使用 C++11 之后的语法。 3. 多用前置自增 (++i) 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增，自减运算符。 不考虑返回值的话，前置自增 (++i) 通常要比后置自增 (i++) 效率更高。 4. 尽可能用 sizeof(a) 代替 sizeof(int) 这里 a 是一个参数名 原因：当代码中变量类型改变时会自动更新。 5. 多使用列表初始化 C++11 中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下： // Vector 接收了一个初始化列表。 // 不考虑细节上的微妙差别，大致上相同。 // 可以任选其一。 vector v{\"foo\", \"bar\"}; vector v = {\"foo\", \"bar\"}; // 可以配合 new 一起用。 auto p = new vector{\"foo\", \"bar\"}; // map 接收了一些 pair, 列表初始化大显神威。 map m = {{1, \"one\"}, {2, \"2\"}}; // 初始化列表也可以用在返回类型上的隐式转换。 vector test_function() { return {1, 2, 3}; } // 初始化列表可迭代。 for (int i : {-1, -2, -3}) {} // 在函数调用里用列表初始化。 void TestFunction2(vector v) {} TestFunction2({1, 2, 3}); 6. 初始化时：整数用0，实数用0.0，指针用nullptr，字符 (串) 用'\\0' C++11 引入了一个新的关键字 nullptr，用来表示空指针。相对于传统的 NULL 或 0，nullptr 更加明确、类型安全。使用 nullptr 可以避免一些潜在的编程错误，比如将整数值误传给函数，导致出现不可预期的行为。 因此，建议在 C++11 及以上的版本中使用 nullptr 来表示空指针。 7. 少用 auto，使用前需对 auto 有更全面的了解 auto 是 C++11 引入的关键字，它可以让编译器自动推导出变量的类型。之后，C++14 和 C++17 对 auto 的使用也有了一些扩展和改进。 C++11：auto 只能用于定义局部变量，并且必须初始化。例如： auto i = 42; // 推导出 i 的类型为 int auto f = 3.14f; // 推导出 f 的类型为 float auto s = \"hello\"; // 推导出 s 的类型为 const char* C++14：auto 可以用于定义函数返回值类型，使得函数定义更加简洁。例如： auto add(int x, int y) { return x + y; } // 推导出返回类型为 int auto divide(double x, double y) { return x / y; } // 推导出返回类型为 double C++17：auto 进一步扩展为 auto 和模板结合使用时，可以直接指定模板类型参数，从而实现更加灵活的类型推导。例如： std::vector v{1, 2, 3}; auto it = v.begin(); // 推导出 it 的类型为 std::vector::iterator auto [first, second] = std::make_pair(1, 3.14); // 使用结构化绑定和 auto 推导出 first 和 second 的类型 但是大家注意，在 abacus 中，我们只支持 C++11 的标准，C++14/17 语法是不接受的。 8. auto 和 for 的混合使用时注意事项 在 C++11 中，auto 和 for 循环的结合使用已成为一种常见的编程范式，它可以让代码更加简洁、易读，并且减少了手动指定类型的错误。 int arr[] = {1, 2, 3}; for (auto i : arr) // 相当于复制 { std::cout 9. constexpr 替代宏定义和 const 常量 在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。（真正的常量在编译时和运行时都不变） #define PI 3.14159 // PI 是一个宏定义常量，它不会进行类型检查，容易出错； const double kE = 2.71828; // kE 是一个 const 常量，它不能用于编译期计算。 constexpr double kGravity = 9.8; constexpr 可以替代宏定义和 const 常量的主要原因是： 类型安全：使用 constexpr 定义的常量会进行类型检查，避免了宏定义可能带来的类型错误，同时也比 const 常量更加严格。 编译时计算：constexpr 声明的变量或函数在编译时就可以被求值，而不需要在运行时计算。这比宏定义和 const 常量更高效，尤其是在需要多次使用同一个值的情况下。 更好的可读性和可维护性：使用 constexpr 可以使代码更加清晰易懂，减少了宏定义可能导致的代码混乱问题。同时，由于 constexpr 可以使用函数、类等 C++ 语言特性，因此更加灵活，对于复杂的计算也更容易维护和修改。 因此，在 C++11 及以上的版本中，建议使用 constexpr 来替代宏定义和 const 常量，以提高代码的可读性、可维护性和效率。 七、关于 ABACUS 中常用的关键词缩写 有些名字很长，我们希望尽量言简意赅的表达出一些关键词的意思。原则是一般 3-5 个字母的范围下尽量说清楚一个变量的含义。这些统一的命名会出现在函数名或者变量名里。 1. 两个字符 pw：代表plane wave平面波 op：代表具有multi-device和multi-precision支持的算子（operator），和Operator模块含义不同 2. 三个字符 fft：快速傅里叶变换 kpt：布里渊区kpoint的缩写 nao：代表numerical atomic orbitals （nao经常用来表示number of atomic orbitals，不知道会不会混） orb：orbital，轨道 hmt：代表hamilt或者hamiltonian pot：代表potential chg：代表charge den：代表density（电荷密度尽量都用chg） scf：代表自洽迭代self consistent field thr：代表threshold tab：代表table kin：代表kinetic，动能的 cal：代表calculate opt：代表optimize gen：代表generate 3. 四个字符 iter：代表iteration init：代表初始化initializaiton read：读入 stru：代表structure veff：代表有效势 vloc：代表局域势 Reference Google C++ Style Guide "},"develop-dox.html":{"url":"develop-dox.html","title":"ABACUS 注释规范：Doxygen 入门 (c++)","keywords":"","body":"ABACUS 注释规范：Doxygen 入门 (c++) 作者：金祖鑫，邮箱：jinzx@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/15 一、简介 开源密度泛函理论软件 ABACUS 目前由众多社区开发者共同开发，因此有一个统一的代码注释规范是非常重要的，本文主要推荐以 Doxygen 工具为辅助的代码注释格式。 1. 什么是 Doxygen Doxygen 是一款支持包括 C/C++, Python, Fortran 等多种语言的静态程序分析与文档生成工具。通过搜集并整理代码中的信息，包括但不限于 函数的调用/被调用 类的成员以及继承、协作关系 文件夹之间的依赖关系 头文件 include 关系 Doxygen 不仅能自动生成包含以上信息的图表与列表，也能将代码中采用特定格式的注释附到相应位置，最终生成内容翔实的文档。在适当的 Doxygen 配置与良好的代码注释下，Doxygen 自动生成的文档能为开发者提供诸多便利，降低阅读代码的难度，从而促进开发者社区的建设。 2. 功能与文档范例 Doxygen 可以生成某个函数的调用与被调用图(call & caller graph)。以开源密度泛函理论软件 ABACUS 代码为例，其中负责计算三次样条插值的函数 ModuleBase::CubicSpline::eval，doxygen 可将其调用关系自动可视化为如下图表： Doxygen 可以将类的继承关系生成图表。下图展示了 ModuleESolver::ESolver 的一系列继承 Doxygen 可以生成类的协作图（collaboration diagram）。下图展示了 container::Tensor 的成员以及成员的成员之间的关系： Doxygen 可以生成文件夹之间的依赖关系图。下图展示了 source/module_basis 及其内部成员文件夹与其他文件夹的耦合。 Doxygen 可以将头文件的 include 关系可视化成图表 (include dependency graph)。下图（部分地）展示了 module_basis/module_nao/numerical_radial.h 包含与被包含的情况： 大量项目使用 Doxygen 生成文档 (https://www.doxygen.nl/projects.html)。对科学计算开发者而言一个著名的例子是 LAPACK 的在线文档 https://www.netlib.org/lapack/explore-html/ 二、如何使用 Doxygen Doxygen 可以自动识别代码逻辑并生成以上例子中的函数调用、类的继承与协作、文件夹依赖以及头文件依赖等图表。但是，对理想的开发者文档而言代码注释中的信息亦不可或缺。在最终生成的文档中，除以上自动生成的图表外，Doxygen 会将类的成员与函数一一列举，并识别代码中特定格式的注释后将其附在对应位置。 1. 如何写能被 Doxygen 识别的注释 通常开发者会希望一部分精心撰写的注释——比如类的功能介绍或者函数参数的含义——出现在开发者文档里，而不希望文档充斥着临时变量的描述或某一行意义的解释。Doxygen 充分考虑了这一点。事实上，普通的注释均会被 Doxygen 忽略；只有特定格式的注释会被 Doxygen 识别。下面的代码是一个简单的例子。尽管其中各处都附上了注释，但这些均不会出现在最终生成的文档中： // A class that represents a circle. // This toy class will be used to demonstrate the usage of Doxygen. class Circle { public: // Initializes a Circle object with a given radius. // A unit circle is assumed by default. Circle(double r = 1.0); // Rescales a Circle object. // The radius of the given Circle object is multiplied by the given factor. static void rescale(Circle* circ, // pointer to the Circle object double factor // radius rescaling factor ); private: double r_; // radius of the Circle object static constexpr double PI = 3.14159265358979324; }; 以上代码生成的文档如下。Doxygen 会自动将成员变量和函数一一列举，但由于注释不符合特定格式，因而不会出现在文档相应位置。 下面介绍如何写能被 Doxygen 识别的注释以及一些基本用法。 1.1 基本格式 在 c++ 中 Doxygen 会识别以下三种注释格式： Javadoc-style /** * This is a Javadoc-style comment */ Qt-style /*! * This is a Qt-style comment */ Extended c++ style /// This is the so-called extended c++-style comment //! This also works! 以上三种格式本身均是合法的 C++ 注释，只是在 // 和 / / 的基础上添加了额外的 '*' ，'!' 或 '/' 。一旦文档中出现了以上三者之一，Doxygen 便会将之后的注释内容填入文档的相应位置。这三种基本格式是所有 Doxygen 用法的基础，所有的进阶功能（如 group，module，equation 等）均需在这三者之一开启的注释行/块内实现。这三种基本格式可以混用，开发者可以按自己的习惯选择一种或多种使用。 Doxygen 默认注释作用于之后的类、变量或函数（允许有空行）。如我们希望注释作用于之前的对象，则可在基本格式后立刻添加 ' //！ this comment line applies to print(), even though there's an empty line below void print(); /// 1.2 详细与简略描述 如之前例子所示，Doxygen 自动生成类的文档时会先把成员函数与变量罗列在开头，随后才是每个成员的介绍（当然，由于之前的例子里没有采用 doxygen 格式，详细描述为空）。只要使用了基本格式，Doxygen 就会自动将注释附在对应成员处。比如若将之前构造函数前的 // 注释替换为 /// : /// Initializes a Circle object with a given radius. /// A unit circle is assumed by default. Circle(double r = 1.0); 这些内容即会出现在原先为空的 Constructor & Destructor Documentation 下 Circle()的描述里: Doxygen 还允许让一些简略描述出现在类文档的开头部分。有两种方式可以实现这一目的。较为正式的方式是在注释块里添加 @brief 或者 \\brief。以这种方式指定的简略描述可以跨多行（如下面开头 Circle 类的注释）。另一种较为轻便的方式是使用单行的 extended C++ style 注释，如下面 Circle 的构造函数。【多行的 extended c++ style 注释只会被当做详细描述】 /** * @brief A class that represents * a circle. * * This toy class will be used to demonstrate the usage of Doxygen */ class Circle { public: /// Initializes a Circle object with a given radius. /*! * A unit circle is assumed by default. */ Circle(double r = 1.0); /*! * \\brief Rescales a Circle object. * * The radius of the given Circle object is multiplied by the given factor. * */ static void rescale(Circle* circ, double factor ); private: double r_; /// 以上代码生成的 Doxygen 文档在开头罗列部分会出现对应的简略描述；详细介绍部分则会包括所有的注释（包括 brief）。 1.3 函数参数 一个开发者写的函数经常会被很多其他开发者使用。除对函数整体功能的描述外，每个参数含义的注释也十分重要。Doxygen 支持两种给函数参数添加注释的方式。较为正式的方式是在注释块内添加 @param 或 \\param： /*! * \\brief Rescales a Circle object. * * The radius of the given Circle object is multiplied by the given factor. * * @param [in,out] circ Pointer to the Circle object to be rescaled. * @param [in] factor Radius rescaling factor. */ static void rescale(Circle* circ, double factor ); 较为轻便的方式是在函数声明的参数列表里直接添加（加在参数后注意要使用 ' /*! * \\brief Rescales a Circle object. * * The radius of the given Circle object is multiplied by the given factor. */ static void rescale(Circle* circ, /// [in], [out] 或 [in, out] 可以提示该参数是输入还是输出参数。这并非 Doxygen 的强制要求，但十分推荐。 以上两种参数注释方式对 Doxygen 而言是等价的，开发者可按习惯选择一种使用，生成的函数描述如下： 1.4 数学公式 有时一些函数严格对应了某个公式，这种情况下直接用数学公式作为注释的效果可能胜过大段的文字描述。Doxygen 允许开发者以 Latex 的语法实现公式注释。如有在文字中嵌入公式的需求，可以采用 \\f$ ... \\f$： /// A constant that represents the value of \\f$ \\pi \\f$. static constexpr double PI = 3.14159265358979324; 单行公式由 \\f[ ... \\f] 实现： /*! * @brief Returns the area of the current Circle object. * * The area of the a circle is given by * * \\f[ S = \\pi r^2 \\f] */ double area() const; 如有多行公式的需求，Doxygen 支持调用 eqnarray 等 latex 数学环境： /*! * @brief Returns the circumference of the current Circle object. * * The circumference of the a circle is given by * * \\f{eqnarray*}{ * L &= \\pi d \\\\ * &= 2 \\pi r * \\f} * */ double circumference() const; 【在配置文件中采用 “USE_MATHJAX = YES” 可以调用 mathjax 渲染公式得到更好的视觉效果】 1.5 列表 Doxygen 还有大量用法可供用户生成理想的文档。 对齐的 '-', '+' 或 '*' 可自动生成列表 (bullet list)；'-#'则可用来生成带序号的列表： /** * @brief A class that represents * a circle. * * This toy class will be used to demonstrate the usage of Doxygen * * List of functionalities: * -# initialize a Circle object with a given radius * - a unit circle is assumed by default * -# get the radius of the current Circle object * -# get the area of the current Circle object * -# get the circumference of the current Circle object * -# rescale a Circle object by a factor * */ class Circle */ */ 1.6 Member Group & Module 变量或函数可以由 @{ ... ``@} 归类为 member group 并附上相应注释，这能使文档更有层次感： ///@{ @name Properties /// Functions that return the properties of the current Circle object. /// Gets the radius of the current Circle object. double radius() const { return r_; } /*! * @brief Returns the area of the current Circle object. * * The area of the a circle is given by * * \\f[ S = \\pi r^2 \\f] */ double area() const; /*! * @brief Returns the circumference of the current Circle object. * * The circumference of the a circle is given by * * \\f{eqnarray*}{ * L &= \\pi d \\\\ * &= 2 \\pi r * \\f} * */ double circumference() const; ///@} 有共性的类之间亦可归类组成 Modules: /// @defgroup shape Shape Module /// @brief A module that contains various shape classes. /// /// This module contains the following classes: /// - Circle /// - Rectangle /// - Triangle /// @addtogroup shape /// @{ class Circle { ... }; ///@} /// @addtogroup shape /// @{ class Rectangle { ... }; ///@} /// @addtogroup shape /// @{ class Triangle { ... }; ///@} 更多用法可参考官方文档 Doxygen Manual: Overview 2. 如何生成文档 上一节介绍了 Doxygen 支持的注释格式以及一些常见的使用方式。以下以 Ubuntu 用户为例介绍让开发者在本地生成 html 文档的方法： 1. 安装 doxygen 与 graphviz sudo apt install doxygen graphviz 2. 生成 Doxygen 的配置文件 doxygen -g 默认的配置文件名为 Doxyfile。 3. 修改配置文件 配置文件内已经包含介绍各选项的注释。常用的选项包括： INPUT：用以生成文档的文件夹或文件路径 RECURSIVE：是否遍历给定路径下的所有子文件夹 EXCLUDE：是否要排除一些子文件夹或子文件 EXTRACT_PRIVATE, EXTRACT_STATIC, EXTRACT_PRIV_VIRTUAL：文档是否要包括私有成员/静态成员/私有虚函数 CALL_GRAPH, CALLER_GRAPH: 文档是否要包含函数调用/被调图 PREDEFINED：预编译宏 MACRO_EXPANSION：是否要展开宏定义 EXPAND_ONLY_PREDEF：是否只展开 PREDEFINED 的宏定义 一个可供参考的 Doxyfile 可见于 Doxygen 使用 （赵天琦） 完整的配置选项可参考官网 Doxygen Manual: Configuration 4. 运行 doxygen 假设配置文件叫 my_doxyfile： doxygen my_doxyfile 附录：Doxygen 与 VS Code Visual Studio Code 上有 doxygen 插件 Doxygen Documentation Generator - Visual Studio Marketplace 可供 VS Code 用户方便使用。 【注：前文中有提到对 doxygen 而言三种基本注释格式可以混用；混用的注释会合并在一起作用于注释后的对象。这个特性与 VS Code 中鼠标悬停于类或函数上时出现的预览窗口不兼容；如注释格式混用则会导致前一种格式的注释被忽略】 "},"develop-path1.html":{"url":"develop-path1.html","title":"Introduction to ABACUS: Path to PW calculation - Part 1","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 1 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/14 &#x1F4A1;写在前面 作为 SIAB（Systematically Improvable Atomic orbital Basis, link）数值原子轨道生成程序的数据上游，本系列文档将首先从平面波基组/SCF（Self-Consistent Field，即自洽场迭代）讲起，将《从 SIAB 到 ABACUS》的讲述延续下去，之后再探索 SIAB 的下游，即涉及 NAOs 的 LCAO method（basis_type = 'lcao'）。 本系列文档的预期受众：新晋 ABACUS 开发者 &#x1F3A8;写在前面 实际上，在 2023 Q1（第一季度），ABACUS 发布了面向团队内部的代码编程规范，因此在代码阅读过程中可能遇到各种还没有被更正的变量命名，请格外注意。代码的缩进与其他格式则由 2023.5 发布的新 Pull request 标准，采用clang-format-16标准执行。 &#x1F4C3;写在前面 本系列文档内容的组织原则为： 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 首先通过位于根目录下的 main.cpp 进入程序： int main(int argc, char **argv) { ModuleIO::parse_args(argc,argv); Parallel_Global::read_mpi_parameters(argc,argv); Driver DD; DD.init(); // Driver 在本文档中，我们跳过所有关于记录时间的函数，只关心最主要的部分。在 main.cpp 中定义的 Driver 类对象 DD，其类成员函数 Driver::init() 在根目录 driver.cpp 下被定义： void Driver::init() { this->reading(); this->atomic_world(); INPUT.close_log(); } Driver::reading() 首先从 Driver::init() 来到其所调用第一个函数 Driver::reading()： void Driver::reading(void) { INPUT.Init(GlobalV::global_in_card); .... } Input 便发现 Driver 类可能有数据成员 INPUT，查看头文件 driver.h，并没有关于 Input INPUT 的声明，并且 Driver 类实际上并无任何数据成员，因此需要从 #include 中寻找： #include \"driver.h\" #include \"module_io/input.h\" #include \"module_io/input_conv.h\" #include \"module_hamilt_pw/hamilt_pwdft/global.h\" #include \"module_base/memory.h\" #include \"module_base/timer.h\" #include \"module_esolver/esolver.h\" #include \"module_io/cal_test.h\" #include \"module_io/print_info.h\" #include \"module_io/winput.h\" 追踪到 input.h，发现外部变量声明： extern Input INPUT; 在 input.cpp 中则有 Input INPUT; 这一 INPUT 的变量定义。类似地，我们在更多的被 include 文件中寻找 extern 变量，这些变量都会在程序运行一开始被定义，直到程序结束时才会销毁： // module_hamilt_pw/hamilt_pwdft/global.h namespace GlobalC { // line 284 extern pseudopot_cell_vnl ppcell; // line 292 extern UnitCell ucell; extern Parallel_Grid Pgrid; extern Parallel_Kpoints Pkpoints; extern Restart restart; // Peize Lin add 2020.04.04 即是说例如对于 UnitCell ucell，其数据成员全部会在程序运行一开始被创建。 Input::init() Driver 首先调用的 INPUT 的成员函数 Input::Init()（ABACUS 中很多类都具有 init() 函数，但存在函数名无法体现其功能的问题，可能会在后续工作中修改），该成员函数定义在 source/module_io/input.cpp，同时也发现了 Input INPUT 的定义： //source/module_io/input.cpp Input INPUT; void Input::Init(const std::string &fn) { this->Default(); bool success = this->Read(fn); this->Default_2(); #ifdef __MPI Parallel_Common::bcast_bool(input_error); Parallel_Common::bcast_bool(success); Bcast(); #endif bool out_dir = false; if(!out_app_flag && (out_mat_hs2 || out_mat_r || out_mat_t || out_mat_dh)) out_dir = true; ModuleBase::Global_File::make_dir_out(this->suffix, this->calculation, out_dir, GlobalV::MY_RANK, this->mdp.md_restart, this->out_alllog); Check(); } Input::init() 唯一参数为 fn，实际被传入参数 GlobalV::global_in_card（这里 GlobalV 代表 Global Variables，是全局变量的意思，一般用全大写的变量名，C++ 区分字母大小写，Fortran 不区分）。这一参数在 module_base/global_variable.cpp 中被定义，类似的文件还有 stru_file 和 global_kpoint_card： //source/module_base/global_variable.cpp std::string global_in_card = \"INPUT\"; std::string stru_file = \"STRU\"; std::string global_kpoint_card = \"KPT\"; 因此 Input::init() 函数实际上将要打开 INPUT 文件。 Input::Default() Input::init() 调用 Input::Default() 函数， //source/module_io/input.cpp void Input::Init(const std::string &fn) { this->Default(); // Read(fn); this->Default_2(); .... 其定义为： //source/module_io/input.cpp void Input::Default(void) { suffix = \"ABACUS\"; stru_file = \"\"; // xiaohui modify 2015-02-01 kpoint_file = \"\"; // xiaohui modify 2015-02-01 pseudo_dir = \"\"; orbital_dir = \"\"; // liuyu add 2021-08-14 read_file_dir = \"auto\"; wannier_card = \"none\"; latname = \"none\"; calculation = \"scf\"; esolver_type = \"ksdft\"; pseudo_rcut = 15.0; // qianrui add this parameter 2021-5 pseudo_mesh = false; // qianrui add this pararmeter ntype = 0; ... 即 Input::Default() 函数为所有变量赋默认值。当前所展示的这些变量实际上均为 Input 类的数据成员，而非 GlobalV 等全局类。全局类的存在是为了避免出现巨大的形参表。在 Input::Default() 之后，调用 Input::Read() 函数读取 INPUT 文件，并确定是否读取成功。 Input::Read() //source/module_io/input.cpp void Input::Init(const std::string &fn) { this->Default(); bool success = this->Read(fn); // Default_2(); .... Input::Read() 函数： //source/module_io/input.cpp bool Input::Read(const std::string &fn) { .... std::ifstream ifs(fn.c_str(), std::ios::in); ifs.clear(); ifs.seekg(0); char word[80]; char word1[80]; .... while (ifs.good()) { ifs >> word1; if (ifs.eof()) break; strtolower(word1, word); if (strcmp(\"suffix\", word) == 0) read_value(ifs, suffix); else if (strcmp(\"stru_file\", word) == 0) read_value(ifs, stru_file); ... &#x1F527;重构思考 Input::read() 函数的功能为读取 INPUT 文件（创建 ifstream 类对象 ifs），之后使用对 N 行参数定义，使用最多 N 次 if 判断 strcmp 的方法进行参数读取，若参数读取成功，被传递给 Input 类的数据成员（覆盖）。 由于我们现在考察针对 PW（Plane Wave，平面波）的相关功能，因此额外注意包含 pw 的相关字段： bool Input::Read(const std::string &fn) { .... if (basis_type == \"pw\" && gamma_only != 0) // pengfei Li add 2015-1-31 { gamma_only = 0; GlobalV::ofs_running 这里 \"gamma_only\" 不为 0，是因为目前 ABACUS 不支持只计算单个布里渊区 k=（0，0，0）（通常称为 Gamma 点）的算法，只用 Gamma 点的算法可以把平面波基矢量减少一半，但目前 ABACUS 还不支持。 Input::Default_2() //source/module_io/input.cpp void Input::Init(const std::string &fn) { this->Default(); bool success = this->Read(fn); this->Default_2(); // 接下来 Input 类成员调用其 Input::Default_2() 方法： //source/module_io/input.cpp void Input::Default_2(void) // jiyy add 2019-08-04 { if (GlobalV::MY_RANK != 0) return; if (vdw_s6 == \"default\") { if (vdw_method == \"d2\") vdw_s6 = \"0.75\"; else if (vdw_method == \"d3_0\" || vdw_method == \"d3_bj\") vdw_s6 = \"1.0\"; } if (vdw_s8 == \"default\") { if (vdw_method == \"d3_0\") vdw_s8 = \"0.722\"; else if (vdw_method == \"d3_bj\") vdw_s8 = \"0.7875\"; } ... if (calculation == \"scf\") { if (mem_saver == 1) { mem_saver = 0; ModuleBase::GlobalFunc::AUTO_SET(\"mem_saver\", \"0\"); } this->relax_nmax = 1; } else if (calculation == \"relax\") { if (mem_saver == 1) { mem_saver = 0; ModuleBase::GlobalFunc::AUTO_SET(\"mem_saver\", \"0\"); } cal_force = 1; if (!this->relax_nmax) this->relax_nmax = 50; } 在首先设置 Default，即参数默认值后再覆盖，然后再调用 Default_2 的好处是可以再次覆盖某些参数的实际取值，并根据 case-by-case 地，调整某些值。实际上，此处暗示了一些已经成熟的参数搭配方式，即是说根据特征的任务，实际上都有其一套参数赋值方案。 void Input::Default_2(void) // jiyy add 2019-08-04 { .... if (basis_type == \"pw\") { if (ks_solver == \"default\") { ks_solver = \"cg\"; ModuleBase::GlobalFunc::AUTO_SET(\"ks_solver\", \"cg\"); } else if (ks_solver == \"cg\") { GlobalV::ofs_warning 考虑到一般而言第一性原理软件分支功能众多，且对于 ABACUS，其功能的扩展需要入侵性修改众多代码，行数过多，易扩展性有待提高（关于程序的易扩展性设计方案，见之后单独文档）。因此以下我们首先假设情景为使用 PW 进行 SCF 计算。 ModuleBase::Global_File::make_dir_out() //source/module_io/input.cpp .... void Input::Init(const std::string &fn) { .... bool out_dir = false; if(!out_app_flag && (out_mat_hs2 || out_mat_r || out_mat_t || out_mat_dh)) out_dir = true; ModuleBase::Global_File::make_dir_out(this->suffix, this->calculation, out_dir, GlobalV::MY_RANK, this->mdp.md_restart, this->out_alllog); // 区别于之前的 Input 类中成员函数，这里突然调用的函数变成了 ModuleBase 类。这个函数的功能为读取 INPUT 文件之后，在 INPUT 中定义的 out_dir、suffix 等，在这里可以拼合成为完整路径，并使用 C++/Linux interface 来根据具体任务创建不同的具体输出路径（jump to the code）： //source/module_io/input.cpp void ModuleBase::Global_File::make_dir_out(const std::string &suffix, const std::string &calculation, const bool &out_dir, const int rank, const bool &restart, const bool out_alllog) { std::string prefix ; #ifdef __EPM #ifdef __MPI prefix = \"OUT_EPM_MPI.\"; #else prefix = \"OUT_EPM.\"; #endif #else prefix = \"OUT.\"; #endif GlobalV::global_out_dir = prefix + suffix + \"/\"; GlobalV::global_stru_dir = GlobalV::global_out_dir + \"STRU/\"; GlobalV::global_matrix_dir = GlobalV::global_out_dir + \"matrix/\"; #ifdef __MPI MPI_Barrier(MPI_COMM_WORLD); #endif int make_dir = 0; std::string command0 = \"test -d \" + GlobalV::global_out_dir + \" || mkdir \" + GlobalV::global_out_dir; if(calculation == \"md\") { int make_dir_stru = 0; std::string command1 = \"test -d \" + GlobalV::global_stru_dir + \" || mkdir \" + GlobalV::global_stru_dir; ....} if((out_dir) && calculation == \"md\") { int make_dir_matrix = 0; std::string command1 = \"test -d \" + GlobalV::global_matrix_dir + \" || mkdir \" + GlobalV::global_matrix_dir; times = 0; ....} std::stringstream ss,ss1; if(out_alllog) { ss &#x1F527;重构思考 这部分定义出了相当多的输出文件和目录，然而多个输出文件往往不利于对 ABACUS 新上手使用者，容易在繁多的文件中迷路，因此可以考虑重新设计输出信息。 最后调用 Input::check() 函数对某些参数进行核对。 Input_Conv 返回 Driver::reading()，来到 Input_Conv::Convert(). void Driver::reading(void) { INPUT.Init(GlobalV::global_in_card); Input_Conv::Convert(); // Input_Conv::Convert() 这个函数实现了从 Input 类对象的数据成员到 GlobalV 和 GlobalC 等全局变量集合的转换。相当于从 Input 到 GlobalV 和 GlobalC，以及其他直接的类的参数上载： 其他内容见 ABACUS 第一版开发手册（02. IO 模块，目前暂为飞书内部文档）： void Input_Conv::Convert(void) { .... else if (INPUT.stru_file != \"\") { GlobalV::stru_file = INPUT.stru_file; } GlobalV::global_wannier_card = INPUT.wannier_card; if (INPUT.kpoint_file != \"\") GlobalV::global_kpoint_card = INPUT.kpoint_file; .... GlobalC::ucell.setup(INPUT.latname, INPUT.ntype, INPUT.lmaxmax, INPUT.init_vel, INPUT.fixed_axes); if (INPUT.calculation == \"relax\" || INPUT.calculation == \"cell-relax\") { if (INPUT.fixed_ibrav && !INPUT.relax_new) { ModuleBase::WARNING_QUIT(\"Input_Conv\", \"fixed_ibrav only available for relax_new = 1\"); } .... GlobalV::fixed_atoms = INPUT.fixed_atoms; } for(int i=0;i &#x1F527;重构思考 对模拟体系的完全与分层次描述，是每个模拟软件包的核心设计要求。INPUT 的数据成员不仅录入到 GlobalV, GlobalC，还录入到 BFGS_Basic, Ions_Move_Basic 等类中，或许部分扰乱了这种层级。 winput &#x1F4DD;开发者旁注 本部分内容已经过时，在未来发行版中将会完全弃用 void Driver::reading(void) { INPUT.Init(GlobalV::global_in_card); Input_Conv::Convert(); .... winput::Init(GlobalV::global_wannier_card); // 接下来来到 Wannier 函数计算部分，调用 Init()函数，传入参数为 wannier 文件的具体路径（winput 相关的这部分功能目前已经基本不使用，相关读入参数都在 INPUT 里面实现，后续版本会把这部分代码删除）。 在 Input::Default() 中，该量被设置为 \"none\"，在 Input::Read() 中，该量对应于关键词 wannier_card 被读入。实际上，一般将 wannier_card 赋值为 INPUTw。 winput::Init() void winput::Init(const std::string &fn) { Default(); Read(fn); Check(); #ifdef __MPI Bcast(); #endif } winput::Default() wannier_card 部分同样具有 Default() 函数， void winput::Default() { //======================== // part1 : control //======================== target = \"test\"; wlmr_dir = \"./\"; rcut = 10; before_iter = false; after_iter = false; begin_stop_flag = false; end_flag = false; ... } 其中各变量均为 winput 中数据成员，类型附加 static 关键词。 winput::Read() &#x1F527;重构思考 此处仍然使用 if(strcmp()) 方法读入输入文件中参数 void winput::Read(const std::string &fn) { if(GlobalV::MY_RANK!=0) return; std::ifstream ifs(fn.c_str(), std::ios::in); ifs.clear(); ifs.seekg(0); char word[80]; .... while (ifs.good()) { ifs >> word; for(auto &i : word) { i = tolower(i); } //parameters for users if (strcmp(\"target\", word) == 0) {read_value(ifs, target);} else if (strcmp(\"trial\", word) == 0) {read_value(ifs, trial);} ... winput::check() 则同样地，进行一些检查。 变量分发举例：winput::Bcast()和 Input::Bcast() 和 Input 一样，winput::Bcast() 对读入所有参数进行节点间广播： #include \"module_base/parallel_common.h\" #ifdef __MPI void winput::Bcast(void) { Parallel_Common::bcast_string( target ); Parallel_Common::bcast_bool( before_iter ); ... Parallel_Common::bcast_double( rcut ); ... Parallel_Common::bcast_string( wlmr_dir ); ... Parallel_Common::bcast_int( imp_pao ); ... 同理在 Input::Bcast() 中： #ifdef __MPI void Input::Bcast() { Parallel_Common::bcast_string(suffix); Parallel_Common::bcast_string(stru_file); // xiaohui modify 2015-02-01 Parallel_Common::bcast_string(pseudo_dir); // Parallel_Common::bcast_string(pseudo_type); // mohan add 2013-05-20 (xiaohui add 2013-06-23) Parallel_Common::bcast_string(orbital_dir); Parallel_Common::bcast_string(kpoint_file); // xiaohui modify 2015-02-01 Parallel_Common::bcast_string(wannier_card); ... Prallel_Common 属于 module_base 中 parallel_common.h 中声明的自建命名空间，其声明大致如下： namespace Parallel_Common { void bcast_complex_double( std::complex *object, const int n); ... void bcast_complex_double( std::complex &object); ... } 举例其中 Prallel_Common::bcast_int()： void Parallel_Common::bcast_int(int &object) { MPI_Bcast(&object, 1, MPI_INT, 0, MPI_COMM_WORLD); } 其中 MPI_Bcast() 为 MPI 内部函数，其参数表中分别传入了需广播数据的内存地址、、数据类型，以及。 ▶ 离开 winput，回到 source/driver.cpp Driver::reading()，只剩下如下内容： std::stringstream ss1; ss1 Driver::atomic_world() Driver::atomic_world() 函数中执行的内容其实只有 Driver::driver_run() 函数： void Driver::atomic_world(void) { this->driver_run(); } 不要忘记我们已经完成 Driver::reading() 函数内容，到达 Driver::atomic_world()。这一点从本文档设置的分级目录中也可以看得到。 cppvoid Driver::init() { this->reading(); this->atomic_world(); // Driver::driver_run() esolver ESolver 是 ABACUS 内部工作流的驱动，根据当前模拟任务所属阶段，按顺序调用各个所需模块， &#x1F4DD;开发者旁注 原则上讲，ESolver 不应当含有 Device 和 FPTYPE 模板参数，未来将会被舍弃 Driver::driver_run() 定义在 source/driver.cpp 文件中，是实际驱动 ABACUS 各模块的驱动（driver）。首先创建 ESolver 类指针，并利用 ModuleESolver::init_esolver() 将其初始化： void Driver::driver_run() { ModuleESolver::ESolver *p_esolver = nullptr; ModuleESolver::init_esolver(p_esolver); ... ModuleESolver::init_esolver() 我们目前只关注 pw 基的方法，首先调用 ModuleESolver::determine_type() 函数，读取具体在 INPUT 中定义的计算类型（GlobalV::ESOLVER_TYPE 和 GlobalV::BASIS_TYPE）： void init_esolver(ESolver*& p_esolver) { std::string esolver_type = determine_type(); 作为回溯，GlobalV::ESOLVER 和 GlobalV::BASIS_TYPE 的赋值在 module_io/input_conv.cpp： GlobalV::BASIS_TYPE = INPUT.basis_type; // line 320 GlobalV::ESOLVER_TYPE = INPUT.esolver_type; // line 273 其在 INPUT 中关键词为（module_io/input.cpp）： else if (strcmp(\"basis_type\", word) == 0) //line 843 { read_value(ifs, basis_type); ... else if (strcmp(\"esolver_type\", word) == 0)// line 685 { read_value(ifs, esolver_type); } ... ModuleESolver::determine_type() 接下来根据 basis_type 和 esolver_type 两关键词对 esolver_type 进行赋值（❗ 此处已经出现 esolver 一词多义，在 ModuleESolver 域中实际上是 [能量计算方法]_[基组](_[任务类型]） 的合并）： std::string determine_type() { std::string esolver_type = \"none\"; if (GlobalV::BASIS_TYPE == \"pw\") { if(GlobalV::ESOLVER_TYPE == \"sdft\") esolver_type = \"sdft_pw\"; else if(GlobalV::ESOLVER_TYPE == \"ofdft\") esolver_type = \"ofdft\"; else if(GlobalV::ESOLVER_TYPE == \"ksdft\") esolver_type = \"ksdft_pw\"; } else if (GlobalV::BASIS_TYPE == \"lcao_in_pw\") { #ifdef __LCAO if(GlobalV::ESOLVER_TYPE == \"sdft\") esolver_type = \"sdft_pw\"; else if(GlobalV::ESOLVER_TYPE == \"ksdft\") esolver_type = \"ksdft_pw\"; #endif } else if (GlobalV::BASIS_TYPE == \"lcao\") { #ifdef __LCAO if(GlobalV::ESOLVER_TYPE == \"tddft\") esolver_type = \"ksdft_lcao_tddft\"; else if(GlobalV::ESOLVER_TYPE == \"ksdft\") esolver_type = \"ksdft_lcao\"; #endif } else { if(GlobalV::ESOLVER_TYPE == \"lj\") esolver_type = \"lj_pot\"; else if(GlobalV::ESOLVER_TYPE == \"dp\") esolver_type = \"dp_pot\"; else if(esolver_type == \"none\") { ModuleBase::WARNING_QUIT(\"ESolver\", \"No such esolver_type combined with basis_type\"); } } return esolver_type; } 得到 esolver_type，返回 ModuleESolver::init_esolver()，之后根据其由 esolver_type 定义的不同内容，为创建的 p_esolver 指定对应类型的内存空间，此时注意到各类 ESolver_* 实际上都是对 ModuleESolver::ESolver 父类的继承，而 p_esolver 为父类指针： if (esolver_type == \"ksdft_pw\") { #if ((defined __CUDA) || (defined __ROCM)) if (GlobalV::device_flag == \"gpu\") { if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); return; } #endif if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); } #ifdef __LCAO else if (esolver_type == \"ksdft_lcao\") p_esolver = new ESolver_KS_LCAO(); else if (esolver_type == \"ksdft_lcao_tddft\") p_esolver = new ESolver_KS_LCAO_TDDFT(); #endif else if (esolver_type == \"sdft_pw\") p_esolver = new ESolver_SDFT_PW(); else if (esolver_type == \"ofdft\") p_esolver = new ESolver_OF(); else if (esolver_type == \"lj_pot\") p_esolver = new ESolver_LJ(); else if (esolver_type == \"dp_pot\") p_esolver = new ESolver_DP(INPUT.mdp.pot_file); } 各种 esolver 的继承关系如下所示。例如 ESolver_KS_PW 和 ESolver_KS_LCAO，均公有继承自 ESolver_KS： // module_solver/esolver_ks_pw.h namespace ModuleESolver { template class ESolver_KS_PW : public ESolver_KS // module_esolver/esolver_ks_lcao.h namespace ModuleESolver { class ESolver_KS_LCAO : public ESolver_KS ESolver_KS 则公有继承自 ESolver_FP： // module_solver/esolver_ks.h namespace ModuleESolver { template class ESolver_KS : public ESolver_FP ESolver_FP 公有继承自 ESolver： // module_solver/esolver_fp.h namespace ModuleESolver { class ESolver_FP : public ESolver 而 p_esolver 为 ModuleESolver::ESolver 类指针，自然可以如此赋值。其他关于各种 ESolver 的层级关系，可见第一版开发者手册的 09. ESolver 模块 （目前暂为飞书内部文档) 。接下来我们假设 esolver_type == \"ksdft_pw\"，则我们需要关注前面已经展示过的（module_esolver/esolver.cpp ModuleESolver::init_esolver(): line 93）： if (esolver_type == \"ksdft_pw\") { #if ((defined __CUDA) || (defined __ROCM)) if (GlobalV::device_flag == \"gpu\") { if (GlobalV::precision_flag == \"single\") { p_esolver = new ESolver_KS_PW(); } else { p_esolver = new ESolver_KS_PW(); } return; } #endif if (GlobalV::precision_flag == \"single\") { p_esolver = new ESolver_KS_PW(); } else { p_esolver = new ESolver_KS_PW(); } } 我们首先只关注 p_esolver = new ESolver_KS_PW();，即精度为浮点双精度，使用 cpu 为计算设备的情况。 不难发现，关于 ESolver_KS_PW 类的具体实现，同时使用数据类型和设备作为模板： namespace ModuleESolver { template ESolver_KS_PW::ESolver_KS_PW() { this->classname = \"ESolver_KS_PW\"; this->basisname = \"PW\"; this->device = psi::device::get_device_type(this->ctx); #if ((defined __CUDA) || (defined __ROCM)) if (this->device == psi::GpuDevice) { hsolver::createBLAShandle(); hsolver::createCUSOLVERhandle(); } #endif } 其代入的设备类型 psi::DEVICE_CPU，是 psi 命名空间的变量。 至此，ModuleESolver::init_esolver() 退出，p_esolver 有值 &ESolver_KS_PW()，来到设置模拟体系的结构部分。 附录 配置便捷高效 Vscode C++ 工作环境（Windows） 在大型程序的代码阅读过程中，往往遇到变量和函数数量大，源文件、头文件不计其数的情况。因此高效、快速寻找当前感兴趣变量/函数/类/命名空间的上下游就十分重要。Vscode 是由 Microsoft 开发的集成开发环境，具有轻量、灵活、功能健全、插件开发者活跃、程序迭代较快等优点，因此推荐 Vscode 作为 ABACUS 的编辑器。 Vscode 下载链接：Download Visual Studio Code - Mac, Linux, Windows 在选择“是否把 vscode 添加到 PATH 环境变量”时，如无特殊需求，建议选择“是”，同时在选择“是否将 vscode 添加到右键菜单”时，选择“是”。 相关资料：新人教程文档（目前暂为飞书内部文档) Vscode C++ 插件 配置完成 Vscode 后，在其扩展商店搜索“C/C++”，即可顺利一并安装三个插件，用于 C++ 程序的开发工作。 Mingw64 GNU compilers 为了让 C++ 开发环境变得更加智能，需要联合编译器，让编译器寻找变量、函数、类、命名空间等之间跨文件的引用关系。为了实现这一点，见 Microsoft Vscode 关于 C++ 编译器的官方配置教程： Get Started with C++ and Mingw-w64 in Visual Studio Code 之后在 vscode setting.json 添加 “C_Cpp.default.compilerPath” 值，且可选 \"C_Cpp.default.cppStandard\" 值，对于 ABACUS，通常选择 \"c++11\" 或 \"c++14\"。 Mingw64 fftw3, mpi and googletest libraries 为了能够尽可能多避免 vscode 浏览 ABACUS 代码过程中报错，可以选择安装发行在 msys2 系列平台上的 fftw3 和 msmpi 库： fftw3: https://packages.msys2.org/package/mingw-w64-i686-fftw?repo=mingw32 msmpi: https://packages.msys2.org/package/mingw-w64-x86_64-msmpi Googletest: https://packages.msys2.org/base/mingw-w64-googletest 其他常见的库也可以在 https://packages.msys2.org/进行搜索后，复制命令在 msys2 prompt 进行下载安装 CMake ABACUS 使用 CMake 便捷编译，因此也可以在本地配置 CMake。 下载、安装 CMake：Download | CMake 将安装好的 CMake 一并放入 PATH 环境变量，之后在 Vscode setting.json 中添加 “cmake.generator”，以及 \"cmake.cmakePath\" 值，设置 \"cmake.additionalCompilerSearchDirs\"。 将本地 Vscode 连通 Bohrium 平台进行高效编译开发 Bohrium 平台提供在线云计算服务，对于 ABACUS 开发工作，可以在其服务器上进行软件编译。 Bohrium 网站： 之后请 follow 单元测试环境搭建教程：新人教程文档 （目前暂为飞书内部文档) 变量、函数、类的声明、定义、调用快捷跳转 对准想要查看其声明、定义和调用（引用）的量，点击鼠标右键： 若跳转到声明（.h 文件），发现其声明旁未添加注释，或注释并非 Doxygen 格式，可以在 Vscode 扩展应用商店下载 Doxygen 插件后，发现菜单出现“生成 Doxygen 注释”，将注释内容复写为 Doxygen 格式。 相关材料：自动文档 Doxygen 使用说明 （目前暂为飞书内部文档) 给你的开发加点魔法：Github.copilot vscode 部署 首先进行 Github 学生认证：https://education.github.com/pack 然后在 vscode 上 Extension 界面下载 Github copilot 插件。vscode 通过最下角 Github 账号登录来验证 Github.copilot 的使用权限（完成学生认证后自动拥有 Github.copilot 的使用权限）。 系列链接 上篇：从 SIAB 到 ABACUS（一）：准备工作（施工中 &#x1F6A7;） 下篇：Introduction to ABACUS: Path to PW calculation - Part 2 "},"develop-path2.html":{"url":"develop-path2.html","title":"Introduction to ABACUS: Path to PW calculation - Part 2","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 2 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/15 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 承接上篇对 INPUT 文件的解析，本篇延续 ABACUS workflow，介绍和 STRU 文件中信息读取紧密相关的 UnitCell 类。 Driver Driver::atomic_world() Driver::driver_run() ucell 在 driver_run.cpp 中直接调用了 GlobalC 的数据成员 UnitCell ucell 的成员函数 UnitCell::setup_cell()， // driver_run.cpp void Driver::driver_run() { .... GlobalC::ucell.setup_cell(GlobalV::stru_file, GlobalV::ofs_running); 则自然回忆回溯在何时 ucell 被声明、定义、初始化的（尽管在上篇中已经明确提到）。寻得在 module_hamilt_pw/hamilt_pwdft/global.h 中，有关于 ucell 为 extern 变量的声明： namespace GlobalC { extern UnitCell ucell; 同时在 module_hamilt_pw/hamilt_pwdft/global.cpp 中，有其定义： namespace GlobalC { UnitCell ucell; 则对于需要使用到 UnitCell 对象 ucell 的场合，只需要包含 module_hamilt_pw/hamilt_pwdft/global.h 头文件即可，其中 ucell 为全局类（将来可能会把这个全局类去掉，换成指定范围内可以使用的模块）。 UnitCell:setup_cell() ucell 的一些数据成员在 Input_Conv::Convert() 函数中赋值： // line 266 GlobalC::ucell.setup(INPUT.latname, INPUT.ntype, INPUT.lmaxmax, INPUT.init_vel, INPUT.fixed_axes); GlobalC::UnitCell::setup() 函数除了导入前四个量外，根据最后一个传入参数，控制 UnitCell ucell 中晶格矢量的约束条件 lc[0], lc[1] 和 lc[2]。可见 lc[i] 实际上可能会出现在晶格矢量的 rescale factor 里，额外使用 lc[i] 作为变化量的 factor，若为 0，固定，则该晶格矢量在程序运行中不会有变化。 void UnitCell::setup(const std::string& latname_in, const int& ntype_in, const int& lmaxmax_in, const bool& init_vel_in, const std::string& fixed_axes_in) { this->latName = latname_in; this->ntype = ntype_in; this->lmaxmax = lmaxmax_in; this->init_vel = init_vel_in; if (fixed_axes_in == \"None\") this->lc[0] = 1; this->lc[1] = 1; this->lc[2] = 1; else if (fixed_axes_in == \"volume\") { this->lc[0] = 1; this->lc[1] = 1; this->lc[2] = 1; if (!GlobalV::relax_new) { ModuleBase::WARNING_QUIT( \"Input\", \"there are bugs in the old implementation; set relax_new to be 1 for fixed_volume relaxation\"); } } else if (fixed_axes_in == \"shape\") { if (!GlobalV::relax_new) { ModuleBase::WARNING_QUIT(\"Input\", \"set relax_new to be 1 for fixed_shape relaxation\"); } this->lc[0] = 1; this->lc[1] = 1; this->lc[2] = 1; } else if (fixed_axes_in == \"a\") this->lc[0] = 0; this->lc[1] = 1; this->lc[2] = 1; ....//omit b and c else if (fixed_axes_in == \"ab\") this->lc[0] = 0; this->lc[1] = 0; this->lc[2] = 1; ....//omit without b and c else if (fixed_axes_in == \"abc\") this->lc[0] = 0; this->lc[1] = 0; this->lc[2] = 0; else ....//warning and quit return; } 回到 Driver::driver_run() 的 line 33（Link），其所调用 UnitCell::setup_cell() 函数首先根据前文提到在 Input_Conv::Convert() 中调用的 UnitCell::setup() 函数，确定了 UnitCell::ntype，因此使用 ntype 重新为 magnet.start_magnetization 分配内存空间。UnitCell::magnet 成员变量在 module_cell/unitcell.h 中被声明。类似的还有 ucell.atoms 等。 void UnitCell::setup_cell(const std::string &fn, std::ofstream &log) { delete[] magnet.start_magnetization; magnet.start_magnetization = new double[this->ntype]; this->atoms = new Atom[this->ntype]; this->set_atom_flag = true; class UnitCell { public: Magnetism magnet; // magnetism Yu Liu 2021-07-03 在 Driver::driver_run() 中调用 UnitCell::setup_cell() 时，传入参数 GlobalV::stru_file 和文件流对象 GlobalV::ofs_running，前者具有默认值 STRU（Introduction to ABACUS: Path to PW calculation - Part 1 Input::init()），后者同样具有默认值，见 global_file.cpp。 STRU file parse 若 STRU 文件存在，读取其中内容： const int error = this->read_atom_species(ifa, log); ok2 = this->read_atom_positions(ifa, log, GlobalV::ofs_warning); ifa 即为打开 STRU 的 ifstream 文件流对象，log 为 GlobalV:ofs_running 变量。 Basic structure of STRU file: examples 在开始阅读 STRU 文件解析程序部分之前，首先展示几种 STRU 文件样例： // with latname = 'fcc' in INPUT file ATOMIC_SPECIES Si 28.00 Si_ONCV_PBE-1.0.upf // label; mass; pseudo_file NUMERICAL_ORBITAL Si_gga_8au_60Ry_2s2p1d.orb //numerical_orbital_file LATTICE_CONSTANT 10.2 // lattice scaling factor (Bohr) ATOMIC_POSITIONS Direct //Cartesian or Direct coordinate. Si // Element type 0.0 // magnetism 2 // number of atoms 0.00 0.00 0.00 0 0 0//the position of atoms and other parameter specify by key word 0.25 0.25 0.25 1 1 1 // with latname = 'none' or do not set it in INPUT file ATOMIC_SPECIES Si 28.00 Si_ONCV_PBE-1.0.upf upf201 // label; mass; pseudo_file; pseudo_type NUMERICAL_ORBITAL Si_gga_8au_60Ry_2s2p1d.orb //numerical_orbital_file LATTICE_CONSTANT 10.2 // lattice scaling factor (Bohr) LATTICE_VECTORS 0.5 0.5 0.0 // latvec1 0.5 0.0 0.5 // latvec2 0.0 0.5 0.5 // latvec3 ATOMIC_POSITIONS Direct //Cartesian or Direct coordinate. Si // Element type 0.0 // magnetism(Be careful: value 1.0 refers to 1.0 bohr mag, but not fully spin up !!!) 2 // number of atoms 0.00 0.00 0.00 0 0 0 0.25 0.25 0.25 1 1 1 ATOMIC_SPECIES Pt 195.08 Pt_ONCV_PBE-1.0.upf LATTICE_CONSTANT 1.8897259886 // 1 Angstrom, but unit required is Bohr, so it is this value LATTICE_VECTORS 8.4359998703 0.0000000000 0.0000000000 -4.2179999352 7.3057901940 0.0000000000 0.0000000000 0.0000000000 25.1919994354 ATOMIC_POSITIONS Cartesian // Cartesian (Unit is LATTICE_CONSTANT) Pt 0.0 27 0.000000000 0.000000000 3.288052246 1.405985941 0.811746362 1.643526123 0.000000000 1.623492723 0.000000000 2.811971882 0.000000000 3.287052246 ... // directly start after ATOMIC_POSITIONS' title Fe 1.0 2 0.0 0.0 0.0 m 0 0 0 mag 1.0 angle1 90 angle2 0 0.5 0.5 0.5 m 1 1 1 mag 1.0 angle1 90 angle2 180 &#x1F527;重构思考 将来可以增添 xyz 格式的原子信息文件到 ABACUS 的接口以增强易用性。 UnitCell::read_atom_species() ⚙UnitCell::read_atom_species() 函数实际上读取除原子坐标外的所有信息，如晶格矢量 latvec 等。这些变量都是 UnitCell 的数据成员。具体读取的 section 有 ATOMIC_SPECIES, NUMERICAL_ORBITAL, NUMERICAL_DESCRIPTOR, ABFS_ORBITAL, LATTICE_CONSTANT, LATTICE_VECTORS, LATTICE PARAMETERS 等。 int UnitCell::read_atom_species(std::ifstream &ifa, std::ofstream &ofs_running) { int error = 0; delete[] atom_label; this->atom_mass = new double[ntype]; delete[] atom_mass; this->atom_label = new std::string[ntype]; delete[] pseudo_fn; this->pseudo_fn = new std::string[ntype]; delete[] pseudo_type; this->pseudo_type = new std::string[ntype]; delete[] orbital_fn; this->orbital_fn = new std::string[ntype]; ... if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"ATOMIC_SPECIES\") ) { ... #ifdef __LCAO if(GlobalV::BASIS_TYPE==\"lcao\" || GlobalV::BASIS_TYPE==\"lcao_in_pw\") { if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"NUMERICAL_ORBITAL\") ) { for(int i=0; i> orbital_fn[i]; } if(GlobalV::deepks_setorb) { if (ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"NUMERICAL_DESCRIPTOR\")) { ifa >> descriptor_file; } } else descriptor_file = GlobalV::global_orbital_dir + orbital_fn[0]; } ... #ifdef __EXX if( GlobalC::exx_info.info_global.cal_exx ) { if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"ABFS_ORBITAL\") ) { for(int i=0; i> ofile; GlobalC::exx_info.info_ri.files_abfs.push_back(ofile); } } } if (GlobalV::rpa_setorb) { if (ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"ABFS_ORBITAL\")) { GlobalV::rpa_orbitals.resize(ntype); for (int i = 0; i > GlobalV::rpa_orbitals[i]; } } .... if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_CONSTANT\") ) { ModuleBase::GlobalFunc::READ_VALUE(ifa, lat0); lat0_angstrom = lat0 * 0.529177 ; this->tpiba = ModuleBase::TWO_PI / lat0; this->tpiba2 = tpiba * tpiba; } ... if(latName==\"none\"){ if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_VECTORS\") ) { ifa >> latvec.e11 >> latvec.e12; ModuleBase::GlobalFunc::READ_VALUE(ifa, latvec.e13); ifa >> latvec.e21 >> latvec.e22; ModuleBase::GlobalFunc::READ_VALUE(ifa, latvec.e23); ifa >> latvec.e31 >> latvec.e32; ModuleBase::GlobalFunc::READ_VALUE(ifa, latvec.e33); // read e(i)3 in this way is to change to the next line } if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_PARAMETERS\") ) { ModuleBase::WARNING_QUIT(\"UnitCell::read_atom_species\",\"do not use LATTICE_PARAMETERS without explicit specification of lattice type\"); } } else{ if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_VECTORS\") ) { ModuleBase::WARNING_QUIT(\"UnitCell::read_atom_species\",\"do not use LATTICE_VECTORS along with explicit specification of lattice type\"); } if(latName==\"sc\"){//simple-cubic, ibrav = 1 latvec.e11 = 1.0; latvec.e12 = 0.0; latvec.e13 = 0.0; latvec.e21 = 0.0; latvec.e22 = 1.0; latvec.e23 = 0.0; latvec.e31 = 0.0; latvec.e32 = 0.0; latvec.e33 = 1.0; else if(latName==\"fcc\"){//face-centered cubic, ibrav = 2 ...} else if(latName==\"bcc\"){//body-centered cubic, ibrav = 3 ...} ... else if(latName==\"triclinic\"){//triclinic, ibrav = 14 double bba = 0.0; double cba = 0.0; double cosab = 0.0; double cosac = 0.0; double cosbc = 0.0; double sinab = 0.0; double term = 0.0; if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_PARAMETERS\") ) { ifa >> bba >> cba >> cosab >> cosac; ModuleBase::GlobalFunc::READ_VALUE(ifa, cosbc); sinab = sqrt(1.0-cosab*cosab); } latvec.e11 = 1.0; latvec.e12 = 0.0; latvec.e13 = 0.0; latvec.e21 = bba * cosab; latvec.e22 = bba * sinab; latvec.e23 = 0.0; latvec.e31 = cba * cosac; latvec.e32 = cba * (cosbc - cosac*cosab) / sinab; term = 1.0 + 2.0 * cosab*cosac*cosbc - cosab*cosab - cosac*cosac - cosbc*cosbc; term = sqrt(term)/sinab; latvec.e33 = cba * term; } else{ std::cout 我们约定，LATTICE_CONSTANT无量纲，LATTICE_VECTORS有量纲，STRU文件中原子坐标无量纲。 UnitCell::read_atom_positions() &#x1F527;重构思考 同样地，UnitCell::read_atom_positions() 函数也不仅仅读取原子的位置，还额外读取各种具体涉及每个原子的速度、固定、磁化等等信息。 首先来到读取 STRU ATOMIC_POSITIONS 部分： bool UnitCell::read_atom_positions(std::ifstream &ifpos, std::ofstream &ofs_running, std::ofstream &ofs_warning) { if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifpos, \"ATOMIC_POSITIONS\")) { ModuleBase::GlobalFunc::READ_VALUE( ifpos, Coordinate); STRU 第二行指定坐标类型，被读取为 UnitCell::Coordinate。UnitCell::Coordinate 在 STRU 里有不同选项，⚙ 决定原子的具体位置和单位： if(Coordinate != \"Cartesian\" && Coordinate != \"Direct\" && Coordinate != \"Cartesian_angstrom\" && Coordinate != \"Cartesian_au\" && Coordinate != \"Cartesian_angstrom_center_xy\" && Coordinate != \"Cartesian_angstrom_center_xz\" && Coordinate != \"Cartesian_angstrom_center_yz\" && Coordinate != \"Cartesian_angstrom_center_xyz\" ) { ModuleBase::WARNING(\"read_atom_position\",\"Cartesian or Direct?\"); ofs_warning 这将决定最后实际的原子坐标： // module_cell/read_atom.cpp: line 695 if(Coordinate==\"Direct\") { atoms[it].taud[ia] = v; atoms[it].tau[ia] = v * latvec; } else if(Coordinate==\"Cartesian\") { atoms[it].tau[ia] = v ; } else if(Coordinate==\"Cartesian_angstrom\") { atoms[it].tau[ia] = v / 0.529177 / lat0; } else if(Coordinate==\"Cartesian_angstrom_center_xy\") { latcenter.x = (latvec.e11 + latvec.e21 + latvec.e31)/2.0; latcenter.y = (latvec.e12 + latvec.e22 + latvec.e32)/2.0; latcenter.z = 0.0; atoms[it].tau[ia] = v / 0.529177 / lat0 + latcenter; ... &#x1F527;重构思考 ABACUS 代码中现在分原子类型导入数据，尽管在代码中分种类管理原子是十分自然的选择，但 ABACUS 将这种选择表露在用户端，因此 STRU 中关于原子位置的定义也必须按类型分开输入。 接下来是按原子种类循环 ATOMIC_POSITIONS section: int na = 0; this->nat = 0; assert(ntype>0); for (int it = 0;it &#x1F527;重构思考 进入循环体，检查在 ATOMIC_POSITIONS section 中原子定义的顺序是否和 ATOMIC_SPECIES 相同 &#x1F4DD;开发者旁注 已在重构计划中 ModuleBase::GlobalFunc::READ_VALUE(ifpos, atoms[it].label); bool sequence_match = false; for(int it2=0; it2atoms[it].label == this->atom_label[it2] ) { if (it2 == it) sequence_match = true; } } if(!sequence_match) { ... return 0; } 读取当前原子类型的 starting_magnetization、原子总数 na ModuleBase::GlobalFunc::READ_VALUE(ifpos, magnet.start_magnetization[it] ); ... ModuleBase::GlobalFunc::READ_VALUE(ifpos, na); this->atoms[it].na = na; .... this->nat += na; .... 在当前 type 下刷新 type-specific 的原子性质： // positions and positional constraints delete[] atoms[it].tau; delete[] atoms[it].taud; delete[] atoms[it].mbl; atoms[it].tau = new ModuleBase::Vector3[na]; atoms[it].taud = new ModuleBase::Vector3[na]; atoms[it].mbl = new ModuleBase::Vector3[na]; // evoluation delete[] atoms[it].vel; delete[] atoms[it].dis; atoms[it].vel = new ModuleBase::Vector3[na]; atoms[it].dis = new ModuleBase::Vector3[na]; // magnetization delete[] atoms[it].mag; delete[] atoms[it].angle1; delete[] atoms[it].angle2; delete[] atoms[it].m_loc_; atoms[it].mag = new double[na]; atoms[it].angle1 = new double[na]; atoms[it].angle2 = new double[na]; atoms[it].m_loc_ = new ModuleBase::Vector3[na]; ⚙ 然后在 ATOMIC_POSITIONS 中读取： atoms[it].mass = this->atom_mass[it]; ❗ 此处的 atoms[it].mass 与 this->atom_mass[it] 的用法与 atomis[it].label 与 this->atom_label[it] 不同：传值 vs 核对。 接下来读取类中每个原子的速度信息，在做分子动力学模拟的时候可能需要用到： for (int ia = 0;ia > v.x >> v.y >> v.z; 然而，当前 STRU 文件在 ATOMIC_POSITIONS 的设计比较复杂，其可以包括任何一组 atom-specific 数据，且数量和顺序均不受限制，这导致判断条件变得复杂，详见 module_cell/read_atoms.cpp:line 536 - 567（link）。 atoms[it].mag 的赋值并非直接读取： else if ( tmpid == \"mag\" || tmpid == \"magmom\") { set_element_mag_zero = true; double tmpamg=0; ifpos >> tmpamg; tmp=ifpos.get(); while (tmp==' ') tmp=ifpos.get(); // ASCII code 48 to 57 are 0 to 9 the Arabic number if((tmp >= 48 && tmp > atoms[it].m_loc_[ia].y>>atoms[it].m_loc_[ia].z; atoms[it].m_loc_[ia].x=tmpamg; atoms[it].mag[ia]=sqrt(pow(atoms[it].m_loc_[ia].x,2) +pow(atoms[it].m_loc_[ia].y,2) +pow(atoms[it].m_loc_[ia].z,2) ); input_vec_mag=true; } else { ifpos.putback(tmp); atoms[it].mag[ia]=tmpamg; } } ⚙ 若 mag/magmom 后有一个值，则读取其值赋给 atoms[it]::mag[ia]，将 input_vec_mag 置为 false，若有三个值，则三个值依次被传入 atoms[it].m_loc_[ia].x, atoms[it].m_loc_[ia].y 和 atoms[it].m_loc_[ia].z，并将 input_vec_mag 置为 true，之后其向量模长为 atoms[it]::mag[ia]，然后在使用 angle1, angle2 来重新生成 mag。 if(GlobalV::NSPIN==4) { if(GlobalV::NONCOLIN) { if(input_angle_mag) { atoms[it].m_loc_[ia].z = atoms[it].mag[ia] * cos(atoms[it].angle1[ia]); if(sin(atoms[it].angle1[ia]) > 1e-10 ) { atoms[it].m_loc_[ia].x = atoms[it].mag[ia] * sin(atoms[it].angle1[ia]) * cos(atoms[it].angle2[ia]); atoms[it].m_loc_[ia].y = atoms[it].mag[ia] * sin(atoms[it].angle1[ia]) * sin(atoms[it].angle2[ia]); .... else if (input_vec_mag) { double mxy=sqrt(pow(atoms[it].m_loc_[ia].x,2)+pow(atoms[it].m_loc_[ia].y,2)); atoms[it].angle1[ia]=atan2(mxy,atoms[it].m_loc_[ia].z); if(mxy>1e-8) { atoms[it].angle2[ia]=atan2(atoms[it].m_loc_[ia].y,atoms[it].m_loc_[ia].x); .... else { // isn't this corresponds to common unrestricted case? atoms[it].m_loc_[ia].x = 0; atoms[it].m_loc_[ia].y = 0; atoms[it].m_loc_[ia].z = atoms[it].mag[ia]; } .... else if(GlobalV::NSPIN==2) { atoms[it].m_loc_[ia].x = atoms[it].mag[ia]; atoms[it].m_loc_[ia].y = 0; atoms[it].m_loc_[ia].z = 0; ... &#x1F914;批判性思考 然而，在 Quantum ESPRESSO 中，并不允许出现 nspin=4 且 noncolinear=.false. 的情况，在 ABACUS≤3.3.0 中是允许的，你怎么看？ Quantum ESPRESSO 相关信息： ABACUS 对 nspin=4 情况的参数处理： //module_io/input_conv.cpp line 376 if (INPUT.noncolin || INPUT.lspinorb) { GlobalV::NSPIN = 4; } if (GlobalV::NSPIN == 4) { GlobalV::NONCOLIN = INPUT.noncolin; // wavefunctions are spinors with 2 components GlobalV::NPOL = 2; // set the domag variable to make a spin-orbit calculation with zero magnetization GlobalV::DOMAG = false; GlobalV::DOMAG_Z = true; GlobalV::LSPINORB = INPUT.lspinorb; GlobalV::soc_lambda = INPUT.soc_lambda; if (INPUT.cal_force || INPUT.cal_stress) { ModuleBase::WARNING_QUIT(\"input_conv\", \"force & stress not ready for soc yet!\"); } if(INPUT.gamma_only_local) { ModuleBase::WARNING_QUIT(\"input_conv\", \"soc does not support gamma only calculation\"); } } else { GlobalV::LSPINORB = false; GlobalV::NONCOLIN = false; GlobalV::DOMAG = false; GlobalV::DOMAG_Z = false; GlobalV::NPOL = 1; } Input::noncolin 等变量使用默认值初始化为： //input.cpp line 409 noncolin = false; lspinorb = false; soc_lambda = 1.0; Summary 经过 UnitCell::read_atom_species() 和 UnitCell::read_atom_positions()，以下量被赋值： // lattice info. // unit UnitCell::Coordinate; // lattice constant (real space) UnitCell::lat0; UnitCell:: lat0_angstrom; // lattice constant (reciprocal space) UnitCell::tpiba; UnitCell::tpiba2; // lattice vectors UnitCell::latvec; UnitCell::latcenter; UnitCell::a1; UnitCell::a2; UnitCell::a3; // atoms overall info. UnitCell::nat; // types UnitCell::ntype; UnitCell::atom_mass; UnitCell::atom_label; // supplementary element-specific info. // pseudopotential UnitCell::pseudo_fn; UnitCell::pseudo_type; // numerical orbital UnitCell::orbital_fn // atom type specific info. // atom type overall info. UnitCell::atoms::label; UnitCell::atoms::na; // atom position info. （constraint included） UnitCell::atoms::taud; UnitCell::atoms::tau; UnitCell::atoms::mbl; // atom move info. (velocities and displacements) UnitCell::atoms::vel; UnitCell::atoms::dis; // atom magnetization info. UnitCell::magnet::starting_magnetization; UnitCell::atoms::mag; // nspin = 4; noncolinear case UnitCell::atoms::m_loc_; UnitCell::atoms::angle1; UnitCell::atoms::angle2; UnitCell::setup_cell(): the rest, and an example of backtracking unclear variable 离开 STRU 文件的解析部分，接下来计算了初始磁化强度： //after read STRU, calculate initial total magnetization when NSPIN=2 if(GlobalV::NSPIN == 2 && !GlobalV::TWO_EFERMI) { for(int it = 0;itntype; it++) { for(int ia = 0; iaatoms[it].na; ia++) { GlobalV::nupdown += this->atoms[it].mag[ia]; } } } 由于 INPUT 中参数众多，因此在前文中对参数有所遗漏。但基于前文已有内容介绍，关于 GlobalV::TWO_EFERMI 变量，可以通过如下方式查找其意义： 在 module_io/input_conv.cpp 中寻找该变量，是何变量赋其值，发现： if (std::abs(INPUT.nupdown) > 1e-6) { GlobalV::TWO_EFERMI = true; GlobalV::nupdown = INPUT.nupdown; } 因此 GlobalV::TWO_EFERMI 变量实际依赖于 INPUT.nupdown。 接下来在 module_io/input.cpp 中寻找含 INPUT.nupdown 的 if(strcmp(...)) 单元，查看在 INPUT 文件中是何参数赋予其具体值： else if (strcmp(\"nupdown\", word) == 0) { read_value(ifs, nupdown); } 即 INPUT.nupdown 在 INPUT 中也为 nupdown。接下来打开 Full keyword list 寻找其解释。 得到结果，即 nupdown 为 spin up 和 spin down 电子数量差值： 因此该部分逻辑为：若未使用 nupdown 来指定单电子数量，则对每种原子内每个原子，累加其 mag/magmom，即磁矩模长，赋予 GlobalV::nupdown。❗ 但对于两种方式均赋予，但值不一致的情况未进行处理。 接下来根据在 STRU 中读取的晶胞参数，计算晶胞体积，并计算倒空间矢量（在上篇中已经对 latvec, G, GT, GGT 有所介绍，invGGT 的意义也不言自明）： this->omega = std::abs( latvec.Det() ) * this->lat0 * lat0 * lat0 ; this->GT = latvec.Inverse(); this->G = GT.Transpose(); this->GGT = G * GT; this->invGGT = GGT.Inverse(); this->GT0 = latvec.Inverse(); this->G0 = GT.Transpose(); this->GGT0 = G * GT; this->invGGT0 = GGT.Inverse(); 然后建立从[原子索引]到[原子种类]和[种类内原子索引]的映射： this->set_iat2itia(); 即该函数的函数名实际应该写为：set_iat2ia_iat2it()： void UnitCell::set_iat2itia(void) { delete[] iat2it; delete[] iat2ia; this->iat2it = new int[nat]; this->iat2ia = new int[nat]; int iat = 0; for (int it = 0; it iat2it[iat] = it; this->iat2ia[iat] = ia; ++iat; } } return; } 至此，UnitCell::setup_cell() 函数的内容全部结束。 回溯：how many objects are created when we see \"init_esolver()\"? 在阅读整个程序的过程中，还有一个重要的方面需要注意：伴随变量的创建，尤其是创建类对象时，其中同样非简单数据类型的数据成员又是在何时初始化，拥有具体数值？由于 Driver.h 中并无任何变量的声明（如前所述，有变量直接被声明为 extern），且 Input.h 中声明变量的值分别靠 Input::Default()、Input::Read() 和 Input::Default2() 给定，且关系简单直接，因此只剩下 ESolver 和其派生类需要注意。 Constructor: ESolver() class ESolver { .... ESolver() { classname = \"ESolver\"; } ESolver 类的构造函数非常简单，因为其是所有具体 ESolver_* 的抽象基类，所以本身的操作设计原则应该尽可能抽象且共通。关于设计抽象基类和编程范式的问题，请见文档（暂缺失） Constructor: ESolver_FP() ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); pw_big = static_cast(pw_rho); pw_big->setbxyz(INPUT.bx, INPUT.by, INPUT.bz); sf.set(INPUT.nbspline); this->symm.epsilon = this->symm.epsilon_input = INPUT.symmetry_prec; } check 其头文件中变量声明： namespace ModuleESolver { class ESolver_FP : public ESolver { public: ModulePW::PW_Basis* pw_rho; ModulePW::PW_Basis_Big* pw_big; ....// constructor and destructor declarations omitted elecstate::ElecState* pelec = nullptr; Charge chr; ModuleSymmetry::Symmetry symm; psi::Psi>* psi = nullptr; psi::Psi* psid = nullptr; Structure_Factor sf; K_Vectors kv; private: ....// member function(s) omitted }; 创建当前类和子类对象时，该构造函数被调用，Charge 类对象 chr、ModuleSymmetry::Symmetry 类对象 symm、Structure_Factor 类对象 sf，以及 K_Vectors 类对象 kv 被创建并分配内存，而 ModulePW::PW_Basis 类 pw_rho、ModulePW::PW_Basis_Big 类 pw_big、elecstate::ElecState 类 pelec、psi::Psi> 类 psi，以及 psi::Psi 类 psid 则为指针，只创建但并未调用其所属类的构造函数。 Special topic: 继承与多态 在 ESolver_FP 的构造函数中有两行格外醒目： ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); pw_big = static_cast(pw_rho); 对于 ESolver 本身，其指针对象 p_esolver 实际上也有类似操作： //Some API to operate E_Solver void init_esolver(ESolver*& p_esolver) { //determine type of esolver based on INPUT information std::string esolver_type = determine_type(); //initialize the corresponding Esolver child class if (esolver_type == \"ksdft_pw\") { #if ((defined __CUDA) || (defined __ROCM)) if (GlobalV::device_flag == \"gpu\") { if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); return; } #endif if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); } #ifdef __LCAO else if (esolver_type == \"ksdft_lcao\") p_esolver = new ESolver_KS_LCAO(); else if (esolver_type == \"ksdft_lcao_tddft\") p_esolver = new ESolver_KS_LCAO_TDDFT(); #endif else if (esolver_type == \"sdft_pw\") p_esolver = new ESolver_SDFT_PW(); else if(esolver_type == \"ofdft\") p_esolver = new ESolver_OF(); else if (esolver_type == \"lj_pot\") p_esolver = new ESolver_LJ(); else if (esolver_type == \"dp_pot\") p_esolver = new ESolver_DP(INPUT.mdp.pot_file); } “为基类指针分配派生类内存空间，以降低代码复写、提高代码复用率”这种操作称为 C++ 的多态编程，举简单例子如下： //a.cpp #include class a{ public: a() {}; ~a() {}; void TestFunction(); void AnotherFunction(); int GetPrivate(){return this->private_;} bool SetPrivate(int p){this->private_ = p; return true;} void GetPrivateAddress(){std::coutprivate_) //b.cpp #include \"a.cpp\" class b: public a{ public: b() {}; ~b() {}; void TestFunction(); void AnotherFunction(); int GetPrivate(){return this->private_;} bool SetPrivate(int p){this->private_ = p; return true;} void GetPrivateAddress(){std::coutprivate_) //main.cpp #include \"b.cpp\" using namespace std; int main() { a* p_a; p_a = new b(); coutTestFunction(); b* p_tmp = static_cast(p_a); coutTestFunction(); coutTestFunction(); coutAnotherFunction(); coutAnotherFunction(); coutSetPrivate(10); coutGetPrivate()GetPrivate()SetPrivate(20); coutGetPrivate()GetPrivate()GetPrivateAddress(); p_tmp->GetPrivateAddress(); delete p_a; return 0; } //result /* call p_a's member function before static_cast This is a function of a Memory address of p_a is 0x55ee8123beb0 Memory address of p_tmp is 0x55ee8123beb0 call p_tmp's member function after static_cast This is a function of b call p_a's member function after static_cast This is a function of a call p_a's member function This is another function of a call p_tmp's member function This is another function of b now test member variable accessibility p_a's private member is 10 p_tmp's private member is 0 p_a's private member is 10 p_tmp's private member is 20 Re-check memory address of p_a and p_tmp: Memory address of p_a is 0x55ee8123beb0 Memory address of p_tmp is 0x55ee8123beb0 Check private member variables' address 0x55ee8123beb0 0x55ee8123beb4 */ 为基类指针分配派生类内存空间，使得基类和派生类指针指向同一个内存地址（基派生类对象的起始内存位置, line 21, 22: 0x55ee8123beb0），但对于上例，基类需要 4 个字节存储基类对象，而派生类需要 4+4 个字节存储基类对象：因为派生类对象创建时会首先创建其中的基类部分，而实际上即使不进行如此操作，单一创建派生类对象时，在派生类中访问基类数据成员则需要额外以基类的名称作为域标识加以区分。此时基类指针相当于切换成对派生类内存空间的基类视角，即基类指针只能看到派生类存储中的基类部分，但看不到派生类所额外派生的部分，也因此上例共占用内存空间 4+4 字节而非 4+4+4 字节。 举例对于不使用基类指针的情况，在派生类的方法中直接访问其基类数据成员，需要写为： void b::PrintBaseAndDerivedClassVariable() { std::coutprivate_ 而使用指针方法则应该写为： std::coutprivate_private_ 另一点需要注意的是虚函数。实际上，因为基类指针使用派生类指针进行初始化，因此其“语境”为派生类，所以对于虚函数而言，调用的基函数实际为派生类的相应函数。如果使用基类指针调用非虚函数，则调用的是基类的同名函数（examples provided by New Bing Creative）。 注意：不能使用基类指针（即使已经申请派生类内存空间）访问派生类中声明和定义（但基类中无虚函数声明）的函数。 // polymorphism_example.cpp#include using namespace std; class A { public: virtual void f() { cout (p_a); // 以B* p_b=static_cast(p_a)给p_b初始化 p_a->f(); // 调用B::f()，因为f()是虚函数，会根据实际类型进行动态绑定 p_a->g(); // 调用A::g()，因为g()不是虚函数，会根据声明类型进行静态绑定 p_b->f(); // 调用B::f()，因为f()是虚函数，会根据实际类型进行动态绑定 p_b->g(); // 调用B::g()，因为g()不是虚函数，会根据声明类型进行静态绑定delete p_a; // 释放内存空间return 0; } //result /* B::f() A::g() B::f() B::g() */ 当释放内存空间时，则可以使用基类指针为柄，也可以使用派生类指针为柄，编译器将自主判断实际内存占用情况并进行释放（如果声明析构函数为虚函数，则会动态连接并达到如此期望，否则不能）。因此对于 PW_Basis 类对象 pw_rho 而言，其中被声明为虚函数的有： //file module_basis/module_pw/pw_basis.h class PW_Basis { public: .... virtual ~PW_Basis(); .... virtual void initgrids( const double lat0_in, //unit length (unit in bohr) const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors (unit in lat0) const double gridecut //unit in Ry, ecut to set up grids ); .... virtual void initgrids( const double lat0_in, const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors const int nx_in, int ny_in, int nz_in ); .... protected: .... virtual void distribute_r(); //file module_basis/module_pw/pw_basis.h class PW_Basis_Big: public PW_Basis { public: .... virtual void initgrids(const double lat0_in,const ModuleBase::Matrix3 latvec_in, const double gridecut){ .... } .... virtual void initgrids( const double lat0_in, const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors const int nx_in, int ny_in, int nz_in ){ .... } .... protected: .... virtual void distribute_r(){ .... } 派生类的析构函数也可以声明为 virtual。这些函数实际上调用 PW_Basis_Big 此派生类中声明和定义的版本。 其余的数据成员在构造函数中进行初始化均总结于下表： 数据成员 所属类 是否在当前类（ESolver_FP）的构造函数中被调用构造函数 chr Charge 是 symm ModuleSymmetry::Symmetry 是 sf Structure_Factor 是 kv K_Vectors 是 pw_rho ModulePW::PW_Basis 是 pw_big ModulePW::PW_Basis_Big 是 ⚙ 然而，PW_Basis_Big 和 PW_Basis 的关系（后文也有 PW_Basis_K 和 PW_Basis_K_Big）实际并不符合程序设计的抽象理念，这一点将在随后介绍。 变量 声明时赋初值 调用构造函数所赋初值 Charge 类 rho, rho_save, rhog, rhog_save, kin_r, kin_r_save, rho_core, rhog_core, rhopw nulllptr nrxx, nxyz, ngmc, nspin allocate_rho, allocate_rho_final_scf false prenspin 1 Symmetry 类 symm_flag available true s1, s2, s3, a1, a2, a3, p1, p2, p3 ntype, nat, na, istart, itmin_type, itmin_start newpos, rotpos, ptrans, ncell, index cel_const, pcel_const, pre_const symflag_fft, sym_test, pbrav, real_brav, ilattname, plattname gmatrix,kgmatrix, gtrans symop, nop, s_flag, nrot, pgnumber, spgnumber, pgname, spgname optlat,plat nrotk,max_nrotk -1 tab 12 Structure_Factor 类 nbspline, strucFac, eigts1, eigts2, eigts3 c_eigts1, c_eigts2, c_eigts3, z_eigts1, z_eigts2, z_eigts3 nullptr K_Vectors 类 kvec_c, kvec_d, kvec_d_ibz, wk, wk_ibz, ngk, isk, ibz2bz, nmp nspin, nks, nkstot, nkstot_ibz,k_nkstot 0 koffset kc_done, kd_done false k_kword PW_Basis 类 classname \"PW_Basis\" ig2isz, istot2ixy, is2fftixy, d_is2fftixy, fftixy2up, nst_per, npw_per, startz, numz, numg, numr, startg, startr, gdirect, gcar, gg, startnsz_per, ig2igg, gg_uniq nullptr device \"cpu\" precision \"double\" nst, nstnz, nstot, npw, npwtot, nrxx, startz_current, nplane, ngg, ggecut, gridecut_lat, full_pw_dim, poolrank, fftnx, fftny, fftnz, fftnxyz, fftnxy, nx, ny, nz, nxyz, nxy, liy, riy, lix, rix, ng_xeq0, nmaxgr 0 ig_gge0 -1 lat0, tpiba, tpiba2, omega, distribution_type, poolnproc, 1 xprime false PW_Basis:public PW_Basis_big 类 bx, by, bz 1 bxyz, nbx, nby, nbz, nbzp, nbxx, nbzp_start 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 1 下篇：Introduction to ABACUS: Path to PW calculation - Part 3 "},"develop-path3.html":{"url":"develop-path3.html","title":"Introduction to ABACUS: Path to PW calculation - Part 3","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 3 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/15 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class Trigger: ESolver_FP::Init() 承接上篇中已经导入的结构信息，以及了解到构造函数及其伴随的变量初始化和 ABACUS 里应用到的 C++ 多态编程，接下来即将（逐渐）步入 ABACUS 的核心内容。我们暂时跳过位于 source/driver_run.cpp:driver_run() 的： // 3. For these two types of calculations // nothing else need to be initialized if(GlobalV::CALCULATION == \"test_neighbour\" || GlobalV::CALCULATION == \"test_memory\") { p_esolver->Run(0, GlobalC::ucell); ModuleBase::QUIT(); } 直接来到第 44 行，ModuleESolver::ESolver::Init() 函数对 esolver 进行更多的设置： // driver_run.cpp: line 44 p_esolver->Init(INPUT, GlobalC::ucell); 然而查找该函数的定义和声明时，发现该函数在 module_esolver/esolver.h 被声明为纯虚函数，类似的还有 un(), cal_Energy(), cal_Force(), cal_Stress() 等。 namespace ModuleESolver { class ESolver { public: .... virtual void Init(Input& inp, UnitCell& cell) = 0; virtual void Run(int istep, UnitCell& cell) = 0; virtual void cal_Force(ModuleBase::matrix& force) = 0; virtual void cal_Stress(ModuleBase::matrix& stress) = 0; .... 考虑到我们之前已经根据 basis_type 和 esolver_type 确定基类（ESolver）指针 p_esolver 所指向内存空间所存储变量为 ESolver_KS_PW，因此我们首先只关注该纯虚函数在 esolver_ks_pw 的实例化。 查看 module_esolver/esolver_ks_pw.cpp 中该函数的定义： namespace ModuleESolver { .... template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { ESolver_KS::Init(inp, ucell); 从上篇中可知，ESolver_KS_PW 有从 ESolver_KS 的继承，ESolver_KS 是从 ESolver_FP（FP 代表 First-Principles）的继承，ESolver_FP 是从 ESolver 的继承，因此 ESolver 各子类中 Init() 函数均保持结构统一，且第一行为父类的 Init() 函数： module_esolver/esolver_ks.cpp： namespace ModuleESolver { .... template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { ESolver_FP::Init(inp,ucell); module_esolver/esolver_fp.cpp： namespace ModuleESolver { .... void ESolver_FP::Init(Input& inp, UnitCell& cell) { cell.read_pseudo(GlobalV::ofs_running); 同时由于多层的继承关系，p_esolver 现在具有所有的数据成员，ESolver_FP 具有数据成员： namespace ModuleESolver { class ESolver_FP : public ESolver { public: ModulePW::PW_Basis* pw_rho; ModulePW::PW_Basis_Big* pw_big; elecstate::ElecState* pelec = nullptr; Charge chr; ModuleSymmetry::Symmetry symm; psi::Psi>* psi = nullptr; psi::Psi* psid = nullptr; Structure_Factor sf; K_Vectors kv; }; } 同理，ESolver_KS 的数据成员，也被 ESolver_KS_PW 继承。ESolver_FP::Init() 首先调用 UnitCell::read_pseudo() 函数进行赝势文件读取，而将赝势文件读取任务放在 FP 层级下，也暗示对于 ABACUS 的第一性原理方法实现来讲，都需要使用赝势。 Pseudopotential import: UnitCell::read_pseudo() void UnitCell::read_pseudo(std::ofstream &ofs) { read_cell_pseudopots(GlobalV::global_pseudo_dir, ofs); 在解读赝势文件读取功能之前，首先需要对赝势文件的结构和信息做一定程度的了解。 # ONCV pseudopotential file ## Section 0: Norm-conserving conditions, generation of pseudopotential and header of exact UPF file 赝势的意义不言自明，其中模守恒赝势需满足如下条件： \\epsilon^\\text{ps}_l=\\epsilon_l（赝势得到的能级和全电子方法求解的能级一样，这里 ps 代表 pseudopotentials） \\phi^\\text{ps}_l(r)无节点（赝波函数没有结点，nodeless） 在截断半径之外（r>r_c）有\\phi^\\text{ps}_l(r)=\\phi_l(r)（赝波函数在截断半径之后一致） \\int_{r（电子数守恒，即模守恒） 生成赝势的步骤如下： -\\frac{\\hbar^2}{2m}\\frac{d^2}{dr^2}\\phi_{l}(r)+[\\frac{\\hbar^2}{2m}\\frac{l(l+1)}{r^2}+V(r)]\\phi_l(r)=\\epsilon_l\\phi_l(r)，解得(\\phi_l(r)-\\epsilon_l) pair 满足上述四个模守恒条件前提下生成(\\phi^\\text{ps}_l(r)-\\epsilon^\\text{ps}_l) pair，使得-\\frac{\\hbar^2}{2m}\\frac{d^2}{dr^2}\\phi^\\text{ps}_{l}(r)+[\\frac{\\hbar^2}{2m}\\frac{l(l+1)}{r^2}+V(r)]\\phi^\\text{ps}_l(r)=\\epsilon^\\text{ps}_l\\phi^\\text{ps}_l(r)成立 V_l(r)=\\frac{1}{\\phi^\\text{ps}_l(r)}[\\epsilon^\\text{ps}_l-\\frac{\\hbar^2}{2m}\\frac{l(l+1)}{r^2}+\\frac{\\hbar^2}{2m}\\frac{d^2}{dr^2}]\\phi^\\text{ps}_l(r)，解得V_l(r)。 扣除V_l(r)中 Hartree、xc 部分，得到V^\\text{ps}_l(r)：V^\\text{ps}_l(r)=V_l(r)-V^\\text{H}[\\rho^\\text{ps}(r)]-V^\\text{xc}[\\rho^\\text{ps}(r)]。\\rho^\\text{ps}(r)=\\frac{1}{4\\pi}\\sum_i^\\text{occ}{f_{i}|\\phi^\\text{ps}_l(r)|^2} 更多细节见 从 UPF 文件（注意 UPF 文件也有不同的版本，目前 ABACUS 都支持，若有不支持的，可以提 Github 的 issues 进行讨论）开始，截止到 之前，提供了赝势文件的作者信息，引用信息以及生成赝势文件所使用的程序和相应输入文件，并附带输入文件参数中的解释。由于此块内容对实际计算并不起作用，因此暂时略过。 ## Section 1: 部分尽管已经位于所谓“not human readable”区域，但也并非如此。这部分“标签”（HTML 语境）/block 实际上包含了众多精简过的信息，如元素名称（element）、赝势类型（pseudo_type，模守恒，norm-conserving，NC），相对论效应（relativistic），是否为超软赝势等等信息。当前 Al 理论上其原子序数 13，因此有 13 个电子，但此处 z_valence 参数为 11，即有两个 1s 电子被赝化，只留下 2s, 2p, 3s, 3p 电子共 2+6+2+1 个。对于某些元素，甚至有大核赝势与小核赝势之分，根据赝化电子数量不同进行区分。显而易见地，赝化电子数量越多，则计算量越小，但计算结果的精确程度可能更低。 ## Section 2: 0.0000 0.0100 0.0200 0.0300 0.0400 0.0500 0.0600 0.0700 5.9200 5.9300 5.9400 5.9500 5.9600 5.9700 5.9800 5.9900 6.0000 6.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 这部分开始出现了关于实空间格点相关量的定义。在 tag 中不仅指定数据类型为实数，也指定当前数据的长度（size），以及数据存储的列数（columns = 8）。PP_R 为格点坐标，PP_RAB 则为格点间距。 ## Section 3: -4.5793174225E+01 -4.5788454271E+01 -4.5774276797E+01 -4.5750659428E+01 -3.6912752197E+00 -3.6850921941E+00 -3.6789298138E+00 -3.6727880140E+00 -3.6666666933E+00 -3.6605657501E+00 从 部分开始，正式开始写入赝势的具体数值，建立在 和 所描述的实空间格点上。\\hat{V}=\\hat{V}^\\text{loc}+\\hat{V}^\\text{NL}。 正是赝势的局域势部分。 ## Section 4: 0.0000000000E+00 8.1959788337E-02 1.6389680452E-01 2.4578292762E-01 -1.2623857798E-05 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 cutoff_radius_index=\" 246\" cutoff_radius=\" 2.4500000000E+00\" > 5.3707838603E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 -8.2930195943E-01 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 -6.5836757852E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 -4.6797927123E+00 完全非局域部分，\\hat{V}^\\text{NL}=\\sum_{ij}{|\\beta_i\\rangle D_{ij}\\langle\\beta_j|}。其中|\\beta_i\\rangle一般被称为非局域势投影子（projector）。 ## Section 5: and 0.0000000000E+00 3.6337392512E-03 1.4532726686E-02 3.2690254089E-02 为赝波函数， 则为赝电荷密度在实空间格点上的数据。一个简单的赝势文件信息提取脚本： ParseUpfWordByWord.py &#x1F914; 玩玩看！ Quantum ESPRESSO 官网上提供了更多关于 UPF 文件格式的信息：Unified Pseudopotential Format - QUANTUMESPRESSO ❗注意 读入的投影子 projector |\\beta\\rangle和 pswfc \\tilde{\\phi}(r)已经乘径向坐标r。 # UnitCell::read_cell_pseudopots() link to Github -> link void UnitCell::read_cell_pseudopots(const std::string &pp_dir, std::ofstream &log) { std::stringstream ss; ss pseudo_fn[i]; error = upf.init_pseudo_reader( pp_address, this->pseudo_type[i] ); 赝势文件的读取 type-by-type，每次创建 Pseudopot_upf 类对象 upf，之后调用 upf.init_pseudo_reader() 对文件进行读取，需要指定文件的地址（pp_address）和赝势类型（UnitCell::pseudo_type[i]）。Pseudopot_upf::init_pseudo_reader() 为每种赝势文件进行判断，之后进行不同的解析。为方便起见，这里我们只关注 ABACUS 的常用赝势类型，即模守恒 upf。跟随“转到定义”，来到 module_cell/read_pp.cpp 文件（link）： int Pseudopot_upf::init_pseudo_reader(const std::string &fn, std::string &type) { std::ifstream ifs(fn.c_str(), std::ios::in); if (type == \"auto\") { set_pseudo_type(fn, type); } if (type == \"upf\") { int info = read_pseudo_upf(ifs); return info; } else if (type == \"vwr\") { int info = read_pseudo_vwr(ifs); return info; } else if (type == \"upf201\") { int info = read_pseudo_upf201(ifs); return info; } else if (type == \"blps\") { int info = read_pseudo_blps(ifs); return info; } return 0; } 选择 read_pseudo_upf() 函数，跳转到位于 module_cell/read_pp_upf100.cpp 的该函数定义。read_pseudo_upf() 函数分标签读取 upf 格式赝势文件中信息，每个标签都有单独的解析器： while (ifs.good()) { ifs >> dummy; if(dummy==\"\") { ierr = 1; read_pseudo_header(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); break; } } if ( ModuleBase::GlobalFunc::SCAN_BEGIN(ifs, \"\") ) { read_pseudo_mesh(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); } if (this->nlcc) { ModuleBase::GlobalFunc::SCAN_BEGIN(ifs, \"\"); read_pseudo_nlcc(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); } ModuleBase::GlobalFunc::SCAN_BEGIN(ifs, \"\"); read_pseudo_local(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); 与 类似的还有 , , , 从 则可以读取旋轨耦合相关信息： if (has_so) { ModuleBase::GlobalFunc::SCAN_BEGIN (ifs,\"\"); read_pseudo_so (ifs); ModuleBase::GlobalFunc::SCAN_END (ifs,\"\"); } 每个具体 tag 的解析函数 Pseudopot_upf::read_pseudo_xxx() 均赋值于数据成员，声明在 module_cell/read_pp.h 中（link）。 Functions in Pseudopot_upf class Variables value assgined explain void read_pseudo_header(std::ifstream &ifs); this->nv``this->psd``this->tvanp``this->nlcc``this->xc_func``this->zp``this->etotps``this->ecutwfc``this->ecutrho``this->lmax``this->mesh``this->nwfc``this->nbeta``this->els``this->lchi``this->oc Version numberElement labelIf ultrasoft pseudopotentialIf noncolinear correction addedXc functionalAtomic chargesTotal energySuggested energy cutoff for wavefunctionSuggested energy cutoff for charge densityMaximal angular momentum includedNumber of points in radial meshNumber of wavefunctionsNumber of projectorsDim nwfc, labels of orbitalDim nwfc, angular momentum of orbitalDim nwfc, occupation of orbital void read_pseudo_mesh(std::ifstream &ifs); this->r``this->rab Dim this->mesh, realspace mesh of radiusDim this->mesh, void read_pseudo_nlcc(std::ifstream &ifs); this->rho_atc Dim this->mesh, void read_pseudo_local(std::ifstream &ifs); this->vloc Dim this->mesh, Vlocal void read_pseudo_nl(std::ifstream &ifs); this->kkbeta this->lll this->beta``this->dion``this->nd Dim this->nbeta, number of mesh points of projectors.Dim this->nbeta, angular momentum for projectors.Dim this->nbetathis->mesh.Dim this->nbetathis->nbeta.Number of nonzero D_{ij} void read_pseudo_pswfc(std::ifstream &ifs); this->chi Dim this->nwfc*this->mesh, void read_pseudo_rhoatom(std::ifstream &ifs); this->rho_at Dim this->mesh, atomic electron density on realspace mesh void read_pseudo_addinfo(std::ifstream &ifs); Not implemented Not implemented void read_pseudo_so(std::ifstream &ifs); this->nn this->jchi``this->jjj Dim this->nwfc, quantum number of wavefunctionDim this->nwfc, j=l+s, where s=\\pm\\frac{1}{2}.Dim this->nbeta, j=l+s, where s=\\pm\\frac{1}{2}, for projector. 我们假设 ONCV.upf 格式赝势文件顺利读取完毕，upf.init_pseudo_reader() 返回 0（error == 0），来到条件判断： if(error==0) { if(this->atoms[i].flag_empty_element) upf.set_empty_element(); error_ap = upf.average_p(GlobalV::soc_lambda); } Pseudopot_upf::set_empty_element() 的作用为设置 Vloc、dion 和 rho_at 均为 0，Pseudopot_upf::average_p() 则属于自旋轨道耦合（spin-orbital coupling）功能，这里先不介绍。 我们来到 line 82, if(GlobalV::MY_RANK==0) { atoms[i].ncpp.set_pseudo_nc( upf ); .... } 实际上 ABACUS 目前只能处理模守恒的赝势类型。显然该行实现的为将赝势信息从upf到atoms[i].ncpp的拷贝，而 upf 的意义也不言自明：UPF file parser。解析 UPF 文件后传值给 atoms[i].ncpp void pseudo_nc::set_pseudo_nc(const Pseudopot_upf &upf) { this->set_pseudo_h(upf); this->set_pseudo_atom(upf); this->set_pseudo_vl(upf); delete[] lll; lll = new int[nbeta]; for (int i = 0;i kkbeta = 0; for (int nb = 0;nb kkbeta = (upf.kkbeta[nb] > kkbeta) ? upf.kkbeta[nb] : kkbeta; } this->betar.create(upf.beta.nr, upf.beta.nc); this->betar = upf.beta; this->dion.create(nbeta, nbeta); this->dion = upf.dion; } 该函数属于类 pseudo_nc，而 pseudo_nc 对象为 atom 的数据成员，atoms 则为 UnitCell 的数据成员。pseudo_nc::set_pseudo_h()，pseudo_nc::set_pseudo_atom 和 pseudo_nc::set_pseudo_vl 的内容在此省略，但其分别为将 Hamilton, 原子性质和 Vlocal 相关数据从 upf 对象拷贝。之后(1)使用 lll 刷新为 upf 对象的 projectors 的角动量，然后计算出磁角动量区分时的 projector 个数。(2)取所有 projector 衰减到 0 时候的最大最普适半径。 # 赝势信息后处理 回到 module_cell/unitcell.cpp line 663，接下来为每个原子创建目录，在目录中写 [原子label].NONLOCAL 文件。[label].NONLOCAL 文件中内容包含 , 和 三个 tag。 中包含内容： ofs \" label ncpp.pp_type ncpp.lmax \" 中包含内容为 projector 数量 atom->ncpp.nbeta、对应于每个原子的 projector 的角动量为指标的 dion 矩阵： ofs \" ncpp.nbeta ncpp.nbeta; ib++) { for(int ib2=0; ib2ncpp.nbeta; ib2++) { ofs ncpp.lll[ib] ncpp.lll[ib2] ncpp.dion(ib,ib2)\" 中包含内容为 projector 仅其值大于 1.0e-10 的值。首先仍然输出当前原子的 projector 索引，以及角动量，然后截断 projector: int cut_mesh = atom->ncpp.mesh; for(int j=atom->ncpp.mesh-1; j>=0; --j) { if( std::abs( atom->ncpp.betar(i,j) ) > 1.0e-10 ) { cut_mesh = j; break; } } if(cut_mesh %2 == 0) ++cut_mesh; 之后按照截断后的网格重新存储 projector 的 realspace grid, projector value, rab 数据，分三列分别存储： for(int j=0; jncpp.r[j] ncpp.betar(i, j) ncpp.rab[j] \" # 赝势信息分发：UnitCell::bcast_unitcell2(void) #ifdef __MPI #endif # 赝势信息核对 接下来跨原子种类检验泛函是否一致： for(int it=0; it # STRU 结构检查：UnitCell::check_structure() 检验结构中任意两原子之间距离是否大于其固定倍数（ check_structure(GlobalV::MIN_DIST_COEF); # 计算轨道数：UnitCell::cal_natomwfc() UnitCell::cal_natomwfc() 函数计算所有种类的原子轨道数量加和，对于非 nspin=4，即非 soc（自旋轨道耦合）情况，角量子数 l 和 s 非耦合，l 单独可以作为好的量子数来区分量子态，因此对于每个赝势中定义的 wfc，若其对应 occupation 大于等于 0（即有效 wfc），则对应于其角量子数 l，轨道数量增加 2l+1，即计数其磁量子数 m，也相当于对 alpha 和 beta spin 的单独计数。对于 nspin=4 的情况，若考虑 soc，则轨道数对 j=l+s 的情况，当前原子种类当前角量子数对应轨道数量记为 2l+1+1，否则为 2l+1。对于非 soc 但 nspin=4，当前原子种类轨道当前角量子数对应轨道数量记(2l+1)*2： void UnitCell::cal_natomwfc(std::ofstream &log) { this->natomwfc = 0; for (int it = 0;it = 0) { if(GlobalV::NSPIN==4) { if(atoms[it].ncpp.has_so) { tmp += 2 * atoms[it].ncpp.lchi[l]; if(fabs(atoms[it].ncpp.jchi[l] - atoms[it].ncpp.lchi[l] - 0.5) 接下来调用 UnitCell::cal_nwfc() 函数，计算并赋值 波函数 index 到角动量，zeta 和磁量子数的表格， 跨原子种类的最大原子数，以及最大 wfc 数量， 轨道数量和： GlobalV::NLOCAL = 0; for(int it=0; it 建立 UnitCell::itia2iat（种类 index，种类内原子 index）->（原子全局 index）映射表、UnitCell::iat2iwt（原子全局 index）->（波函数全局 index）映射表、UnitCell::iwt2iw（波函数全局 index）->（波函数种类内 index）映射表、UnitCell::iwt2iat（波函数全局 index）->（原子全局 index）映射表、UnitCell::iwt2iw（波函数全局 index）->（波函数种类内 index）映射表。 计算跨原子种类最大角量子数 UnitCell::lmax 和某 l 对应最大 zeta 数 UnitCell::nmax，以及跨原子种类的类内 zeta 数总和最大值 UnitCell::nmax_total 寻找赝势中最大角量子数 UnitCell::lmax_ppwf。 # 价电子数核对 核对赝势中定义的价电子数与 ABACUS 预置库中原子的最小价电子数 # 获取最大格点数量：UnitCell::cal_meshx() 计算跨原子种类的最大格点数量，存储在 UnitCell::meshx 中，目前 ABACUS 代码中变量命名后缀 x 可能代表 max，正如之前看到 npwx 等。 至此，我们离开函数 UnitCell::read_pseudo()，回到 ModuleESolver::ESolver_FP::Init() 函数。 &#x1F4C3;和 Quantum Espresso 对齐的赝势参数 读入 UPF 格式的模守恒赝势之后，如果要和 QE 的结果做 apple-to-apple 的比较，使得总能量受力等性质计算一致，可以把基矢量调成平面波(basis_type 设成 pw)，然后在 INPUT 文件中，把 pseudo_rcut 设成 10（默认是 15），pseudo_mesh 设成 1 即可（默认是 0）。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 2 下篇：Introduction to ABACUS: Path to PW calculation - Part 4 "},"abacus-news.html":{"url":"abacus-news.html","title":"ABACUS 新闻稿整理","keywords":"","body":"ABACUS 新闻稿整理 整理人：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 标题 链接 日期 当Hackathon遇上ABACUS \\ ABACUS@Hackathon作品合集大揭秘 网页链接 2023/09/24 DP+ABACUS还能干这个：钙钛矿氧化物通用力场UniPero 网页链接 2023/09/16 ABACUS新进展：基于数值原子轨道基的meta-GGA密度泛函的实现 网页链接 2023/09/06 ABACUS开发者大会 \\ 聚焦国产密度泛函理论开源软件的进步与挑战 网页链接 2023/08/01 ABACUS 3.3 发布：自动化测试工作流赋能高效研发，为代码质量保驾护航 网页链接 2023/07/13 LibRI：携手 DeepModeling 社区，助力超越常规 DFT 方法的高阶方法计算 网页链接 2023/05/26 ABACUS 3.2 发布：支持 Hefei-NAMD 接口，全面提升代码稳定性和易用性 网页链接 2023/04/01 ABACUS 还能干这个？探索准一维材料碳纳米管中的无序超均匀性 网页链接 2023/03/07 ABACUS 3.1 发布，支持平面波基组下的 GPU 高效计算，发布固液界面计算新功能 网页链接 2023/01/01 探索 AI+DFT 最前线，「原子算筹」ABACUS 3.0 重磅发布！ 网页链接 2022/10/02 探索 AI+DFT 最前线，「原子算筹」ABACUS 3.0 重磅发布！ 网页链接 2022/10/01 ABACUS 3.0：共建 AI 辅助的新一代电子结构算法平台 网页链接 2022/10/01 ABACUS 新进展：用混合随机密度泛函理论方法模拟极端高温物质电子性质 网页链接 2022/09/20 以合作促发展：共建国产密度泛函理论开源软件 ABACUS 网页链接 2022/09/14 ABACUS 新进展：能带反折叠（band unfolding）方法及相关应用 网页链接 2022/07/22 v2.3 来了！ABACUS 小步快跑，重大升级，更快更稳更好用！ 网页链接 2022/07/01 ABACUS 新进展：用密度泛函理论模拟千原子以上半导体电极表面反应 网页链接 2022/06/21 DeePKS+ABACUS：构建高精度第一性原理计算与机器学习势函数的桥梁 网页链接 2022/06/13 ABACUS 2.2 版本介绍 网页链接 2022/04/08 涓流汇沧海，积篑成丘山：一位科学家与 ABACUS 的十五年 网页链接 2021/09/28 ABACUS ：携手 DeepModeling，做源自中国、开源开放的 DFT 软件 网页链接 2021/09/22 "},"abacus-contribute.html":{"url":"abacus-contribute.html","title":"如何贡献 ABACUS 使用教程","keywords":"","body":"如何贡献ABACUS使用教程 一、明确教程格式 第一行，写作者姓名，单位，联系方式（例如Github ID或者邮箱），如果不愿意透露作者信息，也可以不写 第一部分“介绍”：本文档教程要展示的例子、要教授的内容有哪些，相关知识可以给一些参考文献。 第二部分“准备”：介绍输入文件需要哪些，最好是能够提供输入文件的下载（例如网上github仓库），或者直接贴上输入文件 第三部分“流程”：最好通过图文结合的方式，一步步的介绍每一步的命令，能得到什么结果。 第四部分“结语”：对这个功能使用需要注意的地方，或者可以应用的场景都可以给与相关介绍 二、投稿 写好教程，检查无误后，AISI内部直接把稿件发给陈默涵老师（邮箱mohanchen@pku.edu.cn），或者向DeepModeling社区（deepmodeling@deepmodeling.com）投稿，审核通过后会加入到“ABACUS使用教程汇总” "}}