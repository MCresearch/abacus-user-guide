{"./":{"url":"./","title":"介绍","keywords":"","body":"ABACUS 中文文档主页 一、介绍 ABACUS（Atomic-orbtial Based Ab-initio Computation at UStc，中文名原子算筹）是国产开源密度泛函理论软件，相关介绍 ABACUS 的新闻可在 ABACUS 新闻稿整理查看，以下是一些常用地址： ABACUS 在 DeepModeling 社区中的 GitHub 仓库地址为： https://github.com/deepmodeling/abacus-develop ABACUS 的 Gitee 镜像仓库地址为： https://gitee.com/deepmodeling/abacus-develop ABACUS 网站访问： http://abacus.ustc.edu.cn/ 文档（包括安装方法、输入输出参数介绍、功能介绍、算例介绍、开发者须知等）： https://abacus.deepmodeling.com/en/latest/ 本教程系列旨在帮助新手用户入门了解 ABACUS 的使用。秉着开源软件的理念，本文档是由开源社区的老师同学们贡献所成。如果你也想贡献一份文档，我们十分欢迎，请参考如何贡献 ABACUS 使用教程。 本教程中标有 Logo的部分可以直接在 Bohrium Notebook 上打开。 在 Bohrium Notebook 上快速学习，见快速开始 ABACUS｜ 自洽 能带 态密度 结构优化；在 Bohrium 平台上运行大任务，见教程。 二、用户文档 2.1 ABACUS 编译教程 官方编译教程（英文官网） GCC 编译 ABACUS 教程 Intel oneAPI 2024.x 编译 ABACUS 教程 Intel oneAPI 编译 ABACUS 教程 编译 Nvidia GPU 版本的 ABACUS ABACUS LCAO 基组 GPU 版本使用说明 在超算环境编译 ABACUS 的建议 ABACUS 在曙光 DCU 集群上的编译与使用 ABACUS toolchain 脚本集 ABACUS 编译教程系列之一：基于 Intel 编译器（B 站视频） ABACUS 编译教程系列之二：基于 CUDA（B 站视频） ABACUS 编译教程系列之三：docker 的使用（B 站视频） 2.2 建模 准备晶胞和原子位置等信息的文件 STRU：如何转换 STRU 的格式 ABACUS 如何选择晶胞朝向获得最佳并行效率？以碳纳米管为例 ABACUS 如何选择晶胞朝向获得最佳并行效率？以二维氮化硼为例 准备赝势： 模守恒赝势生成方法简介 数值原子轨道基组生成教程： 数值原子轨道（一）：ABACUS 中的数值原子轨道命名和使用方法 数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道 数值原子轨道（三）：产生高精度数值原子轨道 2.3 Kohn-Sham 密度泛函理论 ABACUS 的平面波计算与收敛性测试 电子自洽迭代 ABACUS 使用教程 ｜ 结构优化 ABACUS 磁性材料计算使用教程 ABACUS 使用 DFT+U 计算教程 | 基础版 ABACUS+LibRI 做杂化泛函计算教程 ABACUS 收敛性问题解决手册 ABACUS 答疑手册 v0.2 版本 ABACUS 对比 CP2K 精度和效率测试 | Si 的状态方程（EOS） 有 VASP 使用背景的用户上手 ABACUS 教程：ABACUS新人使用的一些注意事项 2.4 分子动力学 ABACUS 分子动力学使用教程 ABACUS+DeePMD-kit 做机器学习分子动力学模拟 2.5 AI 辅助功能 DeePKS 方法 DeePKS 基础篇 DeePKS 案例篇 + 增强采样 DeePKS 实战（一）| 钙钛矿体系以 PBE 效率实现 HSE06 精度的能量标签训练（针对单一元素组合体系） DeePKS 实战（二）| 钙钛矿体系以 PBE 效率实现 HSE06 精度的多标签计算（针对单一元素组合体系） DeePKS 实战（三）| 钙钛矿体系以 PBE 效率实现 HSE06 精度的多标签训练（针对非单一元素组合体系） DeePKS 实战（附录）| 使用 DeePKS init 功能进行训练数据的生产 ABACUS+DPGEN 使用教程 ABACUS+DeepH 建立碳材料的哈密顿量模型 2.6 特色功能 随机波函数密度泛函理论 ABACUS 随机波函数 DFT 方法使用教程 ABACUS 随机波函数 DFT 计算电子电导热导教程 ABACUS 实时演化含时密度泛函理论使用教程 ABACUS 无轨道密度泛函理论方法使用教程 ABACUS 隐式溶剂模型使用教程 2.7 后处理 ABACUS+Atomkit 计算态密度和能带 ABACUS 计算 PDOS ABACUS 输出部分的电荷密度和波函数及可视化教程 ABACUS 计算电子局域函数 ELF 使用教程 ABACUS+Bader charge 分析教程 ABACUS+pymatgen 计算弹性常数 ABACUS+Phonopy 计算声子谱 ABACUS+pyatb 能带反折叠计算 ABACUS+ShengBTE 计算晶格热导率 ABACUS+Phono3py 计算晶格热导率 ABACUS+Wannier90 使用教程 ABACUS+Candela 使用教程 ABACUS+USPEX 接口教程 ABACUS+Hefei NAMD 使用教程 ABACUS+ASE 做过渡态计算 ATST-Tools: ASE-ABACUS 过渡态计算工作流套件与算例 (支持 NEB，Dimer，AutoNEB 等过渡态方法) ABACUS-ASE做NEB计算 （简单算例） 三、教程 3.1 基于 ABACUS 的表面计算教程 静电势和功函数 偶极修正 表面能计算 表面缺陷能和吸附能计算 外加电场 补偿电荷 固定电势方法在ABACUS中的实现 3.2 《计算材料学》采用 ABACUS 的计算模拟实例 ABACUS 计算模拟实例 | 概述 ABACUS 计算模拟实例 | I. 原子及小分子气体能量计算 ABACUS 计算模拟实例 | II. C2H5OH 的振动模式与频率计算 ABACUS 计算模拟实例 | III. 材料平衡晶格常数计算 ABACUS 计算模拟实例 | IV. 堆垛层错能的计算 ABACUS 计算模拟实例 | V. Al 的弹性性能指标计算 ABACUS 计算模拟实例 | VI. 空位形成能与间隙能计算 2024 秋计算材料学-上机练习：ABACUS 能带和态密度计算 ABACUS 计算模拟实例 | VIII. 基于 HSE06 的态密度与能带计算 ABACUS 计算模拟实例 | IX. 表面能的计算 ABACUS 计算模拟实例 | XI. Pt 表面简单物种的吸附能计算 ABACUS 计算模拟实例 | XII. Pt(111)表面羟基解离的过渡态搜索 ABACUS 计算模拟实例 | XIII. Pt 表面的 ORR 催化路径 3.3 公众号文章推荐 新服务器安装ABACUS ABACUS中坐标变换——调整真空层方向 ABACUS+Wannier90+WannierTools计算Bi2Se3的能带和拓扑性质 更新：ABACUS+Wannier90+WannierTools计算Bi2Se3的能带和拓扑性质 3.4 视频推荐 ABACUS轨道生成 四、开发者文档 4.1 基础规范 ABACUS 的 Github 仓库 Issues 处理流程 ABACUS 开源项目 C++ 代码规范 ABACUS 注释规范：Doxygen 入门 (c++) ABACUS 线上文档输入参数撰写规范 ABACUS 代码存放规范 如何在 ABACUS 中新增一个输入参数（v3.7.0 后） 如何在 ABACUS 中进行异构计算 ABACUS formatter-2.0 版本使用说明书 ABACUS 中使用格式化工具 clang-format 如何在 ABACUS 中新增一个输入参数（截至 v3.5.3） 4.2 性能工具 性能分析工具：vtune 快速上手教程 ABACUS 全局数据结构和代码行数检测 4.3 编程进阶 ABACUS 中的测试（一）：测试的重要性 ABACUS 中的测试（二）：测试工具 gtest C++ 程序设计的一些想法 文件输出功能的实现代码结构设计建议：以 ABCUS CifParser 为例 以格点积分程序为例：一些代码开发习惯小贴士 在 ABACUS 中进行差分测试 ABACUS 如何处理内存 bug？ Tensor 类文档 1：构造和使用说明 Tensor 类文档 2：使用和拓展 4.4 模块介绍 ESolver 模块介绍 HSolver 模块介绍 HContainer 模块介绍 4.5 平面波代码介绍 Introduction to ABACUS: Path to PW calculation - Part 1 Introduction to ABACUS: Path to PW calculation - Part 2 Introduction to ABACUS: Path to PW calculation - Part 3 Introduction to ABACUS: Path to PW calculation - Part 4 Introduction to ABACUS: Path to PW calculation - Part 5 Introduction to ABACUS: Path to PW calculation - Summary 1 Introduction to ABACUS: Path to PW calculation - Part 6 Introduction to ABACUS: Path to PW calculation - Part 7 Introduction to ABACUS: Path to PW calculation - Part 8 Introduction to ABACUS: Path to PW calculation - Part 9 Introduction to ABACUS: Path to PW calculation - Part 10 Introduction to ABACUS: Path to PW calculation - Part 11 Introduction to ABACUS: Path to PW calculation - Summary Final 4.6 Pyabacus 介绍 Pyabacus 文档一：用户手册 Pyabacus 文档二：HSolver 模块 Pyabacus 文档三：开发者指南 五、算法文档 电荷密度混合算法介绍 最大局域化 Wannier 函数方法简介 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:57 "},"news.html":{"url":"news.html","title":"ABACUS 新闻稿整理","keywords":"","body":"ABACUS 新闻稿整理 整理人：陈涛，邮箱：chentao@stu.pku.edu.cn; 张笑扬，邮箱：2100011024@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 标题 链接 日期 公众号 ABACUS：一款开源开放的AI4S时代电子结构软件包 网页链接 2025/03/27 深度势能 ABACUS还能干这个？助力揭秘镍基高温超导材料磁性奥秘 网页链接 2025/02/27 深度势能 ABACUS还能干这个？第一性原理计算阐释二维材料调控复杂氧化物机理 网页链接 2025/01/20 深度势能 ABACUS + DeepH + KPROJ还能干这个? MoSe2/WSe2摩尔晶格的电子结构研究 网页链接 2025/01/15 深度势能 ABACUS还能干这个？千原子以上高熵二维材料MXene的多重超均匀性研究 网页链接 2025/01/10 深度势能 ABACUS还能干这个？结合TB2J软件探索CrTe2薄膜自旋极化的反常现象 网页链接 2025/01/07 深度势能 ABACUS还能干这个？解释S空位诱导基于TiOx/MoS2–xOx结构的RRAM中导电细丝的形成机制 网页链接 2025/01/02 深度势能 ABACUS 3.9发布——平面波基组计算效率大幅提升，新增恒电势模拟功能 网页链接 2024/12/31 深度势能 ABACUS还能干这个？微观探测结合DFT（ABACUS+TB2J）探索GeFe3N材料的微观磁性 网页链接 2024/12/23 深度势能 ABACUS还能干这个？借助AI来描述半导体中的电子动能 网页链接 2024/11/18 深度势能 ABACUS学习日志：新手小白的进阶之路 网页链接 2024/11/14 深度势能 《金属学报》专刊发布，DeepModeling社区赋能材料科学 网页链接 2024/10/14 深度势能 ABACUS还能干这个？Acta Materialia发表关于铝铜合金强化相的稳定性研究 网页链接 2024/10/10 深度势能 ABACUS 3.8发布——数值原子基下的异构加速和杂化泛函效率提升 网页链接 2024/10/08 深度势能 ABACUS+DeePKS保姆级实战教程 \\ 以钙钛矿体系为例 网页链接 2024/10/08 NBHub 高斯基组 vs ABACUS数值原子轨道：EOS与热导率的密度泛函计算对比 网页链接 2024/09/29 深度势能 dftio：携手DeepModeling社区，共建高效的电子结构数据处理工具 网页链接 2024/09/14 深度势能 DeePTB v1见刊Nat. Commun. ，v2重磅发布！支持严格局域等变表示LCAO-量子算符 网页链接 2024/08/15 深度势能 ABACUS还能干这个？探究非局域势效应对温稠密物质的电导率与热导率计算影响 网页链接 2024/07/30 深度势能 2024 Q2 OpenLAM Report \\ 更稳定的代码 更丰富的领域模型 网页链接 2024/07/29 深度势能 ABACUS@Notebooks \\ 探索化学元素周期表的奥秘 网页链接 2024/07/06 NBHub 拓展科学边界 \\ OpenLAM于WAIC发布最新进展 构建大原子模型开放社区平台 网页链接 2024/07/06 深度势能 中国科研团队开发“原子算筹”软件 助力新材料研发 网页链接 2024/07/04 中国新闻网 ABACUS还能干这个？见刊Nat. Commun、ACS Nano，含时密度泛函理论揭示光催化微观机理 网页链接 2024/07/04 深度势能 ABACUS进阶教程：计算材料学中的实战应用 网页链接 2024/07/02 深度势能 ABACUS 3.7发布——完善测试为合金领域应用保驾护航，综合优化提升DCU版本计算性能 网页链接 2024/07/01 深度势能 ABACUS+DP还能干这个? \\ 覆盖IIB到VIA族的半导体机器学习势函数 网页链接 2024/06/27 深度势能 ABACUS 带你领略电子轨道的美妙 网页链接 2024/05/31 深度势能 ABACUS还能干这个？来自德国埃尔朗根-纽伦堡大学的课题组揭示了带缺陷石墨烯纳米带的电子结构性质 网页链接 2024/05/13 深度势能 2024年计算化学公社举办的计算化学程序和DFT泛函的流行程度投票结果 网页链接 2024/05/05 计算化学公社 张林峰：重构世界，从原子开始 网页链接 2024/04/28 深势科技 ABACUS还能干这个？通过梯度锗掺杂实现高效同质结锡基钙钛矿太阳能电池 网页链接 2024/04/28 深度势能 专题进展 \\ 我国计算物理软件研发的现状及展望 网页链接 2024/04/25 SCPMA ABACUS还能干这个？薄膜技术显著增强TaAs中的非线性霍尔效应 网页链接 2024/04/22 深度势能 超算&AI应用周报 \\ ABACUS v3.6.0版本上线超算互联网，助力大原子模型建设 网页链接 2024/04/07 超算互联网 ABACUS软件简单介绍 网页链接 2024/04/06 学术之友 ABACUS 带你领略电子轨道的美妙 网页链接 2024/04/03 NBHub ABACUS 3.6发布——DFT+U算法改进、国产硬件适配助力大原子模型建设 网页链接 2024/04/01 深度势能 ABACUS还能干这个？预测二维铁电材料SnTe中的巨大位移电流效应 网页链接 2024/03/28 深度势能 ABACUS还能干这个？借助AI来描述电子动能 网页链接 2024/03/19 深度势能 ABACUS还能干这个？为数百万度高温物质的DP势提供训练数据 网页链接 2024/01/10 深度势能 涓流汇沧海，积篑成丘山——手动@关注 ABACUS 的您，亲启这封年终回顾 网页链接 2023/12/29 深度势能 ABACUS 3.5发布——更稳定高效的Kohn-Sham方程自洽求解 网页链接 2023/12/29 深度势能 社区人物志 \\ 致力于用电子结构计算改变世界，他是认真的 网页链接 2023/11/30 深度势能 DP还能干这个？深度势能结合DeePKS+ABACUS研究溶液中的质子转移 网页链接 2023/11/22 深度势能 ABACUS 3.4发布：代码重构助力开发者加入，性能提升推动大模型生产 网页链接 2023/10/07 深度势能 当Hackathon遇上ABACUS \\ ABACUS@Hackathon作品合集大揭秘 网页链接 2023/09/24 深度势能 ABACUS计算催化实践@Notebook，快速上手催化理论计算 网页链接 2023/09/20 深度势能 DP+ABACUS还能干这个：钙钛矿氧化物通用力场UniPero 网页链接 2023/09/16 深度势能 ABACUS@Notebooks \\ 边学边练，随时随地运行的 DFT 软件使用教程 网页链接 2023/09/07 深度势能 ABACUS新进展：基于数值原子轨道基的meta-GGA密度泛函的实现 网页链接 2023/09/06 深度势能 ABACUS开发者大会 \\ 聚焦国产密度泛函理论开源软件的进步与挑战 网页链接 2023/08/01 深度势能 ABACUS 3.3 发布：自动化测试工作流赋能高效研发，为代码质量保驾护航 网页链接 2023/07/13 深度势能 LibRI：携手 DeepModeling 社区，助力超越常规 DFT 方法的高阶方法计算 网页链接 2023/05/26 深度势能 ABACUS 3.2 发布：支持 Hefei-NAMD 接口，全面提升代码稳定性和易用性 网页链接 2023/04/01 深度势能 ABACUS 还能干这个？探索准一维材料碳纳米管中的无序超均匀性 网页链接 2023/03/07 深度势能 ABACUS 3.1 发布，支持平面波基组下的 GPU 高效计算，发布固液界面计算新功能 网页链接 2023/01/01 深度势能 探索 AI+DFT 最前线，「原子算筹」ABACUS 3.0 重磅发布！ 网页链接 2022/10/01 深度势能 ABACUS 3.0：共建 AI 辅助的新一代电子结构算法平台 网页链接 2022/10/01 深度势能 ABACUS 新进展：用混合随机密度泛函理论方法模拟极端高温物质电子性质 网页链接 2022/09/20 深度势能 以合作促发展：共建国产密度泛函理论开源软件 ABACUS 网页链接 2022/09/14 深度势能 ABACUS 新进展：能带反折叠（band unfolding）方法及相关应用 网页链接 2022/07/22 深度势能 v2.3 来了！ABACUS 小步快跑，重大升级，更快更稳更好用！ 网页链接 2022/07/01 深度势能 ABACUS 新进展：用密度泛函理论模拟千原子以上半导体电极表面反应 网页链接 2022/06/21 深度势能 DeePKS+ABACUS：构建高精度第一性原理计算与机器学习势函数的桥梁 网页链接 2022/06/13 深度势能 ABACUS 2.2 版本介绍 网页链接 2022/04/08 深度势能 涓流汇沧海，积篑成丘山：一位科学家与 ABACUS 的十五年 网页链接 2021/09/28 深度势能 ABACUS ：携手 DeepModeling，做源自中国、开源开放的 DFT 软件 网页链接 2021/09/22 深度势能 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-28 12:18:41 "},"contribute.html":{"url":"contribute.html","title":"如何贡献 ABACUS 使用教程","keywords":"","body":"如何贡献ABACUS使用教程 一、明确教程格式 第一行，写作者姓名，单位，联系方式（例如Github ID或者邮箱），如果不愿意透露作者信息，也可以不写 第一部分“介绍”：本文档教程要展示的例子、要教授的内容有哪些，相关知识可以给一些参考文献。 第二部分“准备”：介绍输入文件需要哪些，最好是能够提供输入文件的下载（例如网上github仓库），或者直接贴上输入文件 第三部分“流程”：最好通过图文结合的方式，一步步的介绍每一步的命令，能得到什么结果。 第四部分“结语”：对这个功能使用需要注意的地方，或者可以应用的场景都可以给与相关介绍 二、投稿 写好教程，检查无误后，AISI内部直接把稿件发给陈默涵老师（邮箱mohanchen@pku.edu.cn），或者向DeepModeling社区（deepmodeling@deepmodeling.com）投稿，审核通过后会加入到“ABACUS使用教程汇总” Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-gcc.html":{"url":"abacus-gcc.html","title":"GCC 编译 ABACUS 教程","keywords":"","body":"GCC 编译 ABACUS 教程 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/19 一、介绍：关于 ABACUS ABACUS（原子算筹）软件同时支持两种基矢量，一种是平面波（Plane wave，PW） 基组，一种是 LCAO (Linear combination of atomic orbitals)或者称 NAO(Numerical atomic orbitals)基组。因为两种基组运行依赖的软件库不完全相同，所以我们分开介绍。 实际上，LCAO 基组依赖的软件库比 PW 基组更多，因此如果用户只使用 PW 基组，并不需要将所有依赖的数学库全都下载安装好。 下面介绍，两种基组分别都依赖那些数学库： PW 基组依赖以下 3 个 数学库： BLAS：BLAS（Basic Linear Algebra Subprograms）是一组基本的线性代数库，用于高效执行常见的基础线性代数运算，如矩阵乘法和向量操作。 LAPACK：LAPACK（Linear Algebra Package）是一个开源的数值线性代数库，用于解决线性代数问题，包括矩阵分解、方程组求解和特征值计算等。 FFTW3：FFTW3（Fastest Fourier Transform in the West 3）是一个高性能、开源的快速傅里叶变换（FFT）库，用于高效计算各种傅里叶变换和逆变换。 LCAO 基组依赖以下 6 个 软件库： BLAS LAPACK FFTW3 ScaLAPACK：ScaLAPACK（Scalable LAPACK）是一种并行计算库，构建在 LAPACK 之上，用于解决大规模线性代数问题，特别适用于分布式和并行计算环境。 CEREAL：CEREAL 是一个 C++ 序列化库，用于将 C++ 对象转换为可存储或传输的数据格式，以及将其反序列化回对象。 ELPA：ELPA（Eigenvalue SoLvers for Petaflop-Applications）是一个用于高性能计算的开源库，旨在解决大规模高性能计算中的特征值问题，特别是密集矩阵的特征值问题。（用户编译安装 abacus 的时候大多在这里出现问题） ELPA仅用于 LCAO基组求解特征值与特征矩阵的过程，如果由于机器等原因导致 ELPA 难以安装，可以暂不安装ELPA，在编译 abacus 的时候添加-DUSE_ELPA=0即可绕过ELPA安装困难的问题。 在ABACUS中，LCAO基组求解特征值与特征矩阵提供了两种方法，一种是调用ELPA进行求解（默认选项），一种是调用ScaLAPACK进行求解。 如果使用-DUSE_ELPA=0编译选项，请参考使用文档配置ks_solver为scalapack_gvx，调用ScaLAPACK进行求解。（http://abacus.deepmodeling.com/en/stable/advanced/input_files/input-main.html#ks-solver） 二、检查当前服务器基础环境： 1. 查看当前系统版本： root@bohrium-11852-1041346:~# lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 20.04.5 LTS Release: 20.04 Codename: focal 2. 检查当前 GCC 编译器版本： root@bohrium-11852-1041346:~# g++ --version g++ (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0 Copyright (C) 2019 Free Software Foundation, Inc. 3. 检查当前环境是否有 git root@bohrium-11852-1041346:~# git --version git version 2.25.1 三、安装 仅支持 PW 基组的 ABACUS 对于仅支持 PW 基组的 ABACUS，我们同时支持两种版本的编译：串行版本和并行版本。 编译这两个版本的主要区别在于是否需要安装 MPI library。 1. 编译串行版本 1.1 安装依赖库。 sudo apt update sudo apt install -y libopenblas-openmp-dev sudo apt install -y liblapack-dev sudo apt install -y libfftw3-dev 1.2 从仓库克隆代码到本地，并进入目录。 git clone https://github.com/deepmodeling/abacus-develop.git cd abacus-develop/ 1.3 开始编译并安装 abacus。 cmake -B build -DENABLE_MPI=OFF cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus_pw_serial 可执行文件。 abacus_pw_serial 就是串行版本的支持平面波基组的 ABACUS。 2. 编译并行版本 2.1 安装依赖库。（同串行，如果已经安装，则不用重复操作） sudo apt update sudo apt install -y libopenblas-openmp-dev sudo apt install -y liblapack-dev sudo apt install -y libfftw3-dev 2.2 安装 MPI library。这里选择更为常用的 open MPI。 sudo apt install -y libopenmpi-dev 2.3 从仓库克隆代码到本地，并进入目录。 git clone https://github.com/deepmodeling/abacus-develop.git cd abacus-develop/ 2.4 开始编译并安装 abacus。 cmake -B build -DENABLE_LCAO=OFF cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus_pw 可执行文件。 abacus_pw 就是并行版本的支持平面波基组的 ABACUS。 四、安装 支持两种基组的 ABACUS 对于同时支持两种基组的 ABACUS，仅可以编译并行版本。并无串行版本。 在本文最初就提到支持 LCAO 基组的 ABACUS 所依赖软件库的更多。 1. 安装 PW 基组依赖的软件库。（同上，如果已经安装，则不用重复操作） sudo apt update sudo apt install -y libopenblas-openmp-dev sudo apt install -y liblapack-dev sudo apt install -y libfftw3-dev 2. 安装 MPI library。这里选择更为常用的 open MPI。（同上，如果已经安装，则不用重复操作） sudo apt install -y libopenmpi-dev 3. 安装 LCAO 基组依赖的 ScaLAPACK 和 CEREAL 软件库。 sudo apt install -y libscalapack-mpi-dev sudo apt install -y libcereal-dev 4. 安装 ELPA 软件库。（一般这里容易出问题） 如果你的系统是 Ubuntu 22.04，那么你可以以很简单的方式成功安装 ELPA： sudo apt install -y libelpa-dev 如果你的系统不是 Ubuntu 22.04，很可惜，你需要稍微辛苦一点来安装 ELPA。但别急，这也并不难！ 手动编译安装 ELPA 可以分为以下几步： 下载并进入 ELPA 目录： wget https://elpa.mpcdf.mpg.de/software/tarball-archive/Releases/2021.05.002/elpa-2021.05.002.tar.gz tar xzf elpa-2021.05.002.tar.gz cd elpa-2021.05.002 mkdir build && cd build configure ../configure --enable-openmp CFLAGS=\"-O3 -march=native -funsafe-loop-optimizations -funsafe-math-optimizations -ftree-vect-loop-version -ftree-vectorize\" FCFLAGS=\"-O2 -mavx\" --disable-avx512 编译安装 make -j`nproc` make install ln -s /usr/local/include/elpa_openmp-2021.05.002/elpa /usr/local/include/ 注意：ln -s /usr/local/include/elpa_openmp-2021.05.002/elpa /usr/local/include/ 是非常重要的！（很多用户是这里出的问题！） 5. 开始编译并安装 abacus。 cmake -B build cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus 可执行文件。 abacus 就是完整版的 ABACUS，它同时支持两种基矢量，而且还是并行版本！ Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-oneapi.html":{"url":"abacus-oneapi.html","title":"Intel oneAPI 2024.x 编译 ABACUS 教程","keywords":"","body":"Intel oneAPI 2024/2025 编译 ABACUS 教程 作者：陈诺，邮箱：cn037@stu.pku.edu.cn 最后更新时间：2025/03/22 Intel OneAPI 工具链 &#x1F382; 本教程适用于 2024.0 及更新版本的 oneAPI。 简介 本教程介绍如何使用 Intel oneAPI 2024/2025 工具链编译 ABACUS。 和之前的版本相比，新的 oneAPI 工具链在编译器等方面有较大变化。 oneAPI 2024 中，Intel® C++ Compiler Classic (icc) 停止使用，并使用了新的目录布局。 oneAPI 2025 中，Intel® Fortran Compiler Classic (ifort) 停止使用。 OneAPI Base Toolkit OneAPI Base Toolkit 提供了一系列基础工具和库，包括 BLAS, LAPACK, ScaLAPACK and FFTW3 等关键组件： Intel® oneAPI DPC++/C++ Compiler：面向 CPU、GPU、FPGA 的 C++ 编译器。 Intel® oneAPI DPC++ Library：提供并行算法的库。 Intel® oneAPI Math Kernel Library：即 MKL，提供高度优化的数学函数库，包括线性代数、FFT 等。 Intel® VTune™ Profiler：性能分析优化工具。 OneAPI HPC Toolkit OneAPI HPC Toolkit 是为高性能计算（HPC）特别优化的工具集，它在 OneAPI Base Toolkit 的基础上增加了更多针对 HPC 应用的特性和工具，包括： Intel® oneAPI DPC++/C++ Compiler：含有 C++ MPI 编译器。 Intel® Fortran Compiler & Intel® Fortran Compiler Classic：Fortran 编译器。 Intel® MPI Library：MPI 库。 安装 可以从官网上获得最新的安装包。安装需要管理员权限。 Download the Intel® oneAPI Base Toolkit Download the Intel® HPC Toolkit 以 2024.2 版本为例，展示配置环境和安装 ABACUS 的流程。 Offline installer Base Toolkit 下载 wget https://registrationcenter-download.intel.com/akdlm/IRC_NAS/9a98af19-1c68-46ce-9fdd-e249240c7c42/l_BaseKit_p_2024.2.0.634_offline.sh 安装，可选图形化界面安装sudo sh ./l_BaseKit_p_2024.2.0.634_offline.sh 或直接在shell中静默安装sudo sh ./l_BaseKit_p_2024.2.0.634_offline.sh -a --silent --cli --eula accept HPC Toolkit 下载wget https://registrationcenter-download.intel.com/akdlm/IRC_NAS/d4e49548-1492-45c9-b678-8268cb0f1b05/l_HPCKit_p_2024.2.0.635_offline.sh 安装，类似sudo sh ./l_HPCKit_p_2024.2.0.635_offline.sh -a --silent --cli --eula accept 按照默认配置，全局安装目录位于/opt/intel/oneapi。以2024.2版本为例，该目录如下：➜ oneapi ls 2024.2 basekit common dal dev-utilities dnnl dpl installer ippcp logs modulefiles-setup.sh setvars.sh tbb vtune advisor ccl compiler debugger diagnostics dpcpp-ct hpckit ipp licensing mkl mpi support.txt tcm 其中有一些重要的目录和工具，如 2024.2/ 和 installer/ 环境变量设置 要使用 oneAPI 提供的编译器和库，需要正确设置环境。 2024.0 及之后的版本，使用了新的目录布局。这导致了和老版本不同的环境配置方式。 参见 Use the setvars and oneapi-vars Scripts with Linux* 和之前的版本相比，由组件目录布局（Component Directory Layout）改为统一目录布局（Unified Directory Layout），新版本的所有组件（bin, lib, include, share）等统一放在以工具包版本号命名的顶级目录中。 在原先的 Component Directory Layout 中，不同的组件有各自的环境变量设置脚本，由一个位于 oneAPI 安装目录的脚本 /opt/intel/oneapi/setvars.sh 统一管理。新版的 Unified Directory Layout 中，每个组件被集中到组件共用的共享文件夹中，即每个组件将其头文件提供给一个公共的 include 文件夹，将其库文件提供给一个公共的 lib 文件夹，以此类推。这样，不同版本工具包之间的切换更容易，无需维护通用的 setvars.sh，而是通过工具包版本号命名的目录提供的脚本 /opt/intel/oneapi//oneapi-vars.sh 设置。 以 2024.2 为例，每次使用 icpx 等编译器之前，需要在 shell 环境中 source 一次脚本： . /opt/intel/oneapi/2024.2/oneapi-vars.sh # configure, build, ... 此时，编译器应该被添加到环境中，可以运行命令检查是否正确配置： # source前 ➜ oneapi mpiicpx -v zsh: command not found: mpiicpx # source后 ➜ oneapi mpiicpx -v mpiicpx for the Intel(R) MPI Library @IMPI_OFFICIALVERSION@ for Linux* Copyright Intel Corporation. Intel(R) oneAPI DPC++/C++ Compiler 2024.2.0 (2024.2.0.20240602) Target: x86_64-unknown-linux-gnu Thread model: posix InstalledDir: /opt/intel/oneapi/compiler/2024.2/bin/compiler Configuration file: /opt/intel/oneapi/compiler/2024.2/bin/compiler/../icpx.cfg Found candidate GCC installation: /usr/lib/gcc/x86_64-linux-gnu/11 Selected GCC installation: /usr/lib/gcc/x86_64-linux-gnu/11 Candidate multilib: .;@m64 Selected multilib: .;@m64 icpx: warning: argument unused during compilation: '-I /opt/intel/oneapi/2024.2/include' [-Wunused-command-line-argument] &#x1F382; source 和.命令 . 命令在 POSIX 标准中定义，因此它在所有 POSIX 兼容的 shell 中都应该可用。 source 命令一般情况下是 . 的别名，但在某些环境中不可用。如果脚本不能使用 source，请换成通用的 .. 这一步会配置环境变量，但是并不会设定默认的 C++ 编译器。因此，设置了 oneAPI 编译器的环境变量之后，还需要在配置（configure）时指定构建（build）采用的编译器，如 CXX=icpx。 2024.0 开始，原先的 classical 编译器停止使用。 Intel® C++ Compiler Classic Release Notes 请使用新的 icpx/mpiicpx 取代原来的 icpc/mpiicpc。 abacus 安装 依赖库 安装 cereal sudo apt install libcereal-dev 安装 elpa 在 Ubuntu22.04 等发行版中，可以通过 apt 获取预构建的 elpa 包（pre-build packages）。不幸的是，使用不同的 MPI 库构建 elpa 可能会导致冲突，apt 获取的 elpa 包和 oneAPI 2024.2 构建的 abacus 在运行时可能出现问题。 /usr/bin/ld: warning: libmpi.so.40, needed by /usr/lib/x86_64-linux-gnu/libelpa.so, may conflict with libmpi.so.12 运行算例时报错： * * * * * * 因此，我们需要手动利用 oneAPI 工具链构建 elpa。 使用 toolchain 由于 elpa 的编译较复杂，我们可以通过 abacus toolchain 脚本自动构建和安装 elpa。该脚本用 icpx 和 mpiicpc 编译 elpa，同时会默认安装 cereal 和 libxc。 一键配置编译 ABACUS | toolchain 脚本的使用 . /opt/intel/oneapi/2024.2/oneapi-vars.sh cd abacus-develop/toolchain ./toolchain_intel.sh # 脚本将会用intel工具链安装依赖。 安装完成的库目录为 abacus-develop/toolchain/install. # 安装完成的库目录为abacus-develop/toolchain/install ➜ toolchain git:(develop) ✗ ls install cereal-1.3.2 cmake-3.28.1 elpa-2023.05.001 libxc-6.2.2 lsan.supp setup toolchain.conf toolchain.env tsan.supp valgrind.supp 使用 toolchain 构建的 elpa，在构建 abacus 时有警告如下，暂未发现影响使用。该问题由 scalapack 库未指定 mkl 版本导致，“自行编译安装”方式（见下）无此问题。 参见 2.4 Non standard paths or non standard libraries /usr/bin/ld: warning: libmpi.so.40, needed by /lib/x86_64-linux-gnu/libscalapack-openmpi.so.2.1, may conflict with libmpi.so.12 除了使用 toolchain，也可以根据 documentation/INSTALL.md · master · elpa / elpa · GitLab，自行编译安装 elpa。 自行编译安装 自行下载和安装 elpa 到环境中。以 oneAPI 2024.2 和 elpa-2024.05.001 为例。 在官网下载 elpa 包。 wget https://elpa.mpcdf.mpg.de/software/tarball-archive/Releases/2024.05.001/elpa-2024.05.001.tar.gz tar xvf elpa-2024.05.001.tar.gz 以 oneAPI 2024.2 为例提供一个安装脚本，仅供参考。这一步可能需要几分钟。如果运行脚本时显示 oneAPI warnings 提示已经设置过环境变量并退出，请打开一个新的 shell 环境，执行安装脚本。最后的 make install和ln 需要 sudo 权限，如果无法提供，请手动完成这两步。 oneAPI 2025.0 开始，Intel® Fortran Compiler Classic (ifort) 停止使用。 Intel® HPC Toolkit Release Notes 请使用新的 ifx/mpiifx 取代原来的 ifort/mpiifort。 请根据实际情况，指定安装脚本中的 oneAPI 工具链版本。如果使用 oneAPI 2025.0 之后的版本，请把 21 行 FC=mpiifort 替换为 FC=mpiifx。 cd elpa-2024.05.001 #!/bin/bash -e # buildelpa.sh # run in elpa main dir # source oneAPI environments echo \"using oneAPI 2024.2\" . /opt/intel/oneapi/2024.2/oneapi-vars.sh \\ || { echo \"Failed to load oneAPI environment. Please restart in a new shell without oneAPI vars set.\"; false; } # in elpa main dir # check whether there is a 'build' directory if [ -d \"build\" ]; then echo \"rm -rf build\" rm -rf build fi mkdir build && cd build MKL_HOME=/opt/intel/oneapi/2024.2 __CC=mpiicx CXX=mpiicpx FC=mpiifort ../configure \\ --disable-avx --disable-avx2 --disable-avx512 --disable-sse --disable-sse-assembly \\ SCALAPACK_LDFLAGS=\"-L$MKL_HOME/lib/ -lmkl_scalapack_lp64 -lmkl_intel_lp64 -lmkl_sequential \\ -lmkl_core -lmkl_blacs_intelmpi_lp64 -lpthread -lm -Wl,-rpath,$MKL_HOME/lib/\" \\ SCALAPACK_FCFLAGS=\"-L$MKL_HOME/lib/ -lmkl_scalapack_lp64 -lmkl_intel_lp64 -lmkl_sequential \\ -lmkl_core -lmkl_blacs_intelmpi_lp64 -lpthread -lm -I$MKL_HOME/include/mkl/intel64/lp64\" make -j$(nproc) > make.log 2>&1 echo \"installation process may require administrative privileges.\" read -p \"Would you like to continue with 'sudo make install'? (y/n): \" -n 1 -r echo # (Optional) Move to a new line if [[ $REPLY =~ ^[Yy]$ ]] then echo \"Proceeding with installation using administrative privileges...\" sudo make install > install.log 2>&1 else echo \"Installation has been canceled.\" echo \"Please manually execute 'make install' and link elpa to default path.\" fi # link elpa to /usr/local/include # The target path for the symbolic link LINK_PATH=\"/usr/local/include/elpa\" # The source path for the original link (replace with the actual source path) SOURCE_PATH=\"/usr/local/include/elpa-2024.05.001/elpa\" # Check if the link exists if [ -L \"$LINK_PATH\" ]; then # If the link exists, delete it echo \"The link already exists, deleting the old link...\" sudo rm \"$LINK_PATH\" else # If the link does not exist, check for the presence of a file or directory if [ -e \"$LINK_PATH\" ]; then echo \"A file or directory exists at the path, unable to create the link. Please delete or rename the file/directory first.\" exit 1 fi fi # Create a new symbolic link sudo ln -s \"$SOURCE_PATH\" \"$LINK_PATH\" # Check if the link was created successfully if [ -L \"$LINK_PATH\" ]; then echo \"The new symbolic link has been created successfully.\" else echo \"Failed to create the symbolic link.\" exit 1 fi echo \"elpa install over.\" 安装 ABACUS 配置好依赖后，我们可以开始安装 ABACUS。 如果你使用 toolchain 配置环境，那么 toolchain 提供了一系列环境变量和构建工具。构建时，请利用 abacus-develop/toolchain/build_abacus_intel.sh 脚本直接构建 ABACUS（在其中修改配置选项），也可以手动构建。（不推荐） 如果需要手动安装 ABACUS 并使用 toolchain 的 ELPA：需要记住此前 toolchain 安装 elpa 的目录。 如果之前选择手动安装 ELPA，可以用默认方式自行用 cmake 构建。 # 设置环境 . /opt/intel/oneapi/2024.2/oneapi-vars.sh # configure # 在此选择oneAPI的编译器，添加编译选项，指定此前的安装路径，如 CXX=mpiicpx cmake -B build \\ -DELPA_DIR=~/abacus-develop/toolchain/install/elpa-2023.05.001/cpu/ # 根据需要添加其他cmake选项 # build cmake --build build -j`nproc` # install cmake --install build 常见问题和解决方法 在开始构建之前，请清除原有的 build 目录。 rm -rf build 找不到编译器，记得运行 vars 脚本设置 oneAPI 环境变量。 CMake Error at /usr/share/cmake-3.22/Modules/CMakeDetermineCXXCompiler.cmake:48 (message): Could not find compiler set in environment variable CXX: mpiicpx. Call Stack (most recent call first): CMakeLists.txt:7 (project) CMake Error: CMAKE_CXX_COMPILER not set, after EnableLanguage -- Configuring incomplete, errors occurred! # 请设置环境 . /opt/intel/oneapi/2024.2/oneapi-vars.sh 找不到 elpa，请在配置时指定安装路径。 CMake Error in CMakeLists.txt: Imported target \"ELPA::ELPA\" includes non-existent path \"/usr/include/elpa\" in its INTERFACE_INCLUDE_DIRECTORIES. Possible reasons include: * The path was deleted, renamed, or moved to another location. * An install or uninstall procedure did not complete successfully. * The installation package was faulty and references files it does not provide. # 请指定ELPA_DIR（及其他自己手动构建的库） CXX=mpiicpx cmake -B build \\ -DELPA_DIR=~/abacus-develop/toolchain/install/elpa-2023.05.001/cpu/ 期望使用 intel 工具链编译，但 cmake 显示使用 GNU 工具链。请使用 CXX=mpiicpx 指定编译器。 cmake -B build -DELPA_DIR=~/abacus-develop/toolchain/install/elpa-2023.05.001/cpu/ -- The CXX compiler identification is GNU 11.4.0 # CXX=mpiicpx cmake ... # -- The CXX compiler identification is IntelLLVM 2024.2.0 cmake 提示编译器错误，请使用新版的 icpx/mpiicpx，而不是 icpc/mpiicpc CMake Error at /usr/share/cmake-3.22/Modules/CMakeTestCXXCompiler.cmake:62 (message): The C++ compiler \"/opt/intel/oneapi/2024.2/bin/mpiicpc\" is not able to compile a simple test program. # use CXX=mpiicpx instead of CXX=mpiicpc 运行了 oneAPI 配置环境变量脚本，但是链接错误 请检查 oneAPI HPC kits 的安装；可进入 installer 查看当前安装的所有 Toolkits 和对应版本，见下条。 使用 /opt/intel/oneapi/2024.2/oneapi-vars.sh，而不是 /opt/intel/oneapi/setvars.sh 如果安装了多版本的 oneAPI 工具链，怀疑环境遭到破坏，可以使用 /opt/intel/oneapi/installer 中的 installer 工具修复和移除不需要版本以及更新。 cd /opt/intel/oneapi/installer sudo ./installer # 可以用Repair尝试修复环境 # 使用Remove移除不需要的组件 # 使用Update获得新版本 如果遇到 libmpi.so 相关报错，可以用 locate 查看所有相关库。 locate libmpi.so 运行算例或测试失败，请确保最新构建后运行了 install 命令，且没有因为权限不足安装失败。 参考 Abacus 文档 Easy Installation 一键配置编译 ABACUS | toolchain 脚本的使用 Intel oneAPI 编译 ABACUS 教程 · GitBook elpa documentation/INSTALL.md · master · elpa / elpa · GitLab Intel 文档 Use the setvars and oneapi-vars Scripts with Linux* Intel® C++ Compiler Classic Release Notes Porting Guide for DPCPP or ICX Porting Guide for ifort Users to ifx Intel® oneAPI Base Toolkit Release Notes Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-27 15:37:07 "},"abacus-intel.html":{"url":"abacus-intel.html","title":"Intel oneAPI 编译 ABACUS 教程","keywords":"","body":"Intel oneAPI 编译 ABACUS 教程 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/21 一、前言 非特殊情况，linux 系统会默认安装 GCC（GNU Compiler Collection）编译器套件。因此如果你的机器默认没有 Intel® oneAPI Toolkits，那么建议，你可以直接看上一篇文章：GCC 编译 ABACUS 教程 。 如果您的机器恰好有 Intel® oneAPI Toolkits，那么您也可以使用它来编译 ABACUS。 二、关于 Intel® oneAPI Toolkits Intel® oneAPI Toolkits 分为很多个版本的 Toolkit，这里解释下 Intel® oneAPI Base Toolkit 和 Intel® oneAPI HPC Toolkit 的区别。 简单来说：Intel® oneAPI HPC Toolkit 包含 Intel® oneAPI Base Toolkit。 Intel® oneAPI Base Toolkit 中包含：Intel® oneAPI Math Kernel Library（简称为 MKL），这个软件库里面包含了大量常用的数学库，包括 ABACUS 依赖的 BLAS、LAPACK、FFTW3 和 ScaLAPACK 4 个软件库。 因此使用 Intel oneAPI 来编译 ABACUS，可以省去逐个去安装数学库的过程！ Intel® oneAPI HPC Toolkit 相比于 Intel® oneAPI Base Toolkit 多了一些必要的 Intel 的编译器以及 Intel® MPI Library（ABACUS 想要编译并行版本必须的关键库）。 总结一下，使用 Intel oneAPI 编译 ABACUS，必须确保你的机器中包含 Intel® oneAPI HPC Toolkit。 关于 Intel® oneAPI Toolkits 更详细的信息：https://www.intel.com/content/www/us/en/developer/tools/oneapi/toolkits.html#hpc-kit 三、编译 安装 开启 Intel® oneAPI Toolkits： source /opt/intel/oneapi/setvars.sh ELPA仅用于 LCAO基组求解特征值与特征矩阵的过程，如果由于机器等原因导致 ELPA 难以安装，可以暂不安装ELPA，在编译 abacus 的时候添加-DUSE_ELPA=0即可绕过ELPA安装困难的问题。 在ABACUS中，LCAO基组求解特征值与特征矩阵提供了两种方法，一种是调用ELPA进行求解（默认选项），一种是调用ScaLAPACK进行求解。 如果使用-DUSE_ELPA=0编译选项，请参考使用文档配置ks_solver为scalapack_gvx，调用ScaLAPACK进行求解。（http://abacus.deepmodeling.com/en/stable/advanced/input_files/input-main.html#ks-solver） 1. 安装 仅支持 PW 基组的 ABACUS 对于仅支持 PW 基组的 ABACUS，我们同时支持两种版本的编译：串行版本和并行版本。 ABACUS 的 PW 基组只依赖：BLAS、LAPACK、FFTW3 三个数学库，而这三个数学库都已经被 Intel® oneAPI Base Toolkit 中包含：Intel® oneAPI Math Kernel Library（简称为 MKL）所包含，因此我们不需要再安装其他的软件库！ 1.1 编译串行版本 CXX=icpx cmake -B build -DENABLE_MPI=OFF cd build && make -j`nproc` 注意，这里必须指定CXX=icpx，不然系统会使用默认的 CXX 编译器。同时这里的 CXX 也不要指定 icpc，icpc 是 Intel® C++ Compiler Classic，会带来一些报错。 可以看到在当前目录下，已经编译成功了 abacus_pw_serial 可执行文件。 abacus_pw_serial 就是串行版本的支持平面波基组的 ABACUS。 1.2 编译并行版本 CXX=icpx cmake -B build -DENABLE_LCAO=OFF cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus_pw 可执行文件。 abacus_pw 就是并行版本的支持平面波基组的 ABACUS。 2. 安装 支持两种基组的 ABACUS 对于同时支持两种基组的 ABACUS，仅可以编译并行版本。并无串行版本。 完整版的 ABACUS 需要依赖更多的软件库：BLAS、LAPACK、FFTW3、ScaLAPACK、CEREAL、ELPA共 6 个。 而前四个数学库（BLAS、LAPACK、FFTW3、ScaLAPACK）都已经被 Intel MKL 所包含，因此我们只需再额外安装CEREAL、ELPA即可。 2.1 安装 CEREAL sudo apt install -y libcereal-dev 2.2 安装 ELPA 如果你的系统是 Ubuntu 22.04，那么你可以以很简单的方式成功安装 ELPA。 sudo apt install -y libelpa-dev 如果你的系统不是 Ubuntu 22.04，很可惜，你需要稍微辛苦一点来安装 ELPA。但别急，这也并不难！ 注意；这里手动编译安装 ELPA 的方法与在 GCC 下编译不太一样，因为要保证 ELPA 和 ABACUS 都是基于 Intel oneAPI 来编译的！ 手动编译安装 ELPA 可以分为以下几步： 下载并进入 ELPA 目录： wget https://elpa.mpcdf.mpg.de/software/tarball-archive/Releases/2021.05.002/elpa-2021.05.002.tar.gz tar xzf elpa-2021.05.002.tar.gz cd elpa-2021.05.002 mkdir build && cd build configure CC=mpiicc CXX=mpiicpc FC=mpiifort ../configure --enable-openmp FCFLAGS=\"-qmkl=cluster\" 编译安装 make -j`nproc` make install ln -s /usr/local/include/elpa_openmp-2021.05.002/elpa /usr/local/include/ 注意：ln -s /usr/local/include/elpa_openmp-2021.05.002/elpa /usr/local/include/ 是非常重要的！（很多用户是这里出的问题！） 2.3 编译安装 ABACUS CXX=icpx cmake -B build cd build && make -j`nproc` 可以看到在当前目录下，已经编译成功了 abacus 可执行文件。 abacus 就是完整版的 ABACUS，它同时支持两种基矢量，而且还是并行版本！ Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-27 15:36:30 "},"abacus-gpu.html":{"url":"abacus-gpu.html","title":"编译 Nvidia GPU 版本的 ABACUS","keywords":"","body":"编译 Nvidia GPU 版本的 ABACUS 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024/03/15 一、介绍 本教程旨在介绍 ABACUS 在支持 NVIDIA GPU 的服务器上的编译与使用。 当前 ABACUS 支持的 GPU 并行计算 INPUT 文件中 device 参数需设置为 gpu。 目前 GPU 版本的 ABACUS 仅支持 PW 基组的计算，因此 INPUT 文件中 basis_type 参数仅能设置为 pw。 详细请看官方文档：https://abacus.deepmodeling.com/en/latest/advanced/acceleration/cuda.html LCAO 基组的 GPU 计算版本近期会发布。 NVIDIA GPU & CUDA NVIDIA GPU (Graphics Processing Unit) 是由一种专门设计来处理图形和并行计算任务的电子芯片。自从 NVIDIA 推出其首款 GPU 以来，它们已经从仅仅处理视频游戏图形的设备发展成为能处理各种高性能计算和深度学习任务的强大工具。 CUDA（Compute Unified Device Architecture），是显卡厂商 NVIDIA 推出的运算平台。 CUDA 是一种由 NVIDIA 推出的通用并行计算架构，该架构使 NVIDAI GPU 能够解决复杂的计算问题。 为了使 ABACUS 的部分功能支持 NVIDIA GPU，ABACUS 开发团队针对 NVIDIA GPU 写了大量的 CUDA 代码，使其在 NVIDIA GPU 上有较高的运行效率。相比于 CPU 版本的计算任务，有极高的效率提升！ 新闻稿：https://mp.weixin.qq.com/s/D8gcQb0bikMdgizLsbvCfQ 二、检查环境 检查当前环境是否有 NVIDIA GPU nvidia-smi 命令帮助检测你的服务器是否有 NVIDIA GPU 设备。 nvcc --version 命令帮助你检测你的服务器软件环境中是否包含 cuda toolkit 更详细的内容查看：https://abacus.deepmodeling.com/en/latest/advanced/acceleration/cuda.html#required-hardware-software 三、编译 如果您已经尝试过使用 GCC 编译 ABACUS 教程 或者 Intel oneAPI 编译 ABACUS 教程，那么编译支持在 NVIDIA GPU 上运行的 ABACUS 十分简单。 在保证可以正常编译 CPU 版本的 ABACUS 的环境下，使用： cmake -B build -DUSE_CUDA=1 # for GCC cd build && make -j`nproc` # or CXX=icpx cmake -B build -DUSE_CUDA=1 # for Intel oneAPI cd build && make -j`nproc` 这样编译出来的 abacus 可执行文件就是支持 NVIDIA GPU 运行的 ABACUS。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-gpu-lcao.html":{"url":"abacus-gpu-lcao.html","title":"ABACUS LCAO 基组 GPU 版本使用说明","keywords":"","body":"ABACUS LCAO 基组 GPU 版本使用说明 作者：邓子超，邮箱：zcdeng@pku.edu.cnmailto:zcdeng@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2025/06/05 文档对应 notebook：ABACUS LCAO 基组 GPU 版本使用介绍 | Bohrium 一、简介 为了提升 ABACUS 的运行效率，2024 年 10 月发布的 ABACUS 3.8 版本支持 GPU 环境下采用 LCAO（Linear Combination of Atomic Orbitals）基组（即数值原子轨道基组）对 Kohn-Sham 方程进行求解。目前该版本提供 GPU 支持的模块有广义本征值求解器以及实空间生成哈密顿量的格点积分，这两部分也是 LCAO 基组求解 Kohn-Sham 方程的热点。在广义本征值求解器方面，目前 3.8 版本集成了 cuSolver，cuSolverMP，ELPA 软件，从而可以支持单卡和多卡的 GPU 加速。在格点积分模块里我们自研了 GPU 积分加速算法。开发团队未来还会针对 LCAO 算的更多模块提供 GPU 硬件以及其它国产硬件的支持。 二、安装 要使用 GPU 版的 ABACUS，使用 CMAKE 编译 ABACUS 的时候（ABACUS 编译方法详见 https://abacus.deepmodeling.com/en/latest/quick_start/easy_install.html），需要进行如下设置。 格点积分 GPU 版支持，以及 cusolver 求解器支持：需要安装 cuda-toolkit，并在编译 ABACUS 时设置 -DUSE_CUDA=ON。 (可选项)cusolvermp 求解器支持：编译 ABACUS 之前，需要确保系统上安装了 cusolvermp 相关库，具体安装方法见 https://docs.nvidia.com/cuda/cusolvermp/。除了设置 -DUSE_CUDA=ON 之外，还需要设置 -DENABLE_CUSOLVERMP=ON。 (可选项)GPU 版 ELPA 求解器支持：编译 ABACUS 之前，需要确保系统上安装了支持 GPU 版本的 ELPA，安装方法详见 https://github.com/marekandreas/elpa/blob/master/documentation/INSTALL.md，安装过程可以参考 https://github.com/deepmodeling/abacus-develop/pull/4969。安装好 ELPA 之后，在编译 ABACUS 时，需要设置 -DUSE_CUDA=ON, -DUSE_ELPA=ON。 三、使用 1. INPUT 参数设置 目前 ABACUS 的 LCAO 基组已经 GPU 化的模块包括格点积分模块和广义特征值求解模块。这两个模块是否使用 GPU 加速可以分开设置。与格点积分和广义特征值求解相关的输入参数包括 device 以及 ks_solver。下面详细介绍一下这两个参数的设置，注意以下介绍基于 ABACUS 的 LCAO 基组（INPUT 文件中的 basis_type 需要设置为 lcao）。 device:device 用于指定 ABACUS 是否使用 GPU 来加速运算，可以设置为 cpu 或者 gpu。如果编译的是 GPU 版的 ABACUS（编译时设置了 -DUSE_CUDA=ON），同时机器中至少有一张 GPU 卡，那么 device 的默认值为 gpu,否则为 cpu。 如果 device 设置为 gpu, 那么 ABACUS 将使用 GPU 来加速计算，对应的，格点积分将使用 GPU 加速计算，广义特征值求解器 ks_solver 也将默认设置为 cusolver, 如果您的机器包含多张 GPU，也可以将 ks_solver 设置为 cusolvermp 或者 elpa 来调用多卡求解特征值； 如果 device 设置为 cpu，ABACUS 将使用 CPU 进行计算，格点积分部分也会使用 CPU 计算，广义特征值求解器 ks_solver 默认设置为 scalapack_gvx,genelpa,或者 lapack(默认值详见 https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#ks-solver) ks_solver:ks_solver 用于设置广义特征值求解器，目前 LCAO 基组支持的广义特征值求解器有 lapack,scalapack_gvx,genelpa,cusolver,cusolvermp,elpa。其中 cusolver,cusolvermp 与 elpa 可以调用 GPU 进行广义特征值求解,cusolver 只支持单 GPU 卡求解，cusolvermp 与 elpa 支持多 GPU 卡求解。 在 INPUT 文件中设置好 device 和 ks_solver 参数后，运行 ABACUS，即可调用 GPU 进行运算。 2. 多卡计算 ABACUS 的格点积分模块以及广义特征值求解模块均支持多块 GPU 卡加速，ABACUS 调用的 GPU 数量通过 MPI 进程数来设置。如果设置 n 个进程，ABACUS 将会自动调用 n 张 GPU 卡来进行计算，若机器中的 GPU 卡数小于 n，ABACUS 则会调用机器中所有 GPU 卡来进行运算，不推荐进程数设置成大于 GPU 卡数。需要注意的是，ABACUS 的广义特征值求解部分只有 cusolvermp 和 elpa 支持多卡加速，如果 ks_solver 设置成 cusolver，无论设置多少个进程，ABACUS 都只会调用一张 GPU 卡来进行广义特征值求解。 四、示例 下面以 tests/performance/P102_si64_lcao 的 64 个金刚石结构的硅原子体系为例，展示如何使用 GPU 版 ABACUS 进行 LCAO 基组下的计算。 环境：GPU/双 3090, CPU / Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz ABACUS 版本号：3.8.0, commit:72b1d7ce9 1. GPU 算例和结果 我们首先调用双 GPU 卡进行格点积分运算，同时使用 cusolver 进行广义特征值求解：修改 INPUT 文件，添加一行 “device gpu”, 同时将 ks_solver 设置为 cusolver，运行命令 “OMP_NUM_THREADS=12 mpirun -n 2 abacus\", 输出为： Info: Local MPI proc number: 2,OpenMP thread number: 12,Total thread number: 24,Local thread limit: 56 ABACUS v3.8.0 Atomic-orbital Based Ab-initio Computation at UStc Website: http://abacus.ustc.edu.cn/ Documentation: https://abacus.deepmodeling.com/ Repository: https://github.com/abacusmodeling/abacus-develop https://github.com/deepmodeling/abacus-develop Commit: 72b1d7ce9 (Sat Oct 5 16:46:53 2024 +0800) Sat Oct 5 19:04:21 2024 MAKE THE DIR : OUT.autotest/ RUNNING WITH DEVICE : GPU / NVIDIA GeForce RTX 3090 UNIFORM GRID DIM : 192 * 192 * 96 UNIFORM GRID DIM(BIG) : 48 * 48 * 24 DONE(0.652318 SEC) : SETUP UNITCELL DONE(0.70875 SEC) : SYMMETRY DONE(0.789308 SEC) : INIT K-POINTS --------------------------------------------------------- Self-consistent calculations for electrons --------------------------------------------------------- SPIN KPOINTS PROCESSORS NBASE 1 1 2 832 --------------------------------------------------------- Use Systematically Improvable Atomic bases --------------------------------------------------------- ELEMENT ORBITALS NBASE NATOM XC Si 2s2p1d-8au 13 64 --------------------------------------------------------- Initial plane wave basis and FFT box --------------------------------------------------------- DONE(0.818906 SEC) : INIT PLANEWAVE ------------------------------------------- SELF-CONSISTENT : ------------------------------------------- gemm_algo_selector::Fastest time: 0.03072 ms START CHARGE : atomic DONE(8.17035 SEC) : INIT SCF * * * * * * > Leave SCF iteration. * * * * * * ---------------------------------------------------------------- TOTAL-STRESS (KBAR) ---------------------------------------------------------------- 30.8367522660 -0.0000000000 0.0000000000 0.0000000000 75.4069126649 36.2463263984 0.0000000000 36.2463263984 75.4069126649 ---------------------------------------------------------------- TOTAL-PRESSURE: 60.550193 KBAR TIME STATISTICS ---------------------------------------------------------------------------- CLASS_NAME NAME TIME/s CALLS AVG/s PER/% ---------------------------------------------------------------------------- total 95.57 11 8.69 100.00 Driver reading 0.13 1 0.13 0.14 Input_Conv Convert 0.12 1 0.12 0.12 Driver driver_line 95.43 1 95.43 99.86 UnitCell check_tau 0.00 1 0.00 0.00 ESolver_KS_LCAO before_all_runners 2.02 1 2.02 2.11 PW_Basis_Sup setuptransform 0.29 1 0.29 0.30 PW_Basis_Sup distributeg 0.27 1 0.27 0.28 mymath heapsort 0.09 1097 0.00 0.09 Symmetry analy_sys 0.06 1 0.06 0.06 PW_Basis_K setuptransform 0.02 1 0.02 0.02 PW_Basis_K distributeg 0.01 1 0.01 0.01 PW_Basis setup_struc_factor 1.01 1 1.01 1.06 NOrbital_Lm extra_uniform 0.04 5 0.01 0.04 Mathzone_Add1 SplineD2 0.00 5 0.00 0.00 Mathzone_Add1 Cubic_Spline_Interpolation 0.00 5 0.00 0.00 Mathzone_Add1 Uni_Deriv_Phi 0.04 5 0.01 0.04 ppcell_vl init_vloc 0.04 1 0.04 0.04 Ions opt_ions 93.36 1 93.36 97.69 ESolver_KS_LCAO runner 77.64 1 77.64 81.24 ESolver_KS_LCAO before_scf 6.01 1 6.01 6.29 ESolver_KS_LCAO beforesolver 0.27 1 0.27 0.28 ESolver_KS_LCAO set_matrix_grid 0.19 1 0.19 0.20 atom_arrange search 0.00 1 0.00 0.00 Grid_Technique init 0.13 1 0.13 0.14 Grid_BigCell grid_expansion_index 0.01 2 0.01 0.01 Record_adj for_2d 0.05 1 0.05 0.05 Grid_Driver Find_atom 0.01 1152 0.00 0.01 LCAO_domain grid_prepare 0.00 1 0.00 0.00 Veff initialize_HR 0.01 1 0.01 0.01 OverlapNew initialize_SR 0.01 1 0.01 0.01 EkineticNew initialize_HR 0.00 1 0.00 0.00 NonlocalNew initialize_HR 0.03 1 0.03 0.03 Charge set_rho_core 0.00 1 0.00 0.00 Charge atomic_rho 0.98 2 0.49 1.02 PW_Basis_Sup recip2real 30.81 74 0.42 32.24 PW_Basis_Sup gathers_scatterp 1.36 74 0.02 1.42 Potential init_pot 3.73 1 3.73 3.90 Potential update_from_charge 33.03 10 3.30 34.56 Potential cal_fixed_v 0.42 1 0.42 0.44 PotLocal cal_fixed_v 0.41 1 0.41 0.43 Potential cal_v_eff 32.52 10 3.25 34.03 H_Hartree_pw v_hartree 5.66 10 0.57 5.92 PW_Basis_Sup real2recip 8.21 85 0.10 8.59 PW_Basis_Sup gatherp_scatters 2.45 85 0.03 2.56 PotXC cal_v_eff 26.76 10 2.68 28.00 XC_Functional v_xc 26.71 10 2.67 27.95 Potential interpolate_vrs 0.05 10 0.00 0.05 Symmetry rhog_symmetry 8.67 10 0.87 9.07 Symmetry group fft grids 0.70 10 0.07 0.73 H_Ewald_pw compute_ewald 0.02 1 0.02 0.03 Charge_Mixing init_mixing 0.00 1 0.00 0.00 HSolverLCAO solve 23.39 9 2.60 24.47 HamiltLCAO updateHk 17.12 9 1.90 17.91 OperatorLCAO init 15.90 27 0.59 16.63 Veff contributeHR 11.04 9 1.23 11.55 Gint_interface cal_gint 16.54 19 0.87 17.30 Gint_interface cal_gint_vlocal 10.79 9 1.20 11.29 Gint_k transfer_pvpR 0.25 9 0.03 0.26 OverlapNew calculate_SR 1.18 1 1.18 1.23 OverlapNew contributeHk 0.05 9 0.01 0.05 EkineticNew contributeHR 1.18 9 0.13 1.23 EkineticNew calculate_HR 1.17 1 1.17 1.23 NonlocalNew contributeHR 3.59 9 0.40 3.76 NonlocalNew calculate_HR 3.54 1 3.54 3.71 OperatorLCAO contributeHk 0.05 9 0.01 0.05 HSolverLCAO hamiltSolvePsiK 1.27 9 0.14 1.33 DiagoCusolver cusolver 1.22 9 0.14 1.28 ElecStateLCAO psiToRho 4.99 9 0.55 5.22 elecstate cal_dm 0.26 10 0.03 0.27 psiMulPsiMpi pdgemm 0.25 10 0.03 0.26 DensityMatrix cal_DMR 0.10 10 0.01 0.10 Gint transfer_DMR 0.18 9 0.02 0.19 Gint_interface cal_gint_rho 4.39 9 0.49 4.60 Charge_Mixing get_drho 0.04 9 0.00 0.04 Charge mix_rho 4.85 8 0.61 5.07 Charge Broyden_mixing 0.27 8 0.03 0.29 ESolver_KS_LCAO after_scf 0.75 1 0.75 0.78 ModuleIO write_rhog 0.16 1 0.16 0.17 ESolver_KS_LCAO cal_force 15.72 1 15.72 16.45 Force_Stress_LCAO getForceStress 15.72 1 15.72 16.45 Forces cal_force_loc 0.94 1 0.94 0.99 Forces cal_force_ew 0.77 1 0.77 0.81 Forces cal_force_cc 0.00 1 0.00 0.00 Forces cal_force_scc 1.02 1 1.02 1.06 Stress_Func stress_loc 0.22 1 0.22 0.23 Stress_Func stress_har 0.13 1 0.13 0.14 Stress_Func stress_ewa 0.76 1 0.76 0.79 Stress_Func stress_cc 0.00 1 0.00 0.00 Stress_Func stress_gga 1.74 1 1.74 1.82 Force_LCAO ftable 10.13 1 10.13 10.60 Force_LCAO allocate 5.32 1 5.32 5.56 LCAO_domain build_ST_new 2.55 2 1.28 2.67 LCAO_domain vnl_mu_new 2.67 1 2.67 2.79 Force_LCAO cal_fedm 0.06 1 0.06 0.06 Force_LCAO cal_ftvnl_dphi 0.02 1 0.02 0.03 Force_LCAO cal_fvl_dphi 1.36 1 1.36 1.42 Gint_interface cal_gint_force 1.36 1 1.36 1.42 Force_LCAO cal_fvnl_dbeta 3.37 1 3.37 3.52 ESolver_KS_LCAO cal_stress 0.00 1 0.00 0.00 ESolver_KS_LCAO after_all_runners 0.00 1 0.00 0.00 ModuleIO write_istate_info 0.00 1 0.00 0.00 ---------------------------------------------------------------------------- START Time : Sat Oct 5 19:04:21 2024 FINISH Time : Sat Oct 5 19:05:56 2024 TOTAL Time : 95 SEE INFORMATION IN : OUT.autotest/ 2. CPU 算例和结果 可以看到 GPU 运行用了 95 秒，接下来我们调用 CPU 进行计算，在 INPUT 文件中设置 device 为 cpu，同时设置 ks_solver 为 scalapack_gvx，运行命令 “OMP_NUM_THREADS=12 mpirun -n 2 abacus\", 输出： Info: Local MPI proc number: 2,OpenMP thread number: 12,Total thread number: 24,Local thread limit: 56 ABACUS v3.8.0 Atomic-orbital Based Ab-initio Computation at UStc Website: http://abacus.ustc.edu.cn/ Documentation: https://abacus.deepmodeling.com/ Repository: https://github.com/abacusmodeling/abacus-develop https://github.com/deepmodeling/abacus-develop Commit: 72b1d7ce9 (Sat Oct 5 16:46:53 2024 +0800) Sat Oct 5 19:06:27 2024 MAKE THE DIR : OUT.autotest/ RUNNING WITH DEVICE : CPU / Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz UNIFORM GRID DIM : 192 * 192 * 96 UNIFORM GRID DIM(BIG) : 48 * 48 * 24 DONE(0.274561 SEC) : SETUP UNITCELL DONE(0.330937 SEC) : SYMMETRY DONE(0.411047 SEC) : INIT K-POINTS --------------------------------------------------------- Self-consistent calculations for electrons --------------------------------------------------------- SPIN KPOINTS PROCESSORS NBASE 1 1 2 832 --------------------------------------------------------- Use Systematically Improvable Atomic bases --------------------------------------------------------- ELEMENT ORBITALS NBASE NATOM XC Si 2s2p1d-8au 13 64 --------------------------------------------------------- Initial plane wave basis and FFT box --------------------------------------------------------- DONE(0.438332 SEC) : INIT PLANEWAVE ------------------------------------------- SELF-CONSISTENT : ------------------------------------------- START CHARGE : atomic DONE(7.72282 SEC) : INIT SCF * * * * * * > Leave SCF iteration. * * * * * * ---------------------------------------------------------------- TOTAL-STRESS (KBAR) ---------------------------------------------------------------- 30.8367522660 -0.0000000000 0.0000000000 -0.0000000000 75.4069126649 36.2463263984 0.0000000000 36.2463263984 75.4069126649 ---------------------------------------------------------------- TOTAL-PRESSURE: 60.550193 KBAR TIME STATISTICS ---------------------------------------------------------------------------- CLASS_NAME NAME TIME/s CALLS AVG/s PER/% ---------------------------------------------------------------------------- total 224.00 11 20.36 100.00 Driver reading 0.01 1 0.01 0.01 Input_Conv Convert 0.00 1 0.00 0.00 Driver driver_line 223.99 1 223.99 99.99 UnitCell check_tau 0.00 1 0.00 0.00 ESolver_KS_LCAO before_all_runners 1.75 1 1.75 0.78 PW_Basis_Sup setuptransform 0.03 1 0.03 0.01 PW_Basis_Sup distributeg 0.02 1 0.02 0.01 mymath heapsort 0.09 1097 0.00 0.04 Symmetry analy_sys 0.06 1 0.06 0.03 PW_Basis_K setuptransform 0.02 1 0.02 0.01 PW_Basis_K distributeg 0.01 1 0.01 0.00 PW_Basis setup_struc_factor 1.00 1 1.00 0.45 NOrbital_Lm extra_uniform 0.04 5 0.01 0.02 Mathzone_Add1 SplineD2 0.00 5 0.00 0.00 Mathzone_Add1 Cubic_Spline_Interpolation 0.00 5 0.00 0.00 Mathzone_Add1 Uni_Deriv_Phi 0.04 5 0.01 0.02 ppcell_vl init_vloc 0.04 1 0.04 0.02 Ions opt_ions 222.19 1 222.19 99.19 ESolver_KS_LCAO runner 188.63 1 188.63 84.21 ESolver_KS_LCAO before_scf 5.96 1 5.96 2.66 ESolver_KS_LCAO beforesolver 0.20 1 0.20 0.09 ESolver_KS_LCAO set_matrix_grid 0.13 1 0.13 0.06 atom_arrange search 0.00 1 0.00 0.00 Grid_Technique init 0.07 1 0.07 0.03 Grid_BigCell grid_expansion_index 0.01 2 0.01 0.01 Record_adj for_2d 0.05 1 0.05 0.02 Grid_Driver Find_atom 0.01 1152 0.00 0.00 LCAO_domain grid_prepare 0.00 1 0.00 0.00 Veff initialize_HR 0.01 1 0.01 0.00 OverlapNew initialize_SR 0.01 1 0.01 0.00 EkineticNew initialize_HR 0.00 1 0.00 0.00 NonlocalNew initialize_HR 0.02 1 0.02 0.01 Charge set_rho_core 0.01 1 0.01 0.00 Charge atomic_rho 0.98 2 0.49 0.44 PW_Basis_Sup recip2real 30.88 74 0.42 13.78 PW_Basis_Sup gathers_scatterp 1.37 74 0.02 0.61 Potential init_pot 3.74 1 3.74 1.67 Potential update_from_charge 33.04 10 3.30 14.75 Potential cal_fixed_v 0.41 1 0.41 0.19 PotLocal cal_fixed_v 0.41 1 0.41 0.18 Potential cal_v_eff 32.59 10 3.26 14.55 H_Hartree_pw v_hartree 5.67 10 0.57 2.53 PW_Basis_Sup real2recip 8.18 85 0.10 3.65 PW_Basis_Sup gatherp_scatters 2.45 85 0.03 1.09 PotXC cal_v_eff 26.82 10 2.68 11.97 XC_Functional v_xc 26.78 10 2.68 11.95 Potential interpolate_vrs 0.04 10 0.00 0.02 Symmetry rhog_symmetry 8.58 10 0.86 3.83 Symmetry group fft grids 0.69 10 0.07 0.31 H_Ewald_pw compute_ewald 0.03 1 0.03 0.01 Charge_Mixing init_mixing 0.00 1 0.00 0.00 HSolverLCAO solve 134.43 9 14.94 60.01 HamiltLCAO updateHk 71.31 9 7.92 31.83 OperatorLCAO init 70.08 27 2.60 31.29 Veff contributeHR 65.22 9 7.25 29.12 Gint_interface cal_gint 135.97 19 7.16 60.70 Gint_interface cal_gint_vlocal 64.86 9 7.21 28.95 Gint_Tools cal_psir_ylm 22.23 41472 0.00 9.92 Gint_k transfer_pvpR 0.25 9 0.03 0.11 OverlapNew calculate_SR 1.19 1 1.19 0.53 OverlapNew contributeHk 0.04 9 0.00 0.02 EkineticNew contributeHR 1.19 9 0.13 0.53 EkineticNew calculate_HR 1.18 1 1.18 0.53 NonlocalNew contributeHR 3.59 9 0.40 1.60 NonlocalNew calculate_HR 3.55 1 3.55 1.59 OperatorLCAO contributeHk 0.05 9 0.01 0.02 HSolverLCAO hamiltSolvePsiK 10.78 9 1.20 4.81 DiagoElpa elpa_solve 10.73 9 1.19 4.79 ElecStateLCAO psiToRho 52.34 9 5.82 23.37 elecstate cal_dm 0.16 10 0.02 0.07 psiMulPsiMpi pdgemm 0.16 10 0.02 0.07 DensityMatrix cal_DMR 0.09 10 0.01 0.04 Gint transfer_DMR 0.18 9 0.02 0.08 Gint_interface cal_gint_rho 51.86 9 5.76 23.15 Charge_Mixing get_drho 0.04 9 0.00 0.02 Charge mix_rho 4.86 8 0.61 2.17 Charge Broyden_mixing 0.28 8 0.03 0.12 ESolver_KS_LCAO after_scf 0.74 1 0.74 0.33 ModuleIO write_rhog 0.16 1 0.16 0.07 ESolver_KS_LCAO cal_force 33.57 1 33.57 14.98 Force_Stress_LCAO getForceStress 33.56 1 33.56 14.98 Forces cal_force_loc 0.97 1 0.97 0.44 Forces cal_force_ew 0.77 1 0.77 0.34 Forces cal_force_cc 0.00 1 0.00 0.00 Forces cal_force_scc 1.05 1 1.05 0.47 Stress_Func stress_loc 0.23 1 0.23 0.10 Stress_Func stress_har 0.13 1 0.13 0.06 Stress_Func stress_ewa 0.75 1 0.75 0.34 Stress_Func stress_cc 0.00 1 0.00 0.00 Stress_Func stress_gga 1.76 1 1.76 0.79 Force_LCAO ftable 27.88 1 27.88 12.45 Force_LCAO allocate 5.29 1 5.29 2.36 LCAO_domain build_ST_new 2.55 2 1.28 1.14 LCAO_domain vnl_mu_new 2.65 1 2.65 1.18 Force_LCAO cal_fedm 0.06 1 0.06 0.03 Force_LCAO cal_ftvnl_dphi 0.02 1 0.02 0.01 Force_LCAO cal_fvl_dphi 19.14 1 19.14 8.54 Gint_interface cal_gint_force 19.14 1 19.14 8.54 Gint_Tools cal_dpsir_ylm 6.23 2304 0.00 2.78 Gint_Tools cal_dpsirr_ylm 1.84 2304 0.00 0.82 Force_LCAO cal_fvnl_dbeta 3.36 1 3.36 1.50 ESolver_KS_LCAO cal_stress 0.00 1 0.00 0.00 ESolver_KS_LCAO after_all_runners 0.00 1 0.00 0.00 ModuleIO write_istate_info 0.00 1 0.00 0.00 ---------------------------------------------------------------------------- START Time : Sat Oct 5 19:06:27 2024 FINISH Time : Sat Oct 5 19:10:11 2024 TOTAL Time : 224 SEE INFORMATION IN : OUT.autotest/ 输出中的 “RUNNING WITH DEVICE” 一行标出了此次运算使用的设备，同时运行时间统计里可以看到格点积分以及广义特征值求解的具体耗时，通过这两项耗时可以对比 GPU 和 CPU 的计算效率。格点积分耗时对应 cal_gint, cal_gint_vlocal, cal_gint_rho,cal_gint_force 这几项，广义特征值求解对应 hamiltSolvePsiK 项（在上面输出中标黄项）。 可以看到 GPU 运行用了 95 秒，而同样体系用 CPU 运行用了 224 秒，GPU 对于该体系有一定的加速效果。 以上就是本教程的内容，希望对学习采用 ABACUS 结合 GPU 进行密度泛函理论计算的读者有所帮助，大家也可以在 bohrium 平台按照 ABACUS LCAO 基组 GPU 版本使用介绍 | Bohrium 跑一遍实际安装使用流程，有问题可以发邮箱给作者（见开头）。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-06-12 15:15:37 "},"abacus-hpc.html":{"url":"abacus-hpc.html","title":"在超算环境编译 ABACUS 的建议","keywords":"","body":"在超算环境编译 ABACUS 的建议 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/26 由于不同超算环境提供的软件包版本各不相同，因此我们没办法提供给您确切的安装方法。 但是，我们将在本篇文档中介绍一些在超算环境中编译安装 ABACUS 的注意事项和相关知识。 如果在具体编译操作过程中遇到了任何问题，请随时联系我们。 一、关于 ABACUS 首先，再次简单介绍一下 ABACUS。ABACUS（原子算筹）软件同时支持两种基矢量，一种是平面波（Plane wave，PW） 基组，一种是 LCAO (Linear combination of atomic orbitals) 或者称 NAO (Numerical atomic orbitals) 基组。 用户可以编译 仅支持 PW 基组的 ABACUS 或者 同时支持两种基组的 ABACUS。同时，针对 PW 基组的 ABACUS，用户还可以选择编译串行版本或并行版本。但因为这个文档的主题是如何在超算环境中编译 ABACUS（应该没有人在超算上跑串行的 ABACUS 吧），我们接下来只会介绍并行版本的编译方法。如果想要在普通的服务器上安装串行版本的 PW 基组的 ABACUS，可以参考 GCC 编译 ABACUS 教程 · GitBook 和 Intel oneAPI 编译 ABACUS 教程 · GitBook。 二、超算平台的简单介绍： 1. 关于 Modules 一般情况下，大多数超算平台是通过 Environment Modules 来管理基础软件库的。 如何使用 Modules？这里提供一些参考的教程：软件模块使用方法 - 上海交大超算平台用户手册 Documentation 2. 超算上编译 ABACUS 的基本路线 在超算平台上编译 ABACUS，同样也有两种选择： 一种是 基于 GCC（the GNU Compiler Collection）编译 一种是 基于 Intel oneAPI 或者 Intel Parallel Studio 编译 不得不说，使用 Intel oneAPI 将会简单很多！因此，如果你所使用的超算平台正好有 Intel oneAPI ，那么请毫不犹豫的使用它！ 2.1 ABACUS 依赖的软件库 C/C++ 编译器：由于 ABACUS 是由 C++ 语言编写的软件，所以一定需要 C++ 编译器。 Fortran 编译器：Fortran 编译器并不直接用于编译 ABACUS 软件，而是需要用其编译 ABACUS 所依赖的数学库：BLAS、LAPACK、ScaLAPACK 和 ELPA。（这四个软件都是使用 Fortran 语言写的，因此需要依赖 Fortran 编译器） MPI 库：如果要编译并行版本的 ABACUS，那么 MPI Library 是必须的。同时也需要注意，如果你选择自己编译 ScaLAPACK 和 ELPA，那么 MPI Library 也是必须的。 数学库： BLAS：BLAS（Basic Linear Algebra Subprograms）是一组基本的线性代数库，用于高效执行常见的基础线性代数运算，如矩阵乘法和向量操作。 LAPACK：LAPACK（Linear Algebra Package）是一个开源的数值线性代数库，用于解决线性代数问题，包括矩阵分解、方程组求解和特征值计算等。 FFTW3：FFTW3（Fastest Fourier Transform in the West 3）是一个高性能、开源的快速傅里叶变换（FFT）库，用于高效计算各种傅里叶变换和逆变换。 ScaLAPACK：ScaLAPACK（Scalable LAPACK）是一种并行计算库，构建在 LAPACK 之上，用于解决大规模线性代数问题，特别适用于分布式和并行计算环境。 ELPA：ELPA（Eigenvalue SoLvers for Petaflop-Applications）是一个用于高性能计算的开源库，旨在解决大规模高性能计算中的特征值问题，特别是密集矩阵的特征值问题。（用户编译安装 abacus 的时候大多在这里出现问题） CEREAL：CEREAL 是一个 C++ 序列化库，用于将 C++ 对象转换为可存储或传输的数据格式，以及将其反序列化回对象。 如果你只编译 仅支持 PW 基组的 ABACUS，那么你不需要安装 ScaLAPACK、ELPA 和 CEREAL。他们是 LCAO 基组才依赖的软件库。 2.2 基于 Intel oneAPI 编译 ABACUS 首先在此介绍一下 Intel oneAPI 和 Intel Parallel Studio 的区别。用户可能在超算平台上同时看到 Intel oneAPI 和 Intel Parallel Studio。这是因为 Intel Parallel Studio 是 oneAPI 的前身，或者说 Intel Parallel Studio 是 oneAPI 的子集。Intel Parallel Studio 在 2020 年已经停止维护，而 Intel oneAPI 却是在 2019 年 11 月正式提出。因此我们可以将 Intel oneAPI 看作是 新版的 Parallel Studio 或加强版。 Intel oneAPI（Intel® oneAPI Toolkits）同时包含 C/C++ 编译器、 Fortran 编译器 和 Intel MPI Library。因此如果加载了 Intel oneAPI 环境，也就不用再次加载其他的 MPI Library。除此之外，Intel oneAPI 还包含了 Intel® oneAPI Math Kernel Library（简称为 MKL），这个软件库里面包含了大量常用的数学库，包括 ABACUS 依赖的 BLAS、LAPACK、FFTW3 和 ScaLAPACK 4 个软件库。 因此，如果你只编译 支持 PW 基组的 ABACUS，那么 Intel oneAPI 就已经可以解决所有的依赖问题。 如果你要编译 同时支持两种基组的 ABACUS，那么还需要手动编译安装 ELPA 和 CEREAL，安装完成后，可以参考官方文档中的 ABACUS-Installation-Options 编译 ABACUS。 注意： 在使用 Intel oneAPI 编译 ABACUS 的时候，并不意味着软件环境中不需要 GCC。 refer：How the Compiler Uses GCC Intel compilers 需要使用 GCC 中的头文件和库。因此同时也需要加载 GCC。 2.3 基于 GCC 编译 ABACUS GCC（the GNU Compiler Collection）它同时包含 C/C++ 编译器和 Fortran 编译器，但其不包含 MPI Library。因此我们还需要额外的 MPI 库（Open MPI 或者 MPICH）。 由于这是基于 GCC 编译 ABACUS，如果用户所使用的超算环境中没有提供 BLAS、LAPACK、FFTW3、ScaLAPACK、ELPA 和 CEREAL 的 modules，那么这些数学库都需要用户一个个手动编译安装。 在安装完成后，可以参考官方文档中的 ABACUS-Installation-Options 编译 ABACUS。 三、拓展教程 1. ABACUS 高级编译选择： Easy Installation ‒ ABACUS documentation Advanced Installation Options ‒ ABACUS documentation 2. 超算平台使用教程推荐： 上海交大超算平台用户手册 中国科大超算中心用户使用手册 北大超算手册 超算小站 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-dcu.html":{"url":"abacus-dcu.html","title":"ABACUS 在曙光 DCU 集群上的编译与使用","keywords":"","body":"ABACUS 在曙光 DCU 集群上的编译与使用 作者：贾志炜，邮箱：jiazhiwei@stu.pku.edu.cn 审核：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 最后更新时间：2023/07/07 一、介绍 本教程旨在介绍 ABACUS 在 曙光 DCU 计算平台 上的编译与使用。 1. DCU DCU (Deep Computing Unit) 是一款面向人工智能、科学计算的高性能全功能 GPGPU (General-Purpose computing on Graphics Processing Units) 加速卡。 中科海光基于 DCU 硬件提供完整的软件工具链，以 DTK(DCU toolkit)为基础软件层为开发者提供运行、编译、调试和性能分析等功能，并提供多种深度优化的计算加速库。DCU 加速卡支持 ROCm/Hip 并行架构。 曙光计算集群采用 CPU 和 DCU 加速卡（Deep Computing Unit）相结合的异构融合计算体系结构。 2. ABACUS 的异构并行计算 INPUT 文件中 device 参数需设置为 gpu。 目前 GPU/DCU 版本的 ABACUS 仅支持 PW 基组的计算，因此 INPUT 文件中 basis_type 参数仅能设置为 pw。 二、准备 1. 曙光计算平台 用户需要在平台上申请异构计算资源： https://ac.sugon.com/doc/1.0.6/30000/general-handbook/platform/source.html 2. E-shell 曙光计算平台采用 E-shell 来对管理节点进行操作。 可使用网页版或 E-Shell Client。 不可直接运行任务，而是使用 Slurm 调度系统。 采用 modules 工具 来管理环境变量与系统依赖项。许多依赖如编译器版本等可以通过 modules 来处理。 3. slurm Slurm 工作调度工具是面向 Linux 和 Unix 及类似内核的免费和开源工作调度程序，可以方便用户进行作业的提交、管理、监测。 sinfo: 查看系统资源。 squeue: 查看当前作业状态。 salloc: 分配节点的作业提交，用 salloc 申请的节点会在当前终端退出时释放掉。用于程序测试以及中小型任务的提交。 sbatch: 批处理模式的作业提交，需要编写 slurm 作业提交脚本。在 E-shell 的默认目录存有 slurm 脚本模板。在下面的流程中也会介绍提交 ABACUS 任务的脚本案例。 srun: 交互式提交作业命令，有屏幕输出，但容易受网络波动影响，断网或关闭窗口会导致作业中断。 三、流程 1. 配置超算环境 module avail # 列出已有环境 module list # 查看当前已加载环境 module load # 加载环境 module unload # 卸载环境 昆山节点 module purge 1) compiler/devtoolset/7.3.1 2) compiler/rocm/dtk-22.10 3) compiler/cmake/3.17.2 4) mpi/hpcx/2.6.0/gcc-7.3.1 乌镇节点 1) compiler/devtoolset/7.3.1 2) compiler/dtk/23.04 3) compiler/cmake/3.23.1 4) mpi/hpcx/gcc-7.3.1 对于使用其他 DCU 节点（合肥、哈尔滨、西安）的用户，如果 module 中没有找到类似的环境，欢迎在 ABACUS 仓库 提出 issue，我们将尽力协助解决。 2. 编译 ABACUS 依赖软件包 目前按照 DCU 版本已验证的编译方法，有三个数学库需要自行编译。 若曙光平台网络连接不畅，请在软件官网选择合适的软件包，再用曙光平台的 E-File 传送至节点。 FFTW: https://fftw.org/pub/fftw/fftw-3.3.10.tar.gz OpenBLAS: https://github.com/xianyi/OpenBLAS/releases/download/v0.3.21/OpenBLAS-0.3.21.tar.gz ScaLAPACK: https://github.com/Reference-ScaLAPACK/scalapack/archive/refs/tags/v2.2.0.tar.gz 2.1 编译 FFTW tar -zxvf fftw-3.3.10.tar.gz mkdir build ./configure --prefix=/work/home/your_username/fftw-3.3.10/build cd ~/fftw-3.3.10/build make make install FFTW 需要编译单精度版本和双精度版本： cd ~/fftw-3.3.10/build ./configure --prefix=/work/home/your_username/fftw-3.3.10/build --enable-float make make install 2.2 编译 OpenBLAS tar -zxvf OpenBLAS-0.3.23.tar.gz cd OpenBLAS-0.3.23 make USE_OPENMP=1 NO_AVX512=1 FC=\"gfortran -fPIC\" CC=\"gcc -fPIC\" -j8 mkdir build make PREFIX=/work/home/your_username/OpenBLAS-0.3.21/build install 2.3 编译 ScaLAPACK cp SLmake.inc.example SLmake.inc 复制包中提供的 SLmake.inc.example 作为基准，并对 SLmake.inc 的内容作出一部分修改: FC = mpif90 -fPIC CC = mpicc -fPIC BLASLIB = LAPACKLIB = -L/work/home/your_username/OpenBLAS-0.3.21/build/lib -lopenblas make 3. 编译 DCU 版本的 ABACUS git clone https://gitee.com/deepmodeling/abacus-develop # main分支 cd abacus-develop mkdir build cd build CMake 配置： 指定编译器为 clang，关闭 OpenMP、LCAO 计算模块，设定三个数学库的位置，设定 USE_ROCM=ON。 CC=clang CXX=clang++ cmake -B build -DUSE_OPENMP=OFF -DENABLE_LCAO=OFF \\ -DFFTW3_DIR=/work/home/your_username/fftw-3.3.10/build/ \\ -DLAPACK_DIR=/work/home/your_username/OpenBLAS-0.3.21/build/lib \\ -DSCALAPACK_DIR=/work/home/your_username/scalapack-2.2.0/ \\ -DUSE_ROCM=ON Make 编译：make 部分建议不要并行编译。 make 4. 提交任务 salloc（中小型任务与交互性程序测试） salloc -p [队列名] -N 1 -n 32 --gres=dcu:4 ... load text ... salloc: Waiting for resource configuration salloc: Nodes node_num are ready for job # 分配计算节点，可用ssh直接连接 ssh node_num ...交互式进行计算任务 sbatch（大型任务与批量提交） 写一个作业提交脚本，可以参考以下结构： #!/bin/bash #SBATCH --job-name=ABACUS_GPU #SBATCH --partition=kshdnormal #SBATCH --nodes=1 #SBATCH --output=output.log #SBATCH --ntasks-per-node=32 #SBATCH --mail-user=username@email #SBATCH --gres=dcu:4 #dcu个数 #SBATCH --time=01:00:00 #SBATCH --error=error.log #以上的SBATCH信息会由slurm识别 abacus=/work/home/your_username/abacus-develop/build/abacus_pw #设置环境 module purge module load compiler/devtoolset/7.3.1 module load compiler/rocm/dtk-22.10 module load compiler/cmake/3.17.2 module load mpi/hpcx/2.11.0/gcc-7.3.1 #运行脚本 cd your_task_path mpirun -np 4 $abacus sbatch abacus_dcu.slurm 作业已提交，可在“作业管理”中查看。 四、结语 DCU 可以提高 ABACUS 计算性能，也充分利用了 ROCm 并行框架，使得 ABACUS 异构计算能应用在更多的平台上。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-eff1.html":{"url":"abacus-eff1.html","title":"ABACUS 如何选择晶胞朝向获得最佳并行效率？以碳纳米管为例","keywords":"","body":"ABACUS 如何选择晶胞朝向获得最佳并行效率？以碳纳米管为例 作者：谢炘玥，邮箱：xyxie@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2025/02/18 一、背景 不少用户会问当准备的 ABACUS 算例在 XYZ 三个方向的大小不一致时，摆放晶胞会不会对结果产生影响？如果会影响，应该怎么选取摆放的方向？相关的 Github Issue 有：https://github.com/deepmodeling/abacus-develop/issues/3015。为此，我们这里给了一个包含 1000 个碳原子的一维碳纳米管的测试。算例来自：https://github.com/MCresearch/TEAS/tree/main/2022-PRB-CNT/1_DHU/0.01。下面我们分别将真空方向设置为 X、Y、Z 方向，比较计算结果能量和时间来判断真空方向对计算的影响。 二、ABACUS 做不同真空方向计算的流程 本文算例的碳纳米管在一个方向的长度明显大于另外两个方向，我们会采用原子弛豫计算(ABACUS 中设置 calculation 为 relax，只让原子移动而固定晶格常数)。改变真空层的方向通过对 STRU 和 KPT 文件的三列进行轮换实现。我们先来看看为 ABACUS 计算准备的 INPUT 和 KPT 输入文件。 1. INPUT 文件 需要注意的是，上文给出的算例链接中的 INPUT 文件参数属于 ABACUS 老版本，下面已更新为 v3.8.0 的参数名称，输入参数关键词可以参考：Full List of INPUT Keywords # INPUT_PARAMETERS #Parameters (1.General) suffix CNT_0.01 calculation relax nbands 2100 symmetry 0 #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 400 #Parameters (3.Basis) basis_type lcao ks_solver genelpa gamma_only 1 #Parameters (4.Smearing) smearing_method gaussian smearing_sigma 0.001 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.1 mixing_ndim 20 cal_force 1 cal_stress 1 relax_nmax 1000 force_thr_ev 0.04 #move_method cg out_stru 1 2. KPT 文件 K_POINTS 0 Gamma 1 1 1 0 0 0 碳纳米管三个方向长度都较大，因此选择了 Gamma 点计算。 3. STRU 文件 一共有 1000 个 C 原子，STRU 文件较长所以不在此处展示，可以在 https://github.com/MCresearch/TEAS/blob/main/2022-PRB-CNT/1_DHU/0.01/STRU 中查看，结构如下图。 我们一起看看 STRU 文件中的 LATTICE_VECTORS，这是一个 3×3 矩阵，代表我们所计算体系在 X，Y，Z 三个方向上的晶格矢量大小，还要注意晶格矢量由 LATTICE_CONSTANT（晶格常数）进行缩放，此处晶格常数为 1 Bohr。可以参考：https://abacus.deepmodeling.com/en/latest/advanced/input_files/stru.html#lattice-vectors LATTICE_CONSTANT 1 LATTICE_VECTORS 32.1253418058417 0.00000000000000 0.000000000000000 0.00000000000000 34.0150677944206 0.000000000000000 0.00000000000000 0.00000000000000 202.0428810989945 可以观察到此时位于矩阵(3,3)的元素值远大于(1,1)和(2,2)处的值，即此时长边在 Z 方向。我们要做的就是把长边分别放在不同的方向进行计算，比较效率。 放在 X 方向时： LATTICE_CONSTANT 1 LATTICE_VECTORS 202.0428810989945 0.00000000000000 0.00000000000000 0.000000000000000 32.1253418058417 0.00000000000000 0.000000000000000 0.00000000000000 34.0150677944206 放在 Y 方向时： LATTICE_CONSTANT 1 LATTICE_VECTORS 34.0150677944206 0.000000000000000 0.00000000000000 0.00000000000000 202.0428810989945 0.00000000000000 0.00000000000000 0.000000000000000 32.1253418058417 原子坐标的轮换也是相同的规则。 由于布里渊区的 K 点采样选择了 Gamma 点，故 KPT 文件轮换后结果不改变，测试中只轮换了 STRU 文件中的晶格矢量(LATTICE_VECTORS)和原子坐标(ATOMIC_POSITIONS)两部分来改变晶胞摆放。如果读者在做其他需要变换真空层方向的计算时，千万不要忘记当晶格矢量方向改变时，K 点也要改变！ 三、测试结果 我们选择了 64 个型号为 8426Y+ 的 CPU 用 64 个进程对该一维碳纳米管结构进行结构弛豫。下表给出本次测试的总能量，将碳纳米管摆放在 XYZ 三个方向下做结构弛豫的步数都是 212 步。我们通过比较总能量和时间差异来判断真空层方向对计算结果的影响，可以看到系统总能量并不会受到不同碳纳米管取向的影响，但计算时间会受到显著影响。虽然，但是真空层摆放在 X 方向时，计算时间明显慢于摆放在 Z 方向，每一电子步大概慢 8s 左右。 碳纳米管长边朝向 CPU 型号 CPU 个数进程个数 系统总能量 (eV) 计算总时间 (s) 计算总弛豫步数 运行一电子步的时间 (s) FFT UNIFORM GRID DIM(BIG) X 8462Y+ 64 核 64 进程 -154919.0390601 64114 212 18~18.6 1296*216*225 324*54* 45 Y 8462Y+ 64 核 64 进程 -154919.0390599 56846 212 15.5~16 225*1296*216 45*324*54 Z 8462Y+ 64 核 64 进程 -154919.0390613 40630 212 10~10.5 216*225*1296 54*45*432 根据以上测试结果，建议读者们在进行真空层计算时，将碳纳米管的长边摆放在 Z 方向以获得 ABACUS 计算时的最大效率。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-eff2.html":{"url":"abacus-eff2.html","title":"ABACUS 如何选择晶胞朝向获得最佳并行效率？以二维氮化硼为例","keywords":"","body":"ABACUS 如何选择晶胞朝向获得最佳并行效率？以二维氮化硼为例 作者：谢炘玥，邮箱：xyxie@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2025/03/04 一、背景 我们已经测试过了一维材料的长边分别摆放在 XYZ 三个方向时，对计算效率的影响，并通过测试结果给出了建议，参考 ABACUS 如何选择晶胞朝向获得最佳并行效率?以碳纳米管为例 · GitBook。现在我们考虑一个二维六方氮化硼体系，即材料在两个方向的长度明显大于第三个方向。 下面我们分别将短边摆放在 X、Y、Z 方向，比较计算结果能量和时间来判断短边摆放方式对计算的影响。 二、ABACUS 计算的流程 本文算例的氮化硼在一个方向的长度明显小于另外两个方向，我们采用原子弛豫计算(ABACUS 中设置 calculation 为 relax，只让原子移动而固定晶格常数)。同样，通过对 STRU 和 KPT 文件的三列进行轮换改变摆放方式。我们先来看看为 ABACUS 计算准备的 INPUT 、STRU 和 KPT 三个输入文件。 1. INPUT 文件 可以注意到，在本次计算中，我们使用了 kspacing 这个参数（Full List of INPUT Keywords — ABACUS documentation），可以根据晶胞大小自动生成 KPT 文件。因此不再需要我们手动调换 K 点的顺序。 INPUT_PARAMETERS suffix BN pseudo_dir ./ orbital_dir ./ calculation cell-relax symmetry 0 basis_type lcao ecutwfc 100 scf_thr 1e-07 scf_nmax 100 smearing_method gauss smearing_sigma 0.002 mixing_type pulay mixing_beta 0.3 cal_force 1 cal_stress 1 force_thr_ev 0.01 stress_thr 0.5 relax_nmax 100 out_stru 1 kspacing 0.08 2. STRU 文件 在本体系中，B 和 N 原子各有 96 个，h-BN 结构图如下。 可以发现，此时短边在晶胞的 X 方向上。 ATOMIC_SPECIES B 10.81 B_ONCV_PBE-1.0.upf N 14.007 N_ONCV_PBE-1.0.upf NUMERICAL_ORBITAL B_gga_8au_100Ry_2s2p1d.orb N_gga_8au_100Ry_2s2p1d.orb LATTICE_CONSTANT 1.8897261258369282 LATTICE_VECTORS 2.6665300000 0.0000000000 0.0000000000 0.0000000000 16.970664000 0.0000000000 0.0000000000 0.0000000000 28.020088000 ATOMIC_POSITIONS Direct B 0.0000000000 96 0.0000000000 0.0126740000 0.0000000000 1 1 1 mag 0.0 0.5000000000 0.0189860000 0.0768190000 1 1 1 mag 0.0 0.0000000000 0.1439860000 0.0481810000 1 1 1 mag 0.0 0.5000000000 0.1376740000 0.1250000000 1 1 1 mag 0.0 0.0000000000 0.1439860000 0.2018190000 1 1 1 mag 0.0 0.5000000000 0.0189860000 0.1731810000 1 1 1 mag 0.0 0.0000000000 0.2626740000 0.0000000000 1 1 1 mag 0.0 0.5000000000 0.2689860000 0.0768190000 1 1 1 mag 0.0 0.0000000000 0.3939860000 0.0481810000 1 1 1 mag 0.0 0.5000000000 0.3876740000 0.1250000000 1 1 1 mag 0.0 0.0000000000 0.3939860000 0.2018190000 1 1 1 mag 0.0 0.5000000000 0.2689860000 0.1731810000 1 1 1 mag 0.0 0.0000000000 0.5126740000 0.0000000000 1 1 1 mag 0.0 0.5000000000 0.5189860000 0.0768190000 1 1 1 mag 0.0 0.0000000000 0.6439860000 0.0481810000 1 1 1 mag 0.0 0.5000000000 0.6376740000 0.1250000000 1 1 1 mag 0.0 0.0000000000 0.6439860000 0.2018190000 1 1 1 mag 0.0 0.5000000000 0.5189860000 0.1731810000 1 1 1 mag 0.0 0.0000000000 0.7626740000 0.0000000000 1 1 1 mag 0.0 0.5000000000 0.7689860000 0.0768190000 1 1 1 mag 0.0 0.0000000000 0.8939860000 0.0481810000 1 1 1 mag 0.0 0.5000000000 0.8876740000 0.1250000000 1 1 1 mag 0.0 0.0000000000 0.8939860000 0.2018190000 1 1 1 mag 0.0 0.5000000000 0.7689860000 0.1731810000 1 1 1 mag 0.0 0.0000000000 0.0126740000 0.2500000000 1 1 1 mag 0.0 0.5000000000 0.0189860000 0.3268190000 1 1 1 mag 0.0 0.0000000000 0.1439860000 0.2981810000 1 1 1 mag 0.0 0.5000000000 0.1376740000 0.3750000000 1 1 1 mag 0.0 0.0000000000 0.1439860000 0.4518190000 1 1 1 mag 0.0 0.5000000000 0.0189860000 0.4231810000 1 1 1 mag 0.0 0.0000000000 0.2626740000 0.2500000000 1 1 1 mag 0.0 0.5000000000 0.2689860000 0.3268190000 1 1 1 mag 0.0 0.0000000000 0.3939860000 0.2981810000 1 1 1 mag 0.0 0.5000000000 0.3876740000 0.3750000000 1 1 1 mag 0.0 0.0000000000 0.3939860000 0.4518190000 1 1 1 mag 0.0 0.5000000000 0.2689860000 0.4231810000 1 1 1 mag 0.0 0.0000000000 0.5126740000 0.2500000000 1 1 1 mag 0.0 0.5000000000 0.5189860000 0.3268190000 1 1 1 mag 0.0 0.0000000000 0.6439860000 0.2981810000 1 1 1 mag 0.0 0.5000000000 0.6376740000 0.3750000000 1 1 1 mag 0.0 0.0000000000 0.6439860000 0.4518190000 1 1 1 mag 0.0 0.5000000000 0.5189860000 0.4231810000 1 1 1 mag 0.0 0.0000000000 0.7626740000 0.2500000000 1 1 1 mag 0.0 0.5000000000 0.7689860000 0.3268190000 1 1 1 mag 0.0 0.0000000000 0.8939860000 0.2981810000 1 1 1 mag 0.0 0.5000000000 0.8876740000 0.3750000000 1 1 1 mag 0.0 0.0000000000 0.8939860000 0.4518190000 1 1 1 mag 0.0 0.5000000000 0.7689860000 0.4231810000 1 1 1 mag 0.0 0.0000000000 0.0126740000 0.5000000000 1 1 1 mag 0.0 0.5000000000 0.0189860000 0.5768190000 1 1 1 mag 0.0 0.0000000000 0.1439860000 0.5481810000 1 1 1 mag 0.0 0.5000000000 0.1376740000 0.6250000000 1 1 1 mag 0.0 0.0000000000 0.1439860000 0.7018190000 1 1 1 mag 0.0 0.5000000000 0.0189860000 0.6731810000 1 1 1 mag 0.0 0.0000000000 0.2626740000 0.5000000000 1 1 1 mag 0.0 0.5000000000 0.2689860000 0.5768190000 1 1 1 mag 0.0 0.0000000000 0.3939860000 0.5481810000 1 1 1 mag 0.0 0.5000000000 0.3876740000 0.6250000000 1 1 1 mag 0.0 0.0000000000 0.3939860000 0.7018190000 1 1 1 mag 0.0 0.5000000000 0.2689860000 0.6731810000 1 1 1 mag 0.0 0.0000000000 0.5126740000 0.5000000000 1 1 1 mag 0.0 0.5000000000 0.5189860000 0.5768190000 1 1 1 mag 0.0 0.0000000000 0.6439860000 0.5481810000 1 1 1 mag 0.0 0.5000000000 0.6376740000 0.6250000000 1 1 1 mag 0.0 0.0000000000 0.6439860000 0.7018190000 1 1 1 mag 0.0 0.5000000000 0.5189860000 0.6731810000 1 1 1 mag 0.0 0.0000000000 0.7626740000 0.5000000000 1 1 1 mag 0.0 0.5000000000 0.7689860000 0.5768190000 1 1 1 mag 0.0 0.0000000000 0.8939860000 0.5481810000 1 1 1 mag 0.0 0.5000000000 0.8876740000 0.6250000000 1 1 1 mag 0.0 0.0000000000 0.8939860000 0.7018190000 1 1 1 mag 0.0 0.5000000000 0.7689860000 0.6731810000 1 1 1 mag 0.0 0.0000000000 0.0126740000 0.7500000000 1 1 1 mag 0.0 0.5000000000 0.0189860000 0.8268190000 1 1 1 mag 0.0 0.0000000000 0.1439860000 0.7981810000 1 1 1 mag 0.0 0.5000000000 0.1376740000 0.8750000000 1 1 1 mag 0.0 0.0000000000 0.1439860000 0.9518190000 1 1 1 mag 0.0 0.5000000000 0.0189860000 0.9231810000 1 1 1 mag 0.0 0.0000000000 0.2626740000 0.7500000000 1 1 1 mag 0.0 0.5000000000 0.2689860000 0.8268190000 1 1 1 mag 0.0 0.0000000000 0.3939860000 0.7981810000 1 1 1 mag 0.0 0.5000000000 0.3876740000 0.8750000000 1 1 1 mag 0.0 0.0000000000 0.3939860000 0.9518190000 1 1 1 mag 0.0 0.5000000000 0.2689860000 0.9231810000 1 1 1 mag 0.0 0.0000000000 0.5126740000 0.7500000000 1 1 1 mag 0.0 0.5000000000 0.5189860000 0.8268190000 1 1 1 mag 0.0 0.0000000000 0.6439860000 0.7981810000 1 1 1 mag 0.0 0.5000000000 0.6376740000 0.8750000000 1 1 1 mag 0.0 0.0000000000 0.6439860000 0.9518190000 1 1 1 mag 0.0 0.5000000000 0.5189860000 0.9231810000 1 1 1 mag 0.0 0.0000000000 0.7626740000 0.7500000000 1 1 1 mag 0.0 0.5000000000 0.7689860000 0.8268190000 1 1 1 mag 0.0 0.0000000000 0.8939860000 0.7981810000 1 1 1 mag 0.0 0.5000000000 0.8876740000 0.8750000000 1 1 1 mag 0.0 0.0000000000 0.8939860000 0.9518190000 1 1 1 mag 0.0 0.5000000000 0.7689860000 0.9231810000 1 1 1 mag 0.0 N 0.0000000000 96 0.0000000000 0.0518080000 0.0478800000 1 1 1 mag 0.0 0.5000000000 0.1768080000 0.0771200000 1 1 1 mag 0.0 0.0000000000 0.1807370000 0.0000000000 1 1 1 mag 0.0 0.5000000000 0.1768080000 0.1728800000 1 1 1 mag 0.0 0.0000000000 0.0518080000 0.2021200000 1 1 1 mag 0.0 0.5000000000 0.0557370000 0.1250000000 1 1 1 mag 0.0 0.0000000000 0.3018080000 0.0478800000 1 1 1 mag 0.0 0.5000000000 0.4268080000 0.0771200000 1 1 1 mag 0.0 0.0000000000 0.4307370000 0.0000000000 1 1 1 mag 0.0 0.5000000000 0.4268080000 0.1728800000 1 1 1 mag 0.0 0.0000000000 0.3018080000 0.2021200000 1 1 1 mag 0.0 0.5000000000 0.3057370000 0.1250000000 1 1 1 mag 0.0 0.0000000000 0.5518080000 0.0478800000 1 1 1 mag 0.0 0.5000000000 0.6768080000 0.0771200000 1 1 1 mag 0.0 0.0000000000 0.6807370000 0.0000000000 1 1 1 mag 0.0 0.5000000000 0.6768080000 0.1728800000 1 1 1 mag 0.0 0.0000000000 0.5518080000 0.2021200000 1 1 1 mag 0.0 0.5000000000 0.5557370000 0.1250000000 1 1 1 mag 0.0 0.0000000000 0.8018080000 0.0478800000 1 1 1 mag 0.0 0.5000000000 0.9268080000 0.0771200000 1 1 1 mag 0.0 0.0000000000 0.9307370000 0.0000000000 1 1 1 mag 0.0 0.5000000000 0.9268080000 0.1728800000 1 1 1 mag 0.0 0.0000000000 0.8018080000 0.2021200000 1 1 1 mag 0.0 0.5000000000 0.8057370000 0.1250000000 1 1 1 mag 0.0 0.0000000000 0.0518080000 0.2978800000 1 1 1 mag 0.0 0.5000000000 0.1768080000 0.3271200000 1 1 1 mag 0.0 0.0000000000 0.1807370000 0.2500000000 1 1 1 mag 0.0 0.5000000000 0.1768080000 0.4228800000 1 1 1 mag 0.0 0.0000000000 0.0518080000 0.4521200000 1 1 1 mag 0.0 0.5000000000 0.0557370000 0.3750000000 1 1 1 mag 0.0 0.0000000000 0.3018080000 0.2978800000 1 1 1 mag 0.0 0.5000000000 0.4268080000 0.3271200000 1 1 1 mag 0.0 0.0000000000 0.4307370000 0.2500000000 1 1 1 mag 0.0 0.5000000000 0.4268080000 0.4228800000 1 1 1 mag 0.0 0.0000000000 0.3018080000 0.4521200000 1 1 1 mag 0.0 0.5000000000 0.3057370000 0.3750000000 1 1 1 mag 0.0 0.0000000000 0.5518080000 0.2978800000 1 1 1 mag 0.0 0.5000000000 0.6768080000 0.3271200000 1 1 1 mag 0.0 0.0000000000 0.6807370000 0.2500000000 1 1 1 mag 0.0 0.5000000000 0.6768080000 0.4228800000 1 1 1 mag 0.0 0.0000000000 0.5518080000 0.4521200000 1 1 1 mag 0.0 0.5000000000 0.5557370000 0.3750000000 1 1 1 mag 0.0 0.0000000000 0.8018080000 0.2978800000 1 1 1 mag 0.0 0.5000000000 0.9268080000 0.3271200000 1 1 1 mag 0.0 0.0000000000 0.9307370000 0.2500000000 1 1 1 mag 0.0 0.5000000000 0.9268080000 0.4228800000 1 1 1 mag 0.0 0.0000000000 0.8018080000 0.4521200000 1 1 1 mag 0.0 0.5000000000 0.8057370000 0.3750000000 1 1 1 mag 0.0 0.0000000000 0.0518080000 0.5478800000 1 1 1 mag 0.0 0.5000000000 0.1768080000 0.5771200000 1 1 1 mag 0.0 0.0000000000 0.1807370000 0.5000000000 1 1 1 mag 0.0 0.5000000000 0.1768080000 0.6728800000 1 1 1 mag 0.0 0.0000000000 0.0518080000 0.7021200000 1 1 1 mag 0.0 0.5000000000 0.0557370000 0.6250000000 1 1 1 mag 0.0 0.0000000000 0.3018080000 0.5478800000 1 1 1 mag 0.0 0.5000000000 0.4268080000 0.5771200000 1 1 1 mag 0.0 0.0000000000 0.4307370000 0.5000000000 1 1 1 mag 0.0 0.5000000000 0.4268080000 0.6728800000 1 1 1 mag 0.0 0.0000000000 0.3018080000 0.7021200000 1 1 1 mag 0.0 0.5000000000 0.3057370000 0.6250000000 1 1 1 mag 0.0 0.0000000000 0.5518080000 0.5478800000 1 1 1 mag 0.0 0.5000000000 0.6768080000 0.5771200000 1 1 1 mag 0.0 0.0000000000 0.6807370000 0.5000000000 1 1 1 mag 0.0 0.5000000000 0.6768080000 0.6728800000 1 1 1 mag 0.0 0.0000000000 0.5518080000 0.7021200000 1 1 1 mag 0.0 0.5000000000 0.5557370000 0.6250000000 1 1 1 mag 0.0 0.0000000000 0.8018080000 0.5478800000 1 1 1 mag 0.0 0.5000000000 0.9268080000 0.5771200000 1 1 1 mag 0.0 0.0000000000 0.9307370000 0.5000000000 1 1 1 mag 0.0 0.5000000000 0.9268080000 0.6728800000 1 1 1 mag 0.0 0.0000000000 0.8018080000 0.7021200000 1 1 1 mag 0.0 0.5000000000 0.8057370000 0.6250000000 1 1 1 mag 0.0 0.0000000000 0.0518080000 0.7978800000 1 1 1 mag 0.0 0.5000000000 0.1768080000 0.8271200000 1 1 1 mag 0.0 0.0000000000 0.1807370000 0.7500000000 1 1 1 mag 0.0 0.5000000000 0.1768080000 0.9228800000 1 1 1 mag 0.0 0.0000000000 0.0518080000 0.9521200000 1 1 1 mag 0.0 0.5000000000 0.0557370000 0.8750000000 1 1 1 mag 0.0 0.0000000000 0.3018080000 0.7978800000 1 1 1 mag 0.0 0.5000000000 0.4268080000 0.8271200000 1 1 1 mag 0.0 0.0000000000 0.4307370000 0.7500000000 1 1 1 mag 0.0 0.5000000000 0.4268080000 0.9228800000 1 1 1 mag 0.0 0.0000000000 0.3018080000 0.9521200000 1 1 1 mag 0.0 0.5000000000 0.3057370000 0.8750000000 1 1 1 mag 0.0 0.0000000000 0.5518080000 0.7978800000 1 1 1 mag 0.0 0.5000000000 0.6768080000 0.8271200000 1 1 1 mag 0.0 0.0000000000 0.6807370000 0.7500000000 1 1 1 mag 0.0 0.5000000000 0.6768080000 0.9228800000 1 1 1 mag 0.0 0.0000000000 0.5518080000 0.9521200000 1 1 1 mag 0.0 0.5000000000 0.5557370000 0.8750000000 1 1 1 mag 0.0 0.0000000000 0.8018080000 0.7978800000 1 1 1 mag 0.0 0.5000000000 0.9268080000 0.8271200000 1 1 1 mag 0.0 0.0000000000 0.9307370000 0.7500000000 1 1 1 mag 0.0 0.5000000000 0.9268080000 0.9228800000 1 1 1 mag 0.0 0.0000000000 0.8018080000 0.9521200000 1 1 1 mag 0.0 0.5000000000 0.8057370000 0.8750000000 1 1 1 mag 0.0 改变摆放方式时，要同时轮换 LATTICE_VECTORS 和 ATOMIC_POSITIONS 的顺序。 3. KPT 文件 K_POINTS 0 Gamma 16 3 2 0 0 0 如前所述，该 KPT 文件是由 INPUT 文件里的 kspacing 参数所生成，因此不需要我们手动轮换，每次计算都会自动根据晶胞大小产生合适的 K 点。 三、测试结果 计算采用 ABAUCS v3.8.0 版本，选择 64 个型号为 8426Y+ 的 CPU 用 64 个进程对该二维氮化硼体系进行结构弛豫。下表给出本次测试的结果，将氮化硼的短边分别摆放在 XYZ 三个方向完成结构弛豫的步数都是 9 步。我们通过比较总能量和时间差异来判断摆放方式对计算结果的影响，可以看到系统总能量并不会受到短边取向的影响，但计算时间会受到显著影响。短边摆放在 Z 方向时，即两长边分别放在 X、Y 方向，计算时间明显慢于长边摆放在 Y、Z 和 Z、X 方向，每一电子步大概慢 6 s 左右。（注意：我们进行一维材料计算时，也建议将长边摆放在 Z 方向以提高计算效率） h-BN 的两个长边方向 系统总能量 (eV) 计算总时间 (s) 计算总弛豫步数 运行一电子步的时间 (s) FFT UNIFORMGRID DIM(BIG) XY -33578.4871085887 2140 9 24.8~26.8 216*360*36 54*72*18 YZ -33578.4871085889 1609 9 18.7~20.0 36*216*360 9*54*120 ZX -33578.4871085888 1629 9 18.9~20.9 360*36*216 72*9*54 根据以上测试结果，建议读者们在进行二维体系计算时，将短边摆放在 X 或 Y 方向以获得 ABACUS 计算时的最大效率。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-upf.html":{"url":"abacus-upf.html","title":"模守恒赝势生成方法简介","keywords":"","body":"模守恒赝势生成方法简介 作者：陈涛，邮箱：chentao@stu.pku.edu.cn；刘千锐，邮箱：terry_liu@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2025/03/11 一、介绍 UPF（unified PP format）是一种类似 XML 格式的文件格式，用于存储赝势及其相关参数。该格式由 Quantum ESPRESSO（QE）团队开发，并已成为许多量子计算软件包的标准格式之一。 ABACUS（截至 v3.2.3）的 Kohn-Sham 密度泛函理论计算主要支持 UPF 格式的模守恒赝势，在使用 ABACUS 过程中，一般可以直接使用网上已经生成好的赝势，常见的下载位置： ABACUS 官网 SG15-ONCV，参考文献：Optimization algorithm for the generation of ONCV pseudopotentials Quantum ESPRESSO 官网中的模守恒赝势 pseudo-dojo 官网（psp8 格式，需要转换） PWmat 官网 但是，在实际计算中，可能这些赝势并不符合当前的需求，这时候就需要自己生成模守恒赝势。可以通过其他格式赝势转换或者利用赝势软件生成两种方式来获得赝势。 注：ABACUS 的无轨道密度泛函理论计算（Orbital-Free Density Functional Theory，简称 OFDFT）需要用到一种特殊的局域势（不包含非局域势），一般采用 BLPS 局域赝势文件而非上文提到的 UPF 文件，如果做 OFDFT 计算的，可以阅读介绍 OFDFT 计算的文档，或者登录 Emily A. Carter 教授主页寻找相关的信息。 二、从其他格式赝势转换 1. 使用 QE upflib 中的 upfconv 进行转换 其支持将 UPF v.1 格式、vdb/van 格式（Vanderbilt US pseudopotential）、cpi/fhi 格式（FHI/abinit）转化成 UPF v.2 格式 path_to_QE/upflib/upfconv.x -u *.upf/UPF/vdb/van/cpi/fhi 注：这里的 path_to_QE 代表下载的 Quantum Espresso 的软件包地址。 注：文件夹 upflib 在 QE 5.x 和 6.x 版本名称为 upftools，在QE 7.x 版本为 upflib。 2. psp8 格式转换 psp8 格式是 ONCVPSP 软件生成的一种赝势格式，在 Abinit 官网（pseudo-dojo）中，其使用的就是 psp8 的格式，目前没有直接将 psp8 格式的赝势直接转换成 UPF 格式的脚本，但可以将 psp8 中输入文件部分摘抄下来，用 ONCVPSP 软件重新生成 UPF 格式的赝势（具体生成见下面 ONCVPSP 的讲解）。 可供参考的批量处理脚本：https://github.com/pipidog/ONCVPSP 三、赝势的生成 下面介绍三个可以生成 UPF 模守恒赝势的软件，分别是 ONCVPSP，Opium，和 ld1.x 1 ONCVPSP 1.1 介绍 ONCVPSP（Optimized Norm-Conserving Vanderbilt PSeudoPotential）是由 D.R. Hamann 等人提出的优化版模守恒赝势，其有更高的精度与效率。ONCVPSP 依赖 Libxc，支持多种交换关联泛函。 参考文献：Optimized norm-conserving Vanderbilt pseudopotentials。 1.2 安装 1.2.1 安装 Libxc Libxc 网址：Libxc - a library of exchange-correlation functionals for density-functional theory 推荐下载 libxc-4.3.4 然后执行如下命令： cd libxc-4.3.4 autoreconf -i ./configure --prefix='PATH/TO/LIBXC' CC=icc FC=ifort F77=ifort make make install 命令执行完毕后即可在 PATH/TO/LIBXC 目录下看到 bin,include 和 lib 三个目录，代表安装成功 1.2.2 安装 oncvpsp 推荐下载 oncvpsp-4.0.1 然后执行 cd oncvpsp-4.0.1，进入文件夹 这时需要修改 make.inc 文件 修改 F77 = ifort, F90 = ifort, CC = icc FFLAGS 删去 -ffast-math LIBS 改为 -qmkl=\"sequential\" LIBS+ 和 FFLAGS 中的地址改为自己的 PATH/TO/LIBXC 具体如下： # System-dependent makefile options for ONCVPSP # This must be carefully edited before executing \"make\" in src # # Copyright （c） 1989-2019 by D. R. Hamann, Mat-Sim Research LLC and Rutgers # University ##### Edit the following lines to correspond to your compilers #### F77 = ifort F90 = ifort CC = icc FCCPP = cpp FLINKER = $（F90） #FCCPPFLAGS = -ansi -DLIBXC_VERSION=301 #Use this for versions 400 ##### Edit the following optimization flags for your system #### FFLAGS = -O3 -funroll-loops CFLAGS = -O3 ##### Edit the following LAPACK and BLAS library paths for your system #### LIBS = -qmkl=\"sequential\" ##### Edit the following for to use libxc if available ##### OBJS_LIBXC = exc_libxc_stub.o # oncvpsp is compatible with libxc # To build oncvpsp with libxc, uncomment the e following lines and edit # the paths to point to your libxc library and include directories # make clean in src before rebuilding after changing this LIBS += -L/PATH/TO/LIBXC/lib -lxcf90 -lxc FFLAGS += -I/PATH/TO/LIBXC/include #LIBS += -L/home/drh/abinit/fallbacks/exports/lib -lxcf90 -lxc #FFLAGS += -I/home/drh/abinit/fallbacks/exports/include OBJS_LIBXC = functionals.o exc_libxc.o 然后执行如下命令： make # 如果make -j报错，可以忽略再make，即可编译成功 安装测试完成后，即可在 src 目录下看到 oncvpsp.x 可以在 ~/.bashrc 中增加如下命令将 oncvpsp.x 加入环境变量，方便直接调用： export PATH=$PATH:/PATH/TO/ONCVPSP/src 1.3 输入文件 输入文件的准备可以参考 PATH_TO_ONCVPSP/doc/32_Ge_annotated.dat，或者参考已知 ONCV 的赝势里面的 部分来写。 这里以铝（Al）为例，输入文件 Al.dat: # ATOM AND REFERENCE CONFIGURATION # atsym, z, nc, nv, iexc psfile Al 13 1 4 4 upf # # n, l, f （nc+nv lines） 1 0 2 2 0 2 2 1 6 3 0 2 3 1 1 # # PSEUDOPOTENTIAL AND OPTIMIZATION # lmax 1 # # l, rc, ep, ncon, nbas, qcut （lmax+1 lines, l's must be in order） 0 1.29163 0 5 8 10.3003 1 2.40653 0 5 8 7.02214 # # LOCAL POTENTIAL # lloc, lpopt, rc（5）, dvloc0 4 5 0.932267 0 # # VANDERBILT-KLEINMAN-BYLANDER PROJECTORs # l, nproj, debl （lmax+1 lines, l's in order） 0 2 0 1 2 0 # # MODEL CORE CHARGE # icmod, fcfact 0 0 # # LOG DERIVATIVE ANALYSIS # epsh1, epsh2, depsh -5.0 3.0 0.02 # # OUTPUT GRID # rlmax, drl 6.0 0.01 # # TEST CONFIGURATIONS # ncnf 0 # nvcnf # n l f 一些可以调整的参数如下： nc：c = core，芯电子层数 nv：v = valence，价电子层数，调整 nc 和 nv 可以改变赝势的价电子数 iexc：生成赝势所用的交换关联泛函，详情可参考 ONCVPSP-4.0.1 目录下 doc 内的 pwscf_exc.txt 文件，常用的如下 iexc==3 .or. iexc==-001009, 'functional=\"PZ\"' iexc==4 .or. iexc==-101130, 'functional=\"PBE\"' psfile：赝势格式，有 upf 和 psp8 两种。ABACUS 支持 upf 的格式 rc: rc 中较小的为赝势的截断半径。在温度较高或密度较大的温稠密体系，通常需要调整赝势的截断半径，推荐小于 0.7 倍维格纳半径，单位为 Bohr；每个 l 对应一个 rc，其中最小的为赝势的截断半径 rc（5）：rc 都要大于等于 rc（5）。例如 Al 的 l=0 的 rc 为 1.29163 Bohr，l=1 的 rc 为 2.40653 Bohr，rc（5） 为 0.932267 Bohr，因此该赝势的截断半径为 1.29163 Bohr。 qcut：通过调整（+-0.1），直到推荐 ECUT 达到最小 dvloc0：通过调整（+-0.5），直到消除赝势的 GHOST 态（可参考文献 Phys. Rev. B 41, 12264 (1990)） 1.4 生成赝势 执行命令： oncvpsp.x Al.out sed -n '//,//p' Al.out > Al.UPF 生成完赝势需要查看 Al.out 文件，确定没有 GHOST 态（可参考文献 Phys. Rev. B 41, 12264 (1990)）： Testing for highly-localized positive-energy ghosts l \\/rc E Basis Diag. E Cutoff 1 0.974041 120.256772 338.98 WARNING - GHOST（+） 如上，出现 WARNING - GHOST 说明有 GHOST，需要调整 dvloc0 （+-0.5）直到消除 GHOST 态 sed 命令是为了从 Al.out 文件中截取赝势文件到 Al.UPF 中 如果同时要画出类似 Phys. Rev. B 88, 085117 (2013) 的图，需要准备输入文件 Al.dat 并执行命令： sh PATH_TO_ONCVPSP/scripts/run.sh Al 可以画出如下的图： 图 1. 局域势函数与非局域势不同轨道角动量对应的半局域径向势函数 图 2. S赝波函数与全电子波函数对比 图 3. S的双投影波函数 图 4. 不同能级波函数在截断半径处log导数对比，其影响散射性质的计算 图 5. 不同轨道角动量对应的截断能 1.5 优化赝势 依次调节不同 l 对应的 qcut（+-0.1），检查对应 ECUT（l） 变化情况，直到 ECUT（l） 达到最小 参考的脚本： !/bin/bash qcut=17 dq=0.1 #遍历l=0的qcut从17到25，间隔为0.1，输出其对应的ECUT while [ `echo \"$qcut test.dat qcut$qcut.out grep -A 5 \"Energy error\" qcut$qcut.out > _tmp.txt E1=`sed -n \"6p\" _tmp.txt | awk '{print $3}'` E2=`sed -n \"13p\" _tmp.txt | awk '{print $3}'` E3=`sed -n \"20p\" _tmp.txt | awk '{print $3}'` E4=`sed -n \"27p\" _tmp.txt | awk '{print $3}'` # echo $qcut $E1 $E2 $E3 $E4 if [ `echo \"$E1>$E2\" | bc` == '1' ] ;then Emax1=$E1 else Emax1=$E2 fi if [ `echo \"$E3>$E4\" | bc` == '1' ];then Emax2=$E3 else Emax2=$E4 fi echo $qcut $Emax1 $Emax2 qcut=`echo \"$qcut+$dq\" | bc` done 不同的 l 都会有对应的能量截断值 ECUT(l)。一般 rc(l) 越小，对应的 ECUT(l) 越大，赝势也就越精确。由于 DFT 计算中的截断能 ECUT 是由赝势中较大的那个 ECUT(l) 决定，如果不同 l 的 ECUT(l) 相差很大，可以适当减小较小的 ECUT（l） 对应 l 的截断半径 rc，使得不同 l 对应的 ECUT(l) 更接近，这样并不会增加赝势计算的 ECUT，却可以提升精度。 这样调完之后如果有 GHOST 态，需要调整 dvloc0 （+-0.5）直到消除 GHOST 态，这个赝势才可使用 2. Opium Opium 软件包可以生成 RRKJ、TM 或 Kerker 径向波函数的赝势，官网有 LDA、GGA 赝势库（但是某些输入文件已经不匹配最新的 4.1 版本，需要稍作修改） 下载 Opium 之后利用 configure 安装： ./configure make 输入文件可以参考官网 LDA、GGA 赝势库，也可以参考 PATH_TO_OPIUM/tests，这里以铝（Al）为例，输入文件 al.param: [Atom] Al 6 100 2.00 -13.0 # reference configuration 200 2.00 -1.4 # reference configuration 210 6.00 -0.4 # reference configuration 300 2.00 -0.1 # reference configuration 310 0.95 -13.0 # reference configuration 320 -1.0 -0.0 # 这条能带是非束缚态，需要将占据数调成负数，官网给错了 [Pseudo] 3 1.85 1.85 1.97 opt [Optinfo] 7.07 10 # rc[a.u.] qc[sqrt（Ry）] Nb 7.07 10 7.07 10 [Configs] 3 # number of valence configurations # 300 2.00 -13.0 # nlm occ eigen（- means auto-generate） 310 1.00 -6.0 320 0.00 -6.0 # 300 1.00 -13.0 310 2.00 -6.0 320 0.00 -6.0 # 300 2.00 -13.0 310 0.00 -6.0 320 0.00 -6.0 [XC] gga [Relativity] srl 这里的参数可以参考官网手册 之后执行 opium al log all #输出在log文件里，依次执行全电子计算、计算赝势、计算非局域势、可移植性测试 opium al log upf #生成al.upf的输出文件 upfconv.x -u al.upf #利用QE的upflib将UPFv.1转化成UPFv.2格式 3. ld1.x QE 的 atomic 模块中的 ld1.x 支持生成赝势。其不仅可以生成模守恒赝势、还支持超软赝势、PAW 方法，支持全相对论、标量（非）相对论赝势（rel, non-rel/sca-rel），其径向波函数支持 TM（更稳定）与 RRKJ 两种方法，支持交换关联近似 7 类 LDA（pz）,GGA（pbe, pbesol, revpbe, bp, wc, pw91）。 下载好 QE 软件后，可以直接安装： ./configure make ld1 3.1 pslibrary 赝势库 推荐 ld1.x 生成其自带的 pslibrary 赝势库，下载好 pslibrary.1.0.0.tar.gz，解压，进入文件夹，修改 QE_path 文件，指定 QE 的路径。然后打开 make_ps 文件，解锁相应赝势： # These two files generate PAW and US PPs for all elements. These are # high accuracy - high kinetic energy cut-off PPs. # . ../paw_ps_high.job #默认打开的 . ../us_ps_high.job # # These two files generate additional PAW and US PPs for some elements. # These are less accurate PP than the previous one but require # lower kinetic energy cut-off or have less projectors or less semicore # states. # . ../paw_ps_low.job . ../us_ps_low.job # Uncomment the following line to generate the old pslibrary 0.3.1 PPs. # 打开下面的注释，可以解锁其余赝势 # #. ../paw_ps_collection.job #可以打开注释 #. ../us_ps_collection.job #可以打开注释 # Uncomment the following line to generate the NC-PPs. Be very careful # these PPs are completely untested. # 虽然可以生成，但其也提示该赝势的准确性并不能保证 # #. ../nc_ps_collection.job #可以打开注释 下面运行 ./make_all_ps 就能看到在一个个生成赝势库里的赝势： Making Ac.pz-spfn-kjpaw_psl.1.0.0.in ... Done Making Ac.pz-spfn-rrkjus_psl.1.0.0.in ... Done Making Ag.pz-n-kjpaw_psl.1.0.0.in ... Done Making Ag.pz-n-rrkjus_psl.1.0.0.in ... Done Making Ag.pz-spn-kjpaw_psl.1.0.0.in ... Done Making Ag.pz-spn-rrkjus_psl.1.0.0.in ... Done Making Al.pz-n-kjpaw_psl.1.0.0.in ... Done Making Al.pz-n-rrkjus_psl.1.0.0.in ... Done Making Al.pz-nl-kjpaw_psl.1.0.0.in ... Done Making Al.pz-nl-rrkjus_psl.1.0.0.in ... Done 如果不想生成所有的元素的赝势，则可以修改 make_ps 的 element，例如： element='C Si Ge' 3.2 生成自己的赝势 参数的详细解释见 PATH_TO_QE/atomic/Doc/INPUT_LD1.html 或线上的文档（不是最新的，建议前者），输入文件可以参考 pslibrary 赝势库的例子。 这里就简单给个 Al（铝）的例子，准备输入文件 al.in： &input title='Al', zed=13.0, rel=1, config='[Ne] 3s2 3p1 3d-2.0 4f-2.0', iswitch=3, dft='PBE' / &inputp pseudotype=2, file_pseudopw='Al.pbe-n-nc.UPF', #输出赝势 lloc=2, nlcc=.true., tm=.true. / 3 3S 1 0 2.00 0.00 2.60 2.60 0.0 3P 2 1 1.00 0.00 2.60 2.60 0.0 3D 3 2 0.00 0.10 2.60 2.60 0.0 运行 ld1.x 即可生成 Al.pbe-n-nc.UPF 模守恒赝势。 四、结尾 ABACUS 使用的是模守恒赝势，基于模守恒赝势还可以产生数值原子轨道，进行基于数值原子轨道的高效率密度泛函理论计算。有些情况下，网上提供的赝势不能满足需求，这个时候赝势的生成需要对赝势理论有比较深入的了解之后，才能调整好相关参数，生成质量较好的赝势。此外，生成之后，应该经过较为充分的测试，才能保证赝势的可移植性和正确性。如果大家有任何问题，欢迎发 email 至文档开头的邮箱。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-nac1.html":{"url":"abacus-nac1.html","title":"数值原子轨道（一）：ABACUS 中的数值原子轨道命名和使用方法","keywords":"","body":"数值原子轨道（一）：ABACUS 中的数值原子轨道命名和使用方法 作者：梁馨元，邮箱：2201111875@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/07/18 一、数值原子轨道的背景知识 1. 数值原子轨道 对电子结构的求解可以在不同的表象下进行，电子的波函数以及势函数也可以在不同基矢量下表示，常用的有平面波和局域轨道等。LCAO（Linear Combination of Atomic Orbitals）方法就是通过局域的原子轨道来求解量子力学问题。其中局域轨道的选取方式有多种，例如高斯轨道（Gaussian type Orbitals，GTOs 或 Gaussians）、数值原子轨道（Numerical Atomic Orbitals）、万尼尔函数（Wannier Functions）等。 2. 数值原子轨道作为基矢量的优点 数值原子轨道作为基矢量有几个优点：第一，基矢量个数相比于一些常用的基矢量（例如平面波和实空间网格）大幅度降低；第二，数值原子轨道是局域的，空间上可以严格截断，采用数值原子轨道来构建体系的哈密顿量的效率可以达到线性标度的时间复杂度。 3. 构造数值原子轨道基组的几种方案 构造精度高、可系统提升数量、可移植性好的原子轨道基组颇有挑战，因此也有多种方案被提出。例如，Junquera 等人提出在一维薛定谔方程中加入不同形式的约束势场，从而求解出具有严格截断的数值原子轨道[1]。Ozaki 在 OpenMX 软件中采用变分的方法来优化局域轨道的形状，从而得出一组最优的数值原子轨道[2]。Volker 等人提出在一个大的局域轨道基组中挑选最合适的局域轨道组成不同等级的基组轨道，该方案用于全电子密度泛函理论软件 FHI-aims 中[3]。Chen 等人提出利用前人提出的溢出函数（Spillage function）[4-5]来构造可系统提高数量的数值原子轨道，其中每个轨道都由一组球贝塞尔函数作为基矢量展开，该轨道被用在 ABACUS（原子算筹）软件中[6]。 二、数值原子轨道的命名方法 1. 数值原子轨道的组成 数值原子轨道（Numerical Atomic Orbitals，简称 NAO）是目前在 ABACUS 程序中支持的一种基矢量。从数学形式上来看，数值原子轨道可以分解为径向函数 flζ 和球谐函数 Ylm 的乘积。 \\phi_{l m \\zeta}(\\mathbf{r})=f_{l \\zeta}(r) Y_{l m}(\\hat{r}), 其中 l 是角量子数，m 是磁量子数，ζ 代表了每个角量子数上对应的多个径向轨道，实际计算中通常采用多于 1 个轨道来增加基矢量的完备性。 2. 数值原子轨道的命名方法 数值原子轨道有一套常用的命名方案用来表示选取的基组大小，早期该命名方案在 SIESTA 软件中被采用[7][8][9][10]，后来在 OpenMX、FHI-aims 和 ABACUS 中也采取这套命名方案。具体来说是，对于每个被电子占据的角量子数 l，若采用 1 条径向轨道，则称该基组为 Single-ζ 轨道，简称 SZ 轨道基组。若采用 2 条径向轨道，则称该基组为 Double-ζ 轨道，简称 DZ 轨道基组。 目前，在许多赝势结合数值原子轨道的程序里，通常会在 DZ 轨道的基础上引入 1 条极化（polar）的径向轨道，即角量子数更高的轨道，来组成 DZP（Double-ζ valence orbitals plus SZ polarization） 轨道基组。此外，还有基组数量更大的 TZDP（Triple-ζ valence orbitals plus DZ polarization） 轨道等。 3. 数值原子轨道基组的个数 数值原子轨道基组的具体个数除了取决于轨道类别（比如 SZ、DZP、TZDP）外，也取决于元素种类、所选取的赝势。 轨道类别：比如对于 O 元素的赝势而言，一般将两个 1s 电子作为核内电子，在构造赝势的时候只考虑它的外层 6 个价电子部分 2s、2p 轨道，则该 O 赝势下的电子的极化轨道为 d 轨道。故它的 SZ（Single-ζ）轨道包含 1 组 s 轨道、1 组 p 轨道，共 1*1+1*3=4 个轨道；DZP 轨道包含 2 组 s 轨道、2 组 p 轨道、1 组 d 轨道，共包含 2*1+2*3+1*5=13 个轨道；TZDP 轨道包含 3 组 s 轨道、3 组 p 轨道、2 组 d 轨道，共包含 3*1+3*3+2*5=22 个轨道。 元素种类：比如同为 DZP 轨道，对于 H 元素（1 个价电子）即为 2 组 s 轨道、1 组 p 轨道（p 轨道也是 H 的极化轨道），共包含 2*1+1*3=5 个轨道。对于 O 元素即为 2 组 s 轨道、2 组 p 轨道、1 组 d 轨道，共包含 2*1+2*3+1*5=13 个轨道。 赝势：比如对于 Fe 元素而言，同为 DZP 轨道。若选取的赝势为，[Ne]3s^23p^64s^23d^6，即[Ne]=1s^22s^22p^6部分为芯电子，3s^23p^64s^23d^6部分为 16 个价电子，则 DZP 轨道包含 2*2 套 s 轨道（3s 和 4s）、2 套 p 轨道（3p）、2 套 d 轨道（3d）、1 套 f 轨道（极化轨道），即每个原子的 DZP 数值原子轨道个数为 2*2*1+2*3+2*5+1*7=27 个轨道。若选取的赝势为[Ar]4s^23d^6，则 DZP 轨道包含 2 套 s 轨道、2 套 d 轨道、1 套 p 轨道，共 2*1+2*5+1*3=15 个轨道。 三、ABACUS 中数值原子轨道的使用方法 1. ABACUS 中的数值原子轨道文件 ABACUS 提供了已经生成好的数值原子轨道库打包文件供下载（官网下载链接），对于绝大多数计算任务，这些数值原子轨道是经过精度和可靠性验证，可以直接使用的。这些轨道文件的开头提供了关于该轨道的重要信息。以 O_gga_7au_100Ry_2s2p1d.orb 轨道文件为例，首先文件名包含的信息有：氧元素（o），GGA 泛函（gga），数值原子轨道截断半径（7au，即 7 Bohr），推荐能量截断值（100 Ry），数值原子轨道个数（2s2p1d，2 个 s 的径向轨道，2 个 p 的径向轨道，1 个 d 的径向轨道）。值得注意的三个点是： ABACUS 里用到的模守恒赝势和轨道是需要匹配的。因为不同的赝势可能有不同的价电子，而数值原子轨道是用来描述这些价电子的，如果赝势的价电子多，则相应的默认数值原子轨道基组数量也会增多。 推荐用户直接使用轨道文件包含的能量截断值做计算。ABACUS 里的数值原子轨道在生成时，是尽量的去匹配平面波输出的波函数，从而优化得到的。而平面波计算是有一个能量截断值的，因此为了尽可能的保证 LCAO 的精度，我们建议直接使用推荐的能量截断值，而不需要真正做计算的时候做体系能量随着能量截断值变化的收敛性测试。当你在 LCAO 计算时改变能量截断值时候，其实只是改变了平面波的个数，这些平面波是用来做一些数值计算的，本质上并没有改变基矢量的个数，而基矢量的个数增加是靠改变基组大小，例如 DZP 到 TZDP 来实现的。 特殊情况可以自己生成数值原子轨道。如果用户有自己特殊的赝势，或者对目前提供的原子轨道的参数或者个数感觉不满意，例如对于导带的描述能力较差，也可以自己生成数值原子轨道，具体生成的方法可以参考这个系列文档的第二和第三篇。 打开以上提到的氧的数值原子轨道文件，文件的开头如下： --------------------------------------------------------------------------- Element O Energy Cutoff(Ry) 100 Radius Cutoff(a.u.) 7 Lmax 2 Number of Sorbital--> 2 Number of Porbital--> 2 Number of Dorbital--> 1 --------------------------------------------------------------------------- SUMMARY END 这里包括元素种类（Element），生成轨道时指定的截断能量值（Energy Cutoff）、截断半径（Radius Cutoff），最大角量子数（Lmax）及各角量子数轨道的个数（Number of * orbital，*为 S、P、D 等轨道角动量）。根据这些信息可以知道该轨道的类别，比如该举例文件即包含 O 的 DZP 轨道。 上述 ABACUS 提供的数值原子轨道文件中，在取名中即包含文件开头的重要信息，包括各角量子数的轨道个数。由这些轨道的文件名即可判断轨道类型。 轨道文件中包含的后续内容为不同类型、不同角量子数（L）的多个径向数值原子轨道（即不同 N）的具体数据，目前轨道是存在均匀格点上的，之后有可能也会支持非均匀格点。 2. 如何选择数值原子轨道文件 用户需要根据精度要求，选择数值原子轨道合适的截断能量值、截断半径及轨道类型。截断能量值、截断半径越大，轨道类型提升（SZ、DZP、TZDP），精度越高，结果更接近平面波。注意对于不同元素，要达到同样的精度，以上数值设置并不一定相同。 3. 如何修改数值原子轨道文件的设置，获得低精度轨道类型文件 在 ABACUS 中生成数值原子轨道文件时，可以设置同时生成多种精度的轨道文件，即设置 SIAB_INPUT 文件中的参数 Save Orbitals，详见篇目（三）。 如果已有一份数值原子轨道文件，但希望直接用此文件进行低精度计算，比如希望使用 DZP 轨道文件进行 SZ 计算。可以修改文件开头的信息实现，具体是 Lmax 及各角量子数轨道个数，将这些参数调整到低精度计算对应的数值。文件的后续内容不需要做更改。 比如对于 O 元素而言，DZP 轨道文件参数如 3.1 所示，若要进行 SZ 基矢量的计算，则将 Lmax 设置为 1，Number of Sorbital/Porbital/Dorbital=1/1/0 即可。 四、参考文献 [1] J. Junquera, Ó. Paz, D. Sánchez-Portal, and E. Artacho, Numerical Atomic Orbitals for Linear-Scaling Calculations, Phys. Rev. B, 64, 235111 (2001). [2] T. Ozaki, Variationally Optimized Atomic Orbitals for Large-Scale Electronic Structures, Phys. Rev. B, 67, 155108 (2003). [3] V. Blum, R. Gehrke, F. Hanke, P. Havu, V. Havu, X. Ren, K. Reuter, and M. Scheffler, Ab Initio Molecular Simulations with Numeric Atom-Centered Orbitals, Comput. Phys. Commun., 180, 2175 (2009). [4] M. Chen, G.-C. Guo, and L. He, Systematically Improvable Optimized Atomic Basis Sets for Ab Initio Calculations, J. Phys.: Condens. Matter, 22, 445501 (2010). [5] M. Chen, G.-C. Guo, and L. He, Electronic Structure Interpolation via Atomic Orbitals, J. Phys.: Condens. Matter, 23, 325501 (2011). [6] Liu Xiao-Hui et al., Introduction to first-principles simulation package ABACUS based on systematically improvable atomic orbitals, Acta Phys. Sin., 64, 187104 (2015). [7] Sánchez‐Portal D, Ordejon P, Artacho E, et al. Density‐functional method for very large systems with LCAO basis sets, J. International Journal of Quantum Chemistry, 65, 453-461 (1997). [8] Artacho E, Sánchez‐Portal D, Ordejón P, et al. Linear‐scaling ab‐initio calculations for large and complex systems, J. Physica Status Solidi (b), 215, 809-817 (1999). [9] Junquera J, Paz Ó, Sánchez-Portal D, et al. Numerical atomic orbitals for linear-scaling calculations, J. Physical Review B, 64, 235111 (2001). [10] Soler J M, Artacho E, Gale J D, et al. The SIESTA method for ab initio order-N materials simulation, J. Phys.: Condens. Matter, 14, 2475 (2002). Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-nac2.html":{"url":"abacus-nac2.html","title":"数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道","keywords":"","body":"数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/15 在Bohrium Notebook上快速学习： 一、ABACUS 中的数值原子轨道背景知识 1. 数值原子轨道 ABACUS 中的三维数值原子轨道[1]：可以分解为径向部分与角向球谐函数的乘积，即 \\phi_\\mu(\\mathbf{r})=f_{\\mu, l}(\\mathbf{r}) Y_{l m}(\\hat{r}), 其中 \\mu=\\{\\alpha,i,\\xi,l,m\\}，\\alpha是原子种类的指标，i是每个原子种类对应的原子个数的指标，\\xi是角动量l对应的径向函数的个数，m是磁量子数。 径向部分函数：第 \\mu个轨道的径向部分函数可以写为球贝塞尔函数的线性组合(可参考文献[1]) f_{\\mu l}(\\mathbf{r})= \\begin{cases}\\sum_q c_{\\mu q} j_l(q r), & r 其中 j_l(q r)是波矢为q的球贝塞尔函数，r_c是径向部分的截断半径，满足关系j_l(q r_c)=0。q的个数由能量截断值决定（以下会介绍）。在实际计算里，通过用户指定每种元素的数值原子轨道截断半径和能量截断值来确定需要用到多少个球贝塞尔函数。组合系数 c_{\\mu q}是可优化的量，决定了数值原子轨道的形状。 2. 参考体系 参考系统：在ABACUS中构造某个元素对应的数值原子轨道的最普遍方式是为每个元素选取一组参考体系做平面波计算（可以是单k点也可以是多k点），得到这些参考体系的电子波函数，然后通过最小化自定义的一个溢出函数（下面会介绍）来优化c_{\\mu q}系数。换句话说，我们需要选定一组参考系统，生成数值原子轨道基组，并期望它们有良好的迁移性，以便可以在更一般的情况下使用。 Dimer（二聚体）：我们发现二聚体是较为合适的参考系统。具体来说，推荐选择的是若干个不同键长的二聚体（dimer），有时也可选择三聚体（trimer）或四聚体。对同一个元素，我们通常选择几个键长不同的二聚体（例如5-6个），这些键长覆盖二聚体稳定键长附近能量区间，通常可以取与最稳定能量差别为1-2个eV的能量曲线上的点。 周期性体系：数值原子轨道还有一些特殊用途，例如能带插值。面对这种场景，可以选择一系列带多个k点的周期性体系，此时参考态中的每个原子构型就对应了不同k点指标和不同能带指标的波函数，这些波函数会被用于最小化溢出函数来生成数值原子轨道，可以参考文献[2]。 3. 溢出函数 溢出函数（英文为spillage）：由给定参考体系的多个电子波函数与生成的数值原子轨道之间的差别来定义。换个角度理解，溢出函数的大小反映的是由一组“精确”波函数所张成的希尔伯特空间与局域轨道所张成的空间的差别。溢出函数定义如下： \\mathcal{S}=\\frac{1}{N_n} \\sum_{n=1}^{N_n}\\left\\langle\\Psi_n|1-\\hat{P}| \\Psi_n\\right\\rangle, 其中\\Psi_n表示平面波基组下的本征态，N_n是选定的参考电子态的个数，\\hat{P}是由所有原子轨道张成的投影子 \\hat{P}=\\sum_{\\mu v}\\left|\\phi_\\mu\\right\\rangle S_{\\mu v}^{-1}\\left\\langle\\phi_v\\right| \\text, 其中S_{\\mu v}=\\left\\langle\\phi_\\mu \\mid \\phi_v\\right\\rangle是局域轨道\\phi_\\mu与\\phi_v之间的重叠矩阵，投影子用到了重叠矩阵的逆。 轨道正交：事实上，如果我们有了给定的数值原子轨道，我们可以在此基础上再次定义新的溢出函数来得到一组新的数值原子轨道，这也是为什么该算法可以系统性的增加数值原子轨道的原因。定义的方式也比较直接，可以将|\\Psi_n\\rangle和已有原子轨道形成的投影子\\hat{P}正交，公式为 |\\Psi_n^{new}\\rangle=（1-\\hat{P}）|\\Psi_n\\rangle, 这个公式里，左边的波函数经过正交已经不包含原子轨道的成分，这样可以再次作为新的参考体系波函数生成新的数值原子轨道，以上算法已经被实现在SIAB这个程序里。 最小化溢出函数：优化原子轨道时，最终溢出函数值定义为选定的几个二聚体的平均溢出函数值。溢出函数可以用来评估获得的原子轨道基组的质量，溢出函数越小，则原子轨道所张成的空间越接近于参考态波函数。在ABACUS中，通过最小化溢出函数的方式来优化c_{\\mu q}，该系数决定了原子轨道的径向函数的形状。这种方法的好处在于 轨道形状可调：可以由球贝塞尔函数基组的线性组合自动生成，而不需要任何先决条件，因此原则上可获得完全优化的原子轨道。 基组数量可调：可以用统一的方式系统的增加轨道数量，包括增加径向轨道的数量（multi-ζ）和增加更高角动量的轨道（极化轨道）两种方式。为此，我们可以首先生成具有给定角动量的轨道，然后更高级的轨道可以使用相同的程序生成，但是此时只需最小化剩余的希尔伯特空间中的溢出函数，该空间与所有先前生成的原子轨道所张成的空间正交。 参考系统可调：通过选择参考系统及对应能级，可以提高原子轨道基组在不同环境的可迁移性。例如，对于涉及到激发态能级的计算，往往需要在生成数值原子轨道的时候，考虑这组轨道对于非占据态能级的拟合能力，这个时候可以在生成参考体系的时候加入一定数量的非占据能级。 4. 模拟退火算法SA（Simulated Annealing） 我们首先介绍模拟退火法Simulated Annealing（SA）来最小化溢出函数[1]，从而优化球贝塞尔函数的系数c_{\\mu q}。在模拟退火算法中我们用的是Metropolis的算法，需要设置一个初始温度，并且指定温度下降的方式。代码部分我们之后会介绍，这里先简要介绍一下算法。 初始系数：如果没有特别指定，一开始的系数c_{\\mu q}是随机产生的， 每一步SA会更新其中一个系数，当溢出函数被改变的数值在允许接收的范围内时，参数c_{\\mu q}会被更新。 优化过程：当要优化的所有轨道的所有参数c_{\\mu q}都被更新过一次之后，我们称为一步优化。 我们发现大约在每个温度行走500 ~ 1000步就已经足够产生好的原子轨道。最开始的温度我们一般取为1.0e-5，事实上我们发现即便初始温度取得更小，最后的结果也是不错的。 在每一步优化之后，我们将温度乘上一个比率，来达到降温的目的从而得到新的温度，这个参数我们一般取为0.5~0.8，最后的温度一般降到1.0e-9~1.0e-12。接收的概率可以控制在0.2~0.4范围内。 能量截断值：这里的能量截断值实际上是能量截断值，我们知道每个平面波 e^{i\\mathbf{q}\\cdot\\mathbf{r}}都对应一个二阶求导后的动能q^2/2。同样的，每个球贝塞尔函数 j_l(q r)也有一个对应的动能是 q^2/2。在平面波计算里我们通过能量截断值来控制平面波的数量，从而控制计算精度。在生成数值原子轨道的时候，我们也通过能量截断值来控制球贝塞尔函数的个数，从而控制生成的数值原子轨道的精度。 对于ABACUS的平面波计算和产生球贝塞尔函数 j_l(q r)个数的计算，我们建议采用同样的能量截断值，该截断值取得越高，基矢量个数越多同时基组也越完备。对于采用赝势的平面波计算，15~30个球贝塞尔函数已经足够得到质量比较高的数值原子轨道。 数值原子轨道的二阶可导：除了以上操作之外，还有一个需要注意到的地方。为了使数值原子轨道的动能积分是良定义的，需要使原子轨道的二阶导数连续。这可以通过将原子轨道的径向部分乘以一个平滑函数g(r)来实现 g(r)=1-\\exp \\left[-\\frac{\\left(r-r_{\\mathrm{c}}\\right)^2}{2 \\sigma^2}\\right], 该径向轨道会在数值原子轨道的截断值以内起作用，使其在截断值处2阶连续，超过阶段半径之后就严格截断。在我们的测试中，我们发现参数\\sigma对轨道的质量影响不大，所以我们一般固定\\sigma为常数0.1。 数值原子轨道动能和再次使用模拟退火算法：如果仅仅最小化溢出函数值，原子轨道的径向部分经常会出现震荡，原因是震荡有时候有利于溢出函数的值尽可能的低，但震荡厉害的函数往往动能高，可移植性较差。因此，为了去除这些实际上非物理的震荡，在算法中我们还定义了原子轨道的动能： T_{\\mu}=\\sum_{q} c_{\\mu q}^{2} q^{2} / 2+\\kappa, 并再次通过模拟退火算法最小化原子轨道的动能，其中\\kappa则是模拟退火的一个惩罚函数： \\kappa=\\left\\{\\begin{array}{ll} 0, & \\mathcal{S} / \\mathcal{S}_{0}-1\\Delta \\end{array}\\right., 这里\\mathcal{S}\\_{0}是在优化动能之前所得到的数值原子轨道算出来的溢出函数的值，而\\mathcal{S}则是当前在参数c_{\\mu q}下面的溢出函数的值。我们发现参数取\\Delta=0.002~0.005足够使得原子轨道平滑了。轨道动能也是通过同样的模拟退火算法得到，经过动能优化之后，轨道的形状会变平滑，同时溢出函数的值也会相比没有动能优化的轨道会有一点点增加，但是对精度的影响是很小的。 优化动能用的模拟退火算法几乎和优化溢出函数一样，除了一点点参数的区别。 目标函数选择的是所有轨道中最大的动能，而不是像溢出函数一样取平均值。对于每个轨道来说，温度是不一样的，因为每个轨道会有一个不同的动能，在这步动能优化中，我们发现结果对初始的温度不敏感，但最终达到的温度必须取得足够小。实际中我们发现只需要100~200步，动能就可以下降得很快。 所以一般来说优化动能的步数就取得比优化溢出函数要少。 二、ABACUS中产生数值原子轨道的具体流程 注：本文档介绍的是模拟退火算法SA，不适用于基于Pytorch的PyTorch-Gradient方法，关于这两个算法，可以参考本数值原子轨道中文文档系列的第三篇文档。 1. 平面波计算 简化计算量：前文我们提到的溢出函数公式，如果把投影子\\hat{P}带进公式，则可以发现我们不需要在计算溢出函数的时候显示的包含任何基矢量（例如平面波）的操作。实际上，我们只需要先算好数值原子轨道|\\phi_\\mu\\rangle和电子波函数|\\Psi_i\\rangle的重叠矩阵（Overlap Matrix）\\langle \\Psi_i|\\phi_\\mu\\rangle并存下来，以及数值原子轨道之间的重叠矩阵\\langle \\phi_\\mu|\\phi_\\nu\\rangle存下来就可以算溢出函数了。更进一步，我们意识到数值原子轨道|\\phi_\\mu\\rangle的径向部分在程序里是写成了球贝塞尔函数的线性组合，根据线性叠加的原理，我们只需要计算球贝塞尔函数和电子波函数的内积，以及球贝塞尔函数之间的内积，并把这些结果存下来，就可以优化系数c_{\\mu q}了！注意这里指标i遍历体系的所有电子态，包括所有的k点以及能带对应的电子波函数。 换句话说，只需要存储线性代数里的内积结果而不是每个波函数在基矢量下的展开系数就可以优化我们想要的系数，因此数值原子轨道的优化过程可以极大提速！ 采用ABACUS做平面波计算： 因此，第一步我们先调用ABACUS主程序，计算出以上overlap矩阵，首先需要准备INPUT文件如下： INPUT_PARAMETERS suffix H pseudo_dir /home/liuyu/github/abacus-develop/tests/PP_ORB wannier_card INPUTw calculation scf ks_solver dav nspin 1 lmaxmax 1 symmetry 0 nbands 10 ecutwfc 100 scf_thr 1.0e-7 scf_nmax 1000 smearing_method gauss smearing_sigma 0.01 mixing_type pulay mixing_beta 0.4 mixing_ndim 8 printe 1 bessel_nao_ecut 100 // same as ecutwfc bessel_nao_rcut 6 // rcut 如上所示，该INPUT与平常的平面波计算相比，只有3个参数（已标红）需要注意： wannier_card：指定wannier相关参数的输入文件名INPUTw bessel_nao_ecut：球贝塞尔函数的截断能，根据公式\\sqrt{E_{cut}} \\times r_{cut} / \\pi来决定求贝塞尔函数的数量 bessel_nao_rcut：数值原子轨道的截断半径r_{cut} 此外，我们还需要准备输入文件 INPUTw 如下（将来计划会把 INPUTw 文件去掉，把参数加入 INPUT 里）： WANNIER_PARAMETERS out_spillage 2 // output overlap spillage_outdir OUT.H // could be the same as OUT.${suffix} 通过 ABACUS 做平面波基矢量计算可以计算出： 1）电子波函数|\\Psi_i\\rangle和球贝塞尔函数 j_l(q r)之间的 overlap\\langle \\Psi_i|j_l(q r)\\rangle； 2）球贝塞尔函数之间的 overlap\\langle j_{l_2}(q_2 r)|j_{l_1}(q_1 r)\\rangle； 3）电子波函数|\\Psi_i\\rangle之间的 overlap\\langle \\Psi_i|\\Psi_i\\rangle。 这些输出将存在文件 OUT.${suffix}/orb_matrix.0.dat 中，而这个文件将被读入进行数值原子轨道的生成。 2. 编译 SIAB SIAB 的全称是 Systematically Improvable Atomic orbital Basis generator based on spillage formula，目前是包含在 ABACUS 软件里的一个独立程序，可用来读入以上 ABACUS 产生的数据文件并且生成数值原子轨道，具体编译方法如下： 拉取 deepmodeling/abacus-develop 仓库（github 和 gitee 二选一即可，国内建议用 gitee） # github仓库 $ git clone -b develop https://github.com/deepmodeling/abacus-develop.git # gitee仓库 $ git clone -b develop https://gitee.com/deepmodeling/abacus-develop.git 编译 SIAB 模拟退火（SA）方法生成数值原子轨道的代码在 SIAB 文件夹里，采用 C++ 编写，目前 Makefile 仅支持 intel 编译器。 SIAB 程序有串行（make s）和并行（make p）两种版本，一般情况下串行版本即可满足使用需求。 $ cd abacus-develop/tools/SIAB/SimulatedAnnealing/source $ make clean $ make s 编译成功后，在目录 abacus-develop/tools/SIAB/SimulatedAnnealing/source 下可以看到生成数值原子轨道的可执行程序 SIA_s.exe，这里 s 代表编译串行版(serial)。此外，对于并行版本，SIAB 还可以结合 MPI 编译并行版，通过命令 make p 指令得到 SIA_p.exe 可执行程序，这里 p 代表 parallel，但注意并行版只对某些特定算法进行并行，之后对代码进行一个更好整理之后我们会给出并行版的教程。 3. 运行例子 进入 tests_s 目录，可以看到 H-6-0.6.15.dat 文件，这是用来生成数值原子轨道所需要准备的输入文件，从 ABACUS 的平面波自洽迭代计算后获得，现在该文件已经改名为 OUT.${suffix}/orb_matrix.0.dat。 此外，还有一个输入文件 INPUT 如下： 1 // bool: calculate the spillage. 1/0 0 // bool: restart or not. 1/0 1 // bool: output the file. 1/0 1 // integer: number of structures. H-6-0.6.15.dat // Each structure's file name occupies one line 1 // integer: number of k points (for parallel version) 1 // integer: number of pools (for parallel version) 15 // can be ignored now 2 // The way to calculate spillage, 2 means averaged spillage 1.0e-8 // real: start temperature for minimizing spillage 0.5 // real: cooling rate for the temperature in minimizing spillage 2 // integer: number of temperatures (spillage) 500 // integer: number of steps per temperature (spillage) 1.0e-2 // real: starting temperature for the kinetic energy 0.8 // real: cooling rate for temperature in minimizing kinetic energy 1 // integer: number of temperatures (kinetic) 100 // integer: number of steps per temperature (kinetic) 0.05 // real: delta kappa for kinetic energy 49 // integer: selectly output information every n steps 100 // integer: change accept rate every n steps, can be ignored now 0.4 // real: acceptance rate (high), can be ignored now 0.2 // real: acceptance rate (low), can be ignored now 50 // real: max allowed kinetic energy (Rydberg) 0.01 // real: 'dr' for the 1d r grid to compute kinetic energy 1 // integer: 1: Kin 2: Ecut, can be ignored now 1 // bool: to control the number of bands 1 // int, the start band index(>0). 1 // int, the end band index( 2 // Number of levels. # label / na / skip / lmax / each L / 01 2 new 1 1 1 01 2 new 1 1 1 01 2 new 1 1 1 0.01 //dr(a.u.) of uniform mesh. Attention!!dr will affect kinetic energy minmized largely. -6 //xmin 1 //zed, chosen as valence charge. 0.01 //dx 6.0 //xmax 0 // print out the C4, this section can be ignored now 2 ./FILE/Si-S.ORBITAL 0 ./FILE/Si-P.ORBITAL 1 0 // for tests, can be ignored now 14.0 // rcut, only useful for test program 0.01 // dr, for simpson integral 2 // test eigenvalue index 2 // lmax C4：代表 4 个重要参数：\\alpha,\\xi,l,nq，\\alpha是原子种类的指标，\\xi是角动量l对应的径向函数的个数，nq 是对应的球贝塞尔函数的个数。 该输入文件包含 SIAB 程序需要读取的一系列参数，基本上重要参数的说明都有列上去，一些可忽略的参数可以先不用设置，之后我们会推出更详细的关于此输入文件的说明文档。 准备好该输入文件后，可以通过如下命令执行 SIAB 程序： $ ~/abacus-develop/tools/SIAB/SimulatedAnnealing/source/SIA_s.exe 运行完毕后，可以得到一系列输出文件，其中 ORBITAL_1U.dat 则是我们需要的数值原子轨道文件。我们可以通过文件的前几行获取关键信息：这是 H 原子的轨道文件，平面波截断能为 100 Ry，截断半径为 6 Bohr，最大角动量为 1，角动量 s 和 p 的径向函数的个数都为 2，即 2 条 s 轨道和 6 条 p 轨道，共 8 条轨道。为了体现这些关键信息，在使用轨道的时候我们建议重命名该文件为 H_gga_100Ry_6au_2s2p.orb。 --------------------------------------------------------------------------- Element H Energy Cutoff(Ry) 100 Radius Cutoff(a.u.) 6 Lmax 1 Number of Sorbital--> 2 Number of Porbital--> 2 --------------------------------------------------------------------------- SUMMARY END 三、ABACUS 中数值原子轨道的生成脚本 我们需要采用平面波计算不同键长的二聚体，并且存在不同层级的轨道，因此也可以通过一个脚本来实现自动化整个流程：abacus-develop/tools/SIAB/Generate_Orbital_AllInOne.sh。该脚本需要读入一个输入文件 ORBITAL_INPUT 如下： #1.exe_dir #-------------------------------------------------------------------------------- EXE_mpi mpirun -np 4 EXE_pw /home/liuyu/github/abacus-develop/build/abacus EXE_orbital /home/liuyu/github/abacus-develop/tools/SIAB/SimulatedAnnealing/source/SIA_s.exe #-------------------------------------------------------------------------------- #( In this part, the direction of the two used exe is provided ) #2.electronic calculatation #-------------------------------------------------------------------------------- targets 14_Si_60 # element ref_bands 4 6 # reference bands nbands 8 12 # num of bands for calculate Ecut 60 # cutoff energy (in Ry) Rcut 6 7 # cutoff radius (in a.u.) Pseudo_dir /home/liuyu/github/abacus-develop/tests/PP_ORB Pseudo Si_ONCV_PBE-1.0.upf smearing_sigma 0.01 # energy range for gauss smearing (in Ry) #-------------------------------------------------------------------------------- #( In this part , some parameters of calculating are given ) #3.structure information #-------------------------------------------------------------------------------- #the Bond Length list for each STRU BLSTRU1 1.8 2.0 BLSTRU2 2.4 # if skip the orbital optimization for each STRU (1:skip, 0:not skip). SkipSTRU 0 0 # set the objective structure list to fit for orbital optimization ListSTRU dimer trimer #-------------------------------------------------------------------------------- #(In this part, it gives us the bond length of the reference system(in angstrom) ) #4.orbital calculatation #-------------------------------------------------------------------------------- maxL 2 # the max angular momentum Level 2 3 # num of levels to generate orbitals( 该输入文件主要分为 5 个部分： 1. exe_dir EXE_mpi：MPI 并行计算命令，这里我们采用的是 4 核 MPI 并行进行 dimer（或者 trimer）的平面波计算。 EXE_pw：ABACUS 可执行程序的绝对路径。 EXE_orbital：数值原子轨道生成程序 SIA_s.exe 的绝对路径。 2. electronic calculatation targets：可以任取，一般格式是${原子序数}_${元素名}_${截断能}。 ref_bands：参考体系的能带数，取值为电子总数的一半。注意这里有多个取值，原因是我们选择了多组参考构型，既有 dimer，也有 trimer。 nbands：平面波计算中的实际能带数，必须大于 ref_bands，以保证包含非占据态。同理，由于多组参考构型，nbands 也有多个取值。 Ecut：平面波截断能，单位为 Ry。 Rcut：数值原子轨道的截断半径，单位为 Bohr。这里的多个取值表明，采用相同的一套参数，生成多个不同截断半径的数值原子轨道文件，根据第一部分的基础知识，截断半径会极大地影响数值原子轨道的质量，因此该参数可以帮助我们一次性生成多个不同截断半径的数值原子轨道文件。 Pseudo_dir：平面波计算采用的赝势文件所在文件夹的绝对路径。 Pseudo：平面波计算采用的赝势文件名。 smearing_sigma：平面波计算采用 Gaussian smearing 的展宽，单位为 Ry，一般取 0.01 即可。 3. structure information BLSTRU1：第一组参考构型的键长，单位为埃。如上所示，第一组参考构型包含两个构型，键长分别为 1.8 和 2.0 埃。 BLSTRU2：第二组参考构型的键长，单位为埃。如上所示，第二组参考构型包含一个构型，键长为 2.4 埃。 以此类推，可以存在 BLSTRU3、BLSTRU4 等等。 SkipSTRU：是否跳过该组参考构型的优化，一般而言，都取为 0 即可。 ListSTRU：指定 BLSTRU1、BLSTRU2 等等参考体系的具体构型，这里说明 BLSTRU1 是 dimer，BLSTRU2 是 trimer。如果取值缺省（第一个不可缺省），则默认为 dimer。 4. orbital calculatation maxL：最大角动量。 Level1：根据上文可知，轨道可以分为多个层级，这里 level1 是 SZ 层级，最大角动量为 1，角动量 s 和 p 的径向函数的个数为 1 和 1，即 1 条 s 轨道和 3 条 p 轨道。 Level2：同上，这里 level2 的最大角动量为 2，角动量 s，p 和 d 的径向函数的个数为 1，1 和 1，即 1 条 s 轨道，3 条 p 轨道和 5 条 d 轨道。level1 和 level2 合在一起，是 DZP 层级。 Level3：同 Level2。 Level：BLSTRU1 和 BLSTRU2 分别负责一部分轨道的生成，Level 的 2 个取值对应的是 BLSTRU1 和 BLSTRU2 的 endlevel，即 BLSTRU1 用于 level1 和 level2 轨道的生成，BLSTRU2 用于 level3 轨道的生成。 5. Metropolis parameters 如注释所说，这部分参数实际上大多数情况下不需要改变。 Start_tem_S：优化 Spillage 的初始温度，更高的初始温度可以搜索更大的温度范围。 Start_tem_K：优化动能的初始温度，更高的初始温度可以搜索更大的温度范围。 Step_S：优化 Spillage 的步数。 Step_K：优化动能的步数。 Delta_kappa：模拟退火的惩罚函数\\kappa所用的参数\\Delta。 准备好以上输入文件后，通过以下命令即可开始生成轨道： $ ~/abacus-develop/tools/SIAB/Generate_Orbital_AllInOne.sh ORBITAL_INPUT 四、ABACUS 中数值原子轨道的测试流程 在生成轨道之后，为了保证基于数值原子轨道基组的第一性原理计算拥有与平面波基组相当的精度，我们需要针对该元素的一些常见的晶体结构做一些验证性计算。 以 Al 元素为例，我们可以选择 simple cubic（sc），body center cubic（bcc），face center cubic（fcc）和 hexagonal close-packed（hcp）这 4 种常见的晶体结构，采用平面波（Plane wave）基组和数值原子轨道基组计算这些晶体结构的平衡晶格常数、体弹性模量等基态性质，评估两种基组之间的误差随着截断半径、最大角动量以及轨道数量的收敛趋势，选择合适的数值原子轨道文件。例如以下就是用 ABACUS 的平面波和数值原子轨道 DZP 计算的铝的四种体相材料的体积-能量曲线，来自文献[1]。从图中可以看到，DZP 轨道描述不同体相的铝的相对能量还是精度较高的。细心的读者会发现纵坐标给出的是绝对能量，因为两种基矢量采用了相同的赝势，但左图给出的能量更低，这是因为平面波更加完备，所以根据 Honhenberg-Kohn 定理，体系总能量的密度泛函可以在更完备的基矢量下得到更好的收敛，即总能量更低。一般来说，平面波得到的总能量比 DZP 轨道小一些，大概在 0.1-0.2 eV/atom，是比较合理的。如果采用了同样的赝势，但两种基矢量给出的能量差别远远大于这个数值，则要检查一下是不是数值原子轨道产生出了问题。最后，大家有任何问题，欢迎写邮件到文档开头邮箱。 五、参考文献 [1] M. Chen, G.-C. Guo, and L. He, Systematically Improvable Optimized Atomic Basis Sets for Ab Initio Calculations, J. Phys.: Condens. Matter 22, 445501 (2010). [2] M. Chen, G.-C. Guo, and L. He, Electronic Structure Interpolation via Atomic Orbitals, J. Phys.: Condens. Matter 23, 325501 (2011). Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-nac3.html":{"url":"abacus-nac3.html","title":"数值原子轨道（三）：产生高精度数值原子轨道","keywords":"","body":"数值原子轨道（三）：产生高精度数值原子轨道 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：林霈泽，邮箱：linpeize@sslab.org.cn 最后更新时间：2023/06/20 在Bohrium Notebook上快速学习： 一、PTG（PyTorch Gradient）方法 这篇文档是数值原子轨道系列的第三篇文档，除了第二篇文档提到的模拟退火算法之外，还可以使用 Pytorch 中的自动微分算法来最小化溢出函数。首先定义损失函数如下，并可以证明它与溢出函数是等价的： \\Delta \\mathrm{PSI} \\stackrel{\\text { def }}{=} \\frac{1}{N_n} \\sum_{n=1}^{N_m} \\|\\left|\\Psi_n\\right\\rangle-\\left|\\tilde{\\Psi}_n\\right\\rangle \\|^2, 其中 \\left|\\tilde{\\Psi}_n\\right\\rangle \\stackrel{\\text { def }}{=} \\hat{P}\\left|\\Psi_n\\right\\rangle, 且\\hat{P}是由所有原子轨道张成的投影子，即\\hat{P}=\\sum_{\\mu v}\\left|\\phi_\\mu\\right\\rangle S_{\\mu v}^{-1}\\left\\langle\\phi_v\\right| \\text {}。由 \\hat{P}^2=\\hat{P}及 \\left\\langle\\Psi_n|\\Psi_n\\right\\rangle=\\delta_{mn}可知，此处的损失函数\\Delta \\mathrm{PSI}与溢出函数是等价的。 二、PTG_dpsi（PyTorch Gradient with dpsi）方法 为了增加局域轨道做电子结构计算时的精度，损失函数的定义还可以被拓展，即在其中加入波函数的梯度，将总的损失函数定义为： \\Delta \\mathrm{PSI} \\stackrel{\\text { def }}{=} \\frac{1}{N_n} \\sum_{n=1}^{N_m} [\\|\\left|\\Psi_n\\right\\rangle-\\left|\\tilde{\\Psi}_n\\right\\rangle \\|^2+\\|\\left|\\nabla\\Psi_n\\right\\rangle-\\left|\\nabla\\tilde{\\Psi}_n\\right\\rangle \\|^2]. 由于投影波函数\\left|\\tilde{\\Psi}_{n}\\right\\rangle是数值原子轨道的线性组合： \\left|\\tilde{\\Psi}_{n}\\right\\rangle=\\sum_{\\mu} a_{\\mu n}\\left|\\phi_{\\mu}\\right\\rangle, 其中系数的表达式为 a_{\\mu n}=\\sum_{\\nu} S_{\\mu \\nu}^{-1}\\left\\langle\\phi_{\\nu} \\mid \\Psi_{n}\\right\\rangle. 那么投影波函数的梯度可以表示为数值原子轨道梯度的线性组合： \\left|\\nabla \\tilde{\\Psi}_{n}\\right\\rangle=\\sum_{\\mu} a_{\\mu n}\\left|\\nabla \\phi_{\\mu}\\right\\rangle. 因此，损失函数的梯度项可以转化为： \\begin{array}{l} \\|\\left|\\nabla \\Psi_{n}\\right\\rangle-\\left|\\nabla \\tilde{\\Psi}_{n}\\right\\rangle \\|^{2} \\\\ =\\left\\langle\\nabla \\Psi_{n} \\mid \\nabla \\Psi_{n}\\right\\rangle-\\sum_{\\mu} a_{\\mu n}\\left\\langle\\nabla \\Psi_{n} \\mid \\nabla \\phi_{\\mu}\\right\\rangle \\\\ -\\sum_{\\nu} a_{v n}^{*}\\left\\langle\\nabla \\phi_{v} \\mid \\nabla \\Psi_{n}\\right\\rangle+\\sum_{\\mu \\nu} a_{\\mu n} a_{v n}^{*}\\left\\langle\\nabla \\phi_{v} \\mid \\nabla \\phi_{\\mu}\\right\\rangle. \\end{array} 根据经验，使用这个算法生成的双重-ζ + 极化(DZP)基组，精度与模拟退火法或 PTG 法生成的三重-ζ + 双极化(TZDP)甚至四倍-ζ + 三重极化(QZTP)基组相当。 在平面波计算中，除了数值原子轨道（二）：生成给定模守恒赝势的数值原子轨道 提到的 overlap 输出文件 OUT.${suffix}/orb_matrix.0.dat 之外，overlap 输出文件 OUT.${suffix}/orb_matrix.1.dat 同样会作为生成轨道的输入文件之一，该文件保存与波函数梯度相关的如下 overlap 项： 1）电子波函数梯度|\\nabla \\Psi_i\\rangle和局域轨道梯度|\\nabla \\phi_\\mu\\rangle的 overlap，也就是电子波函数梯度|\\nabla \\Psi_i\\rangle以及球贝塞尔函数梯度\\nabla j_l(q r)之间的 overlap\\langle \\nabla \\Psi_i|\\nabla j_l(q r)\\rangle； 2）球贝塞尔函数梯度\\nabla j_l(q r)之间的 overlap\\langle \\nabla j_{l_2}(q_2 r)|\\nabla j_{l_1}(q_1 r)\\rangle； 3）电子波函数梯度|\\nabla \\Psi_i\\rangle之间的 overlap\\langle \\nabla \\Psi_i|\\nabla \\Psi_i\\rangle。 三、安装 Pytorch PTG 和 PTG_dpsi 方法采用 python 语言，无需编译，但是依赖 pytorch 包，下面介绍利用 conda 安装 pytorch 的方法： # 确定conda版本 $ conda -V conda 4.8.3 # 确定python3版本 $ python3 -V Python 3.5.2 # 创建python环境 $ conda create -n pytorch python=3.5 # 激活环境（每次使用pytorch需要激活该环境） $ source activate pytorch # 安装pytorch $ conda install pytorch torchvision torchaudio cpuonly -c pytorch # 安装依赖库 $ pip3 install --user scipy numpy $ pip3 install --user torch_optimizer # 退出python环境（使用完毕后） $ source deactivate 四、产生高精度数值原子轨道流程 首先下载 PTG_dpsi 仓库 # github仓库 git clone -b main https://github.com/abacusmodeling/ABACUS-orbitals 接着准备输入文件 SIAB_INPUT #-------------------------------------------------------------------------------- #1. CMD & ENV EXE_mpi mpirun -np 4 EXE_pw /home/liuyu/github/abacus-develop/build/abacus EXE_opt /home/liuyu/github/ABACUS-orbitals/SIAB/opt_orb_pytorch_dpsi/main.py #-------------------------------------------------------------------------------- #2. Electronic calculatation element Si # Element Name Ecut 100 # in Ry Rcut 6 7 # in Bohr Pseudo_dir /home/liuyu/github/abacus-develop/tests/PP_ORB Pseudo_name Si_ONCV_PBE-1.0.upf sigma 0.01 # energy range for gauss smearing (in Ry) #-------------------------------------------------------------------------------- #3. Reference structure related parameters for PW calculation #For the built-in structure types (including 'dimer', 'trimer' and 'tetramer'): #STRU Name #STRU Type #nbands #MaxL #nspin #Bond Length list STRU1 dimer 8 2 1 1.8 2.0 2.3 2.8 3.8 STRU2 trimer 10 2 1 1.9 2.1 2.6 #-------------------------------------------------------------------------------- #4. SIAB calculatation max_steps 200 # Orbital configure and reference target for each level #LevelIndex #Ref STRU Name #Ref Bands #InputOrb #OrbitalConf Level1 STRU1 4 none 1s1p Level2 STRU1 4 fix 2s2p1d Level3 STRU2 6 fix 3s3p2d #-------------------------------------------------------------------------------- #5. Save Orbitals #Index #LevelNum #OrbitalType Save1 Level1 SZ Save2 Level2 DZP Save3 Level3 TZDP 该输入文件同样包含 5 个部分： 1. CMD & ENV EXE_mpi：MPI 并行计算命令，这里我们采用的是 4 核 MPI 并行进行 dimer（或者 trimer）的平面波计算。 EXE_pw：ABACUS 可执行程序的绝对路径。 EXE_opt：数值原子轨道生成程序 PTG_dpsi 的绝对路径。 2. Electronic calculatation element：元素名。 Ecut：平面波截断能，单位为 Ry。 Rcut：数值原子轨道的截断半径，单位为 Bohr。这里的多个取值表明，采用相同的一套参数，生成多个不同截断半径的数值原子轨道文件，根据第一部分的基础知识，截断半径会极大地影响数值原子轨道的质量，因此该参数可以帮助我们一次性生成多个不同截断半径的数值原子轨道文件。 Pseudo_dir：平面波计算采用的赝势文件所在文件夹的绝对路径。 Pseudo：平面波计算采用的赝势文件名。 sigma：平面波计算采用 Gaussian smearing 的展宽，单位为 Ry，一般取 0.01 即可。 3. Reference structure related parameters for PW calculation STRU Name：参考构型组别 STRU1、STRU2、STRU3...... STRU Type：参考体系构型，一般可取 dimer，trimer，tetramer。 nbands：平面波计算中的实际能带数，必须保证包含非占据态。 MaxL：最大角动量。 nspin：自旋量子数。 Bond Length list：键长取值列表，单位为埃。以 STRU1 为例，这一组共有 5 个不同键长的 dimer 作为生成轨道的参考构型。 4. SIAB calculatation max_steps：优化步数 LevelIndex：轨道分层的 index，取 Level1、Level2、Level3...... Ref STRU Name：该层级的轨道采用哪一组参考构型生成。以上面的输入参数为例，Level1 和 Level2 的轨道采用 STRU1 组别的 dimer 参考构型生成，Level3 的轨道采用 STRU2 组别的 trimerr 参考构型生成。 Ref Bands：拟合参考体系的能带数，若输入“auto”则自动拟合所有基态。 InputOrb：是否在已有的轨道基础上生成新轨道，一般 Level1 设为 none，即没有旧轨道；Level2 一般以 Level1 生成的轨道为基础继续生成轨道，Level3 往后同理。 OrbitalConf：轨道的具体配置，这里 Level1 是 SZ 层级，Level2 是 DZP 层级，Level3 是 TZDP 层级，实际上还可以继续设置更高层级的轨道。 5. Save Orbitals Index：取值 Save1、Save2、Save3...... LevelNum：将特定 Level 的轨道保存到一个轨道文件中。以上面的输入参数为例，分别将 Level1、Level2、Level3 对应的轨道保存到单独的轨道文件中。 OrbitalType：即保存的轨道文件中，该轨道基组所属的层级。以上面的输入参数为例，分别为 SZ、DZP、TDZP。 准备好输入参数文件 SIAB_INPUT 后，运行如下命令即可开始生成轨道： $ python3 ~/github/ABACUS-orbitals/SIAB/SIAB.py SIAB_INPUT 程序正常结束后，轨道会分别保存在 Orbital_Si_SZ、Orbital_Si_DZP、Orbital_Si_TZDP 中，并自动命名成标准格式（如 Si_gga_6au_100Ry_2s2p1d.orb）。 五、参考文献 [1] Peize Lin, Xinguo Ren and Lixin He, Strategy for constructing compact numerical atomic orbital basis sets by incorporating the gradients of reference wavefunctions, Phys. Rev. B 103, 235131 (2021). Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-pw.html":{"url":"abacus-pw.html","title":"ABACUS 的平面波计算与收敛性测试","keywords":"","body":"ABACUS 的平面波计算与收敛性测试 作者：谢炘玥，邮箱：xyxie@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024/04/09 一、背景介绍 ABACUS(原子算筹)作为一款国产的电子结构软件，可用于对材料进行密度泛函理论（Density Functional Theory，简称 DFT）的第一性原理（first-principles）计算，其主要核心功能之一是电子自洽迭代计算(Self Consistent Field，简称SCF)，在给定材料微观层面的晶胞和原子位置的条件下，我们可以通过 SCF 流程的计算获得电子结构的总能量、能级、电子波函数、电子密度等关键信息，这些信息可用于进一步计算得出材料体系的其它性质。然而，对于初学者来说，初次运行 ABACUS 难免不熟悉输入参数，容易出错，要熟练掌握好 SCF 计算要领也颇具难度。因此，本文将主要针对初学者，详细介绍（1）如何采用ABACUS设置合理的输入参数完成一个SCF 计算，以及（2）如何对体系做收敛性测试，以便确定所有计算参数。这里收敛性测试包括在平面波（Plane Wave，简称 pw）基矢量下面对 ecut（电子动能截断值）进行测试，以及对布里渊区的 k 点个数进行测试来确定这些参数。 对密度泛函理论计算不太了解的读者，我们想先介绍密度泛函理论的三个特点。第一，只要给定原子坐标和种类，密度泛函理论就可以用于预测该体系的许多物理和力学等性质。第二，对于不同的原子坐标排列方式以及不同元素种类，密度泛函理论软件提供了一系列参数用于调节计算的精度和效率，只有将参数设定在某一些正确的范围之内，得到的结果才有意义。反之，如果参数过于粗糙，则得到的结果可能也不收敛，因此不具有价值。第三，密度泛函理论计算是一种虽然较为流行的但也相对昂贵的科学计算方法。笔记本电脑只能跑得动几个原子的小体系计算，真正数十个原子乃至更大的体系需要借助超算进行长时间的计算（几个小时甚至几天），而选择不同的参数可能会对最终运行时间有较大的影响。因此，基于以上三点认识，有必要更加细致地掌握密度泛函理论计算的具体参数，下面我们予以介绍。 二、输入文件简介 图 1. 电子自洽迭代计算流程。 图1：控制 SCF 的主要输入文件有三个。KPT 和 STRU 文件分别存储了布里渊区的信息和晶体结构的信息。此外 INPUT 文件主要存储了 5 部分信息，对应于下一章的小节序号，可以对应查看。n_0(\\vec{r})表示体系运行开始时的初猜电荷密度，\\widehat{H}表示电子系统的哈密顿量，\\varphi_{nk}(\\vec{r})表示波函数，其中n代表不同的能级，k代表体系的第一布里渊区里不同的采样点。\\varepsilon_{nk}表示特征值，N_{k}代表k点的个数，N_{occ}表示被电子占据的能级个数，f(\\varepsilon_{nk})表示电子的费米-狄拉克分布函数，n(\\vec{r})表示由波函数算出来的电荷密度，n_i(\\vec{r})表示迭代过程中第i步的电荷密度而n_{i+1}(\\vec{r})表示第i+1步的电荷密度。mixing\\_beta表示混合新电荷密度的比例（取值范围为 0~1）。ABACUS 支持平面波和数值原子轨道双基组，如果使用平面波基矢量，则数值原子轨道信息可以在 STRU 里不提供。 使用 ABACUS 中进行密度泛函理论或者第一性原理分子动力学计算时，一般需要 STRU、KPT、INPUT 三个最基本的文件作为 ABACUS 的基本输入文件。STRU 文件提供元素、晶格、原子的基本结构信息；KPT 文件提供周期性边界条件下布里渊区采样的网格设置。INPUT 文件主要提供计算所需的各种设置参数，在图1里我们分成了五部分且将在下面详细介绍。 三、STRU 和 KPT 文件简单介绍 1. STRU 文件 STRU 文件提供元素种类、原子质量（SCF 中不会用到）、赝势文件（如果做密度泛函理论计算）、数值原子轨道（如果采用该基组做计算）、晶格矢量、原子位置、原子位置是否可移动等基本结构相关的信息。其中，晶格是晶体中原子有序排列的具体形式，我们可以选取一组晶格矢量来描述晶格。晶格确定后，原子的相对位置也可以通过选取不同坐标系（例如 Cartesian 直角坐标系或者 Direct 晶格坐标系）确定下来。 例如，以下是一个金刚石硅的结构文件（8 个硅原子，周期性边界条件） ATOMIC_SPECIES Si 28.085 Si_ONCV_PBE-1.0.upf NUMERICAL_ORBITAL Si_gga_8au_60Ry_2s2p1d.orb LATTICE_CONSTANT 1.8897261258369282 LATTICE_VECTORS 5.4307000000 0.0000000000 0.0000000000 0.0000000000 5.4307000000 0.0000000000 0.0000000000 0.0000000000 5.4307000000 ATOMIC_POSITIONS Direct Si 0.0000000000 8 0.0000000000 0.0000000000 0.0000000000 1 1 1 mag 0.0 0.0000000000 0.5000000000 0.5000000000 1 1 1 mag 0.0 0.5000000000 0.0000000000 0.5000000000 1 1 1 mag 0.0 0.5000000000 0.5000000000 0.0000000000 1 1 1 mag 0.0 0.7500000000 0.7500000000 0.2500000000 1 1 1 mag 0.0 0.7500000000 0.2500000000 0.7500000000 1 1 1 mag 0.0 0.2500000000 0.7500000000 0.7500000000 1 1 1 mag 0.0 0.2500000000 0.2500000000 0.2500000000 1 1 1 mag 0.0 第 2 行 \"元素 原子质量 赝势\" 中的 \"原子质量\" 在进行 DFT 计算时不可以省略不写，哪怕在 SCF 中不会用到。那么什么时候会用到呢？比如在进行分子动力学（Molecular Dynamics，简称 MD，在 INPUT 的 calculation 参数里设置）计算时，涉及运动的积分方程时用的是牛顿的第二定律F=ma，此时会使用原子的质量。另外注意，此行需要提供所使用的 \"赝势\" 文件名称。 第 5 行提供 LCAO 基组所需的 \"某种元素的数值原子轨道\" 文件名称，而如果采用 pw 基组计算，不需要写第 4~5 行内容。 第 8 行代表晶格整体缩放的一个长度，注意1 Angstrom=1.8897261258369282 bohr，这里写 1.8 开头的小数意味着接下来的 LATTICE_VECTORS 部分可以写以 Angstrom 为单位的晶格。 第 11~13 行表示x,y,z方向分别对应的三条晶格矢量。 第 16 行 \"Direct\" 表示给出原子位置的方法是分数坐标（或者称为晶格坐标），常用的还有Cartesian(笛卡尔坐标方法)，就是直角坐标系下的坐标。 第 17 行是元素种类的名称。 第 18 行设置原子初始磁矩，如果 INPUT 里的 nspin 参数设为 1，则不考虑磁性，这个参数不起作用。 第 19 行表示体系的硅原子个数。 第 20~27 行给出所有 8 个硅原子的坐标；前三个数是坐标，之后的(1 1 1)三个数代表允许该原子在对应的x,y,z对应方向上移动，相反，(0 0 0)表示不允许在对应的方向上移动；同样，当考虑磁性计算的时候，\"mag 0.0\" 指定每个原子的初始磁矩，若设置此参数，则第 18 行的值将被覆盖。 关于赝势，还值得多提一些。平面波基组计算涉及采用描述电子和离子吸引作用的赝势，例如模守恒赝势或者超软赝势。需要注意的是，如果赝势换了，则相应的 ecut 能量截断值也需要重新测试收敛性。而基于局域原子轨道(Linear Combination of Atomic Orbitals，简称 LCAO)基组的计算则涉及赝势和数值原子轨道（Numerical Atomic Orbitals，简称 NAO），需要使用者准备好相应文件。这里提到的赝势是一种描述核外电子和离子之间相互作用的近似方法，数值原子轨道是通过数值方法构建的描述电子波函数和电子密度等性质的基函数。需要注意的是，LCAO 计算所采用的数值原子轨道要和对应的赝势匹配，即数值原子轨道是从给定赝势生成出来的，赝势如果改变了，相应的数值原子轨道也要重新生成，才能保证较好的精度。一般来说数值原子轨道的截断半径越长或轨道越多，则基矢量越完备，计算精度越高，但同时计算量也越大。 2. KPT 文件 KPT 文件提供周期性边界条件下布里渊区k点采样的网格设置 K_POINTS 0 Gamma k k k 0 0 0 第 2 行表示k点的总数，如果设置成 \"0\" 代表k点是自动生成的 如果第二行是 0，则第 3 行 \"Gamma\" (Γ-centered Monkhorst-Pack method)是选择以 Gamma 点为中心的 Monkhorst-Pack 方法划分布里渊区网格，此外还可以使用 \"mp\" 方法，即最常用的 Monkhorst-Pack 方法。 第 4 行的前三个整数代表网格沿着每个方向划分成几份，后三个数代表网格的平移量，0 0 0 即代表不平移。 计算立方形晶格时，k点各方向应取相同个数。在本次计算中，我们会将k的各方向从 2 取到 8，测试不同k点下体系能量的收敛情况。 在后文我们将介绍如何进行k点的收敛性测试，当选定一个k点后，若体系在某方向扩胞n次，该方向k点个数大致可以缩小到原来的\\frac{1}{n}。对于 N 原子以上的立方大体系，可通过在 INPUT 文件中设置参数 gamma_only 取 1，即只使用 Gamma 点计算，这个时候计算所需内存会显著下降，计算效率也会有提升。 此外，k点还有所谓的 line mode，或者离散的k点模式，若有兴趣的读者可以查看 KPT 的介绍文档（http://abacus.deepmodeling.com/en/latest/advanced/input_files/kpt.html）。 四、INPUT 文件关键输入参数 我们以金刚石结构硅原子体系（8 个原子）作为示例，进行电子自洽迭代计算(Self Consistent Field，SCF)。接下来让我们需要准备一个 INPUT 文件，我们把一些计算的关键参数分成如下 5 个部分。 1. 基本参数 suffix：suffix 是用户可以自定义的后缀，运行 ABACUS 可执行程序之后，输入文件所在的文件夹里会生成一个包含大部分运行信息的 OUT.suffix 文件夹。例如，在这个例子里我们可设为 \"Si\"，运行后就会产生一个 OUT.Si 文件夹。 calculation：设置本次计算类型，例如本次文档主要展示 \"scf\"(自洽电子结构计算)。scf((Self Consistent Field)、relax、cell-relax、md(Molecular Dynamics)是较常用的四类计算。 scf(自洽电子结构计算)是一种用于求解电子基态电子密度的自洽迭代计算方法，通过迭代来持续更新体系的电子密度，以达到收敛条件。通过电子自洽迭代，计算是否达到收敛由参数 scf_thr 决定。 relax(结构弛豫计算)是通过调整体系中原子的位置来达到系统最稳定的状态的计算方法，每一次 relax 中都包含若干步的 scf 计算。在 relax 中，需要设置参数 force_thr_ev (eV/Angstrom)，代表所有原子中最大受力的收敛阈值。而 relax 计算的收敛需要每一步离子迭代时 scf 中的 scf_thr 都满足，以及最后多步离子迭代后 force_thr_ev 也满足。 cell-relax(结构弛豫计算)与 relax 不同的是，其晶胞参数，比如晶格常数、晶格形状也会发生变化。除 force_thr_ev 外，还需要设置参数 stress_thr(kbar)，是晶胞感受到的应力的阈值。 md(分子动力学)基于牛顿力学原理，通过数值积分模拟粒子的运动轨迹，根据原子间的势能计算相互作用力，因此势函数的选择比较关键，在 ABACUS 里可以选择 DFT 来计算相互作用力，也可以选择 DP 势函数。 symmetry：是否考虑对称性，有如下三个选项 -1 不进行对称性分析 0 仅考虑时间反演对称性 1 进行对称性分析 如果打开对称性（设置为 1），布里渊区k点可以根据对称性进行简化处理，若体系有对称性，则可以减少所需计算的k点。因为每个k点都会进行一次 Kohn-Sham 方程的求解，对称性分析后若 k 点减少则将提升计算效率。本次计算中开启对称性分析，设置 \"1\"，关于对称性分析的测试还在进一步完善，如果计算结果奇怪，建议设置成 \"0\"之后再进行计算，比较结果是否一致。 pseudo_dir：计算中需要使用赝势来近似离子和电子相互作用势能，为计算提供赝势文件。pseudo_dir指定 STRU 文件中赝势文件所在的目录。本次计算将赝势和轨道文件都与 INPUT、STRU、KPT 文件放在一起，因此填入 \".\"，表示处在当前文件夹中。 ABACUS 支持的赝势文件——Si_ONCV_PBE-1.0.upf \"ONCV\"代表模守恒赝势的种类，\"PBE\"是采用的交换关联泛函。 orbital_dir：本次计算将采取 pw（平面波轨道）基组（后文 basis_type 中设置）。若采用 LCAO 基组进行计算，则需要提供作为基组的轨道文件，在 STRU 文件中指定轨道文件所在的目录。若选用 pw 基组，则不需要轨道文件，不需要填写此参数。常用的轨道有：DZP（Double-ζ valence orbitals plus SZ polarization，两条径向轨道和一条杂化轨道）,TZDP（Triple-ζ valence orbitals plus DZ polarization，三条径向轨道和两条杂化轨道）。 ABACUS 支持的轨道文件——Si_gga_7au_100Ry_2s2p1d.orb： \"gga\"代表 GGA 泛函；\"7au\"是轨道半径，半径越大，计算结果会更准确，但花费时间也更久；\"100Ry\"是推荐的 ecutwfc 值；\"2s2p1d\"表明采用了 DZP 轨道，轨道数目越多，即基矢量更完备，计算也会更准确。 basis_type：计算的基组（指描述电子波函数的基函数），在 ABACUS 中常用的有两种： pw：平面波基组（由于基矢量更完备，pw 计算将更准确，同时计算时间也更长） LCAO：局域原子轨道基组（没有 pw 准确，但效率高） ecutwfc：平面波函数的能量截止（单位：Ry），在平面波基组里是很重要的一个参数，其大小决定着作为基矢的平面波函数的个数多少，而基矢的多少，也决定了计算精度的高低。 在本次计算选用的 LCAO 基组中，一般选取轨道文件上推荐的值，设置 \"100\" Ry 即可。 本次计算中选择 pw 基组。如前所述，pw 中不会用到轨道文件。 我们目前填写好的基本参数如下： #Parameters (1.General) suffix Si calculation scf symmetry 1 pseudo_dir . orbital_dir . basis_type pw ecutwfc 100 2. SCF 迭代参数 scf_nmax：针对每个离子构型，scf 电子迭代的最大次数为 scf_nmax，可设为\"50\"或\"100\" 次。半导体和绝缘体是较容易收敛的体系，一般 20 步 scf 以内即可达到收敛，对于金属体系或者费米面较为复杂的体系，有可能 50 步仍未收敛。注意，如果做 relax, cell-relax, 或者 md 的时候发现有某些 scf 迭代次数达到最大时仍未达到收敛条件，建议先把计算停下来弄清楚原因后再继续算，有可能是因为离子构型或者k点等参数的设置不合理引起的。 scf_thr：代表两个相邻电子迭代步之间的电荷密度误差，也是 SCF 计算中判断是否收敛、完成计算的标准，对于 LCAO，一般设置为 \"1e-7\"，可认为精度足够。对于 pw，建议设置 1e-8 或 1e-9 的精度。 #Parameters (2. SCF iterations) scf_nmax 100 scf_thr 1e-8 3. 求解 Kohn-Sham 方程 nbands：计算的 Kohn-Sham 轨道数目，在本次计算中无磁性，参数 nspin 取 1（默认值），程序目前采取 0.5*max(1.2*occupied_bands, occupied_bands + 10) 计算 nbands。 对于 Si，价电子数为 4，每个能级填充可以填充自旋向上和向下 2 个电子，金刚石结构中共有 8 个原子，则nbands=max(1.282，8*2+10)=26。 ks_solver：在不同基组中展开哈密顿矩阵的对角化方法，对于 pw，可以选择 cg(Conjugate Gradient，默认方法)，bpcg(还不是太稳定、测试中)，dav(Davidson 算法)；对于 LCAO，可以选择 genelpa(默认值)，scalapack_gvx(Scalable Linear Algebra PACKage)。如果选用 LCAO 基组，ks_solver 可设置为\"genelpa\"。 #Parameters (3. Solve KS equation) nbands 26 ks_solver cg 4. 展宽技术 smearing_method：对于金属体系或者费米面附近较复杂的体系，电子自洽迭代方法往往不容易收敛，这个时候可以选择给电子提供一个光滑的占据函数，用来调节程序计算电荷密度和总电子数时候的电子占据函数，这对于费米面附近的电子态尤为重要。我们这里称为 \"smearing method\"，或者称为展宽方法。具体来说，对于金属体系可以选择 mp(methfessel-paxton)，mp2(2-nd methfessel-paxton) ，也可以使用 gauss(也可以写作 gaussian)。因为我们计算金刚石 Si 具有半导体性质，所以 smearing 方法基本不起作用，默认可以选择 gauss。此外，非导体计算可以选择 fixed，半导体和非导体也可以选择 fd(Fermi-Dirac)方法。 smearing_sigma：给定展宽方法的能量范围（单位：Ry），默认是 0.015 Ry，我们按照通常情况给定 \"0.01\"。 #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.01 5. 电荷密度混合 mixing_type：进行新旧电荷密度混合时选用的方法，可选 \"plain\"(简单电荷密度混合方法，如图 1 所示)、\"pulay\"、\"broyden\"），默认选择 \"broyden\"算法。 mixing_beta：新旧电荷密度混合时，新电荷的比例，不同系统取值不同。能带大于 1 eV 的体系，设为 0.7；能带小于 1 eV 的金属和过渡金属，设为 0.2。这个参数越大，收敛得越快，但不收敛的风险也会变大，不过取值大小并不会改变基态能量的结果。对于 Si，因为其能带隙为 1.12 eV，本计算中设置此参数为 \"0.7\"。 mixing_gg0：电子迭代过程中，可能出现混合电荷密度不收敛的情况，此时可以通过一种叫 Kerker Mixing 的方法来加快收敛。这个参数代表 Kerker 方法中调整电荷密度的尺度，本计算中设置此参数为 \"0\"。 #Parameters (5.Mixing) mixing_type broyden mixing_beta 0.7 mixing_gg0 0 到此，我们完成了对主要计算参数的设置，此时集成了以上主要参数的 INPUT 文件如下： #Parameters (1.General) suffix Si calculation scf symmetry 1 pseudo_dir . orbital_dir . basis_type pw ecutwfc 100 #Parameters (2. SCF iterations) scf_nmax 100 scf_thr 1e-8 #Parameters (3. Solve KS equation) nbands 26 ks_solver cg #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.01 #Parameters (5.Mixing) mixing_type broyden mixing_beta 0.7 mixing_gg0 0 五、收敛性测试 1. Ecut 收敛（只对平面波有效） 平面波（pw）作为一种可以用于描述周期性边界条件下的电子波函数和电荷密度基矢量，它们都是正交的，且可以通过一个 ecutwfc 参数来控制基矢量的个数，ecut 其实代表了每一个平面波所对应的动能，如果 ecut 取得越大，则基矢量可以描述震荡得越剧烈的物理量（例如氧原子的 2p 轨道），那么计算结果就会越精确，但同时所带来的机时成本消耗也越大。因此我们采用 pw 基组做真正计算前，需要对 ecut 进行测试来获得一个足够准确且效率也高的取值。 保持前文用于计算的基组为\"pw\"，进行 ecut 的收敛性测试，ecut 取值范围为：20~100 Ry。这个例子在 4 进程下启动 MPI 进行并行计算，一般推荐总核数(=线程数*进程数)取 2 的 n 次方或者 n 倍。一个较为粗糙、但基本不会造成计算资源浪费的选取 n 值原则是：体系有多少个原子，不要用超过这个原子个数太多的总核数进行并行计算。例如，体系如果有 16 个原子，不要用远大于 16 的总核数进行计算，一般取 16 的总核数或者更少就够了，具体需要测试。 mpirun -n 4 abacus 计算完成后，建议用脚本提取 ecut 数值下OUT.Si文件夹里running_scf.log文件中收敛的系统总能量，计算单原子能量并绘制其随着 ecut 的变化曲线。如图2，可以看见随 ecut 增大，系统总能量趋于收敛。在 ecut=60 Ry 时，认为总能量收敛(与 ecut=50 Ry 的能量差小于 1 meV/atom)。 图 2. 体系里平均单个Si原子能量(in eV/atom)随ecut (in Ry)变化。 2. k 点收敛 对具有周期性的体系进行计算时，DFT 计算实际会对第一布里渊区中不同离散化k点的单独进行计算（例如每个k点都会单独求解一次依赖于该k点的 Kohn-Sham 方程），并将计算结果进行积分。k点越多，则需要求的离散积分就越多，也将越近似连续积分的结果，但计算资源也会增加。因此，pw 和 LCAO 都有必要对 \"需要多少k点\" 进行测试并得出合适的k点选取方案。 金刚石Si的k点测试结果。同样在4进程下进行并行计算。 mpirun -n 4 abacus 计算完成后，提取各 K 点下OUT.Si文件夹里running_scf.log文件中收敛的系统总能量和计算时间，绘制这两个参数随 K 点的变化曲线。此处，N_k表示各方向上的k点取值个数，\"Energy-N_k\" 图中采用单原子的能量。 分析图3和图4可知，在N_k=6时，结果已收敛，能量不会再发生较大的变化(与N_k=5的能量差小于 1 meV/atom)，而此时花费时间 132 秒，相比于更大的N_k点较低。因此选择 6×6×6 的k点可以同时获得准确的结果和高的计算效率。 图 3. 体系里平均单个Si原子能量(in eV/atom)随K点变化。 图 4. 计算时间随K点变化。 提取出每个计算中实际使用到k点个数，如表一所示，实际使用k点数相比总k点数有较明显的简化。如前所述，INPUT 文件中我们设置了参数 symmetry 取 \"1\"，因此在实际计算中利用了晶胞结构中的对称性，即倒易空间的积分没有使用所有的k点计算，而是巧妙的利用了对称性得到其它k点的信息，简化了布里渊区中的计算工作量。这也解释了图4中明明总k点数不同，计算时间却十分接近的原因。 表一、N_k点数，总k点数，实际使用k点数： N_k 2 3 4 5 6 7 8 总k点个数 8 27 64 125 216 343 512 实际计算k点数（开了对称性） 4 4 10 10 20 20 35 以上就是本教程的内容，希望对学习密度泛函理论计算的初学者有所帮助。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-libri.html":{"url":"abacus-libri.html","title":"ABACUS+LibRI 做杂化泛函计算教程","keywords":"","body":"ABACUS+LibRI 做杂化泛函计算教程 作者：梁馨元，邮箱：2201111875@stu.pku.edu.cn 审核：林霈泽，邮箱：linpeize@sslab.org.cn 最后更新时间：2023/08/21 在Bohrium Notebook上快速学习： 一、介绍 杂化泛函（Hybrid Functional）是指在密度泛函理论框架中的交换关联项里面加入一部分的 Hartree Fock (简称 HF)的精确交换能。开源密度泛函理论软件 ABACUS 可以结合另一款国产开源软件 LibRI 软件进行杂化密度泛函计算，目前仅支持在数值原子轨道基组下使用该功能。可以通过 dft_functional 参数指定所使用的杂化泛函类型，如可以选择 hf (Hartree-Fock), pbe0(PBE0), hse(HSE06)以及 scan0 杂化泛函。本教程以 HSE 杂化泛函为例，介绍如何在 ABACUS 里调用 LibRI 做杂化泛函自洽迭代、求力和应力以及结构优化。 注 1：使用 ABACUS+LibRI 做杂化泛函计算时，最大并行核数是N_a^4N_K^3，其中N_a是原子个数，N_k是 k 点个数。计算资源超出时可以运行，但会造成浪费。 注 2：使用 ABACUS+LibRI 做杂化泛函计算时，因为内存消耗比较大，推荐给定计算资源的前提下，先尽量使用 OpenMP 多线程并行，再考虑使用 MPI 多进程并行。 二、杂化泛函的使用 1. ABACUS 编译准备 如果要在 ABACUS 中使用杂化泛函进行计算，需要在编译 ABACUS 的时候也编译 Libxc、LibRI 和 LibComm 三个软件包，具体请见线上文档 Advanced Installation Options ‒ ABACUS documentation。 注意在链接 LibRI、LibComm 时如果报错未定义的引用等，可以先注意检查 ABACUS 源代码下 deps 文件夹下是否包含 LibRI、LibComm 两个文件夹。如果未包含这两个文件夹，或文件夹中无内容，在本地Github仓库中可以尝试如下两条语句，以获取这两个子仓库内容： git submodule init git submodule update --remote --recursive 2. 采用杂化泛函进行电子自洽迭代计算 本教程在 Gitee 上准备了一个硅晶体使用杂化泛函做自洽计算（SCF）的例子（Gitee 的下载链接），以下是 INPUT 文件及相关的参数。由 dft_functional 设置为 hse 可知，该例子使用的杂化泛函为 HSE 泛函。KPT 文件取的是 444 的布里渊区 k 点。 INPUT_PARAMETERS calculation scf basis_type lcao ntype 1 nbands 8 ecutwfc 60.0 scf_nmax 100 dft_functional hse scf_thr 1e-7 杂化泛函相关的完整参数列表及解释见 Full List of INPUT Keywords / exact-exchange ‒ ABACUS documentation。这里再进行简单概述： 泛函相关参数： exx_hybrid_alpha：杂化泛函中加入的 HF 精确交换能（Fock 交换能）的比例α，即有E_x=αE_{x}^{HF}+(1-α)E_{x}^{LDA/GGA}。如果 dft_functional 设置为 hf，则默认值为1。目前其他杂化泛函的默认值是0.25。但是，如果是 SCAN0 泛函，有的文献取的是 0.1，所以需要根据你想取的值进行设定[1]。 exx_hse_omega：为 HSE 泛函中的区间分割参数（range-separation parameter）\\omega，即有\\frac{1}{r}=\\frac{erfc({\\omega}r)}{r}+\\frac{erf({\\omega}r)}{r}。默认值为0.11（bohr^{-1}），此时为 HSE06 泛函[2]。 exx_lambda：在 basis_type 设置为 lcao_in_pw 的情况下，用于补偿使用 lcao_in_pw 方法评估精确交换能时 G=0 处的发散点。默认值为0.3。 exx_real_number：该参数设定为 True 时，强制 LibRI 使用 double 数据类型，当设定为 False 时，强制 LibRI 使用 complex 数据类型。当gamma_only=1 时，默认为 True，gamma_only=0 时默认为 False。 循环相关参数： exx_separate_loop：ABACUS 提供了两种迭代方法来评估精确交换能E_{exx}。当 exx_separate_loop 设置为False时：采用单层循环，即先进行 GGA 循环，然后进行 Hybrid 循环，在该过程中，使用电子迭代来更新E_{exx}对应的哈密顿量H_{exx}。当 exx_separate_loop 设置为True时：采用双层循环，在内层循环中，进行自洽迭代并更新密度矩阵，在外层循环中，根据在内层循环中收敛的密度矩阵来计算H_{exx}。默认值为 True，即采用双层循环计算。单层循环有利于难以自洽收敛的体系达到收敛，但会显著增加内存消耗。 exx_hybrid_step：在 exx_separate_loop 设置为 True 的情况下，外层循环的最大迭代步数。默认值为100。 exx_mixing_beta：在 exx_separate_loop 设置为 True 的情况下，内层循环每次迭代时，密度矩阵混合的 mixing_beta 取值，默认为1.0。 exx_pca_threshold：为了加速四中心积分\\langle ik\\vert\\ jl\\rangle的计算，ABACUS 采用 LRI 方法，将原子轨道的乘积在辅助基函数(ABF)的基础上展开，即\\Phi_i\\Phi_j \\approx \\sum_aC_{ij}^aP_a，并利用 PCA 减小辅助基函数(ABF)的大小(即P_a个数)。阈值越大，ABF 的数目越少，计算速度越快，计算精度越低。一个相对安全的值是1e-4，也是默认值。 exx_ccp_rmesh_times：此参数决定计算 Columb 势所需的截断半径比原子轨道的截断半径大多少倍。对于 HSE 泛函，设置为 1 就足够了。但是对于 PBE0，必须使用一个大得多的数字。当使用 HSE 泛函时，默认值为1.5，其他情况下默认值为5。 张量筛选相关参数： 针对杂化泛函计算过程中的物理量进行筛选可以加速计算。具体来说，exx_c_threshold、exx_v_threshold、exx_dm_threshold、exx_c_grad_threshold、exx_v_grad_threshold 分别是针对C_{ij}^a、V_{ab}=\\langle P_a\\vert\\ P_b\\rangle、密度矩阵、\\nabla C_{ij}^a、\\nabla V_{ab}。阈值越大，筛掉的张量越多，计算速度越快，计算精度越低。具体请查看完整 INPUT 参数文档。 Cauchy-Schwartz 不等式相关参数： exx_cauchy_threshold：在实际中，Fock 交换矩阵是稀疏的，利用 Cauchy-Schwartz 不等式，我们可以在进行显式求值之前找到每个矩阵元素的上界。小于 exx_cauchy_threshold 的值将被截断。阈值越大，筛掉的张量越多，计算速度越快，精度越低。一个相对安全的值是1e-7，也是默认值。不等式算法参见参考文献[3]。 exx_cauchy_force_threshold、exx_cauchy_stress_threshold与exx_cauchy_threshold类似，区别在于它们分别针对的是求力、应力计算中的 Fock 交换矩阵元。 opt_orb 相关参数：当dft_functional设置为 opt_orb 时使用，opt_orb 参考文献[4]。本功能仅用于生成 opt 辅助基组，不进行杂化泛函计算。 exx_opt_orb_lmax：球贝塞尔函数的最大角动量 L 值，opt-ABF 的径向部分用球贝塞尔函数的线性组合生成。 exx_opt_orb_ecut：球贝塞尔函数展开的截断，在优化 opt-ABF 的时候采用的是球贝塞尔函数基组。 exx_opt_orb_tolerence：解球贝塞尔函数零点时的阈值。 3. 杂化泛函计算代价 杂化泛函的计算精度高，与此同时它的计算代价也比较高。在 ABACUS 的输入参数文件 INPUT 中，若 exx_separate_loop 参数设为 True（默认），仅在 SCF 步骤中就涉及两层循环。每次内层循环完成，外层循环往前推进一步时，屏幕输出 Updating EXX and rerun SCF。 一次 SCF 需要的时间至少是以上两个循环涉及的单次电子迭代时间之和。对于单次电子迭代所需时间，在此提出一些已有的经验。以一步电子迭代的时间为衡量尺标，使用 DZP 基组，CPU 型号为 Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz，使用 4 核计算一个水分子为 0.6s 左右，使用 14 个核计算 32 个水分子为 0.8s 左右，使用 14 个核计算 64 个水需要 1.9s 左右。 若将 exx_separate_loop 参数设为 False，即使用单层循环时，首先会进行 GGA 迭代直到自洽收敛，然后屏幕输出 Entering 2nd SCF, where EXX is updated，进行 Hybrid 迭代，此时每进行一次电子步得到新的密度后，都会更新一次精确交换能。以一步电子迭代 + 更新精确交换能的时间为衡量尺标，使用 DZP 基组，CPU 型号为 Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz，使用 4 核计算一个水分子为 0.7s 左右，使用 14 个核计算 32 个水分子为 115s 左右，使用 14 个核计算 64 个水需要 330s 左右。对于更大的体系，如 2048 个 Si 原子的晶体，使用 DZP 基组，CPU 型号为 Intel(R) Xeon(R) Silver 4310 CPU @ 2.10GHz，用一个节点（56 核）算时，PBE 下一步电子迭代大概需要 380s，而 HSE 一步电子迭代 + 更新精确交换能大概需要 1680s。 在进行杂化泛函计算时推荐尽量使用多线程计算（OpenMP），此时内存开销相对较小，计算速度相对较快。 三、使用杂化泛函做结构优化 1. 数据准备 在 Gitee 上我们准备了一个简单的使用杂化泛函做结构优化的例子。该例子是在 LCAO 基组下，使用 HSE 泛函，优化单个水分子的结构。文件夹中 log.ref 是使用 3.2.1 版本的 ABACUS 软件包，v0.1.0 版本的 LibRI 和 LibComm 计算所得的屏幕输出。 2. 输入文件 准备计算所需的 INPUT 文件、STRU 文件、KPT 文件，以及 H、O 原子对应的数值原子轨道文件。其中 INPUT 文件如下。注意该文件中指明了计算类型为 relax，即不对晶胞做优化（cell relax），只对原子位置做优化（relax）。更多结构优化类型请看文档 Geometry Optimization ‒ ABACUS documentation。 INPUT_PARAMETERS calculation relax basis_type lcao ntype 2 ecutwfc 60.000000 scf_nmax 100 gamma_only 1 dft_functional hse relax_nmax 100 scf_thr 1e-6 force_thr_ev 1e-2 在该例子中，结构优化包括多个离子步，每个离子步中都要做一次 SCF。由 INPUT 文件可知，SCF 收敛的标准由 scf_thr=1e-6 指定，或达到 SCF 的最大步数 scf_nmax=100，并计算受力。根据上一个离子步计算得到的受力，计算下一个离子步的原子位置，计算收敛的标准此时为 force_thr_ev=1e-2，或达到离子步的最大步数 relax_nmax=100。STRU 文件如下，可见在结构弛豫步骤中，三个原子都可以移动。 ATOMIC_SPECIES O 16.00 O_ONCV_PBE-1.0.upf H 1.00 H_ONCV_PBE-1.0.upf LATTICE_CONSTANT 1 LATTICE_VECTORS 28 0 0 0 28 0 0 0 28 ATOMIC_POSITIONS Direct O #label 0 #magnetism 1 #number of atoms 0.677639488918 0.5227809096584 0.232500040128 m 1 1 1 H #label 0 #magnetism 2 #number of atoms 0.641808457616 0.5785821615863 0.228644198512 m 1 1 1 0.708889637644 0.5204300746076 0.175087721492 m 1 1 1 NUMERICAL_ORBITAL O_gga_6au_60Ry_2s2p1d.orb H_gga_6au_60Ry_2s1p.orb 3. 结果 结构弛豫（relax）后的原子结构可见 OUT.ABACUS/STRU_ION_D。由输出文件可知，即使该例子中采用了相对稳定的构型，且 scf_thr 仅设为 1e-6，使用 HSE 做结构弛豫的计算代价仍然很高，使用 6 个核（Intel(R) Xeon(R) Gold 6132 CPU @ 2.60GHz）计算需要 5 分钟左右。 四、参考文献 [1] Staroverov V N, Scuseria G E, Tao J, et al. Comparative assessment of a new nonempirical density functional: Molecules and hydrogen-bonded complexes[J]. The Journal of chemical physics, 2003, 119(23): 12129-12137. [2] Aliaksandr V. Krukau, Oleg A. Vydrov, Artur F. Izmaylov, Gustavo E. Scuseria; Influence of the exchange screening parameter on the performance of screened hybrid functionals. J. Chem. Phys. 14 December 2006; 125 (22): 224106. [3] Lin P, Ren X, He L. Efficient hybrid density functional calculations for large periodic systems using numerical atomic orbitals. Journal of Chemical Theory and Computation, 2021, 17(1): 222–239. [4] Lin P, Ren X, He L. Accuracy of localized resolution of the identity in periodic hybrid functional calculations with numerical atomic orbitals[J]. The Journal of Physical Chemistry Letters, 2020, 11(8): 3082-3088. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-conv.html":{"url":"abacus-conv.html","title":"ABACUS 收敛性问题解决手册","keywords":"","body":"ABACUS 收敛性问题解决手册 作者：周巍青，邮箱：zhouwq@aisi.ac.cn 单位：北京科学智能研究院（AISI） 最后更新日期：2024/2/22 如果遇到手册中无法解决的收敛性问题，欢迎给 ABACUS 提出 Issues，我们将持续更新这个文档 可选参数 mixing_type 描述：混合电荷密度所使用的方法 可选：broyden，pulay，plain 默认值：broyden 说明：没有特殊理由，不建议更改这个参数 mixing_ndim 描述：DIIS 混合计算混合系数时会保存的历史电荷密度数目 可选：int 默认值：8 说明：一般而言，这个值越大，收敛性越好，但是代价是内存消耗线性增加，8 一般是够用的。 mixing_beta 描述：电荷密度的混合系数，1.0 时表示全部用输出电荷，0.0 时表示全部用输入电荷 可选：double 默认值：0.8（nspin=1）；0.4（nspin=2|4） 说明：一般而言，这个值越大，收敛越快，但是 SCF 跑飞不收敛的风险也越大；这个值越小，收敛越慢，但是收敛会更稳定，不收敛的情况会减少。 mixing_gg0 描述：电荷密度混合时所做的 kerker 预处理的强度。Kerker 预处理会显著降低一些低频长程的电荷波动，对于金属性体系的收敛帮助极大。 可选：double 默认值：1.0 说明：默认 1.0 代表 ABACUS 默认打开 kerker 预处理，你可以手动设置成 0.0 将其关闭。一般而言，绝缘体/分子/原子体系中 kerker 预处理的效果不明显，甚至有负优化，可以关闭。 mixing_gg0_min 描述：电荷密度的混合系数，所做的 kerker 预处理中，小于这一$|q|$的电荷分量不再进一步衰减 可选：double 默认值：0.1 说明：没有特殊理由，不建议更改这个参数 mixing_beta_mag 描述：磁密度的混合系数，只在 nspin=2|4 时才会启用 可选：double 默认值：4*mixing_beta，但是最大不超过 1.6 说明：与电荷密度的混合类似，这个值越大，收敛越快，但是 SCF 跑飞不收敛的风险也越大；这个值越小，收敛越慢，但是收敛会更稳定，不收敛的情况会减少。 mixing_gg0_mag 描述：磁密度的混合时所做的 kerker 预处理的强度 可选：double 默认值：0.0 说明：默认 0.0 代表 ABACUS 默认关闭对磁密度的 kerker 预处理，你可以手动设置成非零将其打开。一般而言，对于磁密度的 Kerker 预处理物理意义并不明确，不建议打开。 mixing_angle 描述：使用J. Phys. Soc. Jpn. 82 (2013) 114706中所描述的角度混合来更新电荷密度，只在非共线计算，即 nspin=4 时才可以启用 可选：double 默认值：0.0 说明：默认 0.0 代表 ABACUS 默认不使用这个方法，还是默认优先使用传统的 DIIS 混合。你可以手动设置成非零将其打开。这一方法可以解决非共线计算中磁矩收敛困难、收敛到错误磁态的问题。 mixing_tau 描述：是否混合动能密度，只在 metaGGA 计算中才能使用 可选：bool 默认值：false 说明：ABACUS 默认不混合动能密度。但是打开一般会提升收敛性。 mixing_dmr 描述：使用混合电荷密度的系数，同样混合密度矩阵。打开这一参数的前提必须同时设置 mixing_restart 可选：bool 默认值：false 说明：ABACUS 默认不混合密度矩阵。如果你在进行需要密度矩阵构建算符的计算，例如 DFT+U/EXX/DeePKS，你可以试图打开 mixing_dmr。经过我们大量的 DFT+U 算例测试，mixing_dmr 配合一个合适的 mixing_restart 会显著地提升 ABACUS 计算的收敛性。 mixing_restart 描述：在第 mixing_restart 步 SCF 清空 mixing 的历史，直接使用上一步的输出作为这一步的输入，一般与 mixing_dmr 配合使用 可选：int 默认值：0 说明：ABACUS 默认不进行 restart，一个不适合的 mixing_restart 设置可能导致计算收敛不了。 如果收敛困难怎么办 非磁计算（nspin=1） 非磁实际上可调的自由度不多，所有体系都可以遵循的原则如下： 尝试调小 mixing_beta 尝试调大 mixing_ndim 分情况，你可以进一步有如下特殊的操作： 原子分子体系 原子分子的电荷高度局域，Kerker 预处理一般都难以实际取得正优化，你可以选择关闭 Kerkerk 预处理，mixing_gg0=0.0。 半导体/绝缘体 虽然绝缘体部分电子态也很局域，但是 Kerker 预处理一般是安全的，即使负优化也不会很严重，但是你仍可以选择关闭 Kerkerk 预处理，mixing_gg0=0.0。 金属 调节不同的 mixing_gg0、mixing_gg0_min。 metaGGA 计算 打开 mixing_tau=true。一般会解决 metaGGA 收敛困难，以及 EDIFF 慢于 DRHO 的问题。 检查初始构型 一般而言，你不会在非磁计算遇到收敛性问题。如果真的遇到了，有很大概率初始构型太差，你可以调整构型，或者用先用宽松的收敛判据做几步弛豫计算，让体系构型更合理之后再调小 scf_thr。 共线磁性计算（nspin=2） 磁性计算中所有体系都可以遵循的原则如下： 尝试调小 mixing_beta，并等比例调小 mixing_beta_mag 尝试调大 mixing_ndim 分情况，你可以进一步有如下特殊的操作： 原子分子体系 孤立体系的磁性计算如果出现无法收敛，那大概率是出现一种极端的情况，即某一自旋全部来自某一轨道，不会叠加态。这种情况一旦出现，默认参数无法收敛。这时，请保证电荷密度和磁密度的混合系数完全一致： mixing_beta 0.4 mixing_beta_mag 0.4 mixing_gg0 0.0 mixing_gg0_mag 0.0 相信这个设置之后，问题就会解决。 半导体/绝缘体 与非磁建议一致。 金属 与非磁建议一致。 metaGGA 计算 打开 mixing_tau=true。一般会解决 metaGGA 收敛困难，以及 EDIFF 慢于 DRHO 的问题。 DFT+U 计算 如果你的 DFT+U 计算无法收敛，我们推荐你做如下设置： mixing_restart 10 mixing_dmr 1 mixing_restart=10 代表 SCF 的计算会在第 10 步直接用第 9 步的输出电荷开启一个新的 SCF，在那之后 DFT+U 的计算同时也会混合密度矩阵。在大多数情况下，10 是一个安全有效的设置，但请务必记住 mixing_restart 的设置是危险的，设置之后，你可能会遇到： 本来不设置这 2 个参数还可以收敛，只是收敛的不快，设置之后完全不能收敛了。 答：那是因为 mixing_restart 的位置选取不合适，在 mixing_restart 前一步的输出密度很差，用其做初始密度使得计算直接跑飞。这个时候，我们建议你观察不开 mixing_restart 时候，drho 的收敛曲线，找一个距离基态近一些的位置做 mixing_restart（例如 drho）。 本来不能收敛，设置这 2 个参数之后，仍然不能收敛 答：大概率是 mixing_restart 的晚了，此时 SCF 已经跑飞，结合 drho 的收敛曲线，适当提前 mixing_restart 的位置。 弛豫计算 在弛豫计算中可以分多步做 relax，会使用上一步的 SCF 的磁矩做下一步优化的初始磁矩。这样对于弛豫计算的收敛性帮助巨大。 非共线磁性计算（nspin=4） 在使用传统的 DIIS 计算时，即 mixing_angle=0.0，参数建议与共线磁性一致。但是如果尝试之后，仍难以收敛，或收敛到错误的磁态，那么我们建议你进行如下的设置： mixing_angle 1.0 我们实现了J. Phys. Soc. Jpn. 82 (2013) 114706中的新方法，这个方法寻找非共线基态的能力大大强于传统的 DIIS 混合。相信会对你有帮助。 其他 FAQ 我可以在 STRU 中不设置初始磁矩，就设置成 0 吗？ 答：可以。当 STRU 中所有元素的初始磁矩都是 0 的时候，我们会自动为体系中的所有原子都赋予大小为 1 a.u.的原子磁矩。但是我们仍建议你设置它，因为一个好的初始磁矩对于计算的收敛速度和正确性都有巨大的帮助。 我可以在计算中设置 NUPDOWN 来帮助收敛吗？ 答：可以。一个合理的 NUPDOWN 设置一般会使得计算收敛地比较稳定。但是这么做的前提是，一定要对所做的体系很可靠的先验知识。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-question.html":{"url":"abacus-question.html","title":"ABACUS 答疑手册 v0.2 版本","keywords":"","body":"ABACUS 答疑手册 v0.2 版本 作者：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024/10/24 一、背景 本文档适用于想用 ABACUS（原子算筹）来做电子结构计算的科研工作者。 PW：Plane Wave，指平面波 NAO：Numerical Atomic Orbitals，指数值原子轨道 LCAO：Linear Combination of Atomic Orbitals，指局域轨道，在 ABACUS 里面也指数值原子轨道 基于过去几年来积累的用户问题，接下来本文档将尽量以问答的形式来替使用 ABACUS 的用户答疑解惑，例如 问：ABACUS 和 ABAQUS 是什么关系？ 答：ABAQUS 是一款知名的多物理场有限元仿真分析软件，ABACUS 的英文单词翻译是算盘，ABACUS 作为一款国产密度泛函理论软件，中文名是原子算筹。 问：使用 ABACUS 需要收费吗？ 答：从软件的角度来讲不收费，因为是开源软件，但跑该软件的机器得自己准备，机器要交电费。 问：ABACUS 的开发过程是怎样的，什么人可以成为开发者？ 答：ABACUS 的代码开发记录完全公开，所有代码的修改都在 https://github.com/deepmodeling/abacus-develop 网页上可以查到，ABACUS 为所有感兴趣的参与者都保留了成为开发者的可能性，每个人都有可能称为开发者。 二、ABACUS 使用建议 1. 编译 1.1 从哪里可以下载到 ABACUS 的代码？ 答：如果可以接 github，可以登录 https://github.com/deepmodeling/abacus-develop，建议下载最新版本使用，因为软件一直在更新，总体而言新版本的 bugs 会更少。 如果网络不方便登录 github，还可以登录国内网站 https://gitee.com/deepmodeling/abacus-develop.git 下载。 1.2 怎么安装 ABACUS？ 答：可以参考官方文档 https://abacus.deepmodeling.com/en/latest/quick_start/easy_install.html 也可以登录网址 https://mcresearch.github.io/abacus-user-guide/，上面有一些针对不同编译器的中文编译教程。 另外，注意“安装 ABACUS”这句话其实有歧义，ABACUS 有很多不同的安装选项，比如是否只安装支持平面波的功能，还是也要安装支持数值原子轨道的功能，是否要使用 LIBXC 等等不同选项，可根据自己的需要来安装具体的代码模块。 1.3 如何在曙光的 DCU 上编译 ABACUS？ 答：可参考文档 https://mcresearch.github.io/abacus-user-guide/abacus-dcu.html 2. 计算前准备 2.1 PW 计算需要准备的文件？ 答：INPUT 文件控制输入参数，STRU 文件包含晶胞、原子信息和赝势；KPT 文件包含布里渊区 k 点信息。这三个文件默认是放在一个文件夹内的。但是 INPUT 文件里其实可以控制结构文件所在地址，以及 KPT 文件所在地址。 2.2 KPT 文件什么时候不适用？ 答：第一，在使用 DPGEN 的时候，强烈建议设置 kspacing 这个参数，而不是在 KPT 文件里设置 k 点的个数，这是为了做不同大小体系密度泛函计算的时候，使得计算的精度尽量持平，从而得到不同结构里精度相当的总能量和受力，这对于 DPMD 的训练很重要。第二，LCAO 可以在 INPUT 使用 gamma_only（设为 1），那么 KPT 文件不起作用，所有计算只用到 Gamma（0，0，0）这个 k 点，这种情况下体系有更快速的特殊算法，效率更高，计算内存的消耗也更小。 2.3 LCAO 基组相比于 PW 基组需要额外准备的文件？ 答：数值原子轨道文件，下载地址为 https://abacus.ustc.edu.cn/pseudo/list.htm。注意轨道文件要和对应的赝势相匹配。 关于数值原子轨道的背景知识，可以参考文档： https://mcresearch.github.io/abacus-user-guide/abacus-nac1.html https://mcresearch.github.io/abacus-user-guide/abacus-nac2.html https://mcresearch.github.io/abacus-user-guide/abacus-nac3.html 2.4 能量截断值收敛性测试是必须要做的吗？ 答：是的，除非你或者别人之前已经做过了，得到了推荐的能量截断值。否则，一般来讲一个给定的赝势（模守恒或者超软赝势），你需要从低到高逐步增加能量截断值来判断总能量已经收敛。 2.5 布里渊区 k 点收敛性和什么有关系？ 答：布里渊区 k 点只和实空间的晶胞大小有关系，因此当换了晶胞之后需要测试 k 点的收敛性。然而，一般我们会有一些经验规律，比如实空间某个方向增大一倍，则倒空间相应的 k 点数量可以少取一半，一直小到只取 Gamma 点（0，0，0）为止。所以，改变赝势或者交换关联泛函的时候，并不需要重新测试 k 点的收敛情况。 2.6 关于长度单位 答：没有注意到单位的转换是初学者容易犯的错之一。长度单位 Angstroms（埃）和 Bohr 的转换关系需要了解（1 埃=1.8897259886 Bohr，反过来 1 Borh=0.529177249 Angstroms，转换时候尽可能多地取有效数字，会让原子坐标更准确），不同软件的长度单位可能有取得不同的情况，涉及到晶格矢量、原子位置，以及坐标系转换（Direct 和 Cartesian 的区别，前者是晶格坐标系，后者单位才是长度单位），如果原子位置或者晶胞设错了，不同软件计算结果就会不同。一个小技巧判断不同软件的晶格结构和原子坐标是否一样：可以看不同软件算出来的 Ewald 能量（周期性边界条件下算离子-离子库伦排斥能的快速算法），如果 Ewald 能量能对上（精确到小数点后 10 位以上），那么说明两个软件的原子坐标和晶格矢量设置都是一样的。 2.7 关于能量单位 答：涉及到能量单位的有多处。首先是平面波的能量截断值，VASP 经常用的是 eV，QE 和 ABACUS 用的是 Ry，这两者有转换关系（1 Ry=13.605703976 eV），所以用 VASP 习惯的用户需要把对应的 eV 转换成 Ry 再使用 ABACUS。其次是 smearing 的参数选择，例如 0.015，其单位是 Ry 或者 eV 也对结果有较大影响。 3. 基矢量 3.1 ABACUS 支持的基矢量有几种？ 答：分成 PW（平面波）和 LCAO（具体来讲是 Numerical atomic orbitals，NAO，即数值原子轨道）两种，目前 ABACUS 都支持，像是 VASP 和 QE 只支持 PW，SIESTA 和 OpenMP 支持 LCAO。还有一种叫 lcao_in_pw，就是把 NAO 展开成平面波进行计算，但一般只用于测试目的。 3.2 怎么选择是采用 PW 还是用 LCAO 基矢量来做计算？ 答：如果是较小原子数的固体体系，建议可以采用 PW 效率较高。如果是体系原子数较大（例如大于 50 个原子），建议可以用 LCAO 试试，效率会更高。此外，当使用 LCAO 做计算时，可以先用 PW 这组相对完备的基组来测试赝势带来的能量收敛性。 3.3 如果感觉 LCAO 的效率慢，可能的原因是否和基矢量有关系? 答：ABACUS 里采用的 LCAO 的局域轨道长度一般在 6-10 au 之间，轨道的截断越长，往往计算精度越高，但计算量和内存消耗也会显著的更大。如果要提高速度，可以在尽可能不影响精度（需要自己测试）的前提下，减小数值原子轨道的半径，这样可以大幅度提升计算效率以及降低内存占用量。 3.4 ABACUS 中 LCAO 的 Ecut 是做什么用的？ 答：LCAO 和 PW 一样，都会有一个 Ecut，在使用 LCAO 的时候，增加 Ecut 只会增加局域势格点积分部分的精度（赝势的局域部分 + 交换关联势 +Hartree 势），并不增加数值原子轨道基矢量的完备性，所以原先用于 PW 的收敛性测试方法是不能这样直接用于 LCAO 的。如果要增加 LCAO 的基矢量使得基矢量更完备，需要从例如 DZP 增加到 TZDP，而不是增加 Ecut。 3.5 LCAO 算小分子和固体有什么要注意的？ 答：使用局域轨道的话，会有 BSSE（Basis set superposition error），对于小分子体系，BSSE 带来的误差会较为严重，使得对于一些分子体系，有必要采用更完备的基矢量（或者更长的局域轨道）或者 BSSE 修正。而对于固体系统，一般来讲每个原子会有若干近邻原子，这些近邻原子上的局域轨道会使得在描述每个原子的电子结构时基矢量总体更完备，所以可以相对选择更短的局域轨道。 3.6 如果算出来 SZ 结果比 DZP 好，是否可以用 SZ 结果？ 答：采用 LCAO 时，SZ（single zeta 轨道）的结果一般来讲都不收敛，一般不可以用来发表文章。一般至少是 DZP 及以上才认为基矢量较为准确，是学界可以认可的 NAO 精度。 4. 赝势 4.1 PAW 是不是赝势？ 答：准确来说不是，是一种描述电子-离子相互作用的方法。 4.2 为什么不同软件算出来的统一体系的总能量差距可能会巨大？ 答：因为同样的元素，其不同的赝势（或 PAW 势）允许总能量有一个常数的偏移，因为都对库伦势进行了人为的修改。所以，我们一般在分析结果的时候也不用总能量这个数值，而是用总能量之间的差别，例如 bcc 相比于 fcc 更稳定这种结论，不同赝势哪怕总能量不对齐，其算出来的 bcc 和 fcc 之间的能量差也应该是对齐的。另外一件事情就是画态密度（Density of States，DOS）的时候，我们习惯把费米面取成 0 点，也是因为总能量是可以有一个常数的偏移的。 4.3 赝势为什么和交换关联泛函有关？ 答：因为赝势生成过程中解的是一维的 Kohn-Sham 方程，这个过程也用到了泛函，所以不同泛函生成的赝势就不同。 4.4 赝势改变了，什么参数需要重新测试？ 答：因为电子和离子的描述方式变了，所以需要重新测试能量截断值 Ecut 的收敛性，即增加 Ecut，看总能量变化，例如从 90 Ry 变到 100 Ry，如果总能量变化小于 1 meV/atom，则认为可以收敛。 4.5 从 PBE 泛函换到 Meta-GGA 泛函，例如 SCAN，或者杂化泛函，是否需要换赝势文件？ 答：一个约定俗成的赝势用法是：PBE 的赝势可以用于 Meta-GGA 泛函，例如 SCAN 泛函，甚至杂化泛函包括 PBE0 和 HSE06 泛函。但是，LDA 的赝势就不可以用于 SCAN 泛函或者 PBE0、HSE06 泛函。因为 SCAN 泛函和 HSE06 泛函也是基于 PBE 泛函发展起来的。 4.6 别人文献看到的某元素的能量截断值，是否可以直接拿过来使用？ 答：一般来说是不可以，例如用了 VASP 的 PAW 势，就难以直接拿到模守恒赝势里使用。 5. 电子自洽迭代过程 5.1 为什么 ABACUS 的 SCF 计算比 VASP 慢很多？ 答：首先，先检查 Ecut 是否一样（注意 ABACS 的单位是 Ry，VASP 是 eV，要换算），一般来讲 VASP 用 PAW 方法所需的 Ecut 比 ABACUS 的模守恒赝势要低，目前来讲这部分参数 VASP 占优，你并不能降低 ABACUS 的 Ecut 来和 VASP 的 Ecut 持平。第二，检查你所计算的元素的电子数，往往电子数不同，计算效率会有很大差别。例如 Ga 的模守恒赝势可能有 13 个电子，但 VASP 的 Ga 的 PAW 势可能只有 3 个电子，那么 VASP 的计算效率会快很多也是可以预期的。 5.2 电子自洽迭代里的展宽技术是用来做什么的？ 答：电子自洽迭代过程中使用的展宽（一般称为 Smearing）是一种数值技术，它用于提高计算中的收敛稳定性和速度，尤其是在处理金属和其他导体体系时非常有用。展宽通常采用几种不同的办法来实施，例如费米-狄拉克展宽（Fermi-Dirac smearing）、高斯展宽（Gaussian smearing）、Methfessel-Paxton 展宽等，它们代表不同的电子占据数分布方法。 5.3 电子自洽迭代收敛结果和 smearing 相关吗？ 答：对于没有带隙的金属体系是相关的，采用 smearing 会在体系总能量里额外引入一个电子熵项。一般来讲 smearing_sigma 取得越大越容易收敛，但是要注意的是，smearing_sigma 取大了，总能量结果也愈发不准确。因此在迭代接近收敛时，通常需要逐步减少展宽值，以得到更加准确的接近零温的结果。对于半导体来讲，一般较小的 smearing 参数不影响总能量结果。 5.4 只要体系不收敛，就可以调整 smearing 吗？ 答：在项目里对一系列相关体系进行密度泛函理论计算，如果需要用到这些体系的总能量相对值，但发现有体系不收敛，我可以针对不同体系调整不同的 smearing 参数吗？一般不可以，因为 smearing 可能会改变总能量的数值。 5.5 电荷密度混合是用来做什么的？ 答：在电子自洽迭代过程中，需要不断更新电荷密度，直到输入的电荷密度和由此计算得到的输出电荷密度之间的差异足够小，即达到自洽。混合的具体方法有很多种，比如简单的线性混合、Broyden 混合、Pulay 混合（也称为 DIIS，Direct Inversion in the Iterative Subspace）等。这些方法通过考虑前几次迭代的电荷密度和/或电荷密度差异，来改进当前迭代的电荷密度估计。 5.6 总能量收敛、受力和应力是否收敛了？ 答：一般来讲，总能量在 SCF 中收敛到几乎不变时，受力和应力不一定完全收敛。如果是对受力或者压力敏感的计算，建议也测试一下相应受力和应力是否收敛（即继续降低 scf_thr 数值，设置更严格收敛阈值）。 6. 原子位置和晶胞结构优化(弛豫) 6.1 原子位置和晶胞结构优化有什么需要注意的？ 答：首先要注意的就是，原子位置和晶胞结构优化较慢，很耗机时，动辄就是几十上百个进程跑一两天。所以，如果不是很有把握了解你要算的体系，或者不是特别熟练密度泛函理论计算，建议动手算之前找导师聊一聊这样做的可行性，这样做一方面也是可以少走科研上的弯路，另外一方面也能有效的帮助导师节省机时费。 6.2 原子位置和晶胞结构优化有什么技巧？ 答：首先，就是要小心一些参数不要设多了，例如不要包含太多费米面上方非占据的轨道，如果体系没有磁矩，没有必要打开自旋极化计算（nspin=2）。其次，如果你能预估偏离最终的构型较大，那你可以先采用低精度的方法达到一个接近最终构型的一个临时构型。例如，没有必要用 181818 的 k 点（虽然你认为这样才能完全收敛总能量）来做优化，你可以先选一个 999 的 k 点 mesh 来做。第三，如果你是做的一系列相关结构的原子位置和晶胞结构优化，可以想办法构造一些更好的初猜结构，除非考虑亚稳态的存在，否则一开始猜测的结构越接近，所需要的优化步数就越少。第四，BFGS 算法一般适用于偏离稳定结构较小的情况，而 cg 一般用于偏离稳定结构较大的情况。 6.3 做结构优化很多步都不收敛，怎么办？ 答：首先，检查每一步的 SCF 是否收敛，如果不收敛，先让 SCF 能收敛，再做结构优化。其次，如果能不用 cell-relax 而只用 relax，建议尽量先用 relax，把晶胞内的原子位置先固定住了，最后再做 cell-realx，这样效率更高。原因是如果把 cell 的自由度和原子的自由度一起考虑做 relax，往往效率较低。 6.4 采用 LCAO 和 PW，结构优化收敛上有什么区别？ 答：PW 基组更完备，一般结构优化可以收敛到 0.001 eV/Angstroms。而 LCAO 由于基矢量不够完备，存在诸如 egg box effect 的误差，所以求力能收敛到的精度一般要差一些，通常 0.04 eV/Angstroms 以下是可以接受的，也有不少文章采用这个精度来发表结果，是被认可的。 7. 并行 7.1 MPI 并行和 OpenMP 并行的区别是什么？什么叫进程，什么叫线程？ 答：MPI 进程和 OpenMP 线程的差别，前者内存是不共享的，后者内存是共享的。 7.2 是不是进程或者线程越多，计算就越快？ 答：举个例子，用 7au 的 DZP 轨道算 512 个 Fe 原子的体系，K 点 111，以下是运行时间（OMP 代表线程数，MPI 代表进程数）：1 OMP x 32 MPI = 262s 每电子步；1 OMP x 64 MPI = 581s 每电子步；1 OMP x 128 MPI = 654s 每电子步；1 OMP x 256 MPI = 765s 每电子步。可以看到进程越多，计算反而越慢，这是因为进程间的通讯量随着进程数增多变大了。所以，并不是用的计算资源越多，计算就会越快，建议做计算前先评估好并行效率。 7.3 K 点并行（也就是 KPAR 这个参数），要怎么理解它的使用？ 答：对 PW 来说，不同 K 点的 Kohn-Sham 方程求解（即寻找特征值和特征向量）是比较独立的，因此如果给定了总的进程数，我们可以想办法把不同 K 点的方程求解尽可能并行，KPAR 代表我们要将 K 点分成几组，因此原则上 KPAR 越大效率应该越高。如果 KPAR 设成 1，那么程序执行时是用平面波来并行，在某些时候，平面波并行效率也挺高，因此看不出 K 点并行的优势。对 LCAO 来说，KPAR 并行的优势不大，因此目前 ABACUS 不支持 LCAO 的 K 点并行功能。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-md.html":{"url":"abacus-md.html","title":"ABACUS 分子动力学使用教程","keywords":"","body":"ABACUS 分子动力学使用教程 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024/09/19 在Bohrium Notebook上快速学习： 一、分子动力学方法简介 分子动力学（Molecular Dynamics，简称 MD）：一种模拟原子体系随时间运动的方法，被广泛的用来研究与原子运动路径相关的一些基本过程，如相变、扩散、化学反应等等。本教程旨在介绍 ABACUS 中的分子动力学功能，分子动力学模拟重要的一件事情是如何选取精度和效率的平衡，其中精度高低主要取决于势函数的准确程度，而效率主要受限于求出每个原子的能量和受力的计算量。 经典分子动力学（Classical MD，简称 CMD）：通过构建描述原子间相互作用的势函数，获得每个原子的受力（受力等于能量对原子位置的导数），再通过积分运动方程来获得每个原子的下一时刻位置，从而获得随时间演化的粒子位置和速度。当系统处在一定的密度、温度和压强等物理条件限制下，可以结合统计物理的方法计算物质的性质。具体来说，采取某个系综后，对粒子位置和速度采样，之后统计出体系的热力学宏观性质。 从头算分子动力学（ab initio molecular dynamics，简称 AIMD）：也称为第一性原理的分子动力学方法（first-principles molecular dynamics，简称 FPMD），该方法采用的是第一性原理方法（例如密度泛函理论）来计算体系的势能面，因此计算量相比于经典分子动力学方法要昂贵很多。 ABACUS 的分子动力学功能：支持第一性原理分子动力学 FPMD 方法，也支持经典的 Lennard-Jones（LJ 对势）的分子动力学模拟。此外，ABACUS 还支持深度势能分子动力学（Deep Potential Molecular Dynamics，简称 DPMD）方法，此时需要编译 DeePMD-kit 软件包并在编译原子算筹软件时进行动态库的链接。 二、文档和算例下载地址 ABACUS 里关于分子动力学方法的线上文档地址为：http://abacus.deepmodeling.com/en/latest/advanced/md.html ABACUS 里关于分子动力学参数的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#molecular-dynamics ABACUS 的 MD 算例下载地址为（国内 gitee）： https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/md 可以采用的下载命令是： git clone https://gitee.com/mcresearch/abacus-user-guide.git 之后进入 /abacus-user-guide/examples/md 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/md 注：算例仓库里面包含 1_AIMD，2_LJMD（采用 Lennard-Jones 经典势做 MD），3_DPMD（采用深度势能方法做 MD）和 4_FIRE（采用 FIRE 算法做结构优化）四个目录。 注：以上算例要在 ABACUS v3.2.1 版本及以上可以运行成功，并且我们强烈建议下载使用 ABACUS 最新版本！ 1. 第一性原理分子动力学（AIMD） 进入 1_AIMD 目录，该目录提供了 8 个输入文件，使用的时候将 INPUT_* 复制为 INPUT 即可（INPUT_* 代表从 INPUT_0 到 INPUT_7 共 8 个不同的 INPUT 文件，对应 8 种不同的 MD 算法）。该算例采用 8 原子的金刚石结构 Si，晶格结构放在 STRU 文件里，布里渊区的 k 点采样放在 KPT 文件里。 8 个 INPUT 文件对应的 MD 方法如下： INPUT_0：采用 NVE 微正则系综 INPUT_1：采用 NVT 正则系综 INPUT_2：采用 Langevin 热库 INPUT_3：采用 Anderson 热库，NVT 系综 INPUT_4：采用 MSST 方法 INPUT_5：采用 Berendsen 热库，NVT 系综 INPUT_6：采用 rescaling 方法，NVT 系综 INPUT_7：采用 rescale_v 方法，NVT 系综 以 INPUT_0 为例： INPUT_PARAMETERS #Parameters (1.General) suffix Si_nve calculation md nbands 20 symmetry 0 pseudo_dir ../../../tests/PP_ORB orbital_dir ../../../tests/PP_ORB #Parameters (2.Iteration) ecutwfc 30 scf_thr 1e-5 scf_nmax 100 #Parameters (3.Basis) basis_type lcao ks_solver genelpa gamma_only 1 #Parameters (4.Smearing) smearing_method gaussian smearing_sigma 0.001 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 chg_extrap second-order #Parameters (6.MD) md_type nve md_nstep 10 md_dt 1 md_tfirst 300 这些参数在 ABACUS 线上文档中均有说明，在这里再进行简单概述： calculation：设置 ABACUS 计算类型，做分子动力学模拟请设置为 md。 esolver_type：给定原子位置进行系统能量的计算，默认 Kohn-Sham 密度泛函理论（ksdft），还可以设置 LJ 势（lj）或者深度势能（dp）。理论上来说，所有的 esolver_type 都可以用于 MD 计算。 chg_extrap：电荷外插法，在 relax 和 md 计算中可用于优化电荷密度初始化，加速电子迭代收敛，MD 中可以设置为 second-order。 md_type：MD 算法种类，默认是正则系统 nvt，这里的例子选择的是 nve，即 NVE 微正则系综。 md_nstep：MD 模拟的总步数。 md_dt：MD 计算每一步的时间步长（单位是 fs），与 md_nstep 共同决定 MD 总时长。 md_tfirst：MD 系统的初始温度（单位是 K）。 2. Lennard-Jones 势函数 进入 2_LJMD 目录，ABACUS 软件包中提供了一个采用 Lennard-Jones（LJ）经典势函数进行 MD 模拟的算例，该算例采用 LJ 对势作为能量求解器来做经典分子动力学，初始结构是边长 20 埃的正方体盒子中的 256 个无序 He 原子。 2.1 LJ 对势 LJ 对势的解析形式如下：u^{ij}表示原子 i 与原子 j 之间的相互作用能，r^{ij}表示这两个原子之间的距离，\\epsilon，\\sigma和r_{cut}则是 LJ 势需要的 3 个参数。LJ 势只考虑截断半径r_{cut}内的近邻原子 j 对中心原子 i 的能量贡献。 \\begin{array}{c} u^{i j}=4 \\varepsilon\\left[\\left(\\frac{\\sigma}{r_{i j}}\\right)^{12}-\\left(\\frac{\\sigma}{r_{i j}}\\right)^{6}\\right] \\\\ \\boldsymbol{F}_{i}=-\\nabla_{i} U=\\sum_{j} 4 \\varepsilon\\left[12\\left(\\frac{\\sigma}{r_{i j}}\\right)^{12}-6\\left(\\frac{\\sigma}{r_{i j}}\\right)^{6}\\right] \\frac{\\boldsymbol{r}_{i}-\\boldsymbol{r}_{j}}{r_{i j}^{2}} H\\left(r_{c u t}-r_{i j}\\right) \\end{array} \\\\ H(x)=\\left\\{\\begin{array}{l} 0\\ \\ \\ \\ (x0) \\end{array}\\right.\\\\ 2.2 STRU LJMD 是经典分子动力学，不需要提供 KPT，赝势和轨道文件，STRU 的前面几部分如下： ATOMIC_SPECIES He 4.0026 LATTICE_CONSTANT 1.889727 LATTICE_VECTORS 20 0 0 0 20 0 0 0 20 ATOMIC_POSITIONS Cartesian He #label 0 #magnetism 256 #number of atoms ATOMIC_SPECIES：不需要提供赝势信息 NUMERICAL_ORBITAL：不需要添加轨道信息 2.3 INPUT INPUT 文件中的参数也需要做少量修改： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md pseudo_dir ../../PP_ORB #Parameters (esolver) esolver_type lj lj_rcut 8.5 lj_epsilon 0.01032 lj_sigma 3.405 cal_force 1 cal_stress 1 #Parameters (MD) md_nstep 5 md_type nve md_dt 1 md_tfirst 300 init_vel 1 esolver_type：指定为 lj 就可以做 Lennard-Jones 经典势函数。 lj_rcut：LJ 对势的参数，即截断半径r_{cut}。 lj_epsilon：LJ 对势的参数，即\\epsilon。 lj_sigma：LJ 对势的参数，即\\sigma。 init_vel：读取 STRU 中的原子速度信息，原子单位制。 3. 深度势能（Deep Potential） ABACUS 软件包中提供了一个 DPMD 的算例，进入 3_DPMD 目录。该算例采用 DP 模型（DeePMD-kit 产生的深度势能模型）作为能量求解器来做基于机器学习的分子动力学，初始结构是 864 个无序铝原子。 3.1 DP 模型 DeePMD-kit 是一种基于机器学习的分子动力学模拟方法，该方法是通过使用第一性原理计算数据对深度神经网络模型进行训练，从而得到通用的多体势能模型（DP 模型）。 3.2 编译方式 ABACUS 采用 DP 模型做 MD 计算需要编译与 DeePMD-kit 的接口，cmake 以及 makefile 编译方式可以参考 ABACUS 线上文档。 3.3 INPUT 文件设置 DPMD 是经典分子动力学，不需要提供 KPT，赝势和轨道文件 INPUT 文件中的参数需要做少量修改： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md esolver_type dp pot_file ../../PP_ORB/Al-SCAN.pb cal_force 1 cal_stress 1 md_nstep 3 md_type msst md_dt 1 md_tfirst 200 md_dumpfreq 1 md_restartfreq 1 msst_qmass 200 msst_vel 0.028 msst_vis 0.3 init_vel 1 esolver_type：设置为 dp pot_file：DP 模型文件路径 md_dumpfreq：MD 输出文件 MD_dump 中原子以及晶胞信息的输出频率 md_restartfreq：结构文件 STRU_MD_${istep} 的输出频率，MD 续算文件 Restart_md.dat 的更新频率 三、MD 输出和续算功能 1. MD 输出文件 ABACUS 的 MD 模拟会产生 3 类输出文件：结构文件 STRU_MD_${istep}，续算文件 Restart_md.dat，信息文件 MD_dump。 1.1 结构文件 STRU_MD_${istep} 参数 md_restartfreq 控制 OUT.${suffix}/STRU/文件夹中结构文件STRU_MD_${istep}的输出频率，该文件格式与输入结构文件 STRU 相同，主要用于 MD 续算。这里 istep 代表离子步，从 0 开始计数。 1.2 续算文件 Restart_md.dat 参数 md_restartfreq 控制 OUT.${suffix}/Restart_md.dat 的更新频率，用于 MD 续算。 1.3 信息文件 MD_dump 参数 md_dumpfreq 控制 OUT.${suffix}/MD_dump 文件的追加输出频率，该文件输出每 md_dumpfreq 步的 MD 信息，包括 MD 步数，晶格常数，晶格矢量，晶格维里，原子编号，原子位置，原子受力，原子速度。其中，晶格维里，原子受力，原子速度可以通过输入参数 dump_virial，dump_force，dump_vel 控制是否输出。 MDSTEP: 0 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 123.045275146001 -3.807535058112 -13.541439282961 -3.807535058112 124.421300186299 24.047959743672 -13.541439282961 24.047959743672 125.016024430342 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 0.000000000000 0.000000000000 0.000000000000 -0.885362725233 0.500467424348 0.150239620206 -0.003506076235 0.000412570794 0.000094403053 1 Si 1.300822817264 1.376389287977 1.354798867769 0.885362725233 -0.500467424348 -0.150239620206 0.003506076235 -0.000412570794 -0.000094403053 MDSTEP: 1 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 123.051574098220 -2.465332696362 -10.608474638302 -2.465332696362 123.587154919736 16.307187552709 -10.608474638302 16.307187552709 123.960669810770 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.389827754452 2.701629481339 2.699621723525 -0.602062173578 0.391990779819 0.096323485153 -0.010548689866 0.004659227844 0.001267888485 1 Si 1.308600113700 1.373562332082 1.353979669688 0.602062173578 -0.391990779819 -0.096323485153 0.010548689866 -0.004659227844 -0.001267888485 MDSTEP: 2 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 122.953007762375 -0.240072876170 -4.211946086929 -0.240072876170 122.930693852071 3.378536464243 -4.211946086929 3.378536464243 122.992607262385 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.376757913710 2.708010452044 2.701308224779 -0.124946902346 0.155367961328 0.009378252255 -0.012739769308 0.006644009927 0.001613591879 1 Si 1.321669954442 1.367181361377 1.352293168434 0.124946902346 -0.155367961328 -0.009378252255 0.012739769308 -0.006644009927 -0.001613591879 MDSTEP: 3 LATTICE_CONSTANT: 5.397605400000 Angstrom LATTICE_VECTORS 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 VIRIAL (kbar) 122.881221914392 1.206247195689 2.345023988024 1.206247195689 123.110079832453 -8.436042066928 2.345023988024 -8.436042066928 123.123976300784 INDEX LABEL POSITION (Angstrom) FORCE (eV/Angstrom) VELOCITY (Angstrom/fs) 0 Si 5.364727401370 2.714719749381 2.702800880457 0.310711926370 -0.086233730382 -0.043760493686 -0.009222308089 0.005510922784 0.001122226311 1 Si 1.333700466782 1.360472064040 1.350800512757 -0.310711926370 0.086233730382 0.043760493686 0.009222308089 -0.005510922784 -0.001122226311 2 MD 续算功能 如果 ABACUS 运行达到指定的 MD 步数，或者计算中断，可以通过 MD 续算功能继续之前的 MD 计算。 以上一个 INPUT 文件为例： INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md pseudo_dir ../../PP_ORB esolver_type dp pot_file ../../PP_ORB/Al-SCAN.pb cal_force 1 cal_stress 1 md_nstep 3 md_type msst md_dt 1 md_tfirst 200 md_dumpfreq 1 md_restartfreq 1 md_restart 1 msst_qmass 200 msst_vel 0.028 msst_vis 0.3 init_vel 1 md_restart：控制续算的开关，在 MD 续算时将这个参数设为 1，其他参数不变。当 md_restart 设为 1，ABACUS 会读取${read_file_dir}/Restart_md.dat文件，从中获取当前MD步数istep以及续算所需的其他参数如恒温器以及恒压器的信息，根据istep从OUT.${suffix}/STRU/ 文件夹中读取相应的结构文件 STRU_MD_${istep}，之后就可以进行 MD 续算了。 四、MD 后处理 目前主流的可视化软件如 VESTA、VMD、OVITO 并不支持 ABACUS 的文件格式，因此我们需要通过一些后处理软件实现 ABACUS 的 STRU、MD_dump 文件与常用文件格式的转化。我们比较推荐的后处理软件有： 1 ASE 官网：https://wiki.fysik.dtu.dk/ase/ 用法参考 ABACUS 线上文档：http://abacus.deepmodeling.com/en/latest/advanced/interface/ase.html 2 dpdata github 网址：https://github.com/deepmodeling/dpdata gitee 网址：https://gitee.com/deepmodeling/dpdata 3 案例 现在我们用 LJMD 算例来演示如何采用dpdata+OVITO的方式在 MD 计算完成后制作分子动力学轨迹动画。 3.1 MD 计算 下载案例文件 $ git clone https://gitee.com/mcresearch/abacus-user-guide 进入 LJMD 文件夹 $ cd abacus-user-guide/examples/md/2_LJMD 修改 INPUT 参数，把 md_nstep 改为 100 INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md pseudo_dir ../../PP_ORB #Parameters (esolver) esolver_type lj lj_rcut 8.5 lj_epsilon 0.01032 lj_sigma 3.405 cal_force 1 cal_stress 1 #Parameters (MD) md_nstep 100 md_type nve md_dt 1 md_tfirst 300 init_vel 1 运行 abacus $ abacus 3.2 dpdata 转化格式 安装 dpdata $ git clone https://github.com/deepmodeling/dpdata.git dpdata $ cd dpdata $ pip install . 运行 dpdata，将 MD_dump 文件转化为 GROMACS 的 gro 格式的文件 data.gro $ python3 >>> import dpdata >>> data = dpdata.LabeledSystem(\"./\", fmt=\"abacus/md\") >>> data.to_gro(\"data.gro\") 3.3 OVITO 制作动画 打开 OVITO，点击左上角 load file，选择上一步的 data.gro 文件 右上角 rendering settings 点击 Render active viewport 即可保存动画文件 五、特殊的 MD 方法 1. Fast Inertial Relaxation Engine ABACUS 中实现了一种特殊的基于 MD 的 Fast Inertial Relaxation Engine (FIRE)结构优化方法，该算法比共轭梯度法的标准实现快得多，具有额外的速度修改和自适应时间步长，具有优异的优化效率。 以上面提供的 4_FIRE 算例为例，我们可以介绍一下所需的参数如下： INPUT_PARAMETERS #Parameters (1.General) suffix Si_fire calculation md nbands 6 symmetry 0 pseudo_dir ../../PP_ORB orbital_dir ../../PP_ORB #Parameters (2.Iteration) ecutwfc 30 scf_thr 1e-8 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method gaussian smearing_sigma 0.001 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 chg_extrap second-order #Parameters (6.MD) md_type fire md_nstep 100 md_dt 1 md_tfirst 300 force_thr_ev 0.001 calculation：FIRE 算法是基于 MD 方法的，因此需要将 calculation 设为 md md_type：采用 FIRE 算法，需要设为 fire md_tfirst：MD 需要离子速度，因此需要通过设置初始温度来随机生成离子速度，或者在 STRU 文件中手动设置初始速度 force_thr_ev：离子受力的收敛阈值，当离子受力的每个分量均小于该阈值或者 MD 运行至最大步数时，MD 终止 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-dpmd.html":{"url":"abacus-dpmd.html","title":"ABACUS+DeePMD-kit 做机器学习分子动力学模拟","keywords":"","body":"ABACUS+DeePMD-kit 做机器学习分子动力学 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024/10/15 一、介绍 本教程旨在介绍结合 ABACUS（中文名原子算筹，这里基于 ABACUS 3.8.0 版本）和 DeePMD-kit 软件进行基于机器学习原子间势函数的分子动力学模拟。 DeePMD-kit 是一款基于神经网络拟合第一性原理数据得到势能模型，用于分子动力学模拟的软件。无需人工干预，其可以端对端地将用户提供的数据在数个小时内转化为深度势能模型，可以保持量子力学精度准确性的基础上，将分子动力学的计算速度提升数个量级。 如果不熟悉 DeePMD-kit 的读者，这里可以推荐大家先阅读 DeePMD-kit 的相关原理文档和说明，熟悉这部分的读者可以跳过： https://docs.deepmodeling.com/projects/deepmd/en/r2/ https://bohrium-doc.dp.tech/docs/software/DeePMD-kit https://mp.weixin.qq.com/s/hLULtXgwKbhuT2Zvy6XZLA https://bohrium.dp.tech/notebooks/2649266844 二、准备 2.1 案例下载地址 ABACUS 的 MD 算例下载地址为（国内 gitee）： https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/md 可以采用的下载命令是： git clone https://gitee.com/mcresearch/abacus-user-guide.git 之后进入 /abacus-user-guide/examples/md/3_DPMD 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/md 2.2 安装相关软件 2.2.1 ABACUS 这里默认读者已经准备好 ABACUS 的安装环境和依赖软件，如还没有可以参考相关教程。 2.2.2 DeePMD-kit DeePMD-kit 安装教程请参考 DeePMD-kit 的线上文档：https://docs.deepmodeling.com/projects/deepmd/en/r2/ 新手用户建议采用 offline package 方式安装 DeePMD-kit：https://docs.deepmodeling.com/projects/deepmd/en/r2/getting-started/install.html#install-off-line-packages 如果用户希望直接使用 DPA2 做基于 ABACUS 软件的分子动力学模拟，需要满足以下条件： 安装 DeePMD-kit v3 版本 DeePMD-kit v3 版本应该与采用的 DPA2 训练使用的 DeePMD-kit 版本一致 DeePMD-kit v3 支持 PyTorch backend 2.2.3 ABACUS + DeePMD-kit 1. cmake 安装方式： 在普通 abacus 构建项目命令的基础上，指定 DeePMD-kit 的地址即可编译支持 DP 势场的 ABACUS： $ cmake -B build -DDeePMD_DIR=/dir_to_deepmd-kit ... $ cmake --build build -j4 $ cmake --install build 如果采取的不是 offline packages 安装方式，则 TensorFlow 和 PyTorch 的地址可能与 DeePMD-kit 不同，则需要额外指定他们的地址： $ cmake -B build -DDeePMD_DIR=/dir_to_deepmd-kit -DTensorFlow_DIR=/dir_to_tensorflow -DTorch_DIR=/dir_to_pytorch ... $ cmake --build build -j4 $ cmake --install build TensorFlow 和 PyTorch 后端可能只有一个，也可能都有，用户应该根据自己的需求安装支持对应后端的 DeePMD-kit。如果只有 TensorFlow 后端，则只需要提供 TensorFlow_DIR 即可，PyTorch 后端同理 2. make 安装方式 修改 Makefile.vars 文件，指定 DeePMD_DIR，LIBTORCH_DIR（可选）和 TensorFlow_DIR（可选）： DeePMD_DIR = /dir_to_deepmd-kit LIBTORCH_DIR = /dir_to_pytorch TensorFlow_DIR = /dir_to_tensorflow 或者执行 make 命令时，指定 DeePMD_DIR，LIBTORCH_DIR（可选）和 TensorFlow_DIR（可选）： $ make DeePMD_DIR=/dir_to_deepmd-kit LIBTORCH_DIR=/dir_to_pytorch TensorFlow_DIR=/dir_to_tensorflow 3. 编译可能出现的问题 采用 offilne 方式安装 DeePMD-kit，并使用 intel 编译器编译 ABACUS 时，可能会出现 mkl 库冲突，如 lib/libmkl_sequential.so.2: 对'mkl_lapack_sgesvda_batch_kernel'未定义的引用 为避免影响原有的 DeePMD-kit，可以新建目录/another_dir_to_deepmd，将原地址下的 lib 和 include 文件夹复制至该目录下，然后删除 lib 中所有带 mkl 字符的库文件 $ cd /another_dir_to_deepmd/lib $ rm *mkl* 三、机器学习分子动力学模拟 3.1 INPUT 文件设置 INPUT_PARAMETERS #Parameters (General) suffix autotest calculation md esolver_type dp pot_file ../../PP_ORB/Al-SCAN.pb cal_force 1 cal_stress 1 md_nstep 3 md_type msst md_dt 1 md_tfirst 200 md_dumpfreq 1 md_restartfreq 1 msst_qmass 200 msst_vel 0.028 msst_vis 0.3 init_vel 1 这些参数在 ABACUS 线上文档中均有说明，在这里再进行简单概述： calculation：设置 ABACUS 计算类型，做分子动力学模拟请设置为 md esolver_type：给定原子位置后的能量求解方式，默认 Kohn-Sham 密度泛函理论（ksdft），还可以设置 LJ 势（lj）或者深度势能（dp），这里设置为 dp md_type：MD 算法种类，例如选择不同的系综 nve、nvt、npt 等 md_nstep：MD 模拟的总步数 md_dt：MD 计算每一步的时间步长（单位是 fs），与 md_nstep 共同决定 MD 总时长 md_tfirst：MD 系统的初始温度（单位是 K） pot_file：DP 模型文件路径 md_dumpfreq：MD 输出文件 MD_dump 中原子以及晶胞信息的输出频率 md_restartfreq：结构文件 STRUMD$step 的输出频率，MD 续算文件 Restart_md.dat 的更新频率 init_vel：从 STRU 文件中读取原子速度 3.2 STRU 文件 ATOMIC_SPECIES Al 26.9815 LATTICE_CONSTANT 36.9005650344 LATTICE_VECTORS 1 0 0 #latvec1 0 1 0 #latvec2 0 0 1 #latvec3 ATOMIC_POSITIONS Cartesian Al #label 0 #magnetism 864 #number of atoms 0 0 0 m 1 1 1 v 0.000116448153697 -3.54062829069e-05 6.37221822545e-05 0.0833333333321 0.0833333333321 0 m 1 1 1 v 6.31461715716e-05 -7.68881397243e-05 0.000126053061667 0.0833333333321 0 0.0833333333321 m 1 1 1 v -0.000203773691434 5.08681990052e-05 -5.02990480666e-05 0 0.0833333333321 0.0833333333321 m 1 1 1 v 0.00024862569861 -0.000253289379344 2.04134042994e-05 0 0 0.166666666668 m 1 1 1 v 8.86312919936e-05 0.000160542135344 -0.000121839904824 0.0833333333321 0.0833333333321 0.166666666668 m 1 1 1 v 2.55030351768e-05 -3.68630188311e-05 2.89192521276e-05 0.0833333333321 0 0.25 m 1 1 1 v -0.000135330676077 -3.26957881398e-05 3.15103467938e-07 0 0.0833333333321 0.25 m 1 1 1 v 0.000131365976691 9.92067819339e-05 -0.00017808361164 ... ... ... DPMD 除了不需要提供 KPT，赝势和轨道文件之外，其他设置与正常计算一致。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-dpgen.html":{"url":"abacus-dpgen.html","title":"ABACUS+DPGEN 使用教程","keywords":"","body":"ABACUS+DPGEN 使用教程 作者：刘建川，邮箱：liujianchuan2013@163.com 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/15 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍结合 ABACUS（中文名原子算筹，这里基于 ABACUS 3.2.0 版本）和 DPGEN 软件结合生成机器学习 DP 势，这里 ABACUS 扮演了提供第一性原理训练数据的作用。本教程以碳化硅（SiC）材料为案例，并且教大家使用 DPGEN autotest 功能，计算 SiC 的 Equation of State (EOS)和弹性常数等性质。先介绍主要软件和计算平台： DPGEN软件：是一个结合第一性原理软件来自动产生训练数据标签的软件，如果不熟悉 DPGEN 的读者，这里可以推荐大家先阅读 DPGEN 的相关原理文档和说明，熟悉这部分的读者可以跳过： https://docs.deepmodeling.com/projects/dpgen/en/latest/ https://bohrium-doc.dp.tech/docs/software/DP-GEN https://bohrium-doc.dp.tech/docs/software/DP-GEN_init https://bohrium-doc.dp.tech/docs/software/DP-GEN_autotest https://www.sciencedirect.com/science/article/pii/S001046552030045X?via%3Dihub 计算平台：由于本案例通过 Bohrium 平台教学，所以所用到的 machine.json 文件仅限于 Bohrium 平台使用，如需在其他平台上使用，可参考下面网址，修改 machine.json 文件： https://docs.deepmodeling.com/projects/dpgen/en/latest/run/example-of-machine.html 二、准备 1. 案例下载地址 本教程用到的所有输入文件，均可点击这里下载。 (https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/abacus-dpgen) 此外，在 Linux 下可以采用的下载命令是： git clone https://gitee.com/mcresearch/abacus-user-guide.git 之后进入 /abacus-user-guide/examples/md 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/md 下载完之后，应该可以看到三个文件夹： init，run，以及 auto-test init 文件夹：包含用于 dpgen init_bulk 步骤所需的输入文件，用户可参考其设置自己的体系参数。 run 文件夹：包含用于 dpgen run 步骤所需的输入文件，用户可参考其设置自己的体系参数。 auto-test 文件夹：包含用于计算弹性常数等性质的输入文件，用户可参考其设置自己的体系参数。 2. 安装相关软件 这里默认读者已经安装好了 ABACUS 软件，本算例中 ABACUS 计算采用的是数值原子轨道的 LCAO（Linear Combination of Atomic Orbitals）方法，因为一般来说 LCAO 会比平面波效率更高，此外读者也可以把密度泛函理论计算部分改成平面波基矢量（后续会讲到）。 开始之前，请务必安装/更新 dpgen 和 dpdata（用来转换数据）到最新版本： 1. 安装/更新 dpdata pip install --user git+``https://gitee.com/deepmodeling/dpdata.git@devel 2. 安装/更新 dpgen pip install --user git+``https://gitee.com/deepmodeling/dpgen.git@devel 三、结合 DPGEN 生成 DP 数据的流程 DPGEN 使用流程如下，接下来我们将一一展开介绍： 1. 准备赝势和数值原子轨道文件 本例子所需文件有： 模守恒赝势文件，格式为*.upf，也可以使用其他 ABACUS 支持的赝势格式，注意 ABACUS 目前不支持 PAW 方法或者超软赝势。 数值原子轨道文件，格式为*.orb，注意这里的数值原子轨道文件要和赝势文件匹配，也就是数值原子轨道是由指定赝势产生的，关于如何生成数值原子轨道，我们会提供中文教程。 注：在 ABACUS 官网上可以下载到赝势和数值原子轨道文件： http://abacus.ustc.edu.cn/pseudo/list.htm 本例采用的赝势和轨道是： C 的 PBE 模守恒 ONCV 模守恒赝势：C_ONCV_PBE-1.0.upf Si 的 PBE 模守恒 ONCV 模守恒赝势：Si_ONCV_PBE-1.0.upf C 的 PBE 模守恒 ONCV 赝势对应的数值原子轨道：C_gga_9au_100Ry_3s3p2d.orb Si 的 PBE 模守恒 ONCV 赝势对应的数值原子轨道：Si_gga_9au_100Ry_3s3p2d.orb 注：如果是使用平面波基矢量来做密度泛函理论计算，则不需要提供数值原子轨道文件，结合 DPGEN 使用的流程是一致的（仅需要删除调用轨道文件的输入参数即可）。如果采用其他 ABACUS 支持的赝势文件，可自行生成轨道文件（请参考本教程系列的其它相关中文教程）. 注：这里 C_gga_9au_100Ry_3s3p2d.orb 的意思是 C 元素、采用 GGA 泛函、轨道截断半径是 9 a.u.（轨道截断半径越大，则 ABACUS 所需求解 Kohn-Sham 方程的时间会越长，而且这个时间对于轨道半径极其敏感，推荐可以测试不同轨道半径，选取合适的、截断半径小的轨道可以加速计算），100 Ry 是推荐的平面波截断值（哪怕用了数值原子轨道，程序里还是会用平面波来做某些物理量的计算，比如模守恒赝势的局域赝势部分），3s3p2d 表示 3 个 s 径向轨道、3 个 p 轨道、2 个 d 轨道。 2. 准备原子体系的结构文件 本步骤所需的描述原子结构的文件有： *.cif 可以从多个渠道下载所需体系的结构文件，本案例主要从 materials project 网站下载 cif 文件，使用的 SiC 对应多个原子构型，主要有 3C、2H、4H、6H 四个构型，采用哪些构型取决于用户所研究的体系和性质，一般可选取所关心的物质温度和压强区间内可能出现的结构。本案例主要采用3C 和 2H构型来演示。 3C-SiC：https://materialsproject.org/materials/mp-8062?formula=SiC 2H-SiC: https://materialsproject.org/materials/mp-7140?_skip=15&formula=SiC 4H-SiC: https://materialsproject.org/materials/mp-11714?formula=SiC 6H-SiC: https://materialsproject.org/materials/mp-7631?formula=SiC 得到了 cif 之后，可以使用下列方法把 cif 转换成 STRU 文件： 1. 安装 ASE-ABACUS 接口： git clone https://gitlab.com/1041176461/ase-abacus.git cd ase-abacus python3 setup.py install 2. 设置环境变量（可选） ABACUS 支持两种基组：平面波（PW）和数值原子轨道（LCAO）。赝势和轨道文件的存放路径可以通过环境变量设置，分别为：ABACUS_PP_PATH 和 ABACUS_ORBITAL_PATH,设置方法如下： PP=${HOME}/pseudopotentials ORB=${HOME}/orbitals export ABACUS_PP_PATH=${PP} export ABACUS_ORBITAL_PATH=${ORB} PW 计算只需要设置 ABACUS_PP_PATH 。 LCAO 需要两个都设置：ABACUS_PP_PATH and ABACUS_ORBITAL_PATH 。 3. CIF 转 STRU from ase.io import read, write from pathlib import Path cs_dir = './' cs_vasp = Path(cs_dir, 'SiC.cif') # 修改为自己的cif文件名 cs_atoms = read(cs_vasp, format='cif') cs_stru = Path(cs_dir, 'STRU') pp = {'Si':'Si_ONCV_PBE-1.0.upf','C':'C_ONCV_PBE-1.0.upf'} # 修改为所对应的赝势文件名 basis = {'Si':'Si_gga_9au_100Ry_3s3p2d.orb','C':'C_gga_9au_100Ry_3s3p2d.orb'} # 修改为所对应的轨道文件名 write(cs_stru, cs_atoms, format='abacus', pp=pp, basis=basis) 运行上述 python 脚本，把 cif 转成 ABACUS 所需的 STRU 文件。 3. 产生初始训练数据 本步骤所需文件有： 原子结构文件：STRU 数值原子轨道文件：*.orb 赝势文件：*.upf 布里渊区 k 点采样：KPT 提交任务的文件：machine.json DPGEN 的输入参数文件：param.json 为每一个构型新建一个名为 init 的文件夹。进入该文件夹后，为每个构型都新建一个单独的文件夹，之后单独运行 dpgen init_bulk 命令，用于产生接下来的 dpgen run 步骤的初始数据集。本案例所提供的初始原子构型为 3C 和 2H 结构，并把赝势文件、轨道文件、STRU 文件放入对应的文件夹里。按照下面链接的案例准备适合自己机器的 machine.json 文件，并分别放入 3C 和 2H 文件夹。 https://docs.deepmodeling.com/projects/dpgen/en/latest/run/example-of-machine.html 本教程所用到的文件可以从 Gitee 下载，修改为符合自己的配置即可。 接下来准备 param.jsion 文件，本步骤最关键的设置也是 param.json 文件设置，案例如下： { \"init_fp_style\": \"ABACUS\", \"stages\": [1,2,3,4], \"cell_type\": \"diamond\", \"super_cell\": [1, 1, 1], \"elements\": [\"Si\",\"C\"], \"from_poscar\": true, \"from_poscar_path\": \"./STRU\", \"potcars\": [\"Si_ONCV_PBE-1.0.upf\",\"C_ONCV_PBE-1.0.upf\"], \"orb_files\": [\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C_gga_9au_100Ry_3s3p2d.orb\"], \"relax_incar\": \"./INPUT_rlx\", \"md_incar\" : \"./INPUT_md\", \"relax_kpt\": \"./KPT\", \"md_kpt\": \"./KPT\", \"md_nstep\": 10, \"scale\": [0.99,1.00,1.01], \"skip_relax\": false, \"pert_numb\": 10, \"pert_box\": 0.03, \"pert_atom\": 0.01, \"deepgen_templ\": \"../generator/template/\", \"coll_ndata\": 5000, \"_comment\": \"that's all\" } init_fp_style 关键字需设置为 ABACUS，如果 from_poscar 为 true，则会读取 from_poscar_path 指定的 STRU 文件，且 cell_type 关键字失效。super_cell 用于括胞，推荐直接使用括胞之后的 STRU 文件，则 super_cell 设置为[1, 1, 1]。括胞一般根据需求而定，使得三个方向的 cell 长度约为 6 埃以上（经验性的）。其中还用到了 *.``upf 和 *.``orb 文件，修改为自己所计算的体系即可。 init_bulk 的基本操作流程分为以下 4 个顺序步骤： 生成初始(平衡)结构：输出文件存储在 00.place_ele。 产生 MD 起始构象：放缩扰动 00.place_ele 中的结构，输出文件存储在 01.scale_pert。 执行 AIMD：取 01.scale_pert 起始构象调用 vasp 执行少步数 AIMD，输出文件存储在 02.md。 整理初始数据：调用 dpdata 提取 02.md 中 AIMD 各 snapshots 的数据作为初始数据，输出文件存储在 02.md。 param.json 中将使用 stages 关键词的取值 1~4 控制以上 4 步的执行，操作中，各步骤(2, 3, 4 在所需前一步输出文件存在的前提下)可独立执行。 其他具体参数含义可参考 dpgen 官网： https://docs.deepmodeling.com/projects/dpgen/en/latest/init/init-bulk-jdata.html 另外，还需准备两个 ABACUS 输入文件 INPUT_rlx 和 INPUT_md。 INPUT_rlx 主要用于优化所下载的结构，如下： INPUT_PARAMETERS #Parameters (1.General) suffix ABACUS calculation cell-relax #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type lcao #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.002 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 cal_stress 1 INPUT_md 主要用于产生一定数量的 AIMD 轨迹，用于 DPGEN 迭代的输出数据，如下： INPUT_PARAMETERS #Parameters (1.General) suffix ABACUS calculation md #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type lcao #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.002 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.3 cal_stress 1 #MD chg_extrap second-order md_type 2 md_tfirst 300 md_tlast 300 md_nstep 10 md_tfirst 10 md_tfreq 0.5 注：ABACUS 的 MD 关键字在此 3.2.0新版本有所更改，如果是使用的最新版本，请严格参考手册设置关键字，如md_type在新版本里改为了nvt、npt等形式，而不再用数字（如：2）等： 此外，还需准备一个存放布里渊区 k 点的文件，名为 KPT： K_POINTS 0 Gamma 4 4 4 0 0 0 也可在 INPUT 文件里直接指定 kspacing 参数（注意该参数可选 1 维或者 3 维，如果是表面系统可选 3 维因为真空方向不需要太多 k 点）。 用户可自行根据所研究体系，设置、更改上述参数。 所有以上输入文件准备完毕后，采用如下命令分别对 3C 和 2H 结构运行 dpgen： nohup dpgen init_bulk param.json machine.json 1>log 2>err& 上述命令采用后台提交 dpgen，等所有计算完成之后，dpgen 会自动收集训练 DP 势所需的数据，且转换为 DeePMD-kit 的数据格式，保存在 ./STRU.01x01x01/02.md/sys-0036-0036/deepmd 目录里。 4. 进行数据采样的迭代 run主流程包含一系列迭代，各迭代会根据所选系综在给定的温度、压力或体积等条件下进行 DPMD 采样与筛选，实现同步学习，所有迭代希望能够有效覆盖训练可靠模型所需的势能面上样本空间。每个迭代依次：基于init 准备的初始训练数据与之前迭代积累的训练数据|训练多个新的模型->使用当前的模型进行DPMD采样，根据模型间预测偏差(model-deviation)|挑选候选 snapshot 构象->将本轮候选 snapshot 构象进行第一性原理标定并加入数据集|扩展数据集 。 以上每个迭代中包含的 3 个步骤分别被命名为 00.train，01.model_devi，02.fp，细节如下： 00.train: 使用 init 准备的初始训练数据与之前迭代积累的训练数据，调用 DeepMD-kit 训练多个 (默认 4 个) 模型。模型间的唯一区别来自于初始化神经网络时使用不同的随机数种子。 01.model_devi: 指代 model-deviation。 调用 LAMMPS 使用 00.train 的 1 个模型进行 MD 模拟。对于任一 MD 中 snapshot，模型间预测偏差越大意味着当前模型系综对该 snapshot 构象的精度越低，通过引入模型偏差作为误差判据并设定上下限, 挑选出有希望有效改进模型对 PES 整体预测精度的 snapshot 构象，作为准备加入训练数据集的候选构象。 02.fp: 调用 ABACUS 对 01.model_devi 选取的候选构象进行第一性原理定标(单点计算)，并调用 dpdata 收集整理所得数据加入到训练数据集中。 run 执行后，相关文件即存储在....../iter.*(迭代序号)/步骤文件夹内。以上每个迭代中的每个步骤在实现中被分解为 3 个阶段。以 00.train 为例，3 阶段分别对应: 0：make_train ，为训练任务准备脚本；1： run_train，依据机器配置上传文件并执行训练任务；2：post_train，收集整理分析训练任务的结果。01.model_devi 与 02.fp 的实现步骤与之类似，分别使用 3，4，5 及 6，7，8 来标记其阶段。 用输出文件record.dpgen来记录进程已经执行过及当前正在执行的阶段。如进程中断后需要续算，DP-GEN将根据此文件的记录来自动恢复run主进程。用户也可根据需求手动修改record.dpgen中的记录，来控制接下来将执行哪一阶段的任务：例如，删除最后一阶段(可能未执行完成即中断)的记录，并从前一个已完成阶段后恢复任务。可以通过查看record.dpgen文件监控当前任务的执行阶段。 本步骤所需文件有： STRU *.orb *.upf machine.json （可以直接用 dpgen init bulk 里的） param.json dpgen init bulk 产生的初始训练数据 主要步骤如下： 1. 新建一个文件夹，命名为：run，并进入此目录里 2. 在 run 文件夹里面新建 init_conf 和 init_data 文件夹，用于存放 dpgen init bulk 产生的构型和初始训练数据 3. 为了区分不同构型和初始训练数据，在 init_conf 和 init_data 文件夹里新建名为 3C 和 2H 的两个文件夹 4. 拷贝 dpgen init bulk 产生的构型和初始训练数据至 init_conf 和 init_data 文件夹里，如： cp -rf yourPath/init/3C/STRU.01x01x01/02.md/sys-0032-0032 yourPath/run/init_conf/3C cp -rf yourPath/init/2H/STRU.01x01x01/02.md/sys-0036-0036 yourPath/run/init_conf/2H cp -rf yourPath/init/3C/STRU.01x01x01/02.md/sys-0032-0032/deepmd/* yourPath/run/init_data/3C cp -rf yourPath/init/2H/STRU.01x01x01/02.md/sys-0036-0036/deepmd/* yourPath/run/init_data/2H 5. 拷贝 machine.json、*.orb 和 *.upf 文件到 run 文件夹 6. 新建一个 param.json 文件，如下案例： { \"type_map\": [\"Si\",\"C\"], \"mass_map\": [28.085,12.011], \"init_data_prefix\": \"./init_data\", \"init_data_sys\": [ \"3C\", \"2H\" ], \"sys_format\":\"abacus/stru\", \"sys_configs_prefix\": \"./init_conf\", \"sys_configs\": [ [\"3C/sys-0032-0032/scale-1.000/00****/STRU\"], [\"2H/sys-0036-0036/scale-1.000/00****/STRU\"] ], \"_comment\": \" that's all \", \"numb_models\": 4, \"default_training_param\": { \"model\": { \"type_map\": [\"Si\",\"C\"], \"descriptor\": { \"type\": \"se_e2_a\", \"sel\": \"auto\", \"rcut_smth\": 0.5, \"rcut\": 6.0, \"neuron\": [25, 50, 100], \"resnet_dt\": true, \"axis_neuron\": 12, \"seed\": 1 }, \"fitting_net\": { \"neuron\": [240, 240, 240], \"resnet_dt\": false, \"seed\": 1 } }, \"learning_rate\": { \"type\": \"exp\", \"start_lr\": 0.001, \"stop_lr\": 3.5e-8, \"decay_steps\": 2000 }, \"loss\": { \"start_pref_e\": 0.02, \"limit_pref_e\": 2, \"start_pref_f\": 1000, \"limit_pref_f\": 1, \"start_pref_v\": 0.0, \"limit_pref_v\": 0.0 }, \"training\": { \"stop_batch\": 400000, \"disp_file\": \"lcurve.out\", \"disp_freq\": 100, \"numb_test\": 10, \"save_freq\": 1000, \"save_ckpt\": \"model.ckpt\", \"disp_training\": true, \"time_training\": true, \"profiling\": false, \"profiling_file\": \"timeline.json\", \"_comment\": \"that's all\" } }, \"model_devi_dt\": 0.002, \"model_devi_skip\": 1000, \"model_devi_f_trust_lo\": 0.05, \"model_devi_f_trust_hi\": 0.10, \"model_devi_clean_traj\": true, \"model_devi_merge_traj\": true, \"model_devi_jobs\": [ {\"sys_idx\": [0,1], \"temps\":[50, 250, 450, 650], \"press\": [0, 100, 1000, 5000, 10000, 20000, 50000], \"trj_freq\": 10, \"nsteps\": 3000, \"ensemble\": \"npt-tri\", \"_idx\": \"01\"}, {\"sys_idx\": [0,1], \"temps\":[50, 250, 450, 650], \"press\": [0, 100, 1000, 5000, 10000, 20000, 50000], \"trj_freq\": 10, \"nsteps\": 3000, \"ensemble\": \"npt-tri\", \"_idx\": \"02\"} ], \"fp_style\": \"abacus\", \"shuffle_poscar\": false, \"fp_task_max\": 100, \"fp_task_min\": 5, \"fp_accurate_threshold\": 0.999, \"fp_accurate_soft_threshold\": 0.998, \"fp_pp_path\": \"./\", \"fp_pp_files\": [\"Si_ONCV_PBE-1.0.upf\",\"C_ONCV_PBE-1.0.upf\"], \"fp_orb_files\": [\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C_gga_9au_100Ry_3s3p2d.orb\"], \"user_fp_params\":{ \"ntype\": 2, \"symmetry\": 0, \"basis_type\": \"lcao\", \"ecutwfc\": 100, \"scf_thr\": 1e-6, \"scf_nmax\": 100, \"smearing_method\": \"gauss\", \"smearing_sigma\": 0.002, \"mixing_type\": \"pulay\", \"mixing_beta\": 0.3, \"cal_force\": 1, \"cal_stress\": 1, \"kspacing\": 0.08 } } type_map: 用列表方式设置了体系元素，注意顺序要和 STRU 结构文件里一致 mass_map: 记录了对应的原子质量，和 type_map 对应 init_data_prefix：指定初始训练集的位置所在目录，如：./init_data init_data_sys：定位到初始训练集的具体目录，用列表调用多个，即：./init_data/2H sys_format：指定为 ABACUS 计算的结构，即：abacus/stru sys_configs_prefix：指定探索步所需调用的结构目录，如：./init_conf sys_configs：指定具体的某个构型的目录，用列表调用多个，即：./init_conf/3C/sys-0032-0032/scale-1.000/00****/STRU。其中 00为通配符，dpgen 会遍历 00所有文件夹的 STRU 文件 model_devi_f_trust_lo 和 model_devi_f_trust_hi：可由“init 数据” 中力绝对值的平均值，然后取该值的 20%-50%，设置成 trust level 的上下限。可通过以下 python 脚本计算：（注意指定初始数据位置） import dpdata import numpy as np do06=dpdata.Labeledsystem(\"./\"，\"deepmd/raw\") forces = np.absolute(d006[\"forces\"]) af = np.average(forces) f_trust_lo = af*0.2 f_trust_hi = af*0.5 print(f_trust_lo,f_trust_hi) 如果体系温度升高后力的幅度变大，trust level 也要增大设置 model_devi_jobs 里面每一行代表一轮，每轮设置参数为 LAMMPS 进行 MD 模拟的参数 fp_style 指定，使用 ABACUS 进行 SCF 计算 user_fp_params 里面记录 ABACUS 做 SCF 所需的参数 其他参数含义见：https://docs.deepmodeling.com/projects/dpgen/en/latest/run/index.html 1. 准备好所有输入文件之后，运行命令： nohup dpgen run param.json machine.json 1>log 2>err& 为后台提交，等待迭代计算完成即可。 2. 实时监测每轮的 accurate 数据，在 dpgen.log 文件里有记录 1）模型精度是判断每个迭代中的训练是否收敛的重要指标。 2）掌握训练策略有利于快速迭代和收敛。 3）经验性：一般体系在 5-8 轮迭代内会上升到 80% 以上，若没有提升，如下方法排查： a. 检查是否是探索步已经崩溃了，收集了许多不合理的结构 b. 检查train的loss是否是收敛 c. dp test查看fp数据是否偏差很大，或者有不合理的情况 d. 检查是否是温度设置过高而导致的结构变形严重 e. 及时调整trust level，体系温度升高后力的幅度变大，trust level也要增大设置 3. 一些经验 探索步已经崩溃的解决方案 原因：DPMD 跑崩的情况一般发生在 训练温度 高于 熔点，而这个温区的结构是从“有序”到“无序态”的 ，其构型易变，采样空间增大，导致训练难度增加。DPMD 跑崩表明当前势函数对这类构型描述较差，大概率是因为前期数据集中这类构型采集的较少；特别是无序态结构的原子距离变小。 策略：在熔点附近的 参数设置需要平滑缓慢对待，增加“MD 轨迹保存频率”；缩短“MD 模拟步数”或降低“MD 步长”，增加迭代次数，其 DP 训练势函数稳定后再延长 MD 模拟步数。 ABACUS 收敛性测试 对每种体系一定要先做各个参数的收敛性测试，特别是：K 点、能量截断，也可测试 scf_thr 降低计算量。另外，对于赝势文件也一定要做性质测试，看是否能够正确描述目标体系的性质 每隔几轮做一次 dp test 初始数据得到后，第一轮生成了 dp 势之后，一定要检查 trian 步骤收敛情况和做 dp test。dp test 用如下命令： dp test -m frozen_model.pb -s ./collect_data -n 2000 -d out.out frozen_model.pb 为生成的 4 个模型中的某一个，2000 为 collect_data 里面单个结构的总数。out.out 会生成 out.e.out out.f.out out.f.out 三个偏差数据文件，用于作图判断模型优劣屏幕会输出每个构型力、能量等误差平均值，也可用*.out 文件做出 DP 和 DFT 偏差图，如： 经验性的，力的精度在 1e-2 量级，能量精度在 5e-3 量级，说明模型比较好。 四、计算材料 EOS 和弹性常数的流程 本例子里提供了一个 auto-test 文件夹，进入之后可以结合 DPGEN 的 auto-test 命令计算材料 EOS、弹性常数的流程 auto-test 的详细流程，可以从如下网页教程查阅： https://bohrium-doc.dp.tech/docs/software/DP-GEN_autotest 这里贴上如何使用 ABACUS 来计算材料 EOS、弹性常数的相关输入文件 relaxation.json： { \"structures\": [\"conf\"], \"interaction\": { \"type\": \"abacus\", \"incar\": \"./INPUT\", \"potcar_prefix\":\"./\", \"potcars\": {\"Si\": \"Si_ONCV_PBE-1.0.upf\",\"C\": \"C_ONCV_PBE-1.0.upf\"}, \"orb_files\": {\"Si\":\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C\":\"C_gga_9au_100Ry_3s3p2d.orb\"} }, \"relaxation\": { \"cal_type\": \"relaxation\", \"cal_setting\":{ \"input_prop\": \"./INPUT\" } } } property.json： { \"structures\": [\"conf\"], \"interaction\": { \"type\": \"abacus\", \"incar\": \"./INPUT\", \"potcar_prefix\":\"./\", \"potcars\": {\"Si\": \"Si_ONCV_PBE-1.0.upf\",\"C\": \"C_ONCV_PBE-1.0.upf\"}, \"orb_files\": {\"Si\":\"Si_gga_9au_100Ry_3s3p2d.orb\",\"C\":\"C_gga_9au_100Ry_3s3p2d.orb\"} }, \"properties\": [ { \"type\": \"eos\", \"vol_start\": 0.9, \"vol_end\": 1.1, \"vol_step\": 0.02 }, { \"type\": \"elastic\", \"norm_deform\": 1e-2, \"shear_deform\": 1e-2 } ] } INPUT： INPUT_PARAMETERS calculation cell-relax symmetry 0 basis_type lcao ecutwfc 100.0 scf_thr 1.0e-06 scf_nmax 100 smearing_method gauss smearing_sigma 0.002 mixing_type pulay mixing_beta 0.3 cal_force 1 cal_stress 1 kspacing 0.10 在当前目录建立一个 conf 文件夹，把 STRU 文件放进去，依次运行下面命令： dpgen autotest make relaxation.json nohup dpgen autotest run relaxation.json machine.json & dpgen autotest post relaxation.json dpgen autotest make property.json nohup dpgen autotest run property.json machine.json & dpgen autotest post property.json 计算完成之后，会在 conf/elastic_00/result.out 文件里记录弹性常数、模量等信息，conf/eos_00/result.out 里记录 EOS 等数据。 以上即为采用 ABACUS 3.2.0 和 DPGEN 软件结合的介绍，若有任何问题，欢迎给我们反馈。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-sdft.html":{"url":"abacus-sdft.html","title":"ABACUS 随机波函数 DFT 方法使用教程","keywords":"","body":"ABACUS 随机波函数 DFT 方法使用教程 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/07/11 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍 ABACUS 中随机波函数密度泛函理论（Stochastic Density Functional Theory，以下简称 SDFT）计算功能。目前 ABACUS 使用 SDFT 主要聚焦在高温高压物质的模拟，特别是温稠密物质（Warm Dense Matter，简称 WDM）。在进行温稠密物质计算时（温度高达数十到上千 eV， 1 eV=11604.5 K），传统的 Kohn-Sham 密度泛函理论（KSDFT）需要用到极大数量的占据态电子波函数导致计算困难，而 SDFT 使用随机波函数轨道，可以有效地避开对角化哈密顿矩阵这个问题，应用于高温计算。关于 ABACUS 中实现 SDFT 算法的细节可以参考 Qianrui Liu and Mohan Chen*, \"Plane-wave-based stochastic-deterministic density functional theory for extended systems,\" Phys. Rev. B, 106, 125132 (2022)。本教程中将会展示如何在 ABACUS 计算中使用 SDFT 功能，此外还会介绍混合随机波函数密度泛函理论方法使用（mixed stochastic-deterministic DFT，简称 MDFT），即在 SDFT 计算中，混入一部分的低能 Kohn-Sham 轨道，从而加速结果收敛。 二、软件和算例准备 ABACUS 的软件包（3.2.0 版本）中提供了一个 SDFT 的算例，可以从 Gitee 上下载。可以在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载后解压，之后进入/abacus-user-guide/examples/stochastic 文件夹。算例中有三个文件夹，pw_Si2、pw_md_Al 和 186_PW_SDOS_10D10S。 三、采用 SDFT 进行电子自洽迭代计算 pw_Si2文件夹：这是一个电子温度为 0.6 Ry（约 8.16 eV）的 2 个原子的金刚石结构硅（Si）的电子自洽迭代（Self Consistent Field，简称 SCF）算例，包含布里渊区 K 点的 KPT 文件和包含原子位置的 STRU 文件与传统的 KSDFT 计算并无区别，主要的不同在于输入文件 INPUT，注意目前 SDFT 仅支持 smearing_method 为 fd。INPUT 文件如下： INPUT_PARAMETERS #Parameters (General) calculation scf esolver_type sdft pseudo_dir ../../PP_ORB nbands 4 nbands_sto 64 nche_sto 100 method_sto 1 #Parameters (Accuracy) ecutwfc 50 scf_nmax 20 symmetry 1 #Parameters (Smearing) smearing_method fd smearing_sigma 0.6 以上参数在 ABACUS 的线上文档中均有详细说明，这里再进行简单概述： calculation设置为 scf，代表进行电子自洽迭代计算（self-consistent field）。 esolver_type是选择系统总能量求解方法的，默认为 ksdft（Kohn-Sham density functiona theory），这里需要设置为 sdft 才会使用 SDFT 或者 MDFT 进行计算。 nbands是使用的 Kohn-Sham 轨道的数目（也叫 determinstic orbitals，是通过严格对角化矩阵计算出来的）。如果 nbands 设置为 0，且 nbands_sto（随机轨道数目，这里设成 64）不为 0，则会进行 SDFT 计算；如果 nbands>0，且 nbands_sto>0，则会进行混合 KS 电子轨道和随机轨道（stochastic orbitals）的 MDFT 计算。注意：一般 nbands 设置为能量低于费米能级对应的能带数，计算效率会比较高。 nbands_sto是使用随机波函数（stochastic orbitals）轨道数目，原则上取得越大则随机误差越小，但计算效率也会相应降低。 判断随机波函数个数是否足够的一个经验法则是：测试能量误差。实际计算中，一般可以采用10 个左右不同的随机数种子（可以参考 seed_sto 参数设置随机数种子，下面有介绍）生成的相同数目的随机波函数轨道进行 SDFT 计算，得到系统能量并求得相应误差，增加随机波函数轨道数目直到控制能量误差小于万分之一即可。 当 nbands_sto 设为 0 时， 程序会自动转成 KSDFT 进行计算（ABACUS 3.2.2 版本以后）。 nche_sto是将电子体系的哈密顿量进行切比雪夫展开的阶数，这个数取得越大则用到的切比雪夫展开阶数越多，相应的计算精度也会越高但效率会降低。大致关系为与温度成反比，温度越高，阶数可以取得越小；ecut（正比关系）越大，阶数越大；推荐使用的 nche_sto 的大小是使得输出文件 running_scf.log 中的 Chebyshev Precision 小于 1e-8。 method_sto是进行 SDFT 计算使用的方法：1 代表消耗内存较少但稍慢的方法，2 代表更快但需要更大内存的方法，默认是 2。 此外还有如下参数可能会用到： seed_sto：生成随机轨道的随机种子。默认是 0，代表随时间随机生成；若要控制使用相同的随机种子，可以设置一个大于 1 的整数。 bndpar：将所有并行的进程分成 bndpar 个组，计算所用随机轨道将平均分布在每个组中，可以提高并行效率，默认为 1。值得注意的是，这个参数并不是越大越好，并且不如 K 点并行（kpar参数）有效，实际计算中应该优先使用 K 点并行，然后测试不同大小的 bndpar，确定最佳的 bndpar。 平面波能量截断值 ecut 的测试：由于随机误差的出现，SDFT 的 ecut 的测试与传统的 KSDFT 稍有区别，但是原理是类似的。在确定好 nbands_sto 后，就可以测试 ecut 了。与测试 nbands_sto 类似，在不同的 ecut，需要采用 10 个左右不同的随机种子生成的相同数目的随机波函数轨道进行 SDFT 计算，然后取平均能量。由于温稠密物质能量一般都比较高，因此只要控制相邻二个 ecut（相差为 10 Ry）对应的平均能量差小于一定标准即可（例如万分之一）。 注 1：在这个例子里我们提供的赝势是 Si.pz-vbc.UPF 文件，这个文件包含 4 个硅的价电子。事实上，当温度特别高的时候，一般的赝势可能会面临可移植性差的问题，例如高温会使得内壳层电离。这个时候，要选择合理的赝势进行计算，甚至可能需要自己造一个新的赝势，目前 ABACUS 3.2.0 支持的是模守恒的赝势。 注 2：ABACUS 的 SDFT 和 MDFT 支持多个 k 点采样，因此可以在 KPT 文件里设置不同的 k 点个数，在某些性质的计算里，要注意计算性质随着 k 点的收敛。 四、采用 SDFT 进行分子动力学模拟 pw_md_Al 文件夹：这是一个电子温度为 7.35 Ry（约 100 eV）、包含 16 个铝（Al）原子的结构，我们对其进行分子动力学（Molecular Dynamics，简称 MD）的模拟。INPUT 文件如下： INPUT_PARAMETERS #Parameters (General) calculation md esolver_type sdft pseudo_dir ../../PP_ORB nbands 0 nbands_sto 64 nche_sto 20 method_sto 2 #Parameters (Accuracy) ecutwfc 50 scf_nmax 20 scf_thr 1e-6 symmetry 1 #Parameters (Smearing) smearing_method fd smearing_sigma 7.34986072 #Parameters (MD) md_tfirst 1160400 md_dt 0.2 md_nstep 10 注意要进行分子动力学模拟，calculation 参数需设置为 md。esolver_type 需设置为 sdft，才能进行 SDFT 的计算。这里 nbands 设置为 0，nbands_sto 设置为 64，代表仅仅使用随机轨道而没有 KS 轨道的 SDFT 计算。 五、采用 SDFT 计算态密度 186_PW_SDOS_10D10S 文件夹：采用 SDFT 还可以计算给定体系的态密度（Density of States，简称 DOS）。例如，186_PW_SDOS_10D10S 是一个 1 个 Si 原子的算例，电子温度约为0.6 Ry（约 8.16 eV）。如下所示： INPUT_PARAMETERS #Parameters (1.General) suffix autotest calculation scf esolver_type sdft method_sto 2 nbands 10 nbands_sto 10 nche_sto 120 emax_sto 0 emin_sto 0 seed_sto 20000 pseudo_dir ../../PP_ORB symmetry 1 kpar 1 bndpar 2 #Parameters (2.Iteration) ecutwfc 20 scf_thr 1e-6 scf_nmax 20 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method fd smearing_sigma 0.6 #Parameters (5.Mixing) mixing_type broyden mixing_beta 0.4 out_dos 1 dos_emin_ev -20 dos_emax_ev 100 dos_edelta_ev 0.1 dos_sigma 4 dos_nche 240 npart_sto 2 以上参数在 ABACUS 的线上文档中均有说明，这里再进行简单概述： out_dos：需要设置为 1，才能输出能态密度。 dos_emin_ev：能态密度的能量最小范围，单位 eV。 dos_emax_ev：能态密度的能量最大范围，单位 eV。 dos_edelta_ev：控制输出DOS时的能量间隔，单位 eV。 dos_sigma：能态密度的高斯展宽的因子，单位 eV。 dos_nche：计算能态密度时切比雪夫展开阶数，默认为 100。 npart_sto：当使用 method_sto＝2 运行例如 DOS 的 SDFT 后处理时，将控制使用内存大小为正常的 1/npart_sto，防止内存不够导致无法计算，默认为 1。 注：态密度的输出文件是 OUT 文件夹下的 DOS1_smearing.dat。 六、结尾 总体来讲，随机波函数密度泛函理论方法（SDFT 或者 MDFT）的使用与 KSDFT 并无太大的区别，直接运行 ABACUS 程序即可，但是对一些关键参数的选取会影响精度和效率（例如 nbands, nbands_sto, nche_sto, method_sto, kpar, bnd_par）。对于极端高温计算（>10 eV），使用 SDFT 可以大大提高计算速度，是比普通的 KSDFT 更好的选择。如果大家使用有问题，欢迎写信联系（见上）。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-sdft_cond.html":{"url":"abacus-sdft_cond.html","title":"ABACUS 随机波函数 DFT 计算电子电导热导教程","keywords":"","body":"ABACUS 随机波函数 DFT 计算电子电导热导教程 作者：刘千锐，邮箱：terry_liu@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024/10/15 一、介绍 对于物质的电导热导，一般可以分成电子和离子贡献，而对于电子贡献的部分可以使用 Kubo-Greenwood 的公式进行计算[Phys. Rev. B 83, 235120 (2011)]，该方法已被广泛应用于液态金属、温稠密(Warm Dense matter, WDM)等物质的计算。Kubo-Greenwood 通过直接计算含频的昂萨格系数L_{mn}(\\omega)，来计算电子的电导与热导： L_{mn}(\\omega)=(-1)^{m+n}\\frac{2\\pi e^2}{3\\omega\\Omega}\\\\ \\times\\sum_{ij\\alpha\\mathbf{k}}W(\\mathbf{k})\\left(\\frac{\\epsilon_{i\\mathbf{k}}+\\epsilon_{j\\mathbf{k}}}{2}-\\mu\\right)^{m+n-2} |\\langle\\Psi_{i\\mathbf{k}}|\\hat{v}_\\alpha|\\Psi_{j\\mathbf{k}}\\rangle|^2[f(\\epsilon_{i\\mathbf{k}})-f(\\epsilon_{j\\mathbf{k}})]\\delta(\\epsilon_{j\\mathbf{k}}-\\epsilon_{i\\mathbf{k}}-\\hbar\\omega), 这里的 n,m 指标取值范围为 1, 2， \\Omega为体积，W(\\mathbf{k})为 k 点的权重，\\varepsilon_{i\\mathbf{k}}为第 i 个波函数\\left | \\Psi_{ik} \\right \\rangle对应的本征能量， f(\\varepsilon)=\\frac{1}{1+\\exp(\\frac{\\varepsilon-\\mu}{kT})}为费米狄拉克分布，\\mu为化学势，\\delta(x)为 delta 函数，在实际计算中 delta 函数可以用高斯函数G(x)=\\frac{1}{\\sqrt{2\\pi}s}\\exp\\left(-\\frac{x^2}{2s^2}\\right)或洛伦兹函数L(x)=\\frac{1}{\\pi}\\frac{\\gamma}{x^2+\\gamma^2}代替，\\hat{v}_{\\alpha}为速度算符的第\\alpha个分量(\\alpha=x,y,z)对于速度算符，速度算符的定义为\\hat{v}=\\frac{i}{\\hbar}[\\hat{H},\\hat{r}]。 含频电导\\sigma(\\omega)=L_{11}(\\omega)，直流电导\\sigma_0=\\lim_{\\omega\\to0}\\sigma(\\omega) 含频热导\\kappa(\\omega)=\\frac{1}{e^2T}\\left(L_{22}-\\frac{L^2_{12}}{L_{11}}\\right), 热导\\kappa_0=\\lim_{\\omega\\to0}(\\omega) 以上便是传统 KSDFT 计算的方法，通过 KSDFT 求解的波函数、本征能量，可以轻易的带入公式进行计算。 对于随机波函数密度泛函理论(sDFT)，其没有波函数、本征能量不能通过该方法进行计算。而应从原始的 Kubo 公式中出发： 电流、热流响应函数：C_{mn}(t)=-2\\theta(t)\\Im\\left\\{Tr\\left[\\sqrt{\\hat f}\\hat{j}_m(1-\\hat{f})e^{i\\frac{\\hat{H}}{\\hbar}t}\\hat{j}_ne^{-i\\frac{\\hat{H}}{\\hbar}t}\\sqrt{\\hat f}\\right]\\right\\}, 这里\\theta(x)为阶跃函数，\\Im为取虚部，\\hat{f}=\\frac{1}{1+\\exp(\\frac{\\hat{H}-\\mu}{kT})}为费米狄拉克算符，\\hat{j}_1=e\\hat{v}为电流算符，\\hat{j}_2=(\\hat{v}\\hat{H}+\\hat{H}\\hat{v})/2-\\mu\\hat{v}为热流算符，e^{-i\\hat{H}t/\\hbar}为演化算符。这里求迹便可通过随机波函数进行计算。 而昂萨格系数就可通过响应函数的傅里叶变换进行计算：L_{mn}=\\frac{2e^{m+n-2}}{3\\Omega\\hbar\\omega}\\Im[\\tilde{C}_{mn}(\\omega)]，这里计算\\tilde{C}_{mn}(\\omega)可以使用不同的窗函数： 高斯型：\\tilde{C}_{mn}(\\omega)=\\int_0^\\infty C_{mn}(t)e^{-i\\omega t}e^{-\\frac{1}{2}s^2t^2}dt 洛伦兹型：\\tilde{C}_{mn}=\\int_0^\\infty C_{mn}(t)e^{-i\\omega t}e^{-\\gamma t}dt 其分别与前面提到的高斯函数G(x)和洛伦兹函数L(x)对应。 二、算例准备 下载链接： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/stochastic/cond_Si 三、采用 sDFT 进行电子的电导热导计算 1. 输入文件 cond_Si 文件夹：这是一个电子温度为 0.6 Ry（约 8.16 eV）的 单原子硅（Si）的电导热导计算算例，包含布里渊区 K 点的 KPT 文件和包含原子位置的 STRU 文件与传统的 KSDFT 计算并无区别，主要的不同在于输入文件 INPUT。为了计算电导热导，我们只需要把 cal_cond 参数打开即可，INPUT 文件如下： INPUT_PARAMETERS #Parameters (1.General) suffix Si calculation scf esolver_type sdft nbands 10 nbands_sto 40 nche_sto 120 seed_sto 20000 symmetry 1 kpar 1 bndpar 2 #Parameters (2.Iteration) ecutwfc 40 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method fd smearing_sigma 0.6 #Parameters (5.Mixing) mixing_type broyden mixing_beta 0.4 #Parameters (6.Conductivity) cal_cond 1 cond_smear 1 cond_fwhm 0.4 cond_wcut 20 cond_dw 0.02 cond_dt 0.1 以上参数在 ABACUS 的线上文档中均有详细说明，这里再进行简单概述： cal_cond: 控制是否计算电子贡献的电导热导 cond_smear: 设置展宽类型，1：高斯展宽（默认），2：洛伦兹展宽 cond_fwhm: 设置半高宽 FWHM，对于高斯展宽, \\mathrm{FWHM}=2\\sqrt{2\\ln2}s; 对于洛伦兹展宽 \\mathrm{FWHM}=2\\gamma. cond_wcut: 计算频率的截断值，决定输出含频数据的频率范围, 单位: eV cond_dw: 频率的间隔，单位:eV cond_dt: 对响应函数积分时的积分间隔，原子单位，响应函数振荡过快需要较小积分间隔，一般取值在 0.01-0.2 a.u.，在屏幕输出中有推荐的取值：Recommended dt: 1.553e-01 a.u. cond_dtbatch: 其与 cond_dt 共同决定演化算符\\exp(i\\hat{H}* \\mathrm{cond\\_dtbatch} * dt)的切比雪夫展开阶数，一般来说该值设的越大，内存消耗越多，但速度越快，当其达到一定值，速度就不会增加。当其设为 0 时，程序会自动决定 cond_dtbatch 以使切比雪夫展开阶数在 100 附近。 计算时间的说明： 使用 sDFT 计算电导热导还是比较慢的，计算时间正比于切比雪夫展开阶数和nt = t_{total}/(\\mathrm{cond\\_dtbatch} * dt) 切比雪夫阶数由平面波截断能决定，阶数约正比于截断能 nt 由t_{total}决定，而t_{total}由 cond_fwhm 决定，其长度反比于 cond_fwhm，因此该方法不能使用任意小的展宽。 增加\\mathrm{cond\\_dtbatch} * dt会使切比雪夫展开阶数增加，会使 nt 减小，总体效应是其值越大，计算效率越高，但达到一定程度，效率就不再增高了。 2. 输出文件： 注：结果仅供参考，以最新版本算出的结果为准 a. 屏幕输出： set cond_dtbatch to 69 自动设置cond_dtbatch参数 set N order of Chebyshev for KG as 113 演化算符的切比雪夫展开阶数 Calculating conductivity.... nw: 1000 ; dw: 2.000e-02 eV 总频率数，频率间隔 nt: 4862 ; dt: 1.000e-01 a.u.(ry^-1) 总时间数，时间间隔 Emin_KS(2): 1.373e+01 eV; Emax: 5.442e+02 eV; Recommended max dt: 1.553e-01 a.u. 推荐cond_dt ik=0: (Time left 1.673e+02 s) 估计剩余计算时间 nt: 计算进度 69 138 207 276 345 414 483 552 621 690 759 828 897 966 1035 1104 1173 1242 1311 1380 1449 1518 1587 1656 1725 1794 1863 1932 2001 2070 2139 2208 2277 2346 2415 2484 2553 2622 2691 2760 2829 2898 2967 3036 3105 3174 3243 3312 3381 3450 3519 3588 3657 3726 3795 3864 3933 4002 4071 4140 4209 4278 4347 4416 4485 4554 4623 4692 4761 4830 DC electrical conductivity: 2.454778e+05 Sm^-1 直流电导值（直接线性外推的简单估计值，实际需要根据含频电导拟合外推） Thermal conductivity: 5.968738e+02 W(mK)^-1 热导值 Lorenz number: 3.456403e+00 k_B^2/e^2 洛伦兹常数 b. je-je.txt: #t(a.u.) c11(t) c12(t) c22(t) decay 0 -0 -0 -0 1 0.1 -1.39981 6.61846 -38.6529 0.999999 0.2 -1.91869 6.94748 -25.4566 0.999997 0.3 -1.87453 5.46871 -15.4962 0.999993 0.4 -1.613 3.75367 -6.29163 0.999988 0.5 -1.36998 3.0228 -6.02995 0.999981 0.6 -1.1229 2.41076 -5.2121 0.999972 0.7 -0.84644 1.75119 -5.82033 0.999962 0.8 -0.529567 0.779473 -2.13103 0.99995 储存响应函数的文件，各列分别为均为原子单位，时间 t, 响应函数C_{11}(t), C_{12}(t), C_{22}(t), 窗函数 c. Onsager.txt: ## w(eV) sigma(Sm^-1) kappa(W(mK)^-1) L12/e(Am^-1) L22/e^2(Wm^-1) 0.01 250820 604.318 -4.66249e+06 1.4392e+08 0.03 261503 619.205 -4.83345e+06 1.47997e+08 0.05 283291 649.006 -5.18082e+06 1.56228e+08 0.07 317019 693.79 -5.71545e+06 1.68767e+08 0.09 363915 753.684 -6.45332e+06 1.85835e+08 0.11 425574 828.87 -7.41519e+06 2.07723e+08 0.13 503909 919.555 -8.62601e+06 2.34774e+08 0.15 601083 1025.94 -1.01141e+07 2.67375e+08 0.17 719414 1148.17 -1.19101e+07 3.05944e+08 储存昂萨格系数的文件，各列分别为频率，电导，热导，L_{12}(\\omega), L_{22}(\\omega) Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-tddft.html":{"url":"abacus-tddft.html","title":"ABACUS 实时演化含时密度泛函理论使用教程","keywords":"","body":"ABACUS 实时演化含时密度泛函理论使用教程 作者：赵昊天，邮箱：zaotian@mail.ustc.edu.cn 审核：包涛尼，邮箱：baotaoni@pku.edu.cn 最后更新时间：2024 年 7 月 11 日 一、背景 实时演化含时密度泛函理论（Real-time Time-Dependent Density Functional Theory，简称 rt-TDDFT）是一种基于第一性原理的模拟激发态电子体系动态演化的方法。与传统的密度泛函理论（DFT）不同，rt-TDDFT 是建立在 Runge-Gross 定理之上，主要研究时间依赖的 Kohn-Sham 方程（TDKS 方程）。该理论通过构建时间传播子迭代求解 TDKS 方程，直接演化电子的波函数。此外，它还采用半经典的 Ehrenfest 动力学来模拟离子实的运动，可以实时地得到激发电子态以及离子位置的信息，因此具有较为广泛的应用前景。 周期性体系具有能带结构，而非周期性的原子或分子体系则具有离散能级。体系的基态是指价电子从低到高依次填充至能带或能级中。当体系吸收特定能量后，低能态的电子跃迁至高能态，此时体系便处于激发态。研究激发态性质是 TDDFT 的一大优势，因此掌握如何模拟体系的激发态变得尤为关键。ABACUS 为此提供了两种方式：一种是直接改变占据数，使得叠加态的波函数拥有更多高能态分量；另一种是向一个处于基态的体系施加一个外加电场，为其提供激发所需的能量。下面将分别介绍这两种方式的具体使用。文档中提到的算例可以在如下仓库中找到：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/tddft 有关 TDDFT 输入参数的细节可参考输入参数线上文档：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#tddft-time-dependent-density-functional-theory 二、在ABACUS 中使用rt-TDDFT时改变电子的占据数 算例：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/tddft/occupation 算例输入文件 INPUT 设置如下： INPUT_PARAMETERS #Parameters (1.General) suffix H2_ocp calculation md esolver_type tddft nbands 5 nspin 1 pseudo_dir ../../../tests/PP_ORB orbital_dir ../../../tests/PP_ORB #Parameters (2.Iteration) ecutwfc 60 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type lcao gamma_only 0 #Parameters (4.Smearing) smearing_method gauss #Parameters (5.MD Parameters) md_type nve md_nstep 1000 md_dt 0.05 md_tfirst 0 #Parameters (6.TDDFT Occupation Parameters) ocp 1 ocp_set 1 1 0 0 0 具体参数设置请参考线上文档，这里仅对部分重要参数进行说明： gamma_only：必须设置为 0，gamma_only 为 1 会采用 double 类型计算，rt-TDDFT 使用传播子迭代计算波函数，需要 complex 类型存储数据，不兼容 gamma_only 为 1 的情况。 basis_type：必须设置为 lcao，目前 ABACUS 仅支持基于数值原子轨道基组的 rt-TDDFT 功能。 nbands：能带数，由于 ocp_set 需要手动设置每一条能带的占据数到最高带，建议手动设置 nbands，防止二者不对应。 calculation：必须为 md，同时一般 MD（Molecular Dynamics）计算所需的参数都需要设置，这部分参数会对应 rt-TDDFT 的离子实运动的计算。 esolver_type：tddft，表示采用 rt-TDDFT 求解器。 ocp：改变占据数功能的开关，为 1 的时候开启。 ocp_set：占据数的设置，1 1 0 0`` 0 表示这个算例所计算的五条能带，各自占据的电子数，其总和为 2，代表 H₂ 的两个价电子，可以简化为 2*1 ``3``*0。另外，对于有多个 k 点的体系，ABACUS 支持对各个 k 点单独设置占据数。假设体系拥有 5 条能带，2 个 k 点，则 ocp_set 需要指定 10 个数值，前五个代表第一个 k 点五条能带的占据，后五个代表第二个 k 点五条能带的占据。 按照分子轨道理论，两个 H 原子的原子轨道发生相互作用形成一条成键轨道、一条反键轨道，H₂ 分子的基态占据可以表示为 2 0 0 0`` 0，最低的能态代表成键轨道，则 1 1 0 0`` 0 占据数表示将一个电子从成键轨道上激发到反键轨道，会导致 H₂ 分子发生解离。通过输出目录 OUT.H2_ocp/STRU 下的结构文件，可以看到随着时间的推移，两个 H 原子逐渐解离。运行 occupation 文件夹下的算例，通过 ASE-ABACUS 读取各个时刻 STRU 文件，并计算了两个 H 原子实时的间距d，结果如下图所示： 为了说明这个解离是由于改变占据数引起的，可以将 INPUT 替换为 occupation 文件夹中的 INPUT-1，其中 ocp_set 被改为：2 0 0 0`` 0，同样输出实时的原子间距，可以看到，两个原子间距稳定的振荡，并未发生解离： 三、ABACUS 中使用rt-TDDFT 外加电场计算材料吸收谱 在任意外加电场的影响下，rt-TDDFT 能够实时模拟并获得材料的电子态和离子位置信息。按照 Runge-Gross 定理（相当于 KSDFT 中的 Hohenberg-Kohn 定理），这等价于材料的全部物理性质。在众多的物理性质中，吸收谱作为材料基本的光电响应性质，处理简单，结果直观，可参考对比的数据丰富，很适合用于介绍 TDDFT 外加电场功能的基本细节。 3.1 规范选择 如何加入电场存在规范问题，根据电动力学的知识： \\boldsymbol{E} = -\\nabla V -\\frac{\\partial \\boldsymbol{A}}{\\partial t} 第一种是长度规范，把电场的影响归为纯标势的影响，向势场中加入： V\\propto \\boldsymbol{E} \\cdot \\boldsymbol{r} 因为晶胞很小，按照通常所用的光的波长，体系内的电场在空间上是近似匀强的，故这里没有写成积分的形式。这种形式相对简单，需要处理的项较少，程序处理较快，但是由于\\boldsymbol{r}的存在，它在周期性体系的边界是不连续的，只能采用锯齿状的方式在边界下降来衔接这种不连续性。对于非周期性体系，边界存在真空层，这种锯齿状衔接不会影响到材料的响应，但是对周期性体系，这种做法就行不通了。 对于周期性体系必须采用速度规范，它用矢势而非标势来引入电场： \\boldsymbol{A}(t)\\propto\\int_0^{t} \\boldsymbol{E}(t')\\,\\mathrm{d}t' 在这种规范下，需要对正常的项进行一系列变换，这里不详细论述，想进一步了解的可以参考文献 2 的内容。因而，我们实际上在程序里用的并不是直接的电场，而是标势或者矢势，但是它们都对应一个电场，程序指定电场的参数而不是势场的参数，这样可以统一处理长度和速度规范的场。 简单来说：长度规范只能处理非周期性体系，但是速度较快；速度规范可以处理周期性体系和非周期性体系，但是速度较慢，故一般建议对非周期性体系采用长度规范，周期性体系采用速度规范。 3.2 长度规范示例 算例：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/tddft/absorption_H2_length 输入文件 INPUT： INPUT_PARAMETERS #Parameters (1.General) suffix H2_absoprion calculation md esolver_type tddft pseudo_dir ../../../tests/PP_ORB orbital_dir ../../../tests/PP_ORB #Parameters (2.Iteration) ecutwfc 60 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type lcao gamma_only 0 #Parameters (4.Smearing) smearing_method gauss #Parameters (5.MD Parameters) md_type nve md_nstep 1000 md_dt 0.005 md_tfirst 0 #Parameters (6.Efield Parameters) td_vext 1 td_stype 0 td_tstart 1 td_tend 1000 td_vext_dire 3 3 td_ttype 0 0 td_gauss_freq 3.66 1.22 td_gauss_phase 0.0 0.0 td_gauss_sigma 0.2 0.2 td_gauss_t0 300 300 td_gauss_amp 0.01 0.01 #Parameters (7.Output) out_chg 1 out_efield 1 out_dipole 1 其他的注意事项和占据数一样，这里注意补充一些电场参数的细节： md_nstep：MD 步，这里为了做演示只用了 1000 步，演化总时长 5 fs，为了精度考虑，实际计算时应当增加步数，具体视所需体系有所差异，一般保证 20 fs 以上总时长较为妥当。 td_vext：外加电场的开关，1 为打开外加电场。 td_stype：规范的选择，0 为长度规范，1 为速度规范。 td_tstart：开始加入电场的步数，在 td_tstart 步之前，为无电场状态，一般为 1 即可。 td_tend：电场结束的步数，td_tend 后不再计算电场，用于无电场时节约资源，最大可以等同 md_nstep 的值。td_tend 后，标势为 0，而矢势固定为 td_tend 处的值不再变化。 td_type：电场的波包形状，0-3 分别对应高斯、梯形、三角、阶跃等不同类型的电场。 td_gauss_xxx：由于这里指定的是高斯型，对应高斯型的参数，具体可以参考输入参数的说明文档：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#tddft-time-dependent-density-functional-theory out_dipole：输出每个时刻的电偶极矩，我们通过对电偶极矩的分析得到吸收谱。 out_efield：输出每个时刻的电场。 注意，这里为了覆盖更大的频率范围，通过对电场形式的参数多加一列的方式，在一次计算中加入了两个不同频率的电场。理论上可以用这种方式得到各种形状的场，当加的较多时，支持采用正则表达式 m*x 的形式进行简化。 运行算例，会输出全时刻的电偶极矩文件 SPIN1_DIPOLE，如果 nspin 为 2 则会有 SPIN2_DIPOLE 文件分别对应两种自旋的电子各自的电偶极矩；以及电场文件 efield_x.dat，x 的数量视所加的电场数量而定，这个算例就是两个：efield_0.dat 和 efield_1.dat。不考虑单位，通过下列公式得到分子的吸收谱信息： \\alpha_i(\\omega)=\\frac{\\displaystyle\\int D_i(t)\\mathrm{e}^{\\mathrm{i}\\omega t}\\,\\mathrm{d}t}{\\displaystyle\\int E_i(t)\\mathrm{e}^{\\mathrm{i}\\omega t}\\,\\mathrm{d}t} D_i为i方向的电偶极矩，E_i为i方向的电场。程序自带了相应的后处理功能，具体请参考 tools``/``plot-tools 下的说明进行使用，其结果如下： 这表明在z方向加的电场激发了一个频率为 8.5 eV 左右的吸收峰。 3.3 速度规范示例 算例：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/tddft/absorption_H2_velocity 速度规范的流程与长度规范基本相同，主要不同的参数有两个： td_stype：变为了 1，代表进行速度规范计算。 out_current：输出电流的开关。对无限大的周期性体系无法定义电偶极，采用电流来代替，公式可以参考本文的参考文献 2。简单来说： I(t)\\propto\\frac{\\mathrm{d}D(t)}{\\mathrm{d}t} 因此在傅里叶变换时： D(\\omega)\\propto\\frac{I(\\omega)}{\\mathrm{i}\\omega} 因此二者可以得到类似的结果，不过 current 的结果由于分母的原因，在极低频时会无法避免的发散。相应的问题在文献 3 中有讨论。 四、参考文献 Meng S, Kaxiras E. Real-Time, Local Basis-Set Implementation of Time-Dependent Density Functional Theory for Excited State Dynamics Simulations[J]. The Journal of Chemical Physics, 2008, 129(5), https://doi.org/10.1063/1.2960628 . Pemmaraju C D, Vila F D, Kas J J, et al. Velocity-Gauge Real-Time TDDFT Within a Numerical Atomic Orbital Basis Set[J]. Computer Physics Communications, 2018, 226: 30-38, https://doi.org/10.1016/j.cpc.2018.01.013 . Yabana K, Sugiyama T, Shinohara Y, et al. Time-Dependent Density Functional Theory for Strong Electromagnetic Fields in Crystalline Solids[J]. Physical Review B, 2012, 85(4): 045134, https://link.aps.org/doi/10.1103/PhysRevB.85.045134 . Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-ofdft.html":{"url":"abacus-ofdft.html","title":"ABACUS 无轨道密度泛函理论方法使用教程","keywords":"","body":"ABACUS 无轨道密度泛函理论方法使用教程 作者：孙亮，邮箱：l.sun@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/07/19 在Bohrium Notebook上快速学习： 一、无轨道密度泛函理论背景知识 无轨道密度泛函理论(Orbital free density functional theory, OFDFT)是一种第一性原理模拟方法，相比于 Kohn Sham DFT (KSDFT)，它的优势之一在于O(N\\ln N)的算法复杂度，这使得 OFDFT 可以用于上万原子甚至更大体系的电子基态计算，或者大体系、长时间的第一性原理分子动力学等。 目前，OFDFT 已被应用于简单金属、合金、半导体、小分子、温稠密物质等体系。 1. 无轨道密度泛函理论 在 OFDFT 的框架下，体系的总能量泛函可以写为 E_{\\rm{OF}}[\\rho] = T_{\\rm{s}}[\\rho] + E_{\\rm{ext}}[\\rho] + E_{\\rm{H}}[\\rho] + E_{\\rm{xc}}[\\rho] + E_{\\rm{II}}. 依次为无相互作用动能T_{\\rm{s}}[\\rho]，电子-离子相互作用能E_{\\rm{ext}}[\\rho]，电子-电子相互作用能E_{\\rm{H}}[\\rho]，交换关联能E_{\\rm{xc}}[\\rho]，离子-离子相互作用能E_{\\rm{II}}，其中\\rho为电荷密度。 为了在粒子数守恒的条件下求解其极小值，利用拉格朗日乘子法，定义 L=E_{OF}[\\rho]-\\mu(\\int{\\rho(r)dr}-N), 可以证明，这里的乘子\\mu就是无相互作用体系中最高占据态的能量，即化学势。为了保证密度处处为正，一般对\\sqrt\\rho进行优化，因此求L对\\sqrt\\rho的导数，为了方便，定义\\phi(r) = \\sqrt {\\rho(r)}，则有 \\frac{\\delta L}{\\delta \\phi}=\\frac{ \\delta E_{OF}[ \\rho ] }{ \\delta \\phi }-2\\mu\\phi=0 \\rightarrow V(r)\\phi(r)=\\mu\\phi(r). \\ \\ \\ \\ \\ \\ \\ \\ (*) 其中V(r)=\\frac{ \\delta E_{OF}[ \\rho ] }{ \\delta \\rho(r) }为势能。这就是 OFDFT 求解的方程，一般用共轭梯度（CG）法、截断牛顿（TN）法或 L-BFGS 等优化算法求解。目前 ABACUS 中实现了 TN 法和两种 CG 法（Polak-Ribire 形式和 Hager-Zhang 形式），默认采用 TN 法。 ABACUS 基于平面波基矢量，实现了上述流程，可以进行基于 OFDFT 的自洽计算，分子动力学计算，以及结构弛豫。 2. 动能泛函 OFDFT 的精度高度依赖于动能泛函（kinetic energy density functional, 简称 KEDF）的精度，目前 ABACUS 中实现了 Thomas-Fermi (TF) [1], von Weizsäcker (vW) [2], TFλvW [3], Wang-Teter (WT) [4], Luo-Karasiev-Trickey (LKT) [5]共五种动能泛函。 下面我们对这些泛函做简单介绍，并且介绍在 ABACUS 的 INPUT 文件中如何设置相关的参数。 2.1 Thomas-Fermi KEDF 设置 INPUT 文件中的 of_kinetic tf 参数 T_{\\rm{TF}}=\\frac{3}{10}(3\\pi^2)^{2/3}\\int{\\rho^{5/3}(r)dr}, 对均匀电子气精确成立，可用于极高温体系，比如处于温稠密状态的金属。 可通过 of_tf_weight 调整其权重，默认为 1。 2.2 von Weizsäcker KEDF 设置 of_kinetic vw T_{\\rm{vW}}=-\\frac{1}{2}\\int{\\sqrt{\\rho(r)} \\nabla^2 \\sqrt{\\rho(r)}dr}, 对单电子、双电子体系（只有一条轨道）严格成立，一般不单独使用。 可通过 of_vw_weight 调整其权重，默认为 1。 2.3 TFλvW KEDF 设置 of_kinetic tf+ T=T_\\text{TF}+\\lambda T_\\text{vW}, 当\\lambda=\\frac{1}{9}时就是TF KEDF的二阶梯度展开，一般\\lambda=\\frac{1}{5}时表现最好。 参数\\lambda可通过of_vw_weight设置，默认为1。 2.4 Wang-Teter KEDF 设置of_kinetic wt T_{\\rm{WT}} = \\frac{3}{10}(3\\pi^2)^{2/3} \\iint{\\rho ^{\\alpha}(r)W(r - r'){\\rho ^{\\beta}}(r') drdr'} + T_{\\rm{vW}} + T_{\\rm{TF}}, 基于 Lindhard 响应函数推导，在简单金属 Li、Mg、Al 中有着不错的表现。是 ABACUS 默认采用的 KEDF。 参数\\alpha,\\beta可通过 of_wt_alpha 和 of_wt_beta 设置，默认值均为\\frac{5}{6}。 2.5 Luo-Karasiev-Trickey KEDF 设置 of_kinetic lkt T_{\\rm{LKT}}= \\int{\\tau_{\\rm{TF}}\\frac{1}{\\cosh as}dr} + T_{\\rm{vW}}, s=\\frac{1}{2(3\\pi^2)^{1/3}}\\frac{|\\nabla\\rho|}{\\rho^{4/3}}. 可用于简单金属和半导体，计算效率较高，但在简单金属中精度低于 WT KEDF。 参数 a 可通过 of_lkt_a 设置，默认值为 1.3。 3. 局域赝势 由于 OFDFT 中舍弃了单电子轨道，无法采用常用的非局域赝势，如模守恒赝势，而必须采用局域赝势。 目前 ABACUS 支持 BLPS (bulk-derived local pseudopotential)。 下载地址： https://github.com/EACcodes/local-pseudopotentials实空间赝势：ABINIT, ABACUS； 倒空间赝势：PROFESS。赝势生成(需要和 ABINIT 7.0.5 结合)：https://github.com/EACcodes/BLPSGenerator覆盖 Li, Mg, Al, Si, P, Ga, As, In, Sb 九种元素 使用 BLPS 时，需要在 ABACUS 里调整的参数有： INPUT 中：pseudo_rcut 16 STRU 中：赝势种类设置为 blps，比如 Al 26.98 al.lda.lps blps 二、ABACUS 中进行 OFDFT 计算的具体流程 1. 自洽计算 1.1 示例 下面是输入文件的示例： INPUT 文件记录 OFDFT 计算所需主要参数 INPUT_PARAMETERS #Parameters (1.General) suffix example calculation scf esolver_type ofdft symmetry 1 pseudo_dir ../../PP_ORB/ pseudo_rcut 16 nspin 1 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 50 #Parameters (3.Basis) basis_type pw #OFDFT of_kinetic wt of_method tn STRU 文件记录元素种类、质量、赝势，晶格矢量，原子坐标等信息 ATOMIC_SPECIES Al 26.98 al.lda.lps blps LATTICE_CONSTANT 7.50241114482312 // add lattice constant LATTICE_VECTORS 0.000000000000 0.500000000000 0.500000000000 0.500000000000 0.000000000000 0.500000000000 0.500000000000 0.500000000000 0.000000000000 ATOMIC_POSITIONS Direct Al 0 1 0.000000000000 0.000000000000 0.000000000000 1 1 1 KPT 文件（因为 OFDFT 没有电子波函数，所以不需要布里渊区的多个 k 点，Gamma 点就可以） K_POINTS 0 Gamma 1 1 1 0 0 0 如上所示，与 KSDFT 的自洽计算相比，OFDFT 自洽计算的输入文件有以下几个区别： INPUT 不需要设置 smearing 和 charge mixing 相关参数，如果设置了也没有关系，这些参数不会影响 OFDFT 计算； 将 esolver_type 设置为 ofdft； 将 pseudo_rcut 设置为 16，以适配 BLPS 赝势。 STRU 将赝势种类设置为 blps。 做完以上调整后，即可使用默认参数进行 OFDFT 的自洽计算。 下面列举一些其它的重要参数： of_kinetic：用于选择动能泛函，可选项有 tf, vw, tf+, wt, lkt，默认值为 wt，具体介绍见 1.2 节； of_method：用于选择优化方法，可选项有 tn, cg1, cg2，分别对应截断牛顿法和两种 CG 法（Polak-Ribire 形式和 Hager-Zhang 形式），默认为 tn。一般而言，效率上 tn > cg2 > cg1； of_full_pw：做快速傅里叶变换（FFT）时，是否使用全部的平面波，默认为 True。建议打开，可以保证计算的稳定性和精度； of_full_pw_dim：控制 FFT 维数的奇偶性，可选项有 0, 1, 2，分别表示可奇可偶，保证为奇数，保证为偶数，默认为 0。FFT 维数为偶数时，可能导致微小的误差，但一般来说可以忽略。需要注意的是，如果打开了 nbspline，则需要设置 of_full_pw_dim 1，否则会导致计算不稳定。 1.2 注意事项 目前 ABACUS 的 OFDFT 模块并不是十分完善，使用时请注意以下几个注意事项： 目前 OFDFT 不支持 gamma only，因此使用 OFDFT 功能时请关闭 gamma_only； 目前 OFDFT 只支持自旋简并，即 nspin 1 的计算； 如果使用 PBE 泛函，建议用 dft_functional XC_GGA_X_PBE+XC_GGA_C_PBE 调用 Libxc 中的 PBE，否则可能导致计算不稳定。 2. 分子动力学与结构弛豫 ABACUS 中支持使用 OFDFT 作为能量、力和应力的求解器，进行分子动力学模拟与结构弛豫。 与使用 KSDFT 进行分子动力学或结构弛豫相比，使用 OFDFT 时，不需要对 MD，relax，或 cell-relax 相关参数进行修改，只需要按照 2.1 中的方式，将能量、力和应力的求解器替换为 OFDFT。 下面是几个实际的 INPUT 例子： 2.1 分子动力学（MD） INPUT_PARAMETERS #Parameters (1.General) suffix test calculation md esolver_type ofdft pseudo_dir ../../PP_ORB pseudo_rcut 16 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #OFDFT of_kinetic wt of_method tn of_full_pw_dim 1 #Parameters (3.Basis) basis_type pw md_restart 0 md_type nvt md_nstep 2 md_dt 0.25 md_tfirst 58022.52706 md_dumpfreq 10 md_tfreq 1.08 md_tchain 1 nbspline 10 2.2 原子结构弛豫（relax） INPUT_PARAMETERS #Parameters (1.General) suffix test calculation relax esolver_type ofdft pseudo_dir ../../PP_ORB pseudo_rcut 16 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #OFDFT of_kinetic wt of_method tn #Parameters (3.Basis) basis_type pw relax_nmax 50 2.3 晶格弛豫（cell-relax） INPUT_PARAMETERS #Parameters (1.General) suffix test calculation cell-relax esolver_type ofdft pseudo_dir ../../PP_ORB pseudo_rcut 16 #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #OFDFT of_kinetic wt of_method tn #Parameters (3.Basis) basis_type pw relax_nmax 50 三、参考文献 [1] Fermi E. Statistical method to determine some properties of atoms[J]. Rend. Accad. Naz. Lincei, 1927, 6(602-607): 5. [2] Weizsäcker C F. Zur theorie der kernmassen[J]. Zeitschrift für Physik, 1935, 96(7-8): 431-458. [3] Berk A. Lower-bound energy functionals and their application to diatomic systems[J]. Physical Review A, 1983, 28(4): 1908. [4] Wang L W, Teter M P. Kinetic-energy functional of the electron density[J]. Physical Review B, 1992, 45(23): 13196. [5] Luo K, Karasiev V V, Trickey S B. A simple generalized gradient approximation for the noninteracting kinetic energy density functional[J]. Physical Review B, 2018, 98(4): 041111. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-sol.html":{"url":"abacus-sol.html","title":"ABACUS 隐式溶剂模型使用教程","keywords":"","body":"ABACUS 隐式溶剂模型使用教程 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn；孙梦琳，邮箱：sunmenglin@stu.pku.edu.cn 审核：许审镇，邮箱：xushenzhen@pku.edu.cn；陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/01 一、介绍 近年来，电化学表面反应，例如一些电催化系统，无论是在工业界还是科学研究领域，都受到了广泛的关注。而对于一个真实电极表面反应体系，往往需要考虑许多复杂的情况，例如电极与电解液之间的固液界面，在材料模拟中经常遇到和使用。在这种系统的第一性原理计算中应该考虑溶剂化效应，以便获得准确的性质预测。 溶剂化是指溶质和溶剂之间的相互作用，使溶质在溶液中稳定。这种相互作用的强度和性质影响体系的许多特性。在计算化学中，溶剂模型(Solvation model) 是描述溶剂化行为的一种计算方法。 隐式溶剂化模型(Implicit solvation model)是一种处理溶剂化效应的成熟方法，在有限系统和周期系统中得到了广泛的应用。这种方法将溶剂视为连续介质，而不是单独的“显式”溶剂分子，这意味着嵌入隐式溶剂中的溶质以及溶剂自由度的平均值将隐含在溶剂浴的性质中。与“显式”方法相比，这种隐式溶剂化模型可以以低得多的计算成本提供定性正确的结果，特别适用于大型复杂系统。 ABACUS 中实现的隐式溶剂化模型采用了 Mathew、Sundararaman、Letchworth-Waver、Arias 和 Hennig 在 2014 年开发的方法[1]。 二、文档和算例 ABACUS 里关于隐式溶剂模型的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/scf/advanced.html#implicit-solvation-model ABACUS 里关于隐式溶剂模型参数的线上文档地址为：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#implicit-solvation-model ABACUS 的隐式溶剂模型算例下载地址为（gitee）： https://gitee.com/deepmodeling/abacus-develop/tree/develop/examples/implicit_solvation_model/Pt-slab 可以采用的下载命令是： git clone https://gitee.com/deepmodeling/abacus-develop.git 之后进入 /abacus-develop/examples/``implicit_solvation_model/Pt-slab 目录 或者采用 Github 仓库地址： https://github.com/deepmodeling/abacus-develop/tree/develop/examples/implicit_solvation_model/Pt-slab 三、输入参数 INPUT_PARAMETERS #Parameters (1.General) suffix H2 calculation scf ntype 1 nbands 2 symmetry 0 pseudo_dir ./ #Parameters (2.Iteration) ecutwfc 60 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (Solvation Model) imp_sol 1 eb_k 80 tau 0.000010798 sigma_k 0.6 nc_k 0.00037 以算例提供的 INPUT 文件为例，使用隐式溶剂模型方法只需添加如下参数即可： imp_sol：类型是 Bool，指定隐式溶剂模型的开(1)或者关(0)，默认值为 0 eb_k：类型是 Real，溶剂的相对介电常数，水为 80 tau：类型是 Real，有效表面张力参数，用于描述未被静电项捕获的溶质和溶剂之间的空化、分散和排斥相互作用，单位是$Ry/Bohr^2$，默认值为 1.0798e-05 sigma_k：类型是 Real，由溶质的电子结构隐含地确定的扩散腔的宽度（溶质电子密度与 nc_k 的比值，无量纲），默认值为 0.6 nc_k：类型是 Real，介电腔形成时的电子密度值，单位是$Bohr^{-3}$，默认值为 0.00037 注意，eb_k 可根据需要设置为模拟溶剂分子的相对介电常数参数，默认值 80 为水分子情况。tau，sigma_k，nc_k 的默认值均由在水溶液情况下与实验结果拟合得到，如需考虑其他溶剂，可自行测试拟合。 四、预期结果 如图所示，一个氢分子位于超胞中，模拟其处于溶液环境时的状态。将 imp_sol 设为 1，其他参数使用默认值，表示溶剂为水。 在输出文件 OUT.ABACUS/running_scf.log 中，E_sol_el 和 E_sol_cav 分别表示静电作用和空腔作用引起的能量修正。如案例所示，E_sol_el 代表溶质和溶剂分子之间的静电感应作用，贡献的能量修正一般为负值。E_sol_cav 代表溶质分子在溶剂中产生空腔所引起的能量修正，一般为正值。 体系溶剂化能的计算：打开隐式溶剂模型（imp_sol = 1)时体系总能量(结构优化之后)与真空情况（imp_sol = 0)体系总能量（结构优化之后）之差。 五、参考文献 [1] J. Chem. Phys. 140, 084106 (2014), https://doi.org/10.1063/1.4865107 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-dos.html":{"url":"abacus-dos.html","title":"ABACUS+Atomkit 计算态密度和能带","keywords":"","body":"ABACUS+Atomkit 计算态密度和能带 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024/04/22 一、介绍 电子的态密度（Density of States，简称DOS）和电子能带结构（Electronic band structure）在凝聚态物理和材料科学中分析物质的光学、磁学等诸多性质都有重要用途，因此学会计算和分析材料的 DOS 和能带结构也是一项重要技能。 电子能带结构描述了材料中电子能量与动量（或波矢K）之间的关系。通过电子能带可以揭示材料中电子能级的分布情况，包括能级的高低、能带的宽度、能带之间的间隙（带隙，band gap）等信息。能带结构中的价带和导带之间的能隙大小决定了材料是导体、半导体还是绝缘体。金属没有能隙，半导体有能隙但带隙不大，绝缘体拥有较大的能隙。 DOS 是指在能量为 E 的能量附近可供电子占据的电子状态数目，DOS 是关于能量的函数，通常以每单位能量范围的态数目来表示。DOS 和能带结构紧密相关，通过对能带结构在能量上的积分得到。DOS 的峰值通常对应于能带结构中的范霍夫奇点，这些点是电子浓度变化剧烈的地方，且在费米能级（通常把这个能量设为 0 点，负数代表费米面以下，正数代表费米面以上）附近的行为对材料的电学性质有显著影响。例如，金属的高 DOS 导致高电导率，而半导体和绝缘体在费米能级附近的低 DOS 则导致低电导率。 使用密度泛函理论软件来计算电子态密度和能带一般包括以下两个步骤：第一步，对结构弛豫后的稳定晶体结构（一般来讲是这样操作）做 self-consistent field（简称 scf）自洽计算输出收敛的体系基态电子密度文件；第二步，读入上一步的电子密度，选取想要计算的能级和 K 点，固定电子密度，做一次非自洽（non-self-consistent field，简称 nscf）计算得到态密度以及能带结构。 二、准备 1. 下载并安装 Atomkit 在本教程里会用到 atomkit（并非一定要使用，只是会方便计算流程）来处理 ABACUS 的输入文件。首先推荐大家阅读以下文档并安装好 atomkit： Atomkit 相关文档：ATOMKIT Code ‒ VASPKIT 1.5 documentation Atomkit v0.8.0 下载地址：Download atomkit.0.8.0.linux.x64.tar.gz (vaspkit) wget https://jaist.dl.sourceforge.net/project/vaspkit/Binaries/atomkit.0.8.0.linux.x64.tar.gz tar -zxvf atomkit.0.8.0.linux.x64.tar.gz cd atomkit/ bash setup.sh # modify ~/.atomkit file based on your machine environment source ~/.bashrc 2. 下载例子 可以从 Gitee 上下载。可以在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载后解压，之后进入 abacus-user-guide/examples/dos_band 文件夹 里面有 Al 和 Fe 两个文件夹，分别演示铝（nspin=1，适用无磁性体系）和铁（nspin=2，适用有磁性体系）的计算，均使用平面波基组 三、铝的态密度以及电子能带结构计算 1. 自洽计算 首先进入 Al 文件夹，铝在常温常压下是面心立方结构（fcc），以下是它经过结构优化（弛豫）后的构型文件： ATOMIC_SPECIES Al 26.982 Al_ONCV_PBE-1.0.upf upf201 LATTICE_CONSTANT 1.88972612546 LATTICE_VECTORS 4.0450551637 0.0000000000 0.0000000000 #latvec1 0.0000000000 4.0450551637 0.0000000000 #latvec2 0.0000000000 0.0000000000 4.0450551637 #latvec3 ATOMIC_POSITIONS Direct Al #label 0 #magnetism 4 #number of atoms 0.0000000000 0.0000000000 0.0000000000 m 0 0 0 0.5000000000 0.5000000000 0.0000000000 m 0 0 0 0.5000000000 0.0000000000 0.5000000000 m 0 0 0 0.0000000000 0.5000000000 0.5000000000 m 0 0 0 这是一个标准的 fcc 单胞结构，但是我们做 DOS 和电子能带结构计算时，常用原胞，因此需要做一步结构转换，转换公式如下图所示： 这时也可以使用 Atomkit，执行如下命令，即可得到原胞 PRIMCELL.STRU echo -e \"2\\n 202\\n 101 STRU\\n 101\" | atomkit # 这里为了方便演示，使用了命令行，表示将'2'、'202'、'101 STRU'和'101'依次传入atomkit，实际可以按照atomkit的提示依次输入 # 2代表进行Symmetry Analysis # 202代表进行Find Primitive Cell # 101 STRU代表读取ABACUS的STRU文件 # 101代表输出格式为ABACUS 接着执行如下命令进行自洽计算，要注意这里 calculation 为 scf，且需要设置 out_chg 为 1 以输出电荷密度文件（SPIN1_CHG.cube）。此外，ABACUS 默认读取 STRU 文件，这里我们设置 stru_file 为 PRIMCELL.STRU，读取得到的原胞 cp INPUT-scf INPUT cp KPT-scf KPT mpirun -n 8 abacus 2. 非自洽计算得到态密度 做态密度计算中的非自洽计算通常情况下需设置更加密的 K 点网格。执行如下命令进行非自洽计算，要注意这里 calculation 为 nscf，且需要设置 init_chg 为 file 以读取电荷密度文件（SPIN1_CHG.cube），out_dos 也需要设置为 1 以输出态密度 电荷密度文件（SPIN1_CHG.cube）默认是放在 OUT.suffix 目录下面，非自洽计算会自动去 OUT.suffix 目录下面找这个文件，如果找不到就会报错。熟悉 VASP 的用户可能习惯将这个文件移到另一个目录，这样也可以，但是需要在 INPUT 里设置 read_file_dir 为 SPIN1_CHG.cube 所在目录，read_file_dir 默认值是 OUT.suffix cp INPUT-nscf INPUT cp KPT-nscf KPT mpirun -n 8 abacus 计算得到的态密度存在 DOS1 和 DOS1_smearing.dat 内，我们常用 DOS1_smearing.dat 绘图，第一列是能量（单位为 eV），第二列是态密度，第三列是对态密度的积分 若需要减去费米能，可使用如下命令抓取费米能，然后在绘图时将第一列的数据减去费米能即可 grep EFERMI OUT.*/running_scf.log # EFERMI = 10.963171515 eV 下面是使用 Origin 绘制的态密度图，出现很多毛刺的原因是为了减少计算量 K 点取得较少，可以通过展宽方法做得更平滑（dos_sigma，默认值为0.07），实际计算也可根据需要增大非自洽计算的 K 点网格 2. 非自洽计算得到电子能带 上一步的自洽计算目的是为了得到收敛的电子密度，有了收敛的电子密度，我们就能够快速的得到任意 K 点以及任意多条能带所对应的波函数。根据能带的习惯画法，这一步的 KPT 文件需要选取晶胞的布里渊区高对称点和路径，不同晶胞的高对称点和路径可以参考这个文献 [1]。 这些高对称点能够反映出材料的电子性质，如能隙大小、有效质量、载流子迁移率等。例如，能隙大小直接影响材料是金属、半导体还是绝缘体；有效质量影响载流子的响应速度；而能带的形态和分布则与材料的光学吸收和发射特性密切相关。因此，通过研究布里渊区内的高对称点的能带结构，我们可以预测和解释材料的多种物理性质，这对于材料的设计和应用具有重要意义 对于 fcc 的原胞，它的高对称点和可选的路径如下图 [1] 所示： KPT 需要选择Line模式（Line模式的介绍可以参考这个链接），并且需要设置 symmetry 为 0（INPUT 文件里若没有设置 symmetry，则会默认设置为 0） 这里可以使用 Atomkit 软件自动生成 KPT，执行如下命令 echo -e \"3\\n 301\\n 3\\n 101 PRIMCELL.STRU\\n 0.06\" | atomkit # 这里为了方便演示，使用了命令行，表示将'3'、'301'、'3'、'101 PRIMCELL.STRU'和'0.06'依次传入atomkit，实际可以按照atomkit的提示依次输入 # 3代表进行Generate K-Mesh & K-Path # 301代表输出K点的格式为ABACUS # 3代表Kpath for Bulk Structure # 101 PRIMCELL.STRU代表读取ABACUS的PRIMCELL.STRU文件 # 0.06为kspacing的取值 生成的 KLINES 即是计算所需的 KPT 文件，前三个数是高对称点的分数坐标，第四个数是两个高对称 K 点间采点数，#号后面是该高对称点的名称 K_POINTS 8 Line 0.00000000 0.00000000 0.00000000 25 # GAMMA 0.50000000 0.00000000 0.50000000 9 # X 0.62500000 0.25000000 0.62500000 1 # U 0.37500000 0.37500000 0.75000000 27 # K 0.00000000 0.00000000 0.00000000 22 # GAMMA 0.50000000 0.50000000 0.50000000 18 # L 0.50000000 0.25000000 0.75000000 12 # W 0.50000000 0.00000000 0.50000000 1 # X 接着执行如下命令进行非自洽计算，要注意这里 calculation 为 nscf，同样需要设置 init_chg 为 file 以读取电荷密度文件（SPIN1_CHG.cube），out_band 也需要设置为 1 以输出电子能带 cp INPUT-band INPUT cp KLINES KPT mpirun -n 8 abacus 计算结束之后在 OUT.* 目录下面会有 BANDS_1.dat 文件，其中第一列为 K 点序号，第二列是 K 点在布里渊区里的间隔（以笛卡尔坐标计算），从第三列往后是每条能带的电子能量，单位为 eV 1 0.00000000 -92.49968796 -54.00929724 ... 2 0.00988862 -92.49960078 -54.00938081 ... 3 0.01977723 -92.50345008 -54.00963444 ... ...... 这里，可以使用目录下的 gene_band_dat.py 生成绘图所需的能带文件 # 假设当前目录存在KPT文件存储能带信息，OUT.*目录下有BANDS_*.dat文件 python gene_band_dat.py 10.963171515 # 10.963171515即为费米能数值，也可空缺，则不将能量减去费米能 运行完之后会在当前目录生成 plot_BANDS_1.dat 文件，即为绘图所需的能带文件，第一行为高对称 K 点的坐标，从第二行开始，第一列为 K 点在布里渊区里的间隔，第二列为每条能带的电子能量，单位为 eV。 # 0.0 0.24721543 0.32490774 0.47629565 0.73850721 0.95260205 1.12740976 1.25101747 0.000000 -103.462859 0.009889 -103.462772 ...... 下面是绘制的能带图，图中有不够光滑连线的原因是为了减少计算量，K 点取得较少，实际计算可根据需要增多 K 点间采点数目 四、铁的态密度以及电子能带结构计算 进入 Fe 文件夹，由于铁具有磁性，因此需要在 INPUT 中打开自旋极化选项，即增加参数 nspin 并设置为 2（默认值为 1），并且将铁的初始磁矩设置为非 0（直接设成 0 得不到铁磁基态）。注意此时再对铁做自洽迭代（相比于 nspin 设置为 1 的计算），程序对自旋向上和向下的电子在每一个布里渊区 K 点上都分别进行了 Kohn-Sham 方程的求解，因此计算时间将会几乎翻倍。 计算铁的态密度和电子能带结构的过程与铝几乎相同，但是要注意计算得到的态密度和电子能带结构文件均有两个（分别对应自旋向上和向下），分别为 DOS1 和 DOS2、BANDS_1.dat 和 BANDS_2.dat 绘图仍推荐使用 DOS1_smearing.dat 和 DOS2_smearing.dat，以及 gene_band_dat.py 生成的 plot_BANDS_1.dat 和 plot_BANDS_2.dat，使用绘图软件可得如下 DOS 以及能带图 图 1. 铁的态密度（DOS），红线表示自旋向下电子的能带图，黑线表示自旋向上电子的能带图。费米面设为 0 点，即蓝色虚线所在能量位置。可以看出铁的两个自旋方向态密度并不相等，因此铁具有磁性。 图 2. 铁的能带图，红线表示自旋向下电子的能带图，黑线表示自旋向上电子的能带图。费米面设为 0 点。 五、参考文献 [1] Wahyu Setyawan and Stefano Curtarolo, High-throughput electronic band structure calculations: Challenges and tools, Comp. Mater. Sci., 49, 299-312 (2010). Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-pdos.html":{"url":"abacus-pdos.html","title":"ABACUS 计算 PDOS","keywords":"","body":"ABACUS 计算 PDOS 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024/10/12 一、PDOS 文件分析 ABACUS 使用 LCAO 基组进行自洽迭代场计算（Self-Consistent Field，SCF）或 NSCF（Non-Self-Consistent Field，NSCF）计算时，可以在 INPUT 文件里设置 out_dos 为 2 在输出 DOS（Density Of States）的同时输出 PDOS（Partial DOS），PDOS 的文件格式是 xml，其文件内容在英文文档里有介绍：Calculating DOS and PDOS — ABACUS documentation 下面简单介绍一下 PDOS 文件： 1. 能量范围（横坐标） 第一行 代表输出为 pdos，PDOS 文件最后一行会有 代表 pdos 内容结束 第二行的 2 表示自旋极化计算（npsin=2） 第三行表示该 PDOS 文件一共有 720 个不同的轨道，不同轨道的内容会在后面介绍 第四行 到 中的内容代表 pdos 的能量范围，即横坐标值 2 720 0.00000 0.01000 0.02000 0.03000 0.04000 0.05000 ...... 24.96000 24.97000 24.98000 24.99000 25.00000 ...... 2. 不同轨道的 DOS 中 index=\"1\" 表示第\"1\"条轨道，atom_index=\"1\" 表示第\"1\"个原子，species=\"Li\" 表示元素为\"Li\" l=\"0\"，m=\"0\"，z=\"1\"分别代表角量子数为\"0\"，磁量子数为\"0\"，每个角量子数上对应的径向轨道为\"1\" 例如 Li 在标准原子轨道库里是 DZP，具体轨道为 4s1p，如下表所示共 7 个：4 个 s 轨道（分别对应 z 取 1 到 4；l 取 0；m 取 0 到 2l，即 0），3 个 p 轨道（对应 z 取 1；l 取 1；m 取 0 到 2l，即 0，1，2），更具体的介绍可以参考数值原子轨道基组的个数 到中的内容代表该轨道的 dos，两列分别对应 spin 为上和下的 dos Li s p l 0 0 0 0 1 1 1 m 0 0 0 0 0 1 2 z 1 2 3 4 1 1 1 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 ...... 0.02085550 0.02085546 0.01939430 0.01939436 0.01791958 0.01791972 0.01638296 0.01638315 0.01475548 0.01475571 二、绘制 PDOS 有三种方式，分别对应 species, atom_index, index 1. species 提取指定元素的 PDOS，会在 PDOS_FILE 下生成 species-*.dat 文件，其中 * 代表指定的元素，第一列为横坐标能量范围，第二列到最后一列分别为不同 spin 的 pdos species: [species_1, species_2, species_3, ...] # eg: # species : [\"Li\", \"Co\", \"O\"] 提取指定元素的不同 l（s:0, p:1, d:2, f:3, ......）的 PDOS，会在 PDOS_FILE 下生成 species-* 文件夹，每个文件夹下生成 species-*_l.dat 文件，其中 * 代表指定的元素，第一列为横坐标能量范围，第二列到最后一列分别为不同 spin 的 pdos species : { species_1: [s, p, d], species_2: [s, p], ... } # eg: # species : {\"Li\": [0, 1], \"Co\": [0, 1, 2, 3], \"O\": [0, 1, 2]} 提取指定元素的不同 l 和 m（m:0, 1, ..., 2l）的 PDOS，会在 PDOS_FILE 下生成 species-* 文件夹，每个文件夹下生成 species-*_l_m.dat 文件，其中 * 代表指定的元素，第一列为横坐标能量范围，第二列到最后一列分别为不同 spin 的 pdos species : { species_1: { s: [m_0], p: [m_0, m_1] }, species_2: { s: [m_0], p: [m_0, m_1], ... }} # eg: # species : {\"Li\": { 0: [0], 1: [0, 1, 2] }, \"Co\": { 0: [0], 1: [0, 1, 2], 2: [0, 1, 2, 3, 4], 3: [0, 1, 2, 3, 4, 5, 6] }, \"O\": { 0: [0], 1: [0, 1, 2], 2: [0, 1, 2, 3, 4] }} 2. atom_index 提取指定原子的 PDOS，会在 PDOS_FILE 下生成 atom_index-*.dat 文件，其中 * 代表指定的原子，第一列为横坐标能量范围，第二列到最后一列分别为不同 spin 的 pdos atom_index : {atom_index_1, atom_index_2, atom_index_3, ...} # eg: # atom_index : {1, 2, 3, 16, 32} 提取指定原子的不同 l（s:0, p:1, d:2, f:3, ......）的 PDOS，会在 PDOS_FILE 下生成 atom_index-* 文件夹，每个文件夹下生成 atom_index-*_l.dat 文件，其中 * 代表指定的元素，第一列为横坐标能量范围，第二列到最后一列分别为不同 spin 的 pdos atom_index : { atom_index_1: [s, p, d], atom_index_2: [s, p], ... } # eg: # atom_index : {1: [0, 1], 17: [0, 1, 2, 3], 34: [0, 1, 2]} 提取指定原子的不同 l 和 m（m:0, 1, ..., 2l）的 PDOS，会在 PDOS_FILE 下生成 atom_index-* 文件夹，每个文件夹下生成 atom_index-*_l_m.dat 文件，其中 * 代表指定的元素，第一列为横坐标能量范围，第二列到最后一列分别为不同 spin 的 pdos atom_index : { atom_index_1: { s: [m_0], p: [m_0, m_1] }, atom_index_2: { s: [m_0], p: [m_0, m_1], ... }} # eg: # atom_index : {1: { 0: [0], 1: [0, 1, 2] }, 17: { 0: [0], 1: [0, 1, 2], 2: [0, 1, 2, 3, 4], 3: [0, 1, 2, 3, 4, 5, 6] }, 34: { 0: [0], 1: [0, 1, 2], 2: [0, 1, 2, 3, 4] }} 3. index 提取指定原子轨道对应的 PDOS，会在 PDOS_FILE 下生成 index-*.dat 文件，其中 * 代表指定的原子，第一列为横坐标能量范围，第二列到最后一列分别为不同 spin 的 pdos index : {index_1, index_2, index_3, ...} # eg: # index : {1, 2, 3, 4} 三、绘制 PDOS 的流程 https://github.com/deepmodeling/abacus-develop/tree/develop/tools/plot-tools 使用 abacus-plot 程序可以绘制 PDOS，具体步骤如下： 1. 安装 abacus-plot cd /path_to_abacus/tools/plot-tools python setup.py install 2. 准备输入文件 config.json { \"pdosfile\": \"PDOS\", \"efermi\": 6.585653952007503, \"species\" : [\"Li\", \"Co\", \"O\"] } pdosfile：实际 PDOS 文件的路径（相对路径和绝对路径均可） efermi：费米能，单位是 eV，可以在输出文件 running_scf.log 里得到（关键字：EFERMI） species：对应第二节介绍的三种输出模式参数 3. 运行 abacus-plot 输出 PDOS abacus-plot -d -o Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-04-01 10:52:18 "},"abacus-chg.html":{"url":"abacus-chg.html","title":"ABACUS 输出部分的电荷密度和波函数及可视化教程","keywords":"","body":"ABACUS 输出部分的电荷密度和波函数及可视化教程 作者：包涛尼，邮箱：baotaoni@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024 年 10 月 10 日 一、引言 在第一性原理计算中，电荷密度和波函数的计算及其可视化是理解材料性质的关键步骤之一。电荷密度描述了电子在实空间中的分布情况，直接反映了材料中的电子结构和化学键信息。通过电荷密度或者波函数的可视化，我们可以直观地观察到材料内部的电荷转移、价键的形成及其强弱，以及可能存在的空穴或电荷积累区域，这对于分析材料的导电性、磁性、化学反应活性等各种性质至关重要。 ABACUS 作为第一性原理计算软件，支持两种不同的基组：平面波基组（Plane Wave，PW）和数值原子轨道基组（Linear Combination of Atomic Orbitals，LCAO），两种基组下都支持输出实空间下电荷密度和波函数的信息，并且可以方便地使用其他软件/工具包进行可视化。 电荷密度既可以输出总的，也可以按照不同能带、不同 k 点、不同自旋分开输出（能带分解电荷密度）。但是它们的操作逻辑可能会略有不同，例如在 LCAO 下，能带分解电荷密度的输出需要在 SCF 结束后单独再开一次计算，读入上一步 SCF 的结果才可以进行后处理；但是输出总的电荷密度则可以直接在 SCF 时附带目标参数 out_chg=1 即可。 波函数作为复数，既可以输出其模（envelope function），也可以选择实部和虚部分开输出。在 ABACUS 里需要特定的参数组合进行控制，包括 if_separate_k、bands_to_print、out_wfc_norm 等参数。 这篇文档归类汇总了这类相关信息。 二、基本概念与公式 下面以较为复杂的 LCAO 为例，说明一下基本概念与公式。我们知道，LCAO 中的波函数由如下公式描述： 其中n是能带指标，\\mathbf{k}是 Brillouin 区点的指标。\\phi_{\\mu}(\\mathbf{r}-\\mathbf{\\tau}_{\\alpha i}-\\mathbf{R})是位于布拉维格矢\\mathbf{R}处的原胞中的种类为\\alpha的第i个原子的原子轨道，复合指标\\mu=\\{\\alpha,i,l,m,\\zeta\\}用于标记原子轨道，N是 Born-von Karman 周期性边界条件下超胞中所含原胞的个数，c_{n\\mu,\\mathbf{k}}是原子轨道基组的叠加系数。 那么，电荷（在实空间的）密度就可以计算如下： 其中，N_k是 Brillouin 区中采样的 k 点个数，f_{n\\mathbf{k}}是 Fermi 占据因子。可以看到，在多 k 点的情况下，存在因子\\mathrm{e}^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{R}}，因此多 k 点情况下主要还要对各个 k 点的因子\\mathrm{e}^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{R}}进行求和。这样实空间电荷密度\\rho(\\mathbf{r})就和密度矩阵\\rho_{\\mu\\nu}(\\mathbf{R})（DMR）联系起来： \r \\rho_{\\mu\\nu}(\\mathbf{R})=\\frac{1}{N_{k}}\\sum_{n\\mathbf{k}}f_{n\\mathbf{k}}c_{n\\mu,\\mathbf{k}}^*c_{n\\nu,\\mathbf{k}}\\mathrm{e}^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{R}}\r 然而，能带分解电荷密度（band-decomposed charge density，有时又称为 partial charge density）则是不论某能带n是否占据，都把该能带单独拿出来，计算相应的电荷密度，并且不同自旋、不同 k 点都要求可以单独计算和绘制，也就是这样一个\\rho_{n\\mathbf{k}}^{\\sigma}(\\mathbf{r})： \r \\begin{aligned}\r \\rho_{n\\mathbf{k}}^{\\sigma}(\\mathbf{r})&=\\psi^{\\sigma*}_{n\\mathbf{k}}(\\mathbf{r})\\psi^{\\sigma}_{n\\mathbf{k}}(\\mathbf{r}) \\\\\r &=\\sum_{\\mathbf{R}}\\sum_{\\mu\\nu}\\underbrace{c^{\\sigma *}_{n\\mu,\\mathbf{k}}c^{\\sigma}_{n\\nu,\\mathbf{k}}}_{\\rho^{\\sigma}_{\\mu\\nu,n}(\\mathbf{k})}\\mathrm{e}^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{R}}\\phi^*_{\\mu}(\\mathbf{r}-\\mathbf{\\tau}_{\\alpha i}-\\mathbf{R})\\phi_{\\nu}(\\mathbf{r}-\\mathbf{\\tau}_{\\beta j}) \\\\\r &=\\sum_{\\mathbf{R}}\\sum_{\\mu\\nu}\\underbrace{\\rho^{\\sigma}_{\\mu\\nu,n}(\\mathbf{k})\\mathrm{e}^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{R}}}_{\\rho^{\\sigma}_{\\mu\\nu,n\\mathbf{k}}(\\mathbf{R})}\\phi_{\\mu}(\\mathbf{r}-\\mathbf{\\tau}_{\\alpha i}-\\mathbf{R})\\phi_{\\nu}(\\mathbf{r}-\\mathbf{\\tau}_{\\beta j}) \\\\\r &=\\sum_{\\mathbf{R}}\\sum_{\\mu\\nu}\\rho^{\\sigma}_{\\mu\\nu,n\\mathbf{k}}(\\mathbf{R})\\phi_{\\mu}(\\mathbf{r}-\\mathbf{\\tau}_{\\alpha i}-\\mathbf{R})\\phi_{\\nu}(\\mathbf{r}-\\mathbf{\\tau}_{\\beta j})\r \\end{aligned}\r 能带分解电荷密度可以用来分析不同轨道（或能量范围）对实空间中特定区域的贡献，有助于深入了解和可视化电子、磁性或输运性质，特别是在模拟扫描隧道显微镜（STM）图像时尤为重要。 三、输入输出概述 ABACUS 软件在平面波基组（Plane Wave，PW）和数值原子轨道基组（Linear Combination of Atomic Orbitals，LCAO）下均支持计算基于能带分解或 k 点分解的电荷密度和波函数。由于这两种基组在程序内部实现逻辑上有所不同，因此输入文件的编写和读取上也略有不同，在下面的部分中将会分开详细介绍。这一部分中，我们以电荷密度的计算为例，对一些共性的内容进行说明。 1. 输出文件类型：cube 文件 最终的输出文件类型为 .cube，这是一种用于存储三维网格数据的文件格式，主要用于描述电荷密度、波函数等在实空间中的信息。由于该文件格式最初是为 Gaussian 软件包设计的，因此通常也被称为 Gaussian CUBE file，但被其他第一性原理计算软件所广泛使用。cube 文件可以在免费软件 VESTA（Visualization for Electronic and STructural Analysis）中方便地进行可视化，因此后面的可视化步骤也均由 VESTA 进行。 一个典型的 cube 文件通常形如： Cubefile created from ABACUS. Inner loop is z, followed by y and x 1 (nspin) -0.094637 (fermi energy, in Ry) 2 0.0 0.0 0.0 45 0.103305 0.000000 0.000000 45 -0.051653 0.089465 0.000000 180 0.000000 0.000000 0.104985 6 4 0.000000 0.000000 9.448630 6 4 -0.000000 2.683943 9.448630 7.033e-08 7.920e-08 1.024e-07 1.236e-07 1.439e-07 1.765e-07 2.130e-07 2.281e-07 2.298e-07 2.592e-07 2.988e-07 2.991e-07 （下面还有很多其他数据……） cube 文件的前两行不会被 VESTA 读取，因此可以填写任意信息，ABACUS 在第二行输出了自旋数 nspin 和 Fermi 能级 fermi energy，以支持 NSCF（non self-consistent field，非自洽） 计算。其他信息的含义如下，供参考： Cubefile created from ABACUS. Inner loop is z, followed by y and x 1 (nspin) -0.094637 (fermi energy, in Ry) 2 (总原子数) 0.0 0.0 0.0 (格点数据原点的x,y,z坐标) 45 (FFT nx) 0.103305 0.000000 0.000000 (LATTICE_CONSTANT*a1/nx，单位Bohr) 45 (FFT ny) -0.051653 0.089465 0.000000 (LATTICE_CONSTANT*a2/nx，单位Bohr) 180 (FFT nz) 0.000000 0.000000 0.104985 (LATTICE_CONSTANT*a3/nx，单位Bohr) 6 (第1个原子的原子序数) 4 (价电子数) 0.000000 0.000000 9.448630 (该原子位置的笛卡尔坐标，单位Bohr) 6 (第2个原子的原子序数) 4 (价电子数) -0.000000 2.683943 9.448630 (该原子位置的笛卡尔坐标，单位Bohr) (下面开始是FFT格点上的数据，z坐标变化最快，接下来依次是y和x，一般为6个数据一行，每走完z的一次循环换一行) 7.033e-08 7.920e-08 1.024e-07 1.236e-07 1.439e-07 1.765e-07 2.130e-07 2.281e-07 2.298e-07 2.592e-07 2.988e-07 2.991e-07 （下面还有很多其他数据……） 因此，对于电荷密度输出的 cube 格式文件，其 FFT 格点上数值的单位为 1/Bohr³。值得注意的是，电荷密度积分后的电子数目应该是守恒的，即在晶胞内对电子密度积分应等于该能带上占据的电子数目： 这可以作为检查输出正确性的依据（sanity check）。例如，对于 nspin=1 的情况，电子成对占据能带n，那么积分后的结果应该是 2；对于 nspin=2 的情况，自旋向上和向下是分开考虑的，因此积分结果就应该是 1。在 ABACUS 的能带分解电荷密度计算中，对于空带采取的约定是占据数与 HOMO 的占据数一致。 2. 输出文件命名规则 对于多能带、多 k 点、多自旋的计算，电荷密度输出文件名形如 BAND*_K*_SPIN*_CHG.cube，* 是相应的编号。这些编号都是从 1 开始的（如果发现有从 0 或者非 1 开始命名的编号，请在 ABACUS GitHub issue 中向我们反馈）。波函数的命名规则是类似的。 能带（BAND）编号与 SCF 计算中生成的 istate.info 文件中的约定一致。 自旋（SPIN）编号在 nspin=1 时只有为 1 的编号；nspin=2 时编号为 1 表示自旋向上的分量，编号为 2 表示自旋向下的分量；目前 ABACUS 还不支持对 nspin=4（非共线磁矩）的能带分解电荷密度的计算。 k 点（K）编号顺序与输出的 kpoints 文件中的约定一致。 3. 其他参数与注意事项 关于多 k 点的计算，可以选择是否启用输入参数 if_separate_k。默认情况下，该参数设置为 false，此时所有 k 点的贡献都会被计入，从而算得的电荷密度实际上是 \r \\rho_{n}^{\\sigma}(\\mathbf{r})=\\sum_{\\mathbf{k}}\\rho_{n\\mathbf{k}}^{\\sigma}(\\mathbf{r})\r 输出文件名形如 BAND*_SPIN*_CHG.cube。当 if_separate_k 设置为 true 时，程序会分别计算不同 k 点的贡献并输出，输出文件名形如 BAND*_K*_SPIN*_CHG.cube。 有时候对称性分析会约化一些 k 点，并且相应地，k 点权重会发生改变。例如当 symmetry=1（开启晶格对称性分析）时，对于一个 2×2×2 的 k 点采样，下面是一个可能的 kpoints 文件： nkstot now = 4 K-POINTS DIRECT COORDINATES KPOINTS DIRECT_X DIRECT_Y DIRECT_Z WEIGHT 1 0.00000000 0.00000000 0.00000000 0.1250 2 0.50000000 0.50000000 0.00000000 0.3750 3 0.00000000 0.00000000 0.50000000 0.1250 4 0.50000000 0.50000000 0.50000000 0.3750 nkstot = 8 ibzkpt K-POINTS REDUCTION ACCORDING TO SYMMETRY KPT DIRECT_X DIRECT_Y DIRECT_Z IBZ DIRECT_X DIRECT_Y DIRECT_Z 1 0.00000000 0.00000000 0.00000000 1 0.00000000 0.00000000 0.00000000 2 0.50000000 0.00000000 0.00000000 2 0.50000000 0.50000000 0.00000000 3 0.00000000 0.50000000 0.00000000 2 0.50000000 0.50000000 0.00000000 4 0.50000000 0.50000000 0.00000000 2 0.50000000 0.50000000 0.00000000 5 0.00000000 0.00000000 0.50000000 3 0.00000000 0.00000000 0.50000000 6 0.50000000 0.00000000 0.50000000 4 0.50000000 0.50000000 0.50000000 7 0.00000000 0.50000000 0.50000000 4 0.50000000 0.50000000 0.50000000 8 0.50000000 0.50000000 0.50000000 4 0.50000000 0.50000000 0.50000000 可以看到一些 k 点在计算中被约化，从而拥有了更高的 WEIGHT。 虽然我们已经做了很多代码分析、测试与 benchmark，以保证结果的正确性，但是在打开对称性时仍不排除可能会因为 k 点约化与权重改变而产生不可预料的后果（例如电荷密度要根据对称性进行对称化；未来可能还要加入参数来控制纳入哪些用户选择的 k 点的贡献，此时打开对称性后用户操作得到的结果的正确性是不可控的：例如上述情况中纳入编号为 1 和 2 的 k 点，实际上是有 4 个 k 点的贡献，并且电荷密度没有经过对称性操作在实空间还原，因此会得到错误的结果）。因此，如果可能的话，我们强烈建议在完全关闭对称性（symmetry=-1）或者只启用时间反演对称性（symmetry=0）的情况下进行多 k 点 SCF 和能带分解电荷密度的计算。 四、在平面波基组下进行计算 1. 电荷密度 平面波基组下，能带分解电荷密度的计算是较为简单的，因为实现逻辑中该功能被归类为 SCF 的附带后处理，因此只需要在 SCF 时附带输入参数 bands_to_print 即可。一个可能的 INPUT 文件如下： INPUT_PARAMETERS nbands 20 stru_file STRU kpoint_file KPT pseudo_dir path/to/your/pseudo_potential/folder ecutwfc 100.0 # Rydberg basis_type pw calculation scf gamma_only 0 symmetry -1 # Turn off symmetry bands_to_print 2*1 2*0 1 if_separate_k false nspin 1 参数 bands_to_print 的具体含义可以在输入参数文档 https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#bands-to-print 中进行查看。简单来说，上面 bands_to_print 被指定为 2*1 2*0 1，2*1 意味着前 2 个（第 1 个、第 2 个）能带会被计算，2*0 意味着紧接着的 2 个（第 3 个、第 4 个）能带会被跳过，最后一个 1 意味着紧接着的 1 个（第 5 个）能带会被计算；因此，最终会在 OUT.ABACUS 文件夹下得到第 1、2、5 个能带的分解电荷密度。 参数 if_separate_k 则控制是否将每个 k 点对电荷密度的贡献分开输出，false 表示不分开，因此在多 k 点的情形下，输出文件的电荷密度是各个 k 点贡献之和。 如果想要输出包含了所有 k 点、所有占据能带的贡献的电荷密度，可以加上 out_chg 1 2. 波函数 只需在 INPUT 文件中再添加 out_wfc_norm 1 便可以在 OUT.ABACUS 文件夹下得到文件夹 wfc_realspace，里面存放了不同能带、不同 k 点、不同自旋的波函数的模。 当前版本中，平面波基组下的波函数不支持实部、虚部分开的输出方式。 五、在数值原子轨道基组下进行计算 1. 电荷密度 在数值原子轨道基组下，能带分解电荷密度的计算比平面波稍微复杂一些，我们需要两次计算：一次计算先得到 LCAO 的轨道叠加系数文件，一次计算再根据这些系数文件计算得到分解电荷密度。 1.1 在 SCF 时计算并输出波函数系数文件 一个可能的 INPUT 文件如下： INPUT_PARAMETERS nbands 20 stru_file STRU kpoint_file KPT pseudo_dir path/to/your/pseudo_potential/folder orbital_dir path/to/your/orbital/folder ecutwfc 100.0 # Rydberg basis_type lcao calculation scf gamma_only 0 symmetry -1 # Turn off symmetry nspin 1 out_wfc_lcao 1 out_chg 1 这里，重要的是需要设置参数 out_wfc_lcao，此时你将在 OUT.ABACUS 文件夹下得到各个 k 点的波函数系数文件，名称形如 WFC_NAO_K*.txt，这些文件将在下一步计算中被读取，并计算能带分解电荷密度。 这里的 out_chg 控制的是是否输出体系真实的总电荷密度，包含了所有 k 点、所有占据能带的贡献。因此如果你不需要总电荷密度，大可将 out_chg 设为 0。 1.2 计算并输出能带分解电荷密度 此时，我们最好再单独开一个文件夹，用来计算能带分解电荷密度。KPT 和 STRU 和第 1 步保持一致，但是 INPUT 文件需要将计算类型 calculation 从 scf 更改为 get_pchg。一个可能的 INPUT 文件如下： INPUT_PARAMETERS nbands 20 stru_file STRU kpoint_file KPT pseudo_dir path/to/your/pseudo_potential/folder orbital_dir path/to/your/orbital/folder ecutwfc 100.0 # Rydberg basis_type lcao calculation get_pchg gamma_only 0 symmetry -1 # Turn off symmetry read_file_dir ./ # nbands_istate 2 # pchg above/below Fermi band bands_to_print 2*1 2*0 1 if_separate_k true nspin 1 我们还要将上一步得到的波函数系数文件复制到该文件夹中，推荐使用 ln -s 命令进行软链接。 其他参数和平面波时基本一致，仍然可以使用 bands_to_print 指定需要计算的能带（见平面波计算部分）。不过在 LCAO 情况下，你也可以选择使用参数 nbands_istate，它会选择计算 Fermi 面上下 nbands_istate 条能带的分解电荷密度。当已经设置了 bands_to_print 的情况下，nbands_istate 的效果将会被覆盖。 这里选择将 if_separate_k 设置为 true，表明将不同 k 点的贡献分开输出。 2. 波函数 波函数的计算流程和电荷密度并无二异，同理第一步仍然是 SCF 计算，从而得到各个 k 点的波函数系数文件。 第二步中，我们仅需将之前的计算类型 calculation 参数从 get_pchg 相应地改为 get_wf。这样，你就可以在 OUT.ABACUS 下得到波函数的模文件。如果此时你还打开了 out_wfc_norm=1，还可以在 OUT.ABACUS 下看到文件夹 wfc_realspace，里面存放了（不同能带、不同 k 点、不同自旋的）波函数的实部文件和虚部文件。 五、示例：对电荷密度进行可视化 以单层石墨烯为例，其原胞的 STRU 文件如下： ATOMIC_SPECIES C 12.011 C_ONCV_PBE-1.0.upf NUMERICAL_ORBITAL 6_C_TZDP/C_gga_10au_100Ry_3s3p2d.orb LATTICE_CONSTANT 1.889726 LATTICE_VECTORS 2.4600000000 0.0000000000 0.0000000000 -1.230000000 2.1304220000 0.0000000000 0.0000000000 0.0000000000 10.0000000000 ATOMIC_POSITIONS Direct C 0.0000000000 2 0.0000000000 0.0000000000 0.5000000000 0 0 0 mag 0.0 0.3333333333 0.6666666666 0.5000000000 0 0 0 mag 0.0 我们选择围绕 Γ 点 2×2×1 的 k 点采样（仅作演示用，并不是对该体系收敛的最优采法），KPT 文件如下： K_POINTS 0 Gamma 2 2 1 0 0 0 SCF 计算中可以得到输出的 kpoints 文件，指示了我们输出文件中 k 点编号和倒空间（分数）坐标的对应关系： nkstot now = 4 K-POINTS DIRECT COORDINATES KPOINTS DIRECT_X DIRECT_Y DIRECT_Z WEIGHT 1 0.00000000 0.00000000 0.00000000 0.2500 2 0.50000000 0.00000000 0.00000000 0.2500 3 0.00000000 0.50000000 0.00000000 0.2500 4 0.50000000 0.50000000 0.00000000 0.2500 倒空间基矢的选择可以在输出日志 running_scf.log 中看到，形如： Reciprocal vectors: (Cartesian coordinate: in unit of 2 pi/a_0) +0.406504 +0.234695 -0 -0 +0.469391 -0 +0 -0 +0.1 采用 SeeK-path 工具中可以看到 Brillouin 区的样子： 这里 SeeK-path 是一个能够自动生成标准化的 k 点路径的工具，方便用于各种电子结构计算，可通过网址 https://www.materialscloud.org/work/tools/seekpath 访问。 不难发现，实际上 2×2×1 的 Brillouin 区采样只能采到Γ点和M点（编号 2、3、4 的 k 点都等价为M点，在 symmetry=1 时会显式约化）。可以预想到，K2、K3、K4 在实空间中的分布形状应该是一致的，它们只相差相应的晶格对称性操作。 以 LCAO 为例，开启共线磁矩 nspin=2（仅作为演示，没有磁性的石墨烯自旋上下结果应该完全一致），在第一步 SCF 后可以在 OUT.ABACUS 文件夹下得到如下波函数系数文件：WFC_NAO_K1.txt、……、WFC_NAO_K8.txt。这里 K1 到 K8 代表 8 个 k 点，k 点编号比实际设置时多了一倍是因为其中编号 1～4 是代表自旋向上的波函数文件，而编号 5～8 是代表自旋向下的波函数文件。 SCF 计算结束后，将得到的这些系数文件复制/链接到另一个我们自己创建的新文件夹下，根据上面的教程设置控制文件，开启计算类型 calculation=get_pchg 的新计算，就可以在 OUT.ABACUS 文件夹下得到如下的电荷密度文件。若选择 if_separate_k=true，输出文件将形如： BAND1_K1_SPIN1_CHG.cube BAND1_K1_SPIN2_CHG.cube BAND1_K2_SPIN1_CHG.cube BAND1_K2_SPIN2_CHG.cube ...... 若选择 if_separate_k=false，则输出文件名中不会带有 k 点信息。这些 cube 格式文件可以直接在 VESTA 软件中打开并可视化。 例如，第一条能带 Γ 点自旋向上的贡献存储在 BAND1_K1_SPIN1_CHG.cube 文件里，可视化效果为： 第二条能带三个不同 M 点的贡献为 BAND2_K2_SPIN*_CHG.cube、BAND2_K3_SPIN*_CHG.cube、BAND2_K4_SPIN*_CHG.cube： 可以发现，它们确实形状一致，但是在实空间被旋转了不同的角度，符合预期。 六、结语 以上就是本教程的内容，希望对读者有所帮助。若有问题，请在 ABACUS GitHub issue 中向我们反馈，或者发送邮件联系本教程作者。感谢大家对 ABACUS 软件的支持。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-04-01 10:51:33 "},"abacus-elf.html":{"url":"abacus-elf.html","title":"ABACUS 计算电子局域函数 ELF 使用教程","keywords":"","body":"ABACUS 计算电子局域函数 ELF 使用教程 作者：孙亮，邮箱：l.sun@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024/10/10 一、背景 电子局域函数（Electron localization function，ELF）最早在 1990 年由 Becke 和 Edgecombe 提出[1]，它描述电子的局域化程度。根据定义，ELF 是一个 0 到 1 之间的数，越接近 1，表示电子越局域，ELF=1/2 时，对应均匀电子气，越接近 0，表示电子越离域。 目前，ABACUS 支持使用平面波基组、原子轨道基组下的 Kohn-Sham DFT（KSDFT）和无轨道密度泛函理论计算并输出 ELF。 二、定义 1. 自旋非极化 自旋非极化时，ELF 定义为 \r {\\rm{ELF}} = \\frac{1}{1+\\chi^2}\r 其中\\chi = \\frac{\\tau_{KS} - \\tau_{vW}}{\\tau_{TF}}，\\tau_{KS} = \\frac{1}{2}\\sum_{i}{f_i |\\nabla\\psi_i|^2}为 KSDFT 的正定动能密度，\\tau_{vW} = \\frac{|\\nabla\\rho|^2}{8\\rho}为 von Weizsäcker 泛函的正定形式，\\tau_{TF} = \\frac{3}{10}(3\\pi^2)^{2/3}\\rho^{5/3}为 Thomas-Fermi 泛函。 2. 自旋极化 自旋极化状态下，我们可以针对一种自旋的电子定义 ELF，即 \r {\\rm{ELF}}_\\sigma = \\frac{1}{1+\\chi_\\sigma^2}\r 其中\\chi_\\sigma = \\frac{\\tau^{KS}_\\sigma - \\tau^{vW}_\\sigma}{\\tau^{TF}_\\sigma}，\\tau^{KS}_\\sigma = \\frac{1}{2}\\sum_{i}{f_i |\\nabla\\psi_{i,\\sigma}|^2}为自旋为\\sigma的电子对应的正定动能密度。对于动能泛函，根据自旋标度率，有T_\\sigma = \\frac{1}{2}T[2\\rho_\\sigma]，因此，\\tau^{vW}_\\sigma = \\frac{|\\nabla\\rho_\\sigma|^2}{8\\rho_\\sigma}，\\tau^{TF}_\\sigma = \\frac{1}{2}\\frac{3}{10}(3\\pi^2)^{2/3}(2\\rho_\\sigma)^{5/3} = \\frac{3}{10}(6\\pi^2)^{2/3}\\rho_\\sigma^{5/3}。 注：Becke 和 Edgecombe 对 ELF 的原始定义为 由于这里\\tau_\\sigma = \\sum_{i}{f_i |\\nabla\\psi_{i,\\sigma}|^2} = 2\\tau^{KS}_\\sigma，因此分子分母同除以 2 后与上述定义相同。 同时，我们也可以定义总的 ELF，即 \r {\\rm{ELF}}_{tot} = \\frac{1}{1+\\chi_{tot}^2}\r 其中\\chi_{tot} = \\frac{\\tau^{KS}_\\alpha + \\tau^{KS}_\\beta - \\tau^{vW}_\\alpha - \\tau^{vW}_\\beta}{\\tau^{TF}_\\alpha + \\tau^{TF}_\\beta}。 3. 稳定性修正 在远离原子核的区域，\\chi的分子和分母均趋于零，但分母更快地趋于零，因此\\chi趋于无穷，最终 ELF 趋于零。 但在 LCAO 基组下，由于基组的不完备性，在远离原子核的某些区域，\\chi的分子可能更快地趋于零，导致\\chi趋于零或得到一个有限的值，最终得到非零的 ELF，即电子出现不物理的“局域化”。在 PW 基组下，则没有上述问题。 为了修正基组带来的不稳定性，我们采用了文献[2]中的建议，在\\chi的分子上增加一个很小的修正值，以保证\\chi在远离原子核的区域正确地趋于零。经测试后，ABACUS 取此修正值为 10^{-5}，即可以提升稳定性，又不会影响近核区域的结果。 三、ABACUS 计算 ELF 具体流程 相关参数：out_elf [int] [int]：out_elf 的第一个值控制是否输出 ELF，设置为 1 则输出，默认值为 0；第二个值控制输出的有效数字位数，默认为 3。 在 INPUT 中设置 out_elf 1 并运行 ABACUS 后，ELF 会被存储到 OUT 文件夹下。 自旋非极化情况下（nspin 1）ELF 会被存储到 ELF.cube 文件中；自旋极化的情况下（nspin 2），除了 ELF.cube 中存储的总 ELF，自旋为上和自旋为下的 ELF 会分别存储在 ELF_SPIN1.cube 和 ELF_SPIN2.cube 中。这些 cube 文件都可以直接在 VESTA 中可视化。 下面举两个具体的例子，一个自旋非极化的水分子，另一个是自旋极化的体心立方铁。 1. 计算实例：自旋非极化的水分子 1.1 平面波基组 算例地址：https://github.com/MCresearch/abacus-user-guide/tree/master/examples/elf/H20-pw 运行此算例得到的 ELF.cube 文件如下，由于此算例中的水分子放置在真空中，远离水分子的区域内 ELF 都为零。 STEP: 0 Cubefile created from ABACUS. Inner loop is z, followed by y and x 1 (nspin) 3 0.0 0.0 0.0 180 0.155556 0.000000 0.000000 180 0.000000 0.155556 0.000000 180 0.000000 0.000000 0.155556 1 1.000000 11.967714 18.726812 8.322864 1 1.000000 14.244302 20.657387 7.503683 8 6.000000 13.550429 19.681072 9.139011 0.000e+00 0.000e+00 0.000e+00 0.000e+00 0.000e+00 0.000e+00 0.000e+00 0.000e+00 0.000e+00 0.000e+00 0.000e+00 0.000e+00 ...... 0.000e+00 0.000e+00 0.000e+00 0.000e+00 0.000e+00 0.000e+00 将此文件在 VEASTA 中可视化，得到下图，其中左图为 ELF 的等高面，右图为在 H-O-H 截面上的切面图。 1.2 原子轨道基组 算例地址：https://github.com/MCresearch/abacus-user-guide/tree/master/examples/elf/H20-lcao 运行此算例后，可得到与上例格式相同的 ELF.cube 文件，用 VESTA 可视化的结果如下图，其中左图为 ELF 的等高面，右图为在 H-O-H 截面上的切面图。。 由于使用的基组不同，得到的 ELF 也略有不同。 2. 计算实例：自旋极化的体心立方铁 算例地址：https://github.com/MCresearch/abacus-user-guide/tree/master/examples/elf/bcc-Fe-pw 此算例使用 PW 基组下的 KSDFT。运行此算例后，可以得到 ELF.cube，ELF_SPIN1.cube 与 ELF_SPIN2.cube 三个文件，分别存储总 ELF，自旋为上电子的 ELF 以及自旋为下电子的 ELF，下面为三种不同的 ELF 在(100)晶面上的分布图。 四、参考文献 [1] Becke A D, Edgecombe K E. A simple measure of electron localization in atomic and molecular systems[J]. The Journal of chemical physics, 1990, 92(9): 5397-5403. [2] 卢天, 陈飞武. 电子定域化函数的含义与函数形式[J]. 物理化学学报, 2011, 27(12): 2786-2792. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-bader.html":{"url":"abacus-bader.html","title":"ABACUS+Bader charge 分析教程","keywords":"","body":"ABACUS+Bader charge 分析教程 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 最后更新时间：2024 年 7 月 13 日 前言 我们在软件开发时不可避免遇到化学相关应用场景的需求，其中一个可能重点关注的信息便是“价态”。尽管从原理上考虑，“价态”这个量的定义并不明确，但化学场景的使用者总希望找到各式各样的方法来契合他们的“化学直觉”，便诞生了各种布居分析（Population Analysis）方法：如 Mulliken、Hirshfeld、Hirshfeld-Iterative (Hirshfeld-I)、ADCH、DDEC6、CM5、Mayer、Bader 等，以及各种电子的定域化分析方法，如 Wannier、ELF 等。尽管他们各自存在或致命或物理上定义不明的问题，如 Mulliken 电荷具有非常显著的基组相关效应，Hirshfeld 电荷经常对过渡元素计算出携带负电，Bader 对于电荷分布极其不均匀的体系会得出异常结果等，但仍然有足够普遍的受众群体。 Bader charge 是将电子密度进行类似于 Voronoi tesellation 的剖分，在原子间以电荷密度的梯度为 0 处创建截面，然后将原子周围所有截面包络出的 cell 进行实空间积分，即为 Bader charge。考虑实际计算，我们总能对价电子的密度进行切分，但对近核电子的处理则有所差别：CP2K 支持构造出核电荷分布，VASP 支持从 PAW 势中重建核电荷分布，而 QE 和 ABACUS 则不支持以上处理方式。 Bader 分析软件部署 网站：https://theory.cm.utexas.edu/henkelman/code/bader/ 我们可以直接运行 linux 命令以下载 Bader 电荷分析软件的可执行文件版本，也可以选择下载源码然后手动编译： wget https://theory.cm.utexas.edu/henkelman/code/bader/download/bader_lnx_64.tar.gz tar -zxvf bader_lnx_64.tar.gz chmod +x bader 下载源码： wget https://theory.cm.utexas.edu/henkelman/code/bader/download/bader.tar.gz tar -zxvf bader.tar.gz cd bader make chmod +x bader 使用示例 在了解 bader charge 的原理后，我们首先从 nspin 1（only one spin channel）开始讲解具体使用。 nspin 1 case 生成所需 cube 文件 bader 程序需要读取以 cube 方式，或者 CHGCAR 格式存储的实空间电荷密度，因此运行 ABACUS 时，只需要添加 out_chg 1 即可输出电荷密度。 运行 bader 电荷分析 只需要以 /path/to/bader Si2-ELECTRON_DENSITY.cube 即可，屏幕会有如下输出： GRID BASED BADER ANALYSIS (Version 1.05 08/19/23) OPEN ... Si2-ELECTRO GAUSSIAN-STYLE INPUT FILE DENSITY-GRID: 60 x 60 x 60 CLOSE ... Si2-Si2.cube-ELECTRO RUN TIME: 0.02 SECONDS CALCULATING BADER CHARGE DISTRIBUTION 0 10 25 50 75 100 PERCENT DONE: ********************** REFINING AUTOMATICALLY ITERATION: 1 EDGE POINTS: 97653 REASSIGNED POINTS: 7908 RUN TIME: 0.23 SECONDS CALCULATING MINIMUM DISTANCES TO ATOMS 0 10 25 50 75 100 PERCENT DONE: ********************** RUN TIME: 0.02 SECONDS WRITING BADER ATOMIC CHARGES TO ACF.dat WRITING BADER VOLUME CHARGES TO BCF.dat NUMBER OF BADER MAXIMA FOUND: 8 SIGNIFICANT MAXIMA FOUND: 8 VACUUM CHARGE: 0.0000 NUMBER OF ELECTRONS: 8.00001 同时生成了 ACF.dat，AVF.dat 和 BCF.dat 文件，ACF.dat 中即是 bader 切分该电荷密度后在“Voronoi cell”切分的结果： # X Y Z CHARGE MIN DIST ATOMIC VOL -------------------------------------------------------------------------------- 1 3.653762 2.109500 1.491642 3.999891 1.952476 137.965434 2 0.000000 0.000000 0.000000 4.000124 1.952474 137.962879 -------------------------------------------------------------------------------- VACUUM CHARGE: 0.0000 VACUUM VOLUME: 0.0000 NUMBER OF ELECTRONS: 8.0000 我们将“CHARGE”列数据和赝势中 PP_HEADER 部分的 z_valence 值相减，即可得到该原子所携带电荷量。 nspin 2 case ABACUS 目前分 spin channel 进行电荷密度的输出，若 nspin 2，则会在目录下输出 SPIN1_CHG.cube 和 SPIN2_CHG.cube。然而，直接对每一个 spin channel 进行体积剖分，然后按照原子序号相加的结果可能是错误的，因为两个 spin channel 中不一定每个原子均具有位置相同的“0 梯度面”。因此对同一原子，可能在两个 spin channel 中具有不同大小的 cell。为了避免这种情况，可以首先将两 cube 文件进行加和，之后再调用 bader.x。 Cube manipulator Cube manipulator 是处理 Gaussian cube 格式 3D 实空间格点数据的小工具，可以在 ABACUS 代码包 tools 文件夹下找到（https://github.com/deepmodeling/abacus-develop/blob/develop/tools/plot-tools/cube_manipulator.py）。 通过 --help 可以查看可用选项： myaccount@mycomputer:~/abacus-develop/examples/spin_polarized/AFM/OUT.ABACUS# python3 cube_manipulator.py --help usage: cube_manipulator.py [-h] [-i INP] [-o OUT] [-s SCALE] [--p1d P1D] [--s2d S2D] [-p PLUS] [-m MINUS] manipulate the Gaussian cube format volumetric data. options: -h, --help show this help message and exit -i INP, --inp INP the input Gaussian cube file. -o OUT, --out OUT the output file. -s SCALE, --scale SCALE scale the Gaussian cube file by a factor. --p1d P1D integrate the Gaussian cube file in 2D, followed by the axis: 'x', ... --s2d S2D slice the Gaussian cube file along one axis, followed by string like 'x=0.0', 'y=0.0', 'z=0.0'. Note: should be fractional coodinate. -p PLUS, --plus PLUS plus the two Gaussian cube files. -m MINUS, --minus MINUS minus the two Gaussian cube files. Once meet any problem, please submit an issue at: https://github.com/deepmodeling/abacus-develop/issues 生成所需 cube 文件 我们选择 abacus-develop/examples/spin_polarized/AFM 算例，将 INPUT 文件中 out_chg flag 修改为 1，得到两个 cube 文件分别对应于两个 spin channel。此时我们只需要将两个 SPIN*_CHG.cube 相加即可： python3 cube_manipulator.py -i SPIN1_CHG.cube -p SPIN2_CHG.cube -o ELECTRONIC_DENSITY.cube 运行 bader 电荷分析 对文件 ELECTRONIC_DENSITY.cube 使用 bader.x，得到： GRID BASED BADER ANALYSIS (Version 1.05 08/19/23) OPEN ... ELECTRONIC_DENSITY.c GAUSSIAN-STYLE INPUT FILE DENSITY-GRID: 36 x 36 x 36 CLOSE ... ELECTRONIC_DENSITY.c RUN TIME: 0.00 SECONDS CALCULATING BADER CHARGE DISTRIBUTION 0 10 25 50 75 100 PERCENT DONE: ********************** REFINING AUTOMATICALLY ITERATION: 1 EDGE POINTS: 39985 REASSIGNED POINTS: 6753 RUN TIME: 0.07 SECONDS CALCULATING MINIMUM DISTANCES TO ATOMS 0 10 25 50 75 100 PERCENT DONE: ********************** RUN TIME: 0.00 SECONDS WRITING BADER ATOMIC CHARGES TO ACF.dat WRITING BADER VOLUME CHARGES TO BCF.dat NUMBER OF BADER MAXIMA FOUND: 108 SIGNIFICANT MAXIMA FOUND: 108 VACUUM CHARGE: 0.0000 NUMBER OF ELECTRONS: 31.99909 该例为，呈反铁磁态，每个 Fe 原子有 16 个价电子，最终积分得到电子数量为 31.99909，因此符合预期。同样查看 ACF.dat 文件： # X Y Z CHARGE MIN DIST ATOMIC VOL -------------------------------------------------------------------------------- 1 0.000000 0.000000 0.000000 15.999544 2.060461 76.704205 2 2.676622 2.676622 2.676622 15.999544 2.060459 76.704205 -------------------------------------------------------------------------------- VACUUM CHARGE: 0.0000 VACUUM VOLUME: 0.0000 NUMBER OF ELECTRONS: 31.9991 发现两 Fe 原子均为电中性，同样符合预期。 附录：cube manipulator 更多的使用方法 Cube manipulator 还有除了加法之外的更多功能，例如两 cube 文件进行减法、一个 cube 文件进行乘法等，以及还有面向更实际的应用场景，2D 平面积分与 cube 3D 内容切片。 AXPY 类操作 AXPY 是 BLAS 中函数，代表了诸如： y=\\alpha x+\\beta y 的操作。因此-p flag 即为$\\alpha=1, \\beta=1$，-m flag 即为$\\alpha=1,\\beta=-1$，-s 为$\\alpha=?, \\beta=0$。 例如将 SPIN1_CHG.cube 和 SPIN2_CHG.cube 相减可以获得自旋密度： python3 cube_manipulator.py -i SPIN1_CHG.cube -m SPIN2_CHG.cube -o SPIN_DENSITY.cube 图 1. SPIN1_CHG.cube 图 2. SPIN2_CHG.cube 图 3. SPIN_DENSITY.cube Profile1d 操作 在进行表面模型的功函数计算时，需要对 Hartree 势进行面积分，得到沿某个轴的 1 维曲线。我们分别使用 ELECTRON_DENSITY.cube 和 SPIN_DENSITY.cube 对该功能进行演示： python3 cube_manipulator.py -i ELECTRON_DENSITY.cube --p1d x -o charge1d.dat python3 cube_manipulator.py -i SPIN_DENSITY.cube --p1d x -o spin1d.dat 即对 yz 平面进行积分，进行简单的绘图： 图 4. charge1d.dat，0和0.5位置各有一个Fe原子，Bader电荷切分的地方接近0.25和0.75 图 5. spin1d.dat，spin density由正到负，符合反铁磁Fe2的预期 Slice2d 操作 有时我们会考察某个截面的电子密度，对原子周围电子的局域化程度进行分析。我们仍然分别使用 ELECTRON_DENSITY.cube 和 SPIN_DENSITY.cube 对该功能进行演示： python3 cube_manipulator.py -i ELECTRON_DENSITY.cube --s2d x=0 -o charge2d_000.dat python3 cube_manipulator.py -i ELECTRON_DENSITY.cube --s2d x=0.25 -o charge2d_025.dat python3 cube_manipulator.py -i ELECTRON_DENSITY.cube --s2d x=0.5 -o charge2d_050.dat python3 cube_manipulator.py -i SPIN_DENSITY.cube --s2d x=0 -o spin2d_000.dat python3 cube_manipulator.py -i SPIN_DENSITY.cube --s2d x=0.25 -o spin2d_025.dat python3 cube_manipulator.py -i SPIN_DENSITY.cube --s2d x=0.5 -o spin2d_050.dat 进行简单绘图，电荷密度： 图 6. charge2d_000.dat 图 7. charge2d_025.dat 图 8. charge2d_050.dat 自旋密度： 图 9. spin2d_000.dat 图 10. spin2d_025.dat 图 11. spin2d_050.dat Have a question? Submit issue! 如果在使用 ABACUS+Bader Analysis 过程中发现了 bug 或者运行结果不达预期，可以在 deepmodeling/abacus-develop 仓库下提交 issue。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-elastic.html":{"url":"abacus-elastic.html","title":"ABACUS+pymatgen 计算弹性常数","keywords":"","body":"ABACUS+pymatgen 计算弹性常数 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024/07/11 一、介绍 本教程旨在描述如何采用 ABACUS 来计算材料体系的弹性常数（elastic constants）。弹性常数是表征材料弹性的量，也是材料的重要力学性质，可以通过原子尺度模拟计算获得，例如通过密度泛函理论或者原子间的势函数方法。在晶体结构预测辅助的新材料计算设计中，弹性常数常用于检查结构的稳定性。 在晶体的线弹性范围内，应力\\boldsymbol{\\sigma}和相应应变\\boldsymbol{\\varepsilon}之间的关系符合胡克定律，\\boldsymbol{\\sigma=C\\varepsilon},\\sigma_{ij}=C_{ijkl}\\varepsilon_{kl}，其中i,j,k,l是笛卡尔指标（x,y,z），C_{ijkl}即为弹性常数。 由于\\boldsymbol{\\sigma}和\\boldsymbol{\\varepsilon}均是对称张量，基于 Voigt 表示法：xx\\mapsto1,yy\\mapsto2,zz\\mapsto3,yz\\mapsto4,xz\\mapsto5,xy\\mapsto6，则：\\sigma_1=\\sigma_{xx},\\sigma_2=\\sigma_{yy},\\sigma_3=\\sigma_{zz},\\sigma_4=\\sigma_{yz},\\sigma_5=\\sigma_{xz},\\sigma_6=\\sigma_{xy} \\epsilon_1=\\epsilon_{xx},\\epsilon_2=\\epsilon_{yy},\\epsilon_3=\\epsilon_{zz},\\epsilon_4=\\epsilon_{yz},\\epsilon_5=\\epsilon_{xz},\\epsilon_6=\\epsilon_{xy} 此时，C_{xxxx}\\mapsto C_{11},C_{xxyy}\\mapsto C_{12},..... \\begin{bmatrix}\\sigma_{1}\\\\\\sigma_{2}\\\\\\sigma_{3}\\\\\\sigma_{4}\\\\\\sigma_{5}\\\\\\sigma_{6}\\end{bmatrix}=\\begin{bmatrix}C_{11}&C_{12}&C_{13}&C_{14}&C_{15}&C_{16}\\\\C_{12}&C_{22}&C_{23}&C_{24}&C_{25}&C_{26}\\\\C_{13}&C_{23}&C_{33}&C_{34}&C_{35}&C_{36}\\\\C_{14}&C_{24}&C_{34}&C_{44}&C_{45}&C_{46}\\\\C_{15}&C_{25}&C_{35}&C_{45}&C_{55}&C_{56}\\\\C_{16}&C_{26}&C_{36}&C_{46}&C_{56}&C_{66}\\end{bmatrix}\\begin{bmatrix}\\epsilon_{1}\\\\\\epsilon_{2}\\\\\\epsilon_{3}\\\\2\\epsilon_{4}\\\\2\\epsilon_{5}\\\\2\\epsilon_{6}\\end{bmatrix} 如果我们通过施加应变\\varepsilon_i使晶体变形并计算相应的应力，则可以从方程中获得弹性常数。晶体晶胞上的变形矩阵为\\boldsymbol{D=I+\\varepsilon}，其中\\boldsymbol{I}是 3*3 的单位矩阵，\\boldsymbol{\\varepsilon}是 Voigt 表示法中的应变矩阵。 在 3 维晶体中，应变矩阵为 \\boldsymbol{\\varepsilon}=\\left[\\begin{array}{lrr} \\varepsilon_{1} & \\varepsilon_{6} & \\varepsilon_{5} \\\\ \\varepsilon_{6} & \\varepsilon_{2} & \\varepsilon_{4} \\\\ \\varepsilon_{5} & \\varepsilon_{4} & \\varepsilon_{3} \\end{array}\\right]，在2维平面晶体中，应变矩阵为\\boldsymbol{\\varepsilon}=\\left[\\begin{array}{lrr} \\varepsilon_{1} & \\varepsilon_{6} & 0\\\\ \\varepsilon_{6} & \\varepsilon_{2} & 0 \\\\ 0 & 0 & 0 \\end{array}\\right]。 变形后，晶格矢量为\\boldsymbol{A'=A \\cdot D}，其中\\boldsymbol{A}是初始的晶格矢量。 在实际计算中，6 种应变状态将逐一应用于初始弛豫（relaxation）后的结构，因此每次只考虑一种独立变形。对于 6 种应变状态中的每一种，应用 4 种不同的默认应变大小：\\varepsilon_i\\in\\{-0.01,-0.005,0.005,0.01\\}，将产生 24 种构型。接着对这 24 种构型分别使用 DFT 计算（固定晶格矢量，但允许原子弛豫，即 relax），对所获得的每种应变状态的 4 个应力和应变的集合使用线性拟合来计算相应的弹性常数。 更多细节可以参考：Elastic Constants | Materials Project Documentation 二、准备 1. 下载例子 首先可以下载一个 ABACUS 的计算实例，可以从 Gitee 上下载。具体来说，可以通过在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载后解压，之后进入 abacus-user-guide/examples/elastic 文件夹 里面有 relax 文件夹，为 8 原子金刚石的算例，周期性边界条件。 此外，gene_dfm.py 和 compute_dfm.py 为计算弹性常数使用的 python 脚本。 run_task.sh 和 sub.sh 为批量运行 abacus 计算的 shell 脚本，INPUT、KPT、C_ONCV_PBE-1.0.upf 和 C_gga_7au_100Ry_2s2p1d.orb 为运行 abacus 计算所需的输入文件。 2. 下载并安装 pymatgen Python Materials Genomics (pymatgen，https://pymatgen.org/)是一个 API 包，该软件可以与 materials project 结合进行高通量计算。该软件包是由加州大学圣地亚哥雅各布斯工程学院的纳米工程教授 Shyue Ping Ong 和他的材料虚拟实验室(Materials Virtual Lab)团队开发并维护的程序。 在本教程里会用到 pymatgen 来计算弹性常数，此外还会用到 dpdata，monty，numpy 这三个库，可以使用如下命令安装： pip install monty numpy dpdata pymatgen 弹性常数所用方法相关文档：https://pymatgen.org/pymatgen.analysis.elasticity.html 三、金刚石的弹性常数计算 1. 结构弛豫 进入 relax 文件夹，运行 ABACUS 进行结构弛豫，完成后在 OUT.C8 文件夹下出现 STRU_ION_D 文件。之后的应变都将在这个构型文件基础上产生。此外，计算弹性常数所用的应力也会减去这个构型的应力，因此也需要 running_relax.log 输出应力 2. 产生应变构型 回到例子根目录，执行如下命令： python gene_dfm.py abacus 默认应变的大小（代表晶格常数的倍数，例如 0.01，其形变量是 1%）如下，对应 gene_dfm.py 的 41-42 行： norm_strains = [-0.010, -0.005, 0.005, 0.010] shear_strains = [-0.010, -0.005, 0.005, 0.010] 将会产生 task.000 到 task.023 共 24 个文件夹，分别对应第一节所说的 24 种构型。进入任意 task 文件夹，其中会有 INPUT、KPT、STRU 和 strain.json 四个文件。 其中 INPUT 和 KPT 拷贝自例子根目录下的 INPUT 和 KPT，由于使用的赝势和轨道文件放在例子根目录下，所以 pseudo_dir 和 orbital_dir 均设置为 ../。此外需要进行固定晶格矢量，但允许原子弛豫来计算应力，因此 calculation 设置为 relax。STRU 和 strain.json 分别是生成的构型文件和相应的应变大小。 3. 计算应力 分别进入上述 task 文件夹，运行 abacus 计算相应构型的应力。也可以使用例子根目录下的 run_task.sh 脚本，但要注意根据实际修改其和 sub.sh 的内容。 4. 计算弹性常数 回到例子根目录，执行如下命令： python compute_dfm.py abacus 屏幕输出如下： # Elastic Constants in GPa 1043.31 107.39 107.39 0.00 0.00 0.00 107.39 1043.31 107.39 0.00 0.00 0.00 107.39 107.39 1043.31 0.00 0.00 0.00 0.00 -0.00 -0.00 557.05 0.00 0.00 -0.00 -0.00 -0.00 0.00 557.05 0.00 0.00 0.00 0.00 0.00 0.00 557.05 # Bulk Modulus BV = 419.37 GPa # Shear Modulus GV = 521.42 GPa # Youngs Modulus EV = 1105.91 GPa # Poission Ratio uV = 0.06 第 2 到 7 行即为计算的各种弹性常数（单位：GPa），分别是体弹性模量（Bulk Modulus）、剪切模量（Shear Modulus）、杨氏模量（Youngs Modulus）和泊松比（Poission Ratio）。精度更高的计算结果存储在 elastic.json 内。 以下是常用的几个弹性常数相关的名词解释： 弹性模量（Bulk Modulus）：指当有力施加于物体或物质时，其弹性变形（非永久变形）趋势的数学描述。物体的弹性模量定义为弹性变形区的应力-应变曲线的斜率。 杨氏模量（Young's Modulus）：是材料力学中的名词，一般将杨氏模量习惯称为弹性模量。弹性材料承受正向应力时会产生正向应变，在形变量没有超过对应材料的一定弹性限度时，定义正向应力与正向应变的比值为杨氏模量。杨氏模量的大小标志了材料的刚性，杨氏模量越大，越不容易发生形变。大部分金属在合金成分不同、热处理在加工过程中的应用，其杨氏模量值会有 5％或更大的波动。 剪切模量（Shear Modulus）：又称刚度模量，描述材料在剪切力作用下抵抗形变的能力，即物体形变的大小与作用的剪切应力之间的关系。 泊松比（Poisson's Ratio）：当材料在一个方向被压缩，它会在与该方向垂直的另外两个方向伸长，这就是泊松现象，泊松比是用来反映泊松现象的无量纲的物理量。泊松比一般是正值，表示在一方向拉伸后，在其他方向收缩。不过也存在泊松比为零（在一方向拉伸后，在其他方向的尺寸不变），其至为负的材料。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-phonopy.html":{"url":"abacus-phonopy.html","title":"ABACUS+Phonopy 计算声子谱","keywords":"","body":"ABACUS+Phonopy 计算声子谱 作者：赵天琦，邮箱：zhaotq13@tsinghua.org.cn；陈涛，邮箱：chentao@stu.pku.edu.cn 审核：刘建川，邮箱：liujianchuan2013@163.com 最后更新时间：2023/08/14 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍采用 ABACUS（基于 ABACUS 3.2.2 版本）做密度泛函理论计算，并且结合 Phonopy 软件计算声子谱的流程。此外，本教程还用到 gnuplot 来绘图。 首先推荐大家阅读以下文档中的详细说明： ABACUS 官方文档：Phonopy - ABACUS documentation Phonopy 相关文档：ABACUS & phonopy calculation — Phonopy v.2.19.1 Gnuplot 主页：gnuplot homepage 二、准备 我们以 FCC Al 这个简单例子来演示使用 有限位移方法 来结合 ABACUS 和 Phonopy 计算声子谱。 1. 下载并安装 Phonopy git clone https://github.com/phonopy/phonopy.git cd phonopy python3 setup.py install 2. 下载 FCC Al 例子 可以从 Gitee 上下载。可以在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载后解压，之后进入 abacus-user-guide/examples/interface_Phonopy 文件夹 三、流程 1. 使用 ABACUS 优化结构 这里我们已经给出一个已经优化好的 FCC Al 结构 ABACUS 中的结构文件名为 STRU： ATOMIC_SPECIES Al 26.982 Al_ONCV_PBE-1.0.upf upf201 NUMERICAL_ORBITAL Al_gga_7au_100Ry_4s4p1d.orb LATTICE_CONSTANT 1.88972612546 LATTICE_VECTORS 4.03459549706 0 0 #latvec1 0 4.03459549706 0 #latvec2 0 0 4.03459549706 #latvec3 ATOMIC_POSITIONS Direct Al #label 0 #magnetism 4 #number of atoms 0 0 0 m 0 0 0 0.5 0.5 0 m 0 0 0 0.5 0 0.5 m 0 0 0 0 0.5 0.5 m 0 0 0 2. 用 Phonopy 产生需要计算的超胞及相应微扰构型 这里我们使用 有限位移方法 计算声子谱，因此需要对晶格进行扩胞并对原子位置进行微扰。执行如下命令即可生成 222 的扩胞并产生微扰结构： phonopy -d --dim=\"2 2 2\" --abacus 这一步 phonopy 会根据晶格对称性自动产生相应个数的微扰结构。由于 FCC 的晶格对称性较强，因此这个例子只产生一个微扰结构：STRU-001。这里类似 K 点的对称性分析，晶体结构对称性越强，所需的微扰结构就越少，对称性稍差的体系一般会产生多个微扰结构。 经验性设置：1）扩胞越大，计算结果越精确，但是计算量也会上升，一般来说扩胞三个方向的 cell 长度均在 10-20 Å 是比较合适的；2）对于优化后的晶胞（复杂体系），原子位置可能不处于高对称点上，phonopy 可能计算存在一定的误差，可以使用 Matertial Studio 等软件把对称性加回去之后，再做上述步骤，这样能够得到准确的声子谱数据（保证计算出来的声子谱满足体系的对称性特征）。 3. 产生 FORCE_SET 文件 接着用 ABACUS 计算原子受力，其中需要注意的是 calculation 需要设置为 scf，并且设置 cal_force 为 1，因为这一步目的是输出原子受力。 小技巧：即为了计算不同的微扰结构的受力，可以在 INPUT 里添加关键字 stru_file 来指定 STRU 文件的路径和文件名：stru_file ./STRU-001 INPUT 内容如下： INPUT_PARAMETERS #Parameters (1.General) suffix Al-fcc calculation scf esolver_type ksdft symmetry 1 pseudo_dir ./psp orbital_dir ./psp cal_stress 1 cal_force 1 stru_file STRU-001 #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-7 scf_nmax 50 #Parameters (3.Basis) basis_type lcao gamma_only 0 #Parameters (4.Smearing) smearing_method mp smearing_sigma 0.015 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.7 mixing_gg0 1.5 算完之后用以下命令产生 FORCE_SET 文件： phonopy -f ./disp-001/OUT*/running_scf.log ./disp-002/OUT*/running_scf.log ... 即要指定所有微扰构型算完之后的 running_scf.log 文件位置。如果运行有错，需要首先检查是否所有构型都已正常结束，且其中有力输出（可以找“FORCE”来确认）。 4. 设置 band.conf 文件计算得到声子谱 执行如下命令： phonopy -p band.conf --abacus band.conf 内容如下： ATOM_NAME = Al DIM = 2 2 2 MESH = 8 8 8 PRIMITIVE_AXES = 0 1/2 1/2 1/2 0 1/2 1/2 1/2 0 BAND = 1 1 1 1/2 1/2 1 3/8 3/8 3/4 0 0 0 1/2 1/2 1/2 BAND_POINTS = 101 BAND_CONNECTION = .TRUE. 这一步结束之后会有 band.yaml 文件输出 以上参数在 Phonopy 的线上文档中均有详细说明，这里再进行简单概述： ATOM_NAME：指定结构文件中的元素种类。 DIM：扩胞的大小，需要跟 3.2 用Phonopy产生需要计算的超胞及相应微扰构型 中的“dim”一致。 MESH：q 点的采样网格。‘8 8 8’意味着采用 888 的 q 点网格，默认以（0，0，0）为中心。 PRIMITIVE_AXES：输入晶胞到目标原胞的转换矩阵，并将根据原胞基矢量作为声子计算的坐标系。这里是 FCC 的原胞转换矩阵。 BAND：采样能带的 q 点路径。不同晶格的高对称点不同，具体可以使用 SeeK-path，自动生成 q 点路径。 BAND_POINTS：给出了包括能带路径末端的采样点的数量。 BAND_CONNECTION：在能带交叉处辅助连接能带。 5. 绘制声子谱 本教程使用 gnuplot 绘制声子谱，在 Ubuntu 上 gnuplot 的安装如下： sudo apt-get install gnuplot 用如下命令输出 gnuplot 格式的声子谱，并使用 gnuplot 绘制声子谱并存为 Al-FCC_plot.png： phonopy-bandplot --gnuplot > pho.dat gnuplot plot_pho.gp plot_pho.gp 内容如下： set terminal pngcairo size 1920, 1080 font 'Arial, 36' ## 格式，大小和字体 set output \"Al-FCC_plot.png\" ###输出的文件名 set ylabel 'Frequency (THz)' set ytics 2 unset key x1 = 0.13115990 x2 = 0.17753200 x3 = 0.31664810 xmax = 0.43023590 ymin = 0 ymax = 12 set xrange [0:xmax] set yrange [ymin:ymax] set xtics (\"{/Symbol G}\" 0, \"X\" x1, \"K\" x2, \"{/Symbol G}\" x3, \"L\" xmax) set arrow 1 nohead from x1,ymin to x1,ymax lt 2 set arrow 2 nohead from x2,ymin to x2,ymax lt 2 set arrow 3 nohead from x3,ymin to x3,ymax lt 2 plot 'pho.dat' using 1:($2) w l lw 3 FCC Al 的声子谱： 也可使用 Origin 绘图，pho.dat 的第一列就是上图的横轴（K 点路径），其中高对称 K 点位置见 pho.dat 的第二行，第二列就是上图的纵轴（声子频率，单位 THz）。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-shengbte.html":{"url":"abacus-shengbte.html","title":"ABACUS+ShengBTE 计算晶格热导率","keywords":"","body":"ABACUS+ShengBTE 计算晶格热导率 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/06/15 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍采用 ABACUS（基于 ABACUS 3.2.0 版本）做密度泛函理论计算，并且结合 ShengBTE 软件计算晶格的热导率的流程。其中，整个计算过程中还用到了：1）采用 Phonopy 程序来计算二阶力常数，2）采用 ASE 程序进行原子结构的转换，3）采用 ShengBTE 的 thirdorder 程序计算三阶力常数，4）最后使用 ShengBTE 来计算材料的晶格热导率。 上述提到了一些需要结合的外部软件，这里推荐大家阅读这些软件的相关文档和说明： ShengBTE：https://bitbucket.org/sousaw/shengbte/src/master/ phonopy：http://abacus.deepmodeling.com/en/latest/advanced/interface/phonopy.html ASE：http://abacus.deepmodeling.com/en/latest/advanced/interface/ase.html thirdorder: https://bitbucket.org/sousaw/thirdorder/src/master/ 二、准备 ABACUS 的软件包中提供了一个 ABACUS+ShengBTE 计算晶格热导率的算例，可以从 Gitee 上下载。算例中包含采用数值原子轨道的 LCAO（Linear Combination of Atomic Orbitals）和采用平面波基矢量的 PW（Plane Wave，平面波）两个文件夹。每个文件夹下分别又包含了 2nd、3rd 和 shengbte 这三个文件夹，分别保存了使用 phonopy 计算二阶力常数（2nd）、thirdorder 计算三阶力常数（3rd）和 ShengBTE 计算晶格热导率（shengbte）的相关文件。 三、流程 以 LCAO 文件夹为例，我们这里提供的测试案例是包含 2 个原子的金刚石结构 Si 结构，采用的模守恒赝势是 Si_ONCV_PBE-1.0.upf，以及原子轨道文件采用的是 Si_gga_7au_100Ry_2s2p1d.orb（GGA 泛函，7 au 截断半径，100 Ry 能量截断，以及包含 2s2p1d 的 DZP 轨道）。 1. 计算二阶力常数 要计算二阶力常数，除了 ABACUS 之外，还需要结合 Phonopy 和 ASE。首先，进入 2nd 文件夹。 1.1 结构优化 做晶格热导率计算之前要先对模拟的材料体系的进行原子构型的优化。下面是采用 ABACUS 做结构优化（relax）后得到的原子构型文件 STRU。在这个例子里，为了简单起见，结构优化过程采用的是 2*2*2 的布里渊区 k 点采样，平面波的能量截断值 ecut（LCAO 里面也用到了平面波基矢量）为 100 Ry，注意实际计算中应该要采用更收敛的 k 点采样。 ATOMIC_SPECIES Si 28.0855 Si_ONCV_PBE-1.0.upf NUMERICAL_ORBITAL Si_gga_7au_100Ry_2s2p1d.orb LATTICE_CONSTANT 1.88972612546 LATTICE_VECTORS 0 2.81594778072 2.81594778072 #latvec1 2.81594778072 0 2.81594778072 #latvec2 2.81594778072 2.81594778072 0 #latvec3 ATOMIC_POSITIONS Direct # direct coordinate Si #label 0 #magnetism 2 #number of atoms 0.875 0.875 0.875 m 0 0 0 0.125 0.125 0.125 m 0 0 0 注意：第一行 Si 的质量 28.0855 在计算中不起作用。 1.2 计算二阶力常数 调用 Phonopy 软件产生需要计算的超胞及相应微扰的多个原子构型，命令如下： phonopy setting.conf --abacus -d 其中 setting.conf 文件的内容为： DIM = 2 2 2 ATOM_NAME = Si 这里我们采用的 Si 的例子只需要产生 1 个微扰构型 STRU-001 即可，对所有微扰构型（这里 Si 的例子只有 1 个）进行 SCF 计算（SCF 代表 Self-consistent field，这里代表进行密度泛函理论的电子迭代自洽计算）获得原子受力，算完之后用以下命令产生 FORCE_SET 文件： phonopy -f OUT.DIA-50/running_scf.log 小技巧：在 ABACUS 的输入文件 INPUT 中可以设置变量 stru_file，该变量对应的原子构型文件为 STRU-001 则 ABACUS 可以直接读取该结构文件。 下一步，设置 band.conf 文件计算得到声子谱以及二阶力常数： phonopy -p band.conf --abacus 这里出现的 band.conf 文件，其内容如下（具体参数含义可以查看 Phonopy 说明文档）： ATOM_NAME = Si DIM = 2 2 2 MESH = 8 8 8 PRIMITIVE_AXES = 1 0 0 0 1 0 0 0 1 BAND = 0.0 0.0 0.0 0.5 0.0 0.5 0.625 0.25 0.625, 0.375 0.375 0.75 00 0.0 0.0 0.5 0.5 0.5 BAND_POINTS = 101 BAND_CONNECTION = .TRUE. FORCE_CONSTANTS = WRITE FULL_FORCE_CONSTANTS = .TRUE. 这一步结束之后，Phonopy 软件会产生 band.yaml（用于绘制声子谱）和 FORCE_CONSTANTS 文件。其中，FORCE_CONSTANTS 文件包含的数据即为二阶力常数，注意这里务必设置 FULL_FORCE_CONSTANTS = .TRUE.，输出全部的二阶力常数，否则 ShengBTE 读取数据会报错。 此外，可以使用如下命令输出 gnuplot 格式的声子谱，用于绘制声子谱： phonopy-bandplot --gnuplot > pho.dat 1.3 后处理 注意 ShengBTE 软件要求 FORCE_CONSTANTS_2ND 文件里数据的单位为 eV/Å^2，但是 ABACUS 结合 phonopy 计算的 FORCE_CONSTANTS 单位为 eV/(Å*au)，其中 au 是原子单位制，1 au=0.52918 Å。可以使用 2nd 目录下提供的 au2si.py 脚本进行单位转换，生成 FORCE_CONSTANTS_2ND 文件，命令如下： python au2si.py 在 shengbte 文件夹中提供了 FORCE_CONSTANTS_2ND 文件供参考计算结果。 2. 计算三阶力常数 要计算三阶力常数，需要结合 thirdorder 程序，计算后输出三阶力常数文件 FORCE_CONSTANTS_3RD。但是，thirdorder 目前只支持读取 VASP 和 QE 的输入输出文件。因此，这里我们是通过将 ABACUS 的结构文件和输出受力分别转换为 POSCAR 和 vasprun.xml 来使用 thirdorder，请先进入 3rd 文件夹，具体步骤将在以下叙述。 2.1 获得微扰构型 首先将 ABACUS 软件进行结构优化（relax）后的 STRU 文件转化为 POSCAR（目录下已给出转化过的 POSCAR，或者需要自己动手进行这个转换）。 之后，运行 thirdorder_vasp 程序，产生微扰过后的一系列原子构型文件 3RD.POSCAR.*，例如这个例子一共产生了 40 个构型： thirdorder_vasp.py sow 2 2 2 -2 运行 pos2stru.py，将上述 POSCAR 转化为 STRU 文件，注意该脚本里调用了 ASE 软件包的函数（需提前安装好 ASE）： python pos2stru.py 注意：这里不能调用 dpdata 软件进行转化。因为 dpdata 会强制将晶格改为下三角矩阵，相当于旋转了晶格，会导致原子间受力方向也相应旋转，从而发生错误。 2.2 计算微扰构型的原子受力 可以参考目录下 run_stru.sh 使用脚本批量产生 SCF-* 文件夹并提交计算，这里需要采用 ABACUS 对 40 个原子构型分别进行 SCF 计算，会有些耗时。建议每个 SCF 单独在 SCF-* 文件夹内运行，这里的 INPUT 中的scf_thr 需要至少小到1e-8才能得到收敛的结果。 计算完成后，运行 aba2vasp.py，将 ABACUS 计算的原子受力包装成 vasprun.xml 格式，放置在每个 SCF-* 文件夹中，命令如下： python aba2vasp.py vasprun.xml 格式示意： 1.865e-05 -0.04644196 -0.00153852 -1.77e-05 -0.00037715 -0.00149635 1.973e-05 0.002213 -0.00149461 -1.976e-05 0.00065303 -0.0014804 8.31e-06 -0.0003306 -0.00024288 -8.25e-06 -0.00038306 -0.00025385 1.071e-05 0.00060621 -0.00025797 -1.05e-05 -0.00014553 -0.00027532 0.00668053 0.00645634 -0.04642593 -0.00668085 0.00645595 -0.00040122 -0.00650454 0.00628877 -0.00025123 0.00650504 0.00628892 -0.00028948 -0.00039591 2.479e-05 0.00223371 0.00039608 2.426e-05 0.0006732 0.0003264 3.122e-05 0.00052874 -0.00032589 3.415e-05 -0.00023577 -2.908e-05 -0.00832477 0.00635709 3.737e-05 -0.00125057 -7.444e-05 -2.582e-05 0.00656076 0.00636285 2.566e-05 -0.00049974 -6.661e-05 -5.431e-05 0.00502637 0.00639077 4.553e-05 -0.00180978 0.0001325 -3.609e-05 -0.00676473 0.00638092 3.806e-05 5.503e-05 0.00012759 -0.00670704 0.00646596 0.01310437 0.00670119 3.673e-05 0.00602948 0.00036366 0.00627899 -0.00657272 -0.00036508 2.288e-05 0.00026009 0.00648649 0.0064463 -0.00036521 -0.00648098 1.594e-05 0.00671469 -0.00034493 0.00630074 0.00662932 0.00034331 4.157e-05 -0.0002028 最后执行如下命令： find SCF-* -name vasprun.xml|sort -n|thirdorder_vasp.py reap 2 2 2 -2 即可得到三阶力常数文件 FORCE_CONSTANTS_3RD。在 shengbte 文件夹中提供了 FORCE_CONSTANTS_3rd 文件供参考计算结果。 3. 运行 ShengBTE 得到晶格热导率 进入 shengbte 文件夹，里面已经准备好 CONTROL（ShengBTE 的参数文件）、FORCE_CONSTANTS_2ND（二阶力常数文件）、FORCE_CONSTANTS_3RD（三阶力常数文件）这三个文件，使用如下命令运行 ShengBTE 即可得到晶格热导率，其中 Ref 文件夹中给出了计算结果供参考： mpirun -n 10 ShengBTE 四、结尾 对于 ABACUS 中使用平面波（PW）来做 ShengBTE 的计算也是采用以上类似的流程，但要注意使用平面波时，计算三阶力常数的 INPUT 中scf_thr 需要至少小到1e-12。通过计算结果可以发现，PW 和 LCAO 基组计算出的 Si 的晶格热导率是接近的，300 K 下均在 100 W/(m K) 左右，而实验中 Si 在 300 K 的热导率在 150 W/(m K) 附近。这是因为作为教学例子，这里使用的是 2*2*2 的扩胞以及 2*2*2 的 K 点，导致计算结果偏小，实际科研中需要测试扩胞的大小以及 K 点的采样方案来达到收敛的结果。以上就是 ABACUS(3.2.0)+ShengBTE 计算晶格热导率的全部流程，如果有什么问题，欢迎通过邮件联系。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-wannier.html":{"url":"abacus-wannier.html","title":"ABACUS+Wannier90 使用教程","keywords":"","body":"ABACUS+Wannier90 使用教程 作者：刘人熙，邮箱：rxliu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/11/09 教程使用说明 Wannier 函数是周期性晶格势场中局域表象下的波函数，Wannier 函数在 1937 年由 Gregory H. Wannier 提出，它可以通过傅立叶变换和布洛赫波函数互相转换。Wannier 函数对于理解半导体、过渡金属、分子晶体等价电子局域程度比较高的凝聚态系统有重要帮助，因而在物理中有广泛的应用。 在 ABACUS 等密度泛函理论（Density Functional Theory，简称 DFT）软件中，单电子近似下的布洛赫波函数可以通过自洽迭代求解 Kohn-Sham 方程得到。但是布洛赫波函数存在规范不确定性，进而导致 Wannier 函数[1-4]也不是唯一的。1997 年到 2001 年间，Nicola Marzari、David Vanderbilt 和 Ivo Souza 等人发展了最大局域化的 Wannier 函数（Maximally localized Wannier function, 简称 MLWF）的方法[1,2,4]，提出可以通过优化 Wannier 表象下的电子位置的方差（即 spread 函数）来确定一个规范，在该规范下 Wannier 函数是最局域的；该方法可以在 DFT 电子结构计算完之后以后处理的方式实现计算 MLWF。2008 年，用于产生 MLWF 的 Wannier90 软件发布，并在随后几年获得了广泛的应用。 本教程分为两部分，第一部分 最大局域化 Wannier 函数方法简介 介绍最大局域化 Wannier 函数的算法，主要介绍 1997 年和 2001 年的两篇 PRB 文章中提出的优化算法，侧重物理与算法原理；第二部分即本文档，是 Wannier90 软件的 ABACUS 接口说明，主要介绍如何使用 ABACUS 计算 Wannier90 需要的输入文件，侧重具体软件使用。 一、Wannier90 软件介绍 Wannier90 软件[5-7]是 Arash A. Mostofi 同 Marzari、Vanderbilt 等人在 2008 年写的做 Wannier 函数最局域化的 Fortran 语言写成的软件，目前是做 Wannier 函数最局域化的主流软件。在 Wannier 函数方面，Wannier90 软件可以输出 Wannier 函数的中心（负电中心），也可以画出 Wannier 函数的等值面图像。除了做 Wannier 函数相关的计算，Wannier90 还具有计算能带与态密度、Berry Phase、输运性质等方面的功能，程序的下载和使用方法可以参考其官网：Wannier90。 二、使用 ABACUS 准备 Wannier90 需要的文件 目前的 ABACUS 平面波基组功能支持 Wannier90 接口，LCAO 的接口还在完善中。 使用 Wannier90 接口不需要编译 ABACUS 过程中做额外操作。 1. ABACUS 软件的输入参数解释 参数名 默认值 变量类型 参数解释 towannier90 0 bool 是否打开 Wannier90 接口的计算功能 nnkpfile seedname.nnkp string Wannier90 产生的 nnkp 文件的路径，nnkp 文件包含了 k 点邻居关系等计算 mmn 和 amn 文件必要的信息。 wannier_spin up string 输出向上/向下的波函数及其内积 out_wannier_mmn 1 bool 是否输出 mmn 文件，mmn 文件存储了$M_{mn}^{\\mathbf{k,b}}$，即布洛赫波函数之间的内积。mmn 文件在计算 Wannier 最局域化时必须输出。 out_wannier_amn 1 bool 是否输出 amn 文件，amn 文件存储了$A_{mn}$，即初猜的 Wannier 函数和布洛赫波函数之间的内积。在 Wannier 最局域化计算中最好有该文件（可以加快优化迭代的收敛），也可以没有。 out_wannier_eig 1 bool 是否输出 eig 文件，eig 文件存储了各个 k 点、各个能带的本征能量。在计算输出能带时需要输出，如果不需要输出能带则不需要输出该文件。 out_wannier_unk 1 bool 是否输出 UNK 文件，UNK 文件存储了布洛赫波函数$u_{n\\mathbf{k}}$。计算 Wannier 函数最局域化，输出 Wannier 函数的中心和 spread 不需要波函数信息。只有画 Wannier 函数图像时需要 UNK 文件。 out_wannier_wvfn_formatted 1 bool 输出的 UNK 文件是否是文本文件。非文本文件即二进制文件，输出速度会比文本文件快很多。 在运行 ABACUS+wannier90 程序前，需要准备自洽计算（SCF）的输入文件、非自洽计算（NSCF）的输入文件和 Wannier90 的输入文件，ABACUS 的输入文件有如下注意事项： 自洽计算：需要注意 INPUT 中一定要指定 out_chg 参数为 1，即输出电荷密度，以供给非自洽计算计算使用； 非自洽计算：需要注意 INPUT 中需要把 init_charge 参数设置为 file，即读取文件中的电荷密度；一定要指定 towannier90 参数为 1，同时指定 nnkpfile 参数为 Wannier90 产生的 nnkp 文件的地址；另外需要注意 KPT 文件中的布里渊区 k 点要和 Wannier90 输入文件中的 k 点一模一样，所以最好手动输入 K 点坐标指定； 非自洽计算：INPUT 中有 out_wannier_mmn、out_wannier_amn、out_wannier_eig、out_wannier_unk、out_wannier_wvfn_formatted 五个控制 Wannier90 相关文件输出的参数，默认值都是 1，其中 out_wannier_eig 和 out_wannier_mmn 是必须打开的，out_wannier_unk 和 out_wannier_amn 在需要使用 Wannier90 绘制波函数图时需要打开，out_wannier_wvfn_formatted 控制输出的 UNK 文件是文本文件还是二进制文件，输出文本文件的时间成本和存储空间都会比较大，输出二进制文件的时间开销和存储开销则会相对较小。 2. 运行流程 这里给出了运行 ABACUS+wannier90 的一个脚本文件，结合 examples/interface_wannier90/ 中的例子讲解结合 ABACUS 和 Wannier90 计算最局域化 Wannier 函数的完整运行流程，这里的流程对平面波基组和原子轨道基组均适用，原子轨道基组的 NSCF 会比平面波基组慢一些。 export W90=wannier90.x export ABACUS=abacus export NP=12 # 1. 运行Wannier90软件，生成nnkp文件； cd wannier mpirun -np $NP $W90 -pp diamond.win # 2. 运行ABACUS软件，执行电子结构的自洽计算； cd ../ABACUS cp INPUT-scf INPUT cp KPT-scf KPT mpirun -np $NP $ABACUS >> scf.out # 3. 将nnkp文件放在ABACUS的非自洽计算的INPUT文件中指定的位置，运行ABACUS软件，执行非自洽计算； cp ../wannier/diamond.nnkp . cp INPUT-nscf INPUT cp KPT-nscf KPT mpirun -np $NP $ABACUS >> nscf.out # 4. 将非自洽计算生成的Wannier90所需要的文件（mmn、amn、eig、UNK）放在Wannier90的运行路径下，运行Wannier90软件。 cd ../wannier cp ../ABACUS/OUT.ABACUS/diamond.amn ../ABACUS/OUT.ABACUS/diamond.mmn ../ABACUS/OUT.ABACUS/diamond.eig ../ABACUS/OUT.ABACUS/UNK* . mpirun -np $NP $W90 diamond.win 在这个例子中，Wannier90 的输入文件 diamond.win 中指定要求画出 Wannier 函数的图像，运行结束之后会得到 diamond_0000[1-4].xsf 四个文件，存有 Wannier 函数的实空间格点数值，放在 VESTA 中可以画出如下图的 Wannier 函数的等值面。 3. 运行时间参考 由于 Wannier90 接口只涉及上述步骤中的 NSCF 计算，所以这里只提供 NSCF 部分的时间统计。 在 12 个 CPU（型号：Intel(R) Xeon(R) Bronze 3104 CPU @ 1.70GHz）上并行运行样例，UNK 文件采用二进制格式输出，平面波基组耗时 4 秒，原子轨道基组耗时 98 秒。 4. 样例文件 下载地址为（国内 gitee）： https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/interface_Wannier90 三、参考文献 Nicola Marzari, Arash A. Mostofi, Jonathan R. Yates, Ivo Souza, and David Vanderbilt, Maximally localized Wannier functions: Theory and applications, Rev. Mod. Phys. 84, 1419 (2012). （关于最大局域化 Wannier 函数的综述文献） Nicola Marzari and David Vanderbilt, Maximally localized generalized Wannier functions for composite energy bands, Phys. Rev. B 56, 12847 (1997). （提出最大局域化 Wannier 函数方法的文献） Blount, E. I., Solid State Phys. 13, 305 (1962). （关于 Bloch 状态的诸多基础性质的讨论，最大局域化中$\\langle n\\mathbf{R}|\\mathbf{r}|m\\mathbf{0}\\rangle$在布洛赫表象下的表达式来源于此） Ivo Souza, Nicola Marzari, and David Vanderbilt, Maximally localized generalized Wannier functions for entangled energy bands, Phys. Rev. B 65, 035109 (2001). （从纠缠能带中解耦出部分能带，做最大局域化 Wannier 函数的文献） Arash A. Mostofi, Jonathan R. Yates, Young-Su Lee, Ivo Souza, David Vanderbilt, Nicola Marzari, wannier90: A tool for obtaining maximally-localised Wannier functions, Comput. Phys. Commun., 178, 9, 685 (2008). (发布 Wannier90 软件的文献) Giovanni Pizzi et al. Wannier90 as a community code: new features and applications. J. Phys.: Condens. Matter, 32, 165902 (2020). (Wannier90 软件近期的更新) ABACUS 的 Wannier90 接口的英文文档：Wannier90 ‒ ABACUS documentation Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-candela.html":{"url":"abacus-candela.html","title":"ABACUS+Candela 使用教程","keywords":"","body":"ABACUS+Candela 使用教程 作者：陈涛，邮箱：chentao@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/12/13 在Bohrium Notebook上快速学习： 一、介绍 本教程旨在介绍采用 Candela 分析 ABACUS（基于 3.2.4 版本）分子动力学轨迹，计算径向分布函数（Radial Distribution Function，简称 RDF），静态结构因子（Static Structure Factor，简称 SSF），离子-离子动态结构因子（Ion-ion Dynamic Structure Factor，简称 DSF）以及均方差位移（Mean Square Displacement，简称 MSD）流程。 上述性质的具体描述可以参考：Qianrui Liu et al 2020 J. Phys.: Condens. Matter 32 144002，径向分布函数（RDF）见文中公式（12），静态结构因子（SSF）见公式（13），离子-离子动态结构因子（DSF）见公式（15，16，17）以及均方差位移（MSD）见公式（18）。 Candela 全称 Collection of ANalysis DEsigned for Large-scale Atomic simulations，目前支持分析 QE、ABACUS、LAMMPS 和 VASP 的分子动力学轨迹，Github 主页：https://github.com/MCresearch/Candela 二、准备 1. 下载并安装 Candela git clone https://github.com/MCresearch/Candela.git cd Candela make -j4 #使用intel oneapi编译器 若使用 Intel Oneapi 编译器，按照上述流程操作，在编译完成后即可在 bin 目录下看到 candela 可执行文件 若使用其他编译器，需要按照 Candela 目录下 Makefile.vars 修改相应的 CXX 2 下载例子 可以从 Gitee 上下载。在网页右侧点击克隆/下载-> 下载 ZIP 得到算例，或者在 linux 终端执行如下命令得到算例： git clone https://gitee.com/mcresearch/abacus-user-guide.git 下载完成后解压，之后进入 abacus-user-guide/examples/candela 文件夹 算例中包含 RDF、SSF、DSF、MSD 以及 MSD_ntype_2 五个文件夹和 MD_dump 文件。其中 MD_dump 是 32 原子的铝的 MD 轨迹 三、流程 1 计算径向分布函数 进入 RDF 文件夹，INPUT 文件即为 Candela 的输入文件，具体如下： calculation pdf geo_in_type ABACUS geo_directory ../MD_dump geo_1 0 geo_2 100 geo_interval 2 geo_ignore 50 geo_out Al_rdf.txt ntype 1 natom 32 rcut 2.3 dr 0.01 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 pdf（Pair Distribution Function）即计算径向分布函数 geo_in_type：读取的 MD 轨迹的格式，目前支持分析 pw.x（QE2），cp.x（QE），ABACUS（ABACUS）、LAMMPS（LAMMPS）和 VASP（VASP） geo_directory：MD 轨迹的位置 geo_1：MD 轨迹起始的索引 geo_2：MD 轨迹结束的索引 geo_interval：Candela 读取 MD 轨迹的间隔 geo_ignore：需要跳过的 MD 轨迹帧数 geo_out：输出的文件名，默认为 result.dat ntype：原子种类 natom：原子数 rcut：计算 RDF 的截断半径，一般取晶格的一半，单位为 Angstrom dr：计算 RDF 的 r 的间隔，单位为 Angstrom 执行如下命令： mpirun -n 2 candela 即可得到 RDF，输出到 Al_rdf.txt，其中第一列为 r，单位为 Angstrom，第二列即为对应的 RDF，第三列为对第二列积分的结果。 2 静态结构因子 进入 SSF 文件夹，INPUT 文件具体如下： calculation ssf geo_in_type ABACUS geo_directory ../MD_dump geo_1 0 geo_2 100 geo_interval 2 geo_ignore 50 ssf_out Al_ssf.txt ntype 1 natom 32 struf_dgx 1.32656 struf_dgy 1.32656 struf_dgz 1.32656 struf_ng 6 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 ssf，即计算静态结构因子 ssf_out：输出的文件名 struf_dgx：倒空间中的间隔，一般取 2\\pi/a，其中a为x方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} struf_dgy：一般取 2\\pi/b，其中b为y方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} struf_dgz：一般取 2\\pi/c，其中c为z方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} struf_ng：上述倒空间中的间隔的数量 执行如下命令： mpirun -n 2 candela 即可得到 SSF，输出到 Al_ssf.txt（原始的计算结果）以及 sm-Al_ssf.txt（平滑的计算结果），其中第一列为 q，单位为\\mathrm{Angstrom^{-1}}，第二列即为对应的 SSF。 3 离子-离子动态结构因子 进入 DSF 文件夹，离子-离子动态结构因子需要对中间散射函数（Intermediate Scattering Function）进行傅里叶变换得到，因此需要先计算中间散射函数，INPUT 文件具体如下： calculation isf2 geo_in_type ABACUS geo_directory ../MD_dump geo_1 50 geo_2 100 geo_interval 1 isf_outfile isf.txt ntype 1 natom 32 isf_nt1 11 isf_nt2 40 dt_snapshots 0.00006 isf_target_q 2.65 isf_dgx 1.32656 isf_dgy 1.32656 isf_dgz 1.32656 isf_ngx 6 isf_ngy 6 isf_ngz 6 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 isf2，即计算中间散射函数 isf_outfile：输出的文件名 isf_nt1：中间散射函数的时间长度 isf_nt2：用于平均中间散射函数的时间长度，注意需要控制 interval*(nt1+nt2) dt_snapshots：MD 轨迹每一帧之间的时间步长，单位为 ps isf_target_q：中间散射函数计算的目标 q，单位为\\mathrm{Angstrom^{-1}} isf_dgx：倒空间中的间隔，一般取 2\\pi/a，其中a为x方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} isf_dgy：一般取 2\\pi/b，其中b为y方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} isf_dgz：一般取 2\\pi/c，其中c为z方向的晶格长度，单位为\\mathrm{Angstrom^{-1}} isf_ngx：上述倒空间中 x 方向的间隔的数量 isf_ngy：上述倒空间中 y 方向的间隔的数量 isf_ngz：上述倒空间中 z 方向的间隔的数量 执行如下命令： mpirun -n 2 candela 即可得到 ISF，输出到 isf.txt，其中第一列为时间，单位为 ps，第二列即为对应的 ISF。 接着执行如下命令得到离子-离子动态结构因子，其中PathtoCandela指的是Candela的下载目录： python PathtoCandela/examples/e3_dsf/onedsf.py 0.00006 0.0006 其中第一个参数 0.00006 = dt_snapshots * geo_interval，为 ISF 的时间步长，单位为 ps；第二个参数 0.0006，为对 ISF 做傅里叶变换的总时长，单位为 ps。这里 onedsf.py 默认读取 isf.txt，并输出到 dsf.txt，其中第一列为\\hbar \\omega，单位为 meV，第二列即为对应的 DSF。 4 均方差位移 4.1 单种原子 进入 MSD 文件夹，INPUT 文件具体如下： calculation msd_multiple geo_in_type ABACUS geo_directory ../MD_dump geo_1 0 geo_2 100 geo_interval 1 geo_ignore 50 ntype 1 natom 32 msd_n 2 msd_t0 0.003 msd_t 0.0015 msd_dt0 0.0015 msd_dt 0.00006 msd_natom 32 以上参数在 Candela 的线上文档中均有详细说明，这里再进行简单概述： calculation：设置为 msd_multiple，即计算均方差位移 msd_n：计算均方差位移的段数，目的是将 MD 轨迹分成若干段，分别计算均方差位移 msd_t0：计算均方差位移的起始时间，单位为 ps msd_t：每段均方差位移的时长，单位为 ps msd_dt0：两段均方差位移起始位置的间隔，单位为 ps。若设置等于 msd_t，则每段均方差位移之间的时间距离为 0 msd_dt：获取的 MD 轨迹每一帧之间的时间步长（等于geo_interval * dt，其中 dt 为 MD 轨迹每一帧之间的时间步长），单位为 ps msd_natom：需要设置为计算的原子数 执行如下命令： mpirun -n 2 candela 即可得到 MSD，输出到 MSD_each.txt 和 MSD_total.txt。其中 MSD_each.txt 第一列为时间，单位为 ps，第二列到最后一列即为对应的每段的 MSD，单位为\\mathrm{Angstrom^{2}}；MSD_total.txt 第一列为时间，单位为 ps，第二列为平均的每段的 MSD，单位为\\mathrm{Angstrom^{2}}。 4.2 多种原子 进入 MSD_ntype_2 文件夹，INPUT 文件具体如下： calculation msd_multiple geo_in_type ABACUS geo_directory MD_dump geo_1 0 geo_2 100 geo_interval 1 geo_ignore 50 ntype 2 natom 17 natom1 16 natom2 1 id1 C id2 Li msd_n 2 msd_t0 0.003 msd_t 0.0015 msd_dt0 0.0015 msd_dt 0.00006 ele_select C msd_natom 16 以上参数在 Candela 的线上文档中均有详细说明，与单种原子不同的参数如下： natom1、natom2：不同种类原子的个数 id1、id2：不同种类原子的名称，需要与读入的 MD_dump 中原子名称一致 ele_select：计算 MSD 的原子名称，需要与 id1 或 id2 对应 多种原子的计算过程与结果与单种原子并无区别。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-uspex.html":{"url":"abacus-uspex.html","title":"ABACUS+USPEX 接口教程","keywords":"","body":"ABACUS+USPEX 接口教程 作者：柳向阳，邮箱：xiangyangliu@mail.ustc.edu.cn；郭晓庆，邮箱：xiaoqing.guo@mail.nwpu.edu.cn 审核：牛海洋，邮箱：haiyang.niu@nwpu.edu.cn；陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/14 一、背景介绍 近年来，随着高性能计算机的快速发展，晶体结构预测算法已然成为计算材料学的核心研究手段之一，极大地促进了新材料设计与研发的进程。Artem R.Oganov 教授课题组开发的进化类晶体结构预测算法 USPEX 是当前主流的全局搜索类算法之一。软件自 2004 年发布以来，该算法已被广泛应用于科研人员的研究工作中。晶体结构预测算法的主要作用是生成结构以及控制结构的演进，结构预测的效率及可靠性除却算法本身的影响外还对结构弛豫软件有极强的依赖性。ABACUS（原子算筹）作为一款国产开源密度泛函理论软件，同时兼具高精度和高效率，可适用于从小体系到上千原子体系的电子结构优化、原子结构弛豫、分子动力学等计算。因此实现晶体结构预测算法 USPEX（https://uspex-team.org/en）和第一性原理软件 ABACUS 的结合会给广大研究人员在结构预测研究中带来便利。 本教程旨在为大家提供一个 USPEX-ABACUS 接口的实现教程，方便大家程序配置。本教程以单质硅（Si）的结构预测为例, 介绍了该接口使用所需的输入文件和参数设置。 如需了解更多关于 USPEX 的使用信息，请参考 USPEX 官方文档：USPEX Documentation ‒ USPEX 二、接口介绍 当前发行的 USPEX 提供了分别以 matlab 和 python 为核心编程语言的两个版本，前者的版本编号为 USPEX-vXX（如 USPEX_v10.5），后者的版本编号为 USPEX-YEAR-XX（如 USPEX 2023.0.2），需要注意的是当前只有 python 版本可以自定义外部接口。该教程中的接口是在 USPEX 2023.0.2 和 ABACUS 3.3.0 版本进行编写测试的，如发生版本变更引起的异常，根据报错再行修改。 首先通过 USPEX 官网（USPEX 下载 ‒ USPEX）下载 USPEX 2023.0.2 软件（注册后即可免费下载），解压后根据所使用的 python 版本，选择软件压缩包进行安装，例如 pip install uspex-2023.0.2-cp310-cp310-linux_x86_64.whl。 注：若系统提示需要安装虚拟环境，可以在 USPEX 2023.0.2 目录下激活虚拟环境后重新进行安装。 python -m venv tutorial-env source tutorial-env/bin/activate 该接口共包含三个文件 (1) USPEX/components.py（对接口进行注册） (2) USPEX/Stages/Interfaces/ASEInterfacesAdapter.py（完成 ASE 接口中的读 read 和写 write 功能） (3) USPEX/Stages/Interfaces/ABACUS_Interface.py（接口实体，主要功能是准备 Abacus 的输入文件和读取 Abacus 的计算结果） 注：以上路径中 USPEX 为主目录。 上述文件可在 Github 仓库下载：https://github.com/gxq1219/Interface_USPEX-ABACUS/tree/master 安装完成后将以上文件复制到对应的路径下，并且需要手动添加环境变量，例如:export PATH=python3.10/site-packages/USPEX:$PATH，然后将 USPEX 2023.0.2 目录下的 random_cell 复制到设置的环境变量路径下。 该接口需要安装 ase-abacus 版本的 ase 库，测试版本为 ase-3.23.0b1 安装 ase-abacus 接口 git clone https://gitlab.com/1041176461/ase-abacus.git cd ase-abacus python3 setup.py install 此次测试是在 QSUB 任务管理系统下进行测试，如果更换任务管理系统，应修改 USPEX 输入文件 input.uspex 中的 taskManager 和 TM，此外需修改 USPEX/Stages/TaskManager 中所选任务管理方式中对任务队列状态识别的方式，如在 QSUB.py 文件中应根据所使用平台修改 def _parseJobID 中的内容识别出提交任务的 ID，以及下文的 def isReady 和 def isExist 等函数。 QSUB.py 示例（第 56 行的函数，根据自己超算平台修改，功能是执行 qsub sub.sh 后从屏幕输出的文本中提取出 jobID）： \"\"\" USPEX.Stages.TaskManagers.QSUB ============================== \"\"\" import logging from os.path import join as pj logger = logging.getLogger(__name__) class QSUB: shortname = 'QSUB' _RUNSCRIPT = 'jobscript' def __init__(self, header : str, connector): \"\"\" :param header: description of params of TaskManager :param connector: for remote submission \"\"\" self.connector = connector self.header = header def _prepareSubmission(self, COMMAND_EXEC : str, JOB_NAME : str, inputFile : str, outputFile : str, errorFile : str) -> str: \"\"\" Preparing jobscript for submission :param commandExec: :param jobName: :return: jobscript as string \"\"\" content = '' for line in self.header.split('\\n'): if ' -N ' in line: logger.info('Job name found in HEADER will be overwritten') elif ' -o ' in line: logger.info('Output file name found in HEADER will be overwritten') elif ' -e ' in line: logger.info('Error file name found in HEADER will be overwritten') else: content += line + '\\n' content += f'#PBS -N {JOB_NAME}\\n' content += f'#PBS -o {outputFile}\\n' content += f'#PBS -e {errorFile}\\n' content += f'cd $PBS_O_WORKDIR\\n' content += f'\\n{COMMAND_EXEC}\\n' return ''.join(content) async def submit(self, command: str, jobname: str, input: str, output: str, error: str, calcFolder : str) -> int: content = self._prepareSubmission(command, jobname, input, output, error) with open(pj(calcFolder, self._RUNSCRIPT), 'wt') as f: f.write(content) await self.connector.sync_l2r(pj(calcFolder, self._RUNSCRIPT)) returncode, out, err = await self.connector.execute(f'qsub {self._RUNSCRIPT}', cwd=calcFolder) logger.debug(f'process returned code {returncode}') if returncode != 0: logger.error(err) logger.error(out) jobID = self._parseJobID(out, err) logger.info(f\"Job ID is {jobID}\") return jobID def _parseJobID(self, output : str, error : str) -> int: \"\"\" :param output: :param error: :return: jobID \"\"\" if '.mgmt' in output: tmp = output.index('.mgmt') return int(output[:tmp]) elif 'job' in output: tmp = output.index('job') + 4 return int(output[tmp:]) elif 'comput100' in output: tmp = output.index('comput100')-1 return int(output[:tmp]) else: return int(output) async def isReady(self, jobID): returncode, out, err = await self.connector.execute(f'qstat {jobID}') return not (' R ' in out or ' Q ' in out) async def isExist(self, jobID): returncode, out, err = await self.connector.execute(f'qstat {jobID}') return len(out) > 0 async def kill(self, jobID): returncode, out, err = await self.connector.execute(f'qdel {jobID}') #logger.info(f'Process with jobID={jobID} killed.') 三、流程（以 Si 为例） 1. 准备 USPEX 的输入文件 input.uspex { optimizer: { type: GlobalOptimizer target: { type: Atomistic conditions: {externalPressure: 0.00001} compositionSpace: {symbols: [Si] blocks: [[4]]} } optType: enthalpy selection: { type: USPEXClassic popSize: 4 initialPopSize: 4 bestFrac: 0.6 optType: (aging enthalpy) fractions: { heredity: (0.4 0.7 0.5) softmodemutation: (0.2 0.5 0.3) randSym: (0.05 0.5 0.1) randTop: (0.05 0.5 0.1) } } } stages: [abacus1 abacus2 abacus3 abacus4 abacus5] numParallelCalcs: 4 numGenerations: 25 stopCrit: 10 } #define abacus1 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.20, taskManager: TM} #define abacus2 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.16, taskManager: TM} #define abacus3 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.12, taskManager: TM} #define abacus4 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.08, taskManager: TM} #define abacus5 {type : abacus, commandExecutable : 'OMP_NUM_THREADS=1 mpirun -machinefile $PBS_NODEFILE -env I_MPI_HYDRA_DEBUG 3 -genv I_MPI_FABRICS shm:ofi abacus', kresol: 0.05, taskManager: TM} #define TM { type : QSUB, header:\"#PBS -S /bin/bash #PBS -N single #PBS -l nodes=1:ppn=16 #PBS -j oe #PBS -V\" } 注意：ABACUS在任务提交时，应注意指定OMP_NUM_THREADS，防止内存不足引起计算错误 2. 准备 Specific 文件夹 所需文件：INPUT_X（使用ABACUS弛豫）、ATOMIC_SPECIES、NUMERICAL_ORBITAL以及轨道和赝势文件。 INPUT 文件内容和个数由用户自行设置（需要与 input.uspex 中 stages 对应），具体可参考 uspex 官方文档。 需要注意的是：INPUT 的 suffix 需指定为 USPEX； 需给出 ATOMIC_SPECIES 和 NUMERICAL_ORBITAL 两个文件指定所使用的 upf 文件和 orb 文件。 ATOMIC_SPECIES 内容：元素符号 质量 赝势文件名 NUMERICAL_ORBITAL 内容：元素符号 轨道文件名 3. 根据计算实际需求添加 Seeds 结构（可选，非必须） 4. 提交运算 nohup ./uspex-sub.sh >> log & ### content of uspex-sub.sh #!/bin/sh while true;do data >> log uspex -r >> log sleep 300 ### Users can adjust this value to manipulate the frequency of the call to uspex. done 5. 计算结果 如果程序可以正常提交任务，log文件中会打印如下内容： 2023-08-09 16:52:47,115 - USPEX.Optimizers.Target - INFO - Following utilities was not initialized: ['PowderSpectrumAnalyzer', 'SingleCrystalSpectrumAnalyzer']. 2023-08-09 16:52:47,115 - USPEX.Optimizers.Target - INFO - Permutation does not work when number of symbols in calculation is 1. 2023-08-09 16:52:47,123 - USPEX.Stages.GenerationController - INFO - Calculation initialized from input parameters. 2023-08-09 16:52:47,441 - USPEX.Selection.USPEXClassic - INFO - System 0 successfully created by RandSym operator. 2023-08-09 16:52:47,866 - USPEX.Selection.USPEXClassic - INFO - System 1 successfully created by RandSym operator. 2023-08-09 16:52:48,638 - USPEX.Selection.USPEXClassic - INFO - System 2 successfully created by RandSym operator. 2023-08-09 16:52:48,767 - USPEX.Selection.USPEXClassic - INFO - System 3 successfully created by RandSym operator. 2023-08-09 16:52:48,788 - USPEX.Stages.Executor - INFO - System 0 with tag 1 will be submitted now. 2023-08-09 16:52:48,788 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,792 - USPEX.Stages.Executor - INFO - System 1 with tag 1 will be submitted now. 2023-08-09 16:52:48,792 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,796 - USPEX.Stages.Executor - INFO - System 2 with tag 1 will be submitted now. 2023-08-09 16:52:48,797 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,801 - USPEX.Stages.Executor - INFO - System 3 with tag 1 will be submitted now. 2023-08-09 16:52:48,801 - USPEX.Stages.TaskManagers.QSUB - INFO - Job name found in HEADER will be overwritten 2023-08-09 16:52:48,812 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37768 2023-08-09 16:52:48,818 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37769 2023-08-09 16:52:48,822 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37770 2023-08-09 16:52:48,825 - USPEX.Stages.TaskManagers.QSUB - INFO - Job ID is 37771 如果程序可以正常输出结果，在 results1/Individuals 中会打印相关的信息，示例如下： +----+------------------+-------------+---------------+--------------+---------------+-----------------+---------------+--------------+ | ID | Origin | Composition | Enthalpy (eV) | Volume (A^3) | SYMMETRY (N) | Structure order | Average order | Quasientropy | +----+------------------+-------------+---------------+--------------+---------------+-----------------+---------------+--------------+ | 0 | RandSym | Si: 4 | -425.452 | 59.320 | P6/mmm (191) | 0.334 | 0.334 | -0.000 | | 2 | RandSym | Si: 4 | -418.078 | 59.320 | I4/mmm (139) | 0.287 | 0.287 | -0.000 | | 3 | RandSym | Si: 4 | -425.038 | 59.320 | P4_332 (212) | 0.392 | 0.392 | -0.000 | | 4 | Softmodemutation | Si: 4 | -428.592 | 59.320 | I4/mmm (139) | 0.325 | 0.325 | 0.000 | | 5 | Softmodemutation | Si: 4 | -428.592 | 59.320 | I4/mmm (139) | 0.325 | 0.325 | 0.000 | | 6 | Heredity | Si: 4 | -427.892 | 59.320 | P2_1/m (11) | 0.202 | 0.215 | 0.077 | | 8 | Softmodemutation | Si: 4 | -427.882 | 59.320 | P2_1/m (11) | 0.201 | 0.215 | 0.076 | | 9 | Softmodemutation | Si: 4 | -427.887 | 59.320 | P2_1/m (11) | 0.202 | 0.215 | 0.075 | | 10 | Heredity | Si: 4 | -428.645 | 59.320 | Cmce (64) | 0.261 | 0.261 | 0.000 | | 11 | Softmodemutation | Si: 4 | -428.644 | 59.320 | Cmce (64) | 0.261 | 0.261 | 0.000 | | 12 | Softmodemutation | Si: 4 | -428.645 | 59.320 | Cmce (64) | 0.261 | 0.261 | 0.001 | | 14 | Heredity | Si: 4 | -428.628 | 59.320 | Cmce (64) | 0.263 | 0.263 | 0.000 | | 15 | Heredity | Si: 4 | -428.928 | 59.320 | Cmcm (63) | 0.291 | 0.291 | 0.000 | | 16 | Heredity | Si: 4 | -428.949 | 59.320 | P2_1/m (11) | 0.283 | 0.284 | 0.006 | | 17 | RandSym | Si: 4 | -422.987 | 59.320 | C2/m (12) | 0.250 | 0.250 | 0.000 | | 19 | Softmodemutation | Si: 4 | -428.927 | 59.320 | Cmcm (63) | 0.291 | 0.291 | 0.000 | | 20 | Softmodemutation | Si: 4 | -428.928 | 59.320 | Cmcm (63) | 0.290 | 0.290 | 0.000 | | 21 | Heredity | Si: 4 | -428.926 | 59.320 | Cmcm (63) | 0.290 | 0.290 | 0.000 | 四、结语 建议大家在使用前，首先选择小体系进行测试；此外大家也可根据自己的实际需要对接口文件进行修改扩充，有相关问题可通过邮件方式沟通。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-namd.html":{"url":"abacus-namd.html","title":"ABACUS+Hefei NAMD 使用教程","keywords":"","body":"ABACUS+Hefei NAMD 使用教程 作者：李源波，邮箱：liyuanbo9812@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/01 一、介绍 激发态动力学一直是凝聚态物理中的重要问题，在激发状态下，凝聚态体系中的准粒子会发生复杂的相互作用，涉及到不同时间尺度的超快过程，因此，研究凝聚态体系的激发态动力学不仅需要从时间、空间、能量和动量等多个维度对其进行描述，还需要描述不同准粒子之间的动态耦合，而目前商用的第一性原理软件无法满足这样的需求。针对这一问题，中国科学技术大学赵瑾教授团队发展了自主可控的激发态动力学软件 Hefei-NAMD（https://hefei-namd.org/code/），基于面跳跃算法（Surface Hopping）与经典路径近似，初步实现激发态动力学在时间、空间、动量、能量、自旋等多个维度上的描述，并可以研究激发态电子、空穴、激子、声子、极化子等准粒子的动态相互作用。Hefei-NAMD 程序采用模块化架构，包含单粒子动力学、自旋动力学、动量空间动力学以及 GW+rtBSE 模块。目前程序使用周期性边界条件，可处理上百个原子，且与密度泛函软件 VASP、Quantum Espresso 等存在接口，Hefei-NAMD 和 ABACUS v3.2 建立的接口（主要针对局域轨道算法，涉及波函数与局域轨道下的交叠矩阵等信息，用来计算非绝热耦合项和电子跃迁概率）和提供的相关案例，可以进一步拓宽 Hefei-NAMD 的使用范围。 本教程旨在介绍采用 ABACUS（基于 ABACUS 3.2.0 版本）做分子动力学计算，将结果作为 Hefei NAMD 软件的输入文件进行后续非绝热分子动力学计算的流程。 这里推荐大家阅读 Hefei NAMD 软件的相关文档和说明： http://staff.ustc.edu.cn/~zqj/posts/Hefei-NAMD-Training/ https://github.com/QijingZheng/Hefei-NAMD https://github.com/vtzf/abacus-namd（这个是拥有与 ABACUS 接口的 Hefei NAMD 仓库，功能与上面的仓库是一样的），第一步请先下载这个链接上面的 python 代码。 二、计算流程 我们这里提供的测试案例是包含 2 个原子的金刚石结构 Si 结构，采用的模守恒赝势是 Si_ONCV_PBE-1.0.upf，以及原子轨道文件采用的是 Si_gga_8au_60Ry_2s2p1d.orb（GGA 泛函，8 au 截断半径，60 Ry 能量截断，以及包含 2s2p1d 的 DZP 轨道）。 1. 用 ABACUS 进行分子动力学(MD)计算 1.1 输入文件 INPUT 大部分参数为做分子动力学计算所需要参数，具体含义可以参考 ABACUS 的分子动力学教程。为了后续用 Hefei NAMD 进行非绝热分子动力学计算，ABACUS 会输出每一步分子动力学模拟的哈密顿量矩阵 H、交叠矩阵 S、波函数文件。因此需将相关的 ABACUS 的 INPUT 文件中的输入参数 out_wfc_lcao 和 out_mat_hs 都设置为 1，表示输出这些物理量。计算完成后，在 OUT.*** 文件夹中，每一个分子步都对应一个文件夹 MD_n，在每个文件夹中会有 data-0-H、data-0-S、LOWF_GAMMA_S1.dat 三个文件储存我们需要输出的物理量。 INPUT_PARAMETERS #Parameters (General) suffix autotest pseudo_dir ../../tests/PP_ORB orbital_dir ../../tests/PP_ORB nbands 8 calculation md #Parameters (Accuracy) ecutwfc 50 scf_nmax 20 basis_type lcao md_nstep 10 cal_stress 1 stress_thr 1e-6 cal_force 1 force_thr_ev 1.0e-3 ks_solver genelpa mixing_type pulay mixing_beta 0.7 md_type nve md_restart 0 md_tfirst 10 init_vel 1 read_file_dir ./ gamma_only 1 out_wfc_lcao 1 out_mat_hs 1 1.2 结构文件 STRU ATOMIC_SPECIES Si 1 Si_ONCV_PBE-1.0.upf NUMERICAL_ORBITAL Si_gga_8au_60Ry_2s2p1d.orb LATTICE_CONSTANT 10.2 LATTICE_VECTORS 0.5 0.5 0 #latvec1 0.5 0 0.5 #latvec2 0 0.5 0.5 #latvec3 ATOMIC_POSITIONS Cartesian Si #label 0 #magnetism 2 #number of atoms 0 0 0 m 1 1 1 v 1.75205850628e-05 0.000155425594558 -3.99334763874e-05 0.241 0.255 0.250999999999 m 1 1 1 v -1.75205850628e-05 -0.000155425594558 3.99334763874e-05 2. 用 Hefei NAMD 进行非绝热分子动力学（NAMD）计算 Hefei NAMD 代码为 python 代码，在 src 目录下，建议使用 python 3.9。需要的 python 库有 Numpy，Scipy，Numba，MPI4py（>= 3.1.3）。 2.1 设置 NAMD 计算参数 在 Args.py 中设置 NAMD 的各种参数，在 Args.py 的注释中有关于各种参数具体含义的详细介绍。 # NAMD parameter # manual input start dftdir = '/public/share/zhaojin/tuyy/abacus/sh/OUT.autotest1/' namddir = '../namd_test/' # output NAMD output file in namddir dt = 1 # MD time step (fs) start_t = 1 # start MD step end_t = 2000 # end MD step istart_t = 901 # isample start MD step iend_t = 1000 # isample end MD step LCHARGE = True # output atom projected charge density atom = [13,26]# atom number of all species (only needed in atomic basis) orbital = [27,13]# atomic orbital basis number (only needed in atomic basis) whichA = [0,13,14,15] # atom index for projected charge density (starts from 0) LRANGE = True # select range of band, change iband # if not given, LRECOMB specifies energy range # if LRECOMB not given, energy range: [0,nbands] LHOLE = True # Hole/electron transfer dE = 2.0 # initial energy from VBM/CBM (eV) LPHASE = True # phase correction TEMP = 300 # temperature in Kelvin NACTIME = 1000 # time for used NAC (i_end_t-state_t+NACTIME 2.2 读取 ABACUS 的输出文件 运行 NAC.py 即可将 ABACUS 的输出文件转成 Hefei NAMD 需要的 NATXT 和 EIGTXT 文件。 在超算上计算的话，可以直接使用用 sub_scripts 目录下的 sub_nac 脚本提交任务，用户可在 sub_nac 中自行修改节点数等信息。 sbatch sub_nac 2.3 进行非绝热分子动力学计算 运行 SurfHop.py 即可进行 NAMD 的计算。 在超算上计算的话，可以直接使用用 sub_scripts 目录下的 sub_sh 脚本提交任务，用户可在 sub_sh 中自行修改节点数等信息。 sbatch sub_sh 输出文件中，SUPROP 文件中包含了电子驰豫能量和电子占据数随时间的演化，PSICT 文件则包含波函数系数随时间的演化。可用 https://github.com/QijingZheng/Hefei-NAMD/tree/master/scripts 中的脚本进行画图。 三、结语 本篇主要介绍了如何利用 ABACUS 和 Hefei NAMD 进行非绝热分子动力学的计算，简单来说就是通过 ABACUS 跑分子动力学得到每一步的波函数和哈密顿量等信息，Hefei NAMD 再读入这些信息进行非绝热分子动力学的计算。关于非绝热分子动力学的详细介绍则可以查看 Hefei NAMD 的相关网站（见最上面的网站），如有问题欢迎联系。 四、参考文献 Zheng, Q.; Chu, W.; Zhao, C.; Zhang, L.; Guo, H.; Wang, Y.; Jiang, X.; Zhao, J. Ab initio nonadiabatic molecular dynamics investigations on the excited carriers in condensed matter systems. Wiley Interdiscip. Rev. Comput. Mol. Sci. 2019, 9, e1411. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-surface1.html":{"url":"abacus-surface1.html","title":"采用 ABACUS 进行表面计算（一）：静电势和功函数","keywords":"","body":"采用 ABACUS 进行表面计算（一）：静电势和功函数 作者：孙亮，邮箱：l.sun@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/01 一、背景 静电势（electrostatic potential），也叫电势，是指将单位电荷从参考点移动到场内某一点所做的功。 在密度泛函理论的框架下，静电势V_{static}定义为 V_{static} = V_{H}+V_{ext}+V_{efield}+V_{dipole}+... 其中V_{H} = \\int{\\frac{\\rho(r')}{|r-r'|}dr'}为电子产生的静电势，V_{ext}为离子势（赝势的局域部分），V_{field}为外加电场项，V_{dipole}为偶极修正项，输出静电势和输出局域势的差别在于有没有输出交换关联势。 在处理表面等体系时，静电势可用于计算功函数等物理量，并进一步用于催化活性、化学反应机理以及电子输运性质等性质的计算与分析。 ABACUS 提供了直接输出静电势的接口，并提供了对其进行后处理的 python 脚本。 二、ABACUS 中计算静电势具体流程 此功能在平面波基组、原子轨道基组下的 Kohn-Sham DFT（KSDFT），以及随机波函数密度泛函理论和无轨道密度泛函理论中均适用。接下来，我们以平面波基组下的 KSDFT 为例介绍其使用方法，如果需要使用其它的能量求解器，只需要设置 INPUT 文件里的 esolver_type、basis_type 更换能量求解器并设置相应求解器的参数即可。 1. 计算实例 1.1 输出静电势 下面是输入文件的示例： INPUT 文件记录计算所需主要参数，为了输出静电势，只需要设置 out_pot 2 即可（设置 out_pot 1 时，会输出总的局域势，2 相比于 1 少输出了交换关联势，具体可以参考线上文档 https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#out-pot）。 INPUT_PARAMETERS #Parameters (1.General) suffix example calculation scf ntype 1 nbands 40 symmetry 1 pseudo_dir . #Parameters (2.Iteration) ecutwfc 60 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.0074 #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.7 out_pot 2 STRU 文件记录元素种类、质量、赝势，晶格矢量，原子坐标等信息 ATOMIC_SPECIES Al 13 Al_ONCV_PBE-1.0.upf LATTICE_CONSTANT 7.6513590200098225 // add lattice constant LATTICE_VECTORS 0.707106781187 0.000000000000 0.000000000000 0.000000000000 0.707106781187 0.000000000000 0.000000000000 0.000000000000 5.000000000000 ATOMIC_POSITIONS Direct Al 0.0 5 0.000000000000 0.000000000000 0.000000000000 1 1 1 0.500000000000 0.500000000000 0.100000000000 1 1 1 0.000000000000 0.000000000000 0.200000000000 1 1 1 0.500000000000 0.500000000000 0.300000000000 1 1 1 0.000000000000 0.000000000000 0.400000000000 1 1 1 KPT 文件 K_POINTS 0 Gamma 20 20 1 0 0 0 如上所示，为了输出静电势，只需要在 INPUT 中设置 out_pot`` ``2，计算完成后即可在 OUTOUT.${suffix} 文件夹下找到下面的 ElecStaticPot.cube 文件。 ElecStaticPot.cube 文件（记录了实空间格点上的静电势，单位是 A.U.，下面的文档中，我们在括号中加入了注释。此文件可以直接在 VESTA 中可视化） Cubefile created from ABACUS SCF calculation. The inner loop is z index, followed by y index, x index in turn. 1 (nspin) 5（总原子数） 0.0 0.0 0.0（原点坐标） 27（沿x轴格点数nx） 0.200383 0.000000 0.000000（晶格矢量a1的1/nx，in Bohr。即晶格常数a*a1/nx） 27（沿y轴格点数ny） 0.000000 0.200383 0.000000（晶格矢量a2的1/ny，in Bohr） 192（沿z轴格点数nz） 0.000000 0.000000 0.199254（晶格矢量a3的1/nz，in Bohr） 13（第一个原子的原子序数） 11（赝势中的价电子数） 0.000000 0.000000 0.000000（该原子位置的笛卡尔坐标，in Bohr） 13 11 2.705164 2.705164 3.825680 13 11 0.000000 0.000000 7.651359 13 11 2.705164 2.705164 11.477039 13 11 0.000000 0.000000 15.302718 （空间格点上的数据，z坐标变化最快，接下来依次是y, x，一般为6个数据一行，每走完z的一次循环换一行） -1.808618025e+01 -1.683249579e+01 -1.326226499e+01 -8.726520963e+00 -4.859516723e+00 -2.648153424e+00 -1.754646057e+00 -1.082969997e+00 -7.712730497e-01 -5.301070017e-01 -1.865686936e-01 1.178808012e-03 1.531960521e-01 2.434659807e-01 3.236379649e-01 3.580121711e-01 3.871087692e-01 4.067752520e-01 4.191236489e-01 4.303464392e-01 4.269139054e-01 4.072584618e-01 4.012863417e-01 3.694437712e-01 3.419696568e-01 2.751686292e-01 1.986707660e-01 7.265002162e-02 -9.800789596e-02 -3.699329212e-01 ... 5.605648983e-01 5.596641131e-01 5.601221783e-01 5.558024312e-01 5.582286739e-01 5.509517334e-01 5.484144631e-01 5.474458329e-01 5.413456797e-01 5.310960172e-01 5.220139261e-01 5.057932112e-01 4.893954664e-01 4.661977108e-01 4.379332539e-01 3.906110446e-01 3.390039472e-01 2.575599458e-01 1.632711220e-01 1.092880266e-02 -1.657977733e-01 -5.027618535e-01 -7.758727829e-01 -1.023213291e+00 -1.643162715e+00 -2.406825325e+00 -4.139043775e+00 -7.343485448e+00 -1.119104878e+01 -1.435478802e+01 1.2 后处理 为了方便计算沿着 z 方向的平均静电势，我们在 tools/average_pot 下提供了 python 后处理脚本 aveElecStatPot.py，在存放 ElecStaticPot.cube 的文件夹下运行 python path_to_abacus/tools/average_pot 即可在此文件夹中得到存放了平均静电势的 ElecStaticPot_AVE 文件，如下所示。 ElecStaticPot_AVE 文件（存放了沿 z 方向的平均静电势，单位是 A.U.。此文件的前 11 行与 ElecStaticPot.cube 相同，之后的第一列数为沿着 z 轴的格点指标，第二列数为平均静电势） Average electrostatic potential along z axis 1 (nspin) 5 0.0 0.0 0.0 27 0.200383 0.000000 0.000000 27 0.000000 0.200383 0.000000 192 0.000000 0.000000 0.199254 13 11 0.000000 0.000000 0.000000 13 11 2.705164 2.705164 3.825680 13 11 0.000000 0.000000 7.651359 13 11 2.705164 2.705164 11.477039 13 11 0.000000 0.000000 15.302718 iz average 0 -1.021155030e+00 1 -9.476023401e-01 2 -7.542571394e-01 3 -5.200099451e-01 ... 189 -5.039597208e-01 190 -7.447469356e-01 191 -9.431350596e-01 可视化后如图所示： 1.3 功函数 功函数（work function），又称逸出功，描述把电子从固体内部移到真空中所需的最小能量。 在 DFT 计算中，它可以定义为V_{vaccum} - E_F，其中V_{vaccum}为真空静电势，可以在 ElecStaticPot_AVE 中读到，E_F为体系费米能，可以用 grep EFERMI OUT.${suffix}/running_scf.log 命令从 OUT.${suffix}/running_scf.log 文件中提取出来。 对于上面的例子，V_{vaccum} = 0.563\\ \\rm{Ry}，E_F=3.3293551883\\ \\rm{eV}\\approx0.245\\ \\rm{Ry}，因此功函数为V_{vaccum} - E_F = 0.318\\ \\rm{Ry}。 如果大家使用有问题，欢迎写信联系（见上）。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-surface2.html":{"url":"abacus-surface2.html","title":"采用 ABACUS 进行表面计算（二）：偶极修正","keywords":"","body":"采用 ABACUS 进行表面计算（二）：偶极修正 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/08/28 一、偶极修正介绍（Dipole Correction） 偶极矩（Dipole Moment）是一个矢量，由正、负电荷中心距离和其所带电量乘积得到，方向规定为正电中心指向负电中心，采用原子建模表面时，往往表面会产生偶极矩。 ABACUS 在 xyz 三个方向都采用周期性边界条件（Periodic Boundary Conditions），当使用密度泛函理论（Density Functional Theory，简称 DFT）进行表面体系的电子结构计算时常采用超胞（Supercell）近似，这时所研究的体系在真空方向会出现两个表面。当两个表面不对称时（例如在某表面进行吸附原子计算），这两个表面的电荷密度分布就会不同，这个时候两个表面的偶极密度不同且表面附近的静电势（Electrostatic Potential）会呈现不同的值。然而，周期性边界条件的存在会强制使得静电势也要满足周期性边界条件，这个时候周期性边界条件的存在相当于制造了一个非物理的人造电场（Artificial Electric Field）。 通常情况下，降低这个人造电场的方法是加大真空层的厚度，使得相邻的超胞之间没有相互作用，但这往往要大幅增加密度泛函理论的计算量。因此，为了消除周期性边界条件对表面偶极矩带来的影响，我们可以采用偶极修正（Dipole Correction）的方法，通过引入另外一个外电场来抵消这个人造电场，但注意引入的外电场需要存在于真空中（其位置是程序输入参数的一部分）才不至于影响所要研究的表面体系。经过修正后，人造电场将被抵消，真空电势则维持不变。 ABACUS 中实现了偶极修正功能[1]，可以有效的加速静电势收敛，避免超胞的真空取得太长，从而可以降低计算量。该修正功能主要体现在 Hartree 项的处理上，并且存在相应的原子受力的修正，可以用于平面波（Plane-Wave）基组和数值原子轨道（Numerical Atomic Orbitals）基组计算，但注意该功能只能用于带真空层的表面体系。 二、文档与算例 ABACUS 里关于偶极修正的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/scf/advanced.html#dipole-correction ABACUS 里关于偶极修正参数的线上文档地址为：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#electric-field-and-dipole-correction ABACUS 的偶极修正算例下载地址为（gitee）： https://gitee.com/MCresearch/abacus-user-guide/tree/master/examples/dipole_correction/H2O 可以采用的下载命令是： git clone https://gitee.com/MCresearch/abacus-user-guide 之后进入 /abacus-user-guide/examples/``dipole_correction/H2O/ 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/dipole_correction/H2O 三、偶极修正输入参数介绍 INPUT_PARAMETERS #Parameters (1.General) suffix H2O calculation scf nbands 6 symmetry 0 pseudo_dir ../../PP_ORB #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method fixed #Parameters (5.Mixing) mixing_type pulay mixing_beta 0.7 #Parameters (6.Dipole correction) efield_flag 1 dip_cor_flag 1 efield_pos_max 0.0 efield_pos_dec 0.1 efield_amp 0.00 #Parameters (7.Output) out_pot 2 以算例提供的 INPUT 文件为例，使用偶极修正方法只需添加如下参数即可： efield_flag：类型是 Bool，指定外加电场的开(1)或者关(0)，默认值为 0，注意应用偶极修正功能时，efield_flag 必须设为 true dip_cor_flag：类型是 Bool，指定偶极修正的开(1)或者关(0)，默认值为 0 efield_dir：类型是 Int，外加电场方向，可取 0，1，2 分别表示 x，y，z 方向，默认值为 2 efield_pos_max：类型是 Real，锯齿状电势最大值所在分数坐标，范围[0,1)，默认值为 0.5 efield_pos_dec：类型是 Real，锯齿状电势从最大值到最小值的长度（同样以分数坐标为度量），默认值为 0.1，范围[0,1)。以图1为例，0.5 是最大值，0.6 是最小值，那么 0.5 ~ 0.6 的区域必须放置在没有原子的真空层中 图 1. 锯齿状势场分布图 efield_amp：类型是 Real，电场强度，默认值为 0，单位为 a.u.，其中 1 a.u. = 51.4220632*10^10 V/m。在偶极修正时需要设为 0，不为 0 则说明同时添加了外加电场和偶极修正 四、预期结果 如图2所示，一个水分子位于超胞（尺寸为 3\\times3\\times18 Å^3）的中部（即位于9 Å），那么按照上一部分的说明，锯齿应该放在没有原子的真空处，因此我们将电势的最大值所在的位置设为 efield_pos_max 设为 0.0，之后设置电势从最大值到最小值的长度，即将 efield_pos_dec 设为 0.1（在这个例子是 1.8 Å），如此锯齿即位于 0.0~0.1 的区域。 为了验证结果的正确性，我们可以画出静电势沿 Z 轴（c 方向）的变化如图3所示。在水分子上方（9-18 Å）和下方（0-9 Å）的真空层中，静电势在很长一段区间保持常数不变，出现了两个平台，这说明我们的偶极修正功能使用无误。静电势计算和作图方法请参考静电势和功函数计算文档。 图 2. 一个水分子位于超胞中，红色代表氧原子，白色代表氢原子 图 3. 静电势沿超胞Z轴变化图 五、参考文献 [1] Phys. Rev. B 59, 12301 (1999), https://doi.org/10.1103/PhysRevB.59.12301 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-surface3.html":{"url":"abacus-surface3.html","title":"采用 ABACUS 进行表面计算（三）：表面能计算","keywords":"","body":"采用 ABACUS 进行表面计算（三）：表面能计算 作者：孙亮，邮箱：l.sun@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/12 一、背景 将某一固体沿着某一晶面方向切开会形成相应的表面，许多化学反应都是依托在一些特定的表面系统上展开的。因此，计算表面能也是第一性原理计算经常会遇见的。 表面能（surface energy）定义为单位面积内表面体系与相应的体材料（bulk systems）能量之差，或者建立某特定表面需要做的功。不同表面的原子排布会对应不同大小的表面能，从能量的观点来看，表面能越低的表面体系越稳定，在现实世界里就越有可能稳定存在。 另外，需要注意的是，当沿着固体的某一晶面切开形成表面时，这个表面不一定是稳定结构。由于表面原子所经历的周围环境相比于体材料有所变化，所以往往表面原子会重新排布，只是排布的幅度有大有小。所以，一般来说，需要对表面进行结构优化计算，达到能量最低的稳定态。有一些常见的表面重构，已经被实验所证实，例如硅的表面重构。 密度泛函理论（Density Functional Theory，简称 DFT）也常用来计算材料体系的表面能，但如果使用的是周期性边界条件，往往构造的原子体系会有两个表面，以及一段真空。注意真空的长度一般不能太小（一般大于 10 埃），要长到能量达到收敛。另外，如果表面是有极化的，可以采用 dipole correction 功能进行修正，这样真空往往可以取短一些。另外一方面，构成表面体系的原子层数一般来讲不少于 3-5 层，有时候需要检验更多层以达到收敛，达到收敛时体系最靠近中间的层一般和体材料的原子性质较为接近，这个可以作为表面厚度是否足够的判据之一，另外一个判据就是随着层数的增加，所得到的表面能的值是否已经收敛。 用 DFT 计算材料体系的表面能时，需要进行两次自洽迭代（self-consistent field，简称 scf）计算，一次用于计算体材料体系中每原子的能量E_{0}，一次用于计算表面体系的总能量E_{slab}，最终表面能\\sigma定义为 \\sigma = \\frac{E_{\\rm{slab}} - NE_{0}}{2A} 其中N为表面体系包含的原子数，A为表面面积，分母上的 2 来自于如果计算中采用了周期性边界条件，即表面体系实际有上下两个表面。计算表面能时，需要计算E_{0}和E_{\\rm{slab}}两个能量。ABACUS 软件中，我们可以采用平面波基组、原子轨道基组下的 Kohn-Sham DFT（KSDFT），以及随机波函数密度泛函理论和无轨道密度泛函理论来计算它们。 二、ABACUS 计算表面能具体流程 接下来，我们以平面波基组下的 KSDFT 为例介绍其计算方法，如果需要使用其它的能量求解器，只需要设置 INPUT 文件里的 esolver_type、basis_type 更换能量求解器并设置相应求解器的参数即可。 以下是几个构造表面结构的注意点： 由于 ABACUS 在实空间的并行策略是将格点沿 z 轴分层，关于并行我们有两个建议：第一，为了使得 MPI 并行时负载平衡，建议沿 x 方向设置真空，即让表面的法线沿着 x 轴，避免有些核分不到原子，影响计算效率；第二，如果并行的核数较多，建议沿 z 方向设置真空，即让表面的法线沿着 z 轴，因为每个核至少要分到一些 z 方向的格点，选取长边会使得可以并行的核数更多。 真空层厚度一般设置在 10 埃以上，具体需要调整真空层厚度做收敛性测试； 表面结构（slab）需要用内部的原子模拟体材料，因此其厚度也要做收敛性测试。 1. 铝面心立方晶体(100)表面能计算 算例链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_energy/Al_fcc100 1.1 计算体材料能量 这一步用晶格弛豫方法找到面心立方晶体 fcc Al 的平衡构型以及平衡能量。 链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_energy/Al_fcc100/0_bulk 运行完算例后，用 grep FINAL_ETOT_IS OUT.example/running_cell-relax.log 得到总能量为 -1883.225 eV，由于原胞内只有一个原子，因此E_{0}=-1883.225\\ \\rm{eV}。 从 OUT.example/STRU_ION_D 文件中可以读到平衡晶格常数为a_0=7.586\\ \\rm{Bohr}，它将用于表面构型的构造。 注意，如果是带有磁性的原子，计算体材料的时候也要加上磁性的计算，例如在 INPUT 文件里设置 nspin=2。 1.2 计算表面体系能量 这一步我们搭建表面体系并计算其总能量。 链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_energy/Al_fcc100/1_surface_5layers https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_energy/Al_fcc100/2_surface_7layers 实际计算时，需要对表面构型的原子层数做收敛性测试，作为例子，我们提供了 5 层和 7 层的算例，其构型如下所示： 计算总能量时，可以根据实际需要选择是否做结构优化，这里为了结果更准确，同时兼顾效率，我们固定了内部原子，对表面上的原子结构进行了优化。 对于 5 层构型，用 grep FINAL_ETOT_IS OUT.example/running_relax.log 得到总能量为 -9415.005 eV，因此E_{\\rm{slab}}=-9415.005\\ \\rm{eV}。 对于 7 层构型，总能量E_{slab}=-13181.372\\ \\rm{eV}。 1.3 计算表面能 对于上述构型，表面面积A=(a_0 / \\sqrt{2})^2 = 8.057\\ \\rm{Å}^2。 对于 5 层构型，表面构型原子数N=5，因此表面能\\sigma = \\frac{E_{\\rm{slab}} - NE_{0}}{2A} = 0.070\\ \\rm{eV/Å^2} = 1113\\ \\rm{mJ/m}^2。 对于 7 层构型，表面构型原子数N=7，因此表面能\\sigma = \\frac{E_{\\rm{slab}} - NE_{0}}{2A} = 0.075\\ \\rm{eV/Å^2} = 1196\\ \\rm{mJ/m}^2。 可以看到 7 层的构型相比于 5 层算出的表面能还差别较大，所以需要增加层数一直到表面能收敛。 2. 硅金刚石结构(100)表面能计算 这里金刚石结构我们又名为 CD（Cubid Diamond）结构 算例链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_energy/Si_CD100 2.1 计算体材料能量 这一步我们用晶格弛豫方法找到 CD Si 的平衡构型以及平衡能量。 链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_energy/Si_CD100/0_bulk 运行完算例后，用命令 grep FINAL_ETOT_IS OUT.example/running_cell-relax.log 得到体系总能量为 -214.516 eV，由于原胞内有两个原子，因此E_{0}=-107.258\\ \\rm{eV}。 从 OUT.example/STRU_ION_D 文件中可以读到平衡晶格常数为a_0=10.351\\ \\rm{Bohr}，它将用于表面构型的构造。 2.2 计算表面体系能量 这一步我们搭建表面体系并计算其总能量。 链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_energy/Si_CD100/1_surface 我们搭建了一个 9 层的表面构型，如下图所示： 计算总能量时，可以根据实际需要选择是否做结构优化，这个例子里，为了计算省时，我们没有做结构优化。 用 grep FINAL_ETOT_IS OUT.example/running_scf.log 得到总能量为 -961.337 eV，因此E_{\\rm{slab}}=-961.337\\ \\rm{eV}。 2.3 计算表面能 对于上述构型，表面面积A=(a_0 / \\sqrt{2})^2 = 15.015\\ \\rm{Å}^2，表面构型原子数N=9，因此表面能\\sigma = \\frac{E_{\\rm{slab}} - NE_{0}}{2A} = 0.133\\ \\rm{eV/Å^2} = 2126\\ \\rm{mJ/m}^2。 与实验值 2131\\ \\rm{mJ/m}^2[1]非常接近，但略大于另一个实验值1361\\ \\rm{mJ/m}^2[2]。 注：以上为表面能计算示例，若有问题欢迎邮件联系（见上）。 三、参考文献 [1] Eaglesham D J, White A E, Feldman L C, et al. Equilibrium shape of Si[J]. Physical Review Letters, 1993, 70(11): 1643. [2] Messmer C, Bilello J C. The surface energy of Si, GaAs, and GaP[J]. Journal of Applied Physics, 1981, 52(7): 4623-4629. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-surface4.html":{"url":"abacus-surface4.html","title":"采用 ABACUS 进行表面计算（四）：表面缺陷能和吸附能计算","keywords":"","body":"采用 ABACUS 进行表面计算（四）：表面缺陷能和吸附能计算 作者：孙亮，邮箱：l.sun@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/09 一、背景 在研究表面的稳定性时，我们经常关注表面上形成空穴、或者表面上吸附其它分子的难易程度，这两种现象可以分别用表面缺陷能和表面吸附能描述。 表面缺陷能（surface vacancy energy）定义为在表面上形成原子的空穴所需能量，缺陷能越低，则该表面越容易形成缺陷。 表面吸附能（surface adsorption energy）定义为原子、离子或分子（吸附物，adsorbate）附着在固体表面（吸附剂，adsorbent）的吸附过程中，二者结合时的能量下降，它描述了吸附剂对吸附物的吸附能力，吸附能越低，则吸附能力越强。 由于缺陷间或吸附物间的相互作用，上述两种物理量都与缺陷或吸附物在表面的覆盖率（coverage）\\theta有关，其定义为\\theta = N_{\\rm{v/a}}/N_{\\rm{surface}}，即缺陷数或吸附物数与表面原子数之比。覆盖率越低，则缺陷间或吸附物间相互作用越弱，计算时所需的超胞也越大，实际计算中，可根据需求选择合适的覆盖率。本文档中，为了节省计算量，采取较大的覆盖率\\theta=0.25。 下面我们分别介绍这两个物理量的计算方法，并展示如何使用 ABACUS 计算。 ABACUS 中，我们可以采用平面波基组、原子轨道基组下的 Kohn-Sham DFT（KSDFT）和无轨道密度泛函理论等电子结构计算方法来计算所需的能量，也可以调用 DeePMD 势函数。接下来，我们以平面波基组下的 KSDFT 为例介绍其计算方法，如果需要使用其它的能量求解器，只需要设置 INPUT 文件里的 esolver_type、basis_type 更换能量求解器并设置相应求解器的参数即可。 二、ABACUS 计算表面缺陷能具体流程 表面缺陷能E_{\\rm{vac}}可定义为 E_{\\rm{vac}} = E_{\\rm{slab/vac}} + E_{\\rm{bulk}} - E_{\\rm{slab}} 其中E_{\\rm{slab/vac}}为带缺陷表面构型的总能量，E_{\\rm{bulk}}为体材料中每原子的能量，E_{\\rm{slab}}为无缺陷表面构型的总能量，注意计算E_{\\rm{slab/vac}}所需构型比E_{\\rm{slab}}少一个原子，即缺陷。 因此为了计算某种表面的缺陷能，我们需要进行三次自洽迭代（scf）计算，分别得到上述三个能量。 注意下面的例子中，为了提升效率，我们采用了较低的能量截断值（20 Ry）以及较少的 k 点（gamma 点），实际计算中，需要对二者做收敛性测试。 如果计算体系有磁性原子，要注意体材料的时候是否要加上磁性的计算。 计算实例：钼体心立方 110 表面缺陷能 链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_vacancy_adsorption/0_vacancy/Mo 1.1 计算体材料能量 这一步我们用晶格弛豫方法找到体心立方（bcc） Mo 的晶格常数以及平衡能量。 运行算例后，用 grep FINAL_ETOT_IS OUT.example/running_cell-relax.log 得到总能量为 -1861.827 eV，由于原胞内只有一个原子，因此E_{\\rm{bulk}}=-1861.827\\ \\rm{eV}。 从 OUT.example/STRU_ION_D 文件中可以读到平衡晶格常数为a_0=5.924\\ \\rm{Bohr}，它将用于表面构型的构造。 1.2 计算表面体系能量 这一步我们参考文献[1]，搭建了一个 7 层的 Mo bcc(110)表面体系，每层包含 4 个原子，如下图所示： 计算其总能量时，可以根据实际需要选择是否做结构优化，这里为了效率更高，我们没有做结构优化。 用 grep FINAL_ETOT_IS OUT.example/running_scf.log 得到总能量为 -52129.480 eV，因此E_{\\rm{slab}}=-52129.480\\ \\rm{eV}。 1.3 计算带缺陷的表面体系能量 第三步我们搭建带缺陷的表面体系，方法是从表面上移除一个原子，如下图所示，移除了表面中心的原子： 此算例同样没有做结构优化。 用 grep FINAL_ETOT_IS OUT.example/running_scf.log 得到总能量为 -50265.933 eV，因此E_{\\rm{slab/vac}}=-50265.933\\ \\rm{eV}。 1.4 计算缺陷能 对于上述构型，最终的缺陷能E_{\\rm{vac}} = E_{\\rm{slab/vac}} + E_{\\rm{bulk}} - E_{\\rm{slab}} = 1.720\\ \\rm{eV}。 三、ABACUS 计算表面吸附能具体流程 表面吸附能E_{\\rm{ads}}可定义为 E_{\\rm{ads}} = E_{\\rm{adsorbate/adsorbent}} - E_{\\rm{adsorbent}} - E_{\\rm{adsorbate}} + \\Delta \\rm{ZPE} 其中E_{\\rm{adsorbate/adsorbent}}为吸附物与吸附剂结合后的总能量，E_{\\rm{adsorbent}}为吸附剂体系的总能量，E_{\\rm{adsorbate}}为吸附剂体系的总能量，\\Delta \\rm{ZPE}为零点能，注意计算E_{\\rm{adsorbate/adsorbent}}所需构型的原子数为E_{\\rm{adsorbent}}与E_{\\rm{adsorbate}}之和。 因此为了计算吸附能，我们需要进行三次自洽迭代（scf）计算，分别得到上述三个能量。 计算实例：Li 原子在 Mo bcc(110)表面的吸附能 链接：https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/surface_vacancy_adsorption/1_adsorption/Li-Mobcc110 1.1 计算 Li 原子能量 这一步我们计算孤立 Li 原子的能量，方法是将一个 Li 原子放在一个足够大的原胞中，以排除 Li 原子间的相互作用。比如本例子中 Li 原子间距为 20\\ \\rm{Å}。 用 grep FINAL_ETOT_IS OUT.example/running_cell-relax.log 得到总能量为 -183.156 eV，由于原胞内有两个原子，因此E_{\\rm{adsorbent}}=-183.156\\ \\rm{eV}。 1.2 计算 Mo bcc(110)体系总能量 上文已经计算过E_{\\rm{slab}}=-52129.480\\ \\rm{eV}，因此这里E_{\\rm{adsorbate}}=-52129.480\\ \\rm{eV}。 1.3 计算吸附体系总能量 这一步我们参考文献[1]搭建了以 long bridge 形式吸附了 Li 原子的 Mo bcc(110)表面体系，其中 Li 到 Mo 表面的距离为 2.229\\ \\rm{Å}，如下图所示，绿色的原子为 Li 原子。 这里我们没有做结构优化，但在实际计算中，Li 原子到 Mo 表面的距离应该通过结构优化得到。 用 grep FINAL_ETOT_IS OUT.example/running_scf.log 得到总能量为 -52315.069 eV，因此E_{\\rm{adsorbate/adsorbent}}=-52315.069\\ \\rm{eV}。 1.4 计算吸附能 对于上述构型，吸附能E_{\\rm{ads}} = E_{\\rm{adsorbate/adsorbent}} - E_{\\rm{adsorbent}} - E_{\\rm{adsorbate}} = -2.433\\ \\rm{eV}。（此处忽略了零点能） 四、参考文献 [1] Chen M, Roszell J, Scoullos E V, et al. Effect of temperature on the desorption of lithium from molybdenum (110) surfaces: Implications for fusion reactor first wall materials[J]. The Journal of Physical Chemistry B, 2016, 120(26): 6110-6119. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-surface5.html":{"url":"abacus-surface5.html","title":"采用 ABACUS 进行表面计算（五）：外加电场","keywords":"","body":"采用 ABACUS 进行表面计算（五）：外加电场 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/08/28 一、介绍 电场是电荷及变化磁场周围空间里存在的一种特殊物质。这种物质与通常的实物不同，它虽然不是由分子原子所构成的，但它却是客观存在的特殊物质，具有通常物质所具有的力和能量等客观属性。许多材料在外加电场作用下会表现出不同寻常的性质，例如：铁电体在外加电场的作用下会产生电极化，也可以通过施加的电场来控制磁性和自发极化，因此在信息储存和传输中有广泛应用；二维材料（如石墨烯）在外加电场下表现出不同的电子性质和可控制的物理性质，这种特性使其具有在电子学领域的广泛应用前景。在电子结构计算中，周期性边界条件下对体系施加电场较为容易，而施加磁场则困难很多。 因此，外加电场是密度泛函理论（Density Functional Theory，简称 DFT）软件中可以被实现且重要的功能。ABACUS 中实现了在表面体系中外加恒定电场的功能[1]。注意，在 ABACUS 中，外加电场功能存在相应的原子受力的修正，可以用于平面波（Plane-Wave）基组和数值原子轨道（Numerical Atomic Orbitals）基组计算，但注意该功能只能用于带真空层的表面体系。 本教程中将会展示如何在 ABACUS 计算中使用加电场功能，为使得这个教程较为有趣，我们举一个半金属二维材料 nanoribbon（见图 1）加电场产生半金属的例子来讲解如何给体系添加电场，该 DFT 的计算工作曾发在 2006 年的 Nature 杂志上，具体可参考文献[2]。在这个教程里，我们使用的是数值原子轨道基矢量（Numerical Atomic Orbitals），碳和氢的轨道半径都是 8 a.u.，但实际上也可以使用平面波基矢量，只是前者效率更高所以在这里采用。我们还会使用到电子的自洽场（self-consistent field，简称 SCF）计算，非自洽计算（non-self-consistent field，简称 NSCF），自旋非极化和极化计算等概念。在不考虑自旋时（即设置 nspin=1 时），计算出的能带图中没有带隙，为金属；考虑自旋之后，带隙打开，成为半导体；在自旋极化基础上，外加恒定电场之后，其中一个自旋表现为半导体，另一个自旋则为金属。 图 1. Nanoribbon结构图，黑框代表超胞大小，有真空。超胞里包含32个碳原子（棕色），超胞里接触真空的2个碳原子（每个表面一个碳原子）被2个氢原子（白色）饱和。 二、软件和算例准备 ABACUS 里关于外加电场的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/scf/advanced.html#external-electric-field ABACUS 里关于外加电场参数的线上文档地址为：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#electric-field-and-dipole-correction ABACUS 的外加电场算例下载地址为（gitee）： https://gitee.com/MCresearch/abacus-user-guide/tree/master/examples/electric_field/ 可以采用的下载命令是： git clone https://gitee.com/MCresearch/abacus-user-guide 下载后解压，之后进入 /abacus-user-guide/examples/``electric_field 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide 三、采用加电场进行二维材料的能带计算 该算例中含有六个文件夹，解释如下： 1_unspin_scf：做非自旋极化（INPUT 文件中的 nspin 设为 1）的自洽场迭代 SCF 计算（INPUT 文件中的 calculation 设为 scf），输出自洽迭代之后的电子密度（将 INPUT 中的 out_chg 设为 1），注意二维材料的 KPT 文件，因为超胞大小是 102.459512146645 Å^3，所以对应的布里渊区 k 点取的是 1101，因为实空间周期长度小的方向对应的布里渊区大，所以需要取更多 k 点得到收敛结果。 2_unspin_band： 采用非自洽计算 NSCF（INPUT 文件中的 calculation 设为 nscf），读入上一个步骤输出的电荷密度（INPUT 文件中的 init_chg 设为 file），从而可以读入体系的基态电荷密度进行能带计算。 3_spin_scf：同 1_unspin_scf 的计算，只是把 nspin 设为 2。 4_spin_band：同 2_unspin_band 的计算，只是把 nspin 设为 2。 5_spin_elec_scf：同 3_spin_scf 的计算，只是又外加了电场的参数。 6_spin_elec_band：同 4_spin_band 的计算，只是又外加了电场的参数。 以下是算例 5 的输入文件（包含电场参数）： INPUT_PARAMETERS #Parameters (General) suffix nanoribbon calculation scf nbands 70 nspin 2 pseudo_dir ../../PP_ORB orbital_dir ../../PP_ORB #Parameters (Basis) basis_type lcao #Parameters (Accuracy) ecutwfc 100 scf_thr 1e-6 scf_nmax 200 #Parameters (Smearing) smearing_method gaussian smearing_sigma 0.001 #Parameters (Charge mixing) mixing_type pulay mixing_beta 0.1 mixing_ndim 20 mixing_gg0 1.5 #Parameters (Efield) efield_flag 1 efield_dir 2 efield_amp 0.0019440124 efield_pos_max 0.95 efield_pos_dec 0.10 以算例提供的 INPUT 文件为例，使用外加电场功能只需添加如下参数即可： efield_flag：类型是 Bool，指定外加电场的开(1)或者关(0)，默认值为 0 efield_dir：类型是 Int，外加电场方向，可取 0，1，2 分别表示 x，y，z 方向，默认值为 2 efield_pos_max：类型是 Real，锯齿状电势最大值所在分数坐标，范围[0,1)，默认值为 0.5 efield_pos_dec：类型是 Real，锯齿状电势从最大值到最小值的长度（同样以分数坐标为度量），默认值为 0.1，范围[0,1)。以图2为例，0.5 是最大值，0.6 是最小值，那么 0.5 ~ 0.6 的区域必须放置在没有原子的真空层中，注意这个例子设置的是 0.95 到 0.10 为电场区间。 图 2. 锯齿状势场分布图 efield_amp：类型是 Real，电场强度，默认值为 0，单位为 a.u.，其中 1 a.u. = 51.4220632*10^10 V/m 以上参数的使用方法在采用 ABACUS 进行表面计算（二）：偶极修正中有更详细的说明。 四、预期计算结果 运行完算例 2_unspin_band 后会通过非自洽计算得到体系非自旋极化能带图，横坐标是对二维材料布里渊区取 k 点，从 Gamma 点（坐标为 0 0 0）取到\\pi点（坐标为 0 0.5 0），取了 100 个 k 点算出来的能带图；纵坐标是能级，将费米面设置为 0，取了费米面附近 2 eV 的能量区间画出能带。以下两张图是同样取法。 运行完算例 4_spin_band 后会得到非自洽计算得到的自旋极化能带图（图 3）。 运行完算例 6_spin_elec_band 后会得到自旋极化加电场的能带图（图 4），注意这里所加的电场为 0.1 V/Å，由输入文件 INPUT 中的 efield_amp 设置，但 efield_amp 的单位是 a.u.，需要换算。 图 3. 采用PBE交换关联泛函和非自旋极化得到的二维nanoribbon的能带图，可以看出费米面附近CBM（Conduction Band Minimum）和VBM（Valence Band Maximum）重合，无带隙。 图 4. 采用PBE交换关联泛函和自旋极化得到的二维nanoribbon的能带图。蓝色和红色代表自旋极化方向不同时对应的两副能带图像，可以看出不加电场时，两个自旋方向的能带图几乎一样，都有带隙。 图 5. 采用PBE交换关联泛函和自旋极化，再给体系加上0.1 V/Å的电场得到的二维nanoribbon的能带图。蓝色和红色代表自旋极化方向不同时对应的两副能带图像，可以看出加了能带之后，其中一个自旋方向的能带图出现费米面附近的交叠，呈现金属性质，另外一个自旋方向的能带图依旧保持在费米面处的能隙。 五、参考文献 [1] Phys. Rev. B 59, 12301 (1999), https://doi.org/10.1103/PhysRevB.59.12301 [2] Nature 444, 347–349 (2006), https://doi.org/10.1038/nature05180 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"abacus-surface6.html":{"url":"abacus-surface6.html","title":"采用 ABACUS 进行表面计算（六）：补偿电荷","keywords":"","body":"采用 ABACUS 进行表面计算（六）：补偿电荷 作者：刘裕，邮箱：liuyu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/08/28 一、介绍 现实中的化学反应多数时候发生在恒定电势条件下，而传统的 DFT 计算软件则是基于恒定电荷的条件。若要在计算模拟中保持恒定电势，在电化学表面反应建模时就需要调整晶胞中的电子数。在开源密度泛函理论软件 ABACUS 里，模拟体系时使用的是周期性边界条件，因此需要添加额外的算法保持模拟过程中同时保证超胞的电中性。其中的一种方案就是当从系统中添加/提取额外的电子时，需要在表面模型的真空区域中实现补偿电荷的分布。 目前 ABACUS 软件中实现了补偿电荷功能[1]，与增减电子数相对应的补偿电荷会以带电平板的形式（不考虑平板厚度）予以补偿进而保持电中性，并且存在相应的原子受力的修正，可以用于平面波（Plane-Wave）基组和数值原子轨道（Numerical Atomic Orbitals）基组计算，但注意目前该功能只能用于带真空层的表面体系。我们以下的例子以一个水分子为例，如图 1 所示。 图 1. 一个水分子位于超胞中，红色代表氧原子，白色代表氢原子 二、文档与算例 ABACUS 里关于补偿电荷的线上文档地址为： http://abacus.deepmodeling.com/en/latest/advanced/scf/advanced.html#compensating-charge ABACUS 里关于补偿电荷参数的线上文档地址为：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#gate-field-compensating-charge ABACUS 的补偿电荷算例下载地址为（gitee）： https://gitee.com/mcresearch/abacus-user-guide/tree/master/examples/compensating_charge/H2O 可以采用的下载命令是： git clone https://gitee.com/mcresearch/abacus-user-guide 之后进入 /abacus-develop/``examples/compensating_charge/H2O 目录 或者采用 Github 仓库地址： https://github.com/MCresearch/abacus-user-guide/tree/master/examples/compensating_charge/H2O 三、偶极修正与补偿电荷结合的表面计算 在采用 ABACUS 进行表面计算（二）：偶极修正文档中，我们给出了水分子层计算中应用偶极修正之后的结果。在此基础上，我们可以进一步应用补偿电荷功能。如图 1 所示，我们采用了完全相同的一个水分子在周期性晶胞的结构，只有 INPUT 文件中添加了补偿电荷相关参数。 INPUT_PARAMETERS #Parameters (1.General) suffix H2O calculation scf nbands 8 symmetry 0 pseudo_dir ../../PP_ORB #Parameters (2.Iteration) ecutwfc 100 scf_thr 1e-6 scf_nmax 100 #Parameters (3.Basis) basis_type pw #Parameters (4.Smearing) smearing_method gauss smearing_sigma 0.001 #Parameters (5.Mixing) mixing_type broyden mixing_beta 0.1 #Parameters (6.Dipole correction) efield_flag 1 dip_cor_flag 1 efield_pos_max 0.0 efield_pos_dec 0.1 efield_amp 0.0 #Parameters (7.Compensating charge) gate_flag 1 zgate 0.7 nelec 9 #Parameters (8.Output) out_pot 2 以算例提供的 INPUT 文件为例，使用补偿电荷功能只需添加如下参数即可： gate_flag：类型是 Bool，指定补偿电荷功能的开(1)或者关(0)，默认值为 0 efield_dir：类型是 Int，指定与带电平板垂直的方向，可取 0，1，2 分别表示 x，y，z 方向，默认值为 2 zgate：类型是 Real，指定带电平板（位于真空中）在晶胞中的位置（分数坐标），范围[0,1)，默认值为 0.5 nelec：类型是 Real，设定的体系总电子数，这里是 9 个电子（氧原子因为赝势有 6 个电子，每个氢原子有 1 个电子，总共 8 个电子），即原体系多加了 1 个电子，那么为了保持电中性，带电平板会带 1 个正电荷 block：类型是 Bool，添加势垒以防止电子溢出的功能（可选），1 代表开，0 代表关，默认值为 0 block_down：类型是 Real，势垒的起点（分数坐标），默认是 0.45 block_up：类型是 Real，势垒的终点（分数坐标），默认是 0.55 block_height：类型是 Real，势垒高度，单位是里德堡（Rydberg），默认是 0.1 四、预期结果 如左下图所示，一个水分子位于超胞（尺寸为 3\\times3\\times18 \\mathrm{Å^3}）的中部（即位于9 \\mathrm{Å}）。按照采用 ABACUS 进行表面计算（二）：偶极修正文档中偶极修正参数设置的说明，锯齿即位于 0.0~0.1 的区域。注意在采用偶极修正/外加电场功能的情况下，带电平板的位置应该在真空区域，并且不同于偶极修正锯齿所在的区域。 为了验证结果的正确性，我们可以画出静电势沿 Z 轴（c 方向）的变化如图 2 所示。与只应用偶极修正功能的静电势相比（可参考表面计算二里面的图 3），在分数坐标 0.7（Z 轴 12.6 埃）处，静电势出现了一个向下的凹陷，这来自于此处的补偿电荷带电平板的影响。 静电势计算和作图方法请参考静电势和功函数计算文档。 图 2. 静电势（Electrostatic Potential）沿超胞Z轴变化图 五、参考文献 [1] Phys. Rev. B 89, 245406 (2014), https://doi.org/10.1103/PhysRevB.89.245406 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-issue.html":{"url":"develop-issue.html","title":"ABACUS 的 Github 仓库 Issues 处理流程","keywords":"","body":"ABACUS 的 Github 仓库 Issues 处理流程 作者：赵天琦，邮箱：zhaotq@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/01 一、Github 的 Issues 机制 1. 简介 Github 的 Issues GitHub 上的 Issues 机制是一个用于跟踪和讨论项目相关问题、需求、任务和改进的功能。它为开发者们提供了一个集中式的平台，使得项目的参与者们能够跟踪项目进展、报告错误、提出新功能、讨论改进方向等。 2. Issues 对 ABACUS 软件的作用 ABACUS（原子算筹）是一款国产密度泛函理论（Density Functional Theory，简称 DFT）软件，其涉及到的功能繁多，仅 2023 年上半年统计到的输入参数就有三百多个，应用的对象也很广，在材料、物理、化学、能源和工程等多个领域都有应用。因此，常见的问题是开发者开发出的功能不能包含所有可能的应用对象，因此软件在某些特定场合出现效率不高甚至某个功能无法运行的情况是时有发生的。另外一方面，ABACUS 项目参与的开发人员广泛，不同开发者对同一个软件代码进行修改，容易引发新的 bug。因此，建立一个良好的用户和开发者，乃至开发者之间互动交流的平台，对于发现软件问题，不断改善软件质量和提高稳定性易用性方面具有重要作用。Github 上的 Issues 机制则承担起了这一部分功能。因此，将 Issues 机制建立好是不断提升 ABACUS 软件，使其快速迭代的重要措施。 3. Issues 功能介绍 创建 Issue：项目的任何参与者都可以新建一个 Issue。创建 Issue 时，需要填写标题、描述（可以使用 Markdown 语法格式化描述内容）、分配处理人（Assignees，可选）、添加分类标签（Labels，可选）、关联项目看板（Projects，可选）和设置里程碑（Milestones，可选）。 标签（Labels）：标签是用来对 Issues 进行分类和过滤的。项目维护者可以创建自定义标签，例如：bug、feature、documentation、enhancement 等。这有助于组织和优先处理不同类型的问题。 里程碑（Milestones）：里程碑用于对 Issues 进行分阶段管理和规划。项目维护者可以创建里程碑并为其分配截止日期，这样有助于按照计划进行项目开发。 指派（Assignees）：在 Issue 上指派处理人意味着将该 Issue 的负责人分配给特定的项目参与者。这有助于清楚地了解谁负责解决某个问题。 评论和讨论：项目的参与者们可以在 Issue 下面发表评论，进行讨论。评论支持 Markdown 语法，因此可以方便地插入代码、图片和链接等。 引用和关联 Issue：在评论和提交（Commit）中，可以通过输入类似 #issue编号 的格式引用其他 Issue，这有助于将讨论串联起来。此外，还可以使用关键字（如：close、fix、resolve 等）在提交信息中自动关闭相关 Issue。 通知和订阅：当您参与某个 Issue 时（如创建、评论或被指派），如果您希望及时收到回复，建议您关注是否会收到邮件通知（关注一下 Github 的功能） 关闭和重开 Issue：当某个问题被解决或者不再适用时，项目维护者或 Issue 创建者可以关闭 Issue。如果后续发现问题没有解决或者需要重新讨论，可以重新打开 Issue。 二、ABACUS 项目的 Issues 标签分类 提交 Issues 会让提交者（提交者可以是用户或者开发者）选择标签，以下是 ABACUS 开发者团队推荐的标签及其使用场景 分类 ： Bug Report（开发者/用户）: 用于报告代码问题，例如崩溃、错误或意外行为。 Code Quality（开发者）：用于报告与代码质量相关的问题，例如代码不规范、设计不良、全局类或去全局变量使用不当、或者可维护性问题，开发者会用重构来解决相关问题。 Docs（开发者/用户）：用于报告与软件文档相关的问题，例如缺少或不完整的文档，或难以理解的文档。 Feature Request（开发者/用户）：用于请求新功能或对现有功能进行增强。 Performance（开发者/用户）：用于报告与用户角度下软件性能相关的问题，例如响应时间慢、资源使用率高或可扩展性问题。 Questions（开发者/用户）：软件安装、软件易用性等用户或开发者需要帮助解决的问题。 Tests （开发者）：用于报告与测试相关的问题，例如测试失败、缺少或不完整的测试或测试自动化问题 优先级： Priority High: 通常指的是需要尽快解决的紧急问题，如 CI 不通过，新 PR 全部报错 Priority Medium: 重要且需要近期解决的问题，如... Priority Low：可能是一些不紧急但需要解决的问题，如需求调整、性能优化 专题 DFTU, EXX, big system 等用于记录一些专题类 Issues，以方便开发者系统解决同一个主题的 Issues 三、Issues 处理流程 1. 介绍 提交的Issues会在24小时内得到开发者团队的回复。当前Issues处理的闭环方式有： 提交PR修改代码，解决对应Issues，之后关闭相应的Issue。 ISSUE历史大于两周以上，且ISSUE提出者不对有效回应做回应，则提醒用户后关闭 属于Discussion机制而不属于Issues的范围，会转移到Github的Discussion模块：例如用户的想法，用户的建议，用户对社区的问题等以用户的满意程度为指标的问题 2. 创建一个 ISSUE 有多种方法可以创建 ISSUE，您可以选择最方便的方法来。本例将使用 GitHub UI。有关其他创建 ISSUE 的方法的更多信息，请参考 Github 文档“创建 ISSUE”。以下是具体步骤： 在 GitHub 上，导航到 ABACUS 仓库的主页。 https://github.com/deepmodeling/abacus-develop.git 在 ABACUS 仓库名称下面，单击“Issues”。 单击“New issue”。 选择一个最适合您的 ISSUE 的一个标签模版，点击“Get started”。如果 ABACUS 提供的默认模版不符合您的 ISSUE 类型，可以选择“Open a blank issue”。 3. 填入 ISSUE 信息 给您的 ISSUE 一个描述性的标题。标题应该一眼就能传达问题的内容。 添加一个解释 ISSUE 目的的描述，包括任何可能有助于解决问题的细节。例如，如果这是一个 bug 报告，描述重现 bug 的步骤、预期结果和实际结果。 您可以使用 Markdown 添加格式、链接、表情等。有关更多信息，可参阅“在 GitHub 上撰写”。 以下是 ABACUS 的 Bug report 类型 ISSUE 的模版，您可以根据 ISSUE 模版示例来填入 ISSUE 信息。其中带“*”的项是必填项。 4. ISSUE 的任务列表 请注意“Task list for Issue attackers”是为了帮助开发者检查 ISSUE 解决的进度，并不是要求您选择解决 ISSUE 需要完成哪些工作。所以您只需要提供足够详细的信息以帮助开发者来解决 ISSUE。如果您提供的信息已经完成其中的一些任务列表，可以在相应的任务前打对勾，但是如果没有可以不用关心“Task list for Issue attackers”。当然，了解解决一个 ISSUE 所需要经过的一般步骤，有助于您了解 ABACUS 代码的开发过程。如果您想通过自定义的任务列表给开发者一些提示，可以参考 Github 文档“About task lists”。 5. 添加 ISSUE 标签 如果您选择 ISSUE 模版，创建完 ISSUE 之后会自然有相应的标签出现，如： 此外，您也可以参考 ABACUS 的专题标签（例如 DFTU, EXX 等）添加相应的标签，或者通过“Edit labels”创建新标签： 6. 提交 ISSUE 点击“Submit new issue”以创建您的 ISSUE。您可以在创建问题后编辑上述任何字段。您的 ISSUE 有一个唯一的 URL，您可以与团队成员分享，或在其他 ISSUE 或 Pull Requat 中引用。 7. 与开发者交流 创建 ISSUE 后，通过添加评论与开发者或其他协作者交流对话。您可以键入 @ 邀请协作者或团队关注评论。 要在同一仓库中可以链接相关问题，您可以键入#，后跟 ISSUE 标号或部分标题，然后单击要链接的问题。有关更多信息，请参见““在 GitHub 上撰写””。 8. 查看 ISSUE 解决进度 查看 ISSUE 解决有 3 种方式，如下图所示： 可以通过“task list”的完成进度查看 ISSUE 的解决进度 新建的 ISSUE 会被自动加入 ABACUS ISSUEs 项目，开发者通过讨论之后会在其中加入\"Iteration\"解决周期，\"Priority\"优先级，\"Collaborators\"开发者单位，\"Project\"是否纳入近期的开发者项目等信息，您也可以在这里看到 ISSUEs 的进展。 Assignees 是解决 ISSUE 的开发者，需要 ABACUS 管理员进行分诊。 9. 关闭 ISSUE 以第 1 步和第 2 步同样的方式找到想要关闭的 ISSUE。 点击“Close issue”，关闭 ISSUE。 如果要添加关闭 ISSUE 的原因，可以在“Leave a comment”处添加关闭原因，然后点击“Close with comment”，关闭 ISSUE。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-C++.html":{"url":"develop-C++.html","title":"ABACUS 开源项目 C++ 代码规范","keywords":"","body":"ABACUS 开源项目 C++ 代码规范 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/04 ABACUS（Atomic-orbtial Based Ab-initio Computation at UStc，中文名原子算筹）是国产开源密度泛函理论软件，相关介绍 ABACUS 的新闻可在 ABACUS 新闻稿整理查看。此文档用于给 ABACUS 开发者提供代码编程规范方面的建议。 前言 让任何开发者都可以快速读懂别人的代码，这点对于 ABACUS 项目很重要。此外，使代码易于管理的方法之一是加强代码一致性，这需要从代码规范开始着手。 一、命名约定 1. 普通变量的命名统一是小写，并使用下划线命名法 以下是四种命名方法：下划线命名法、匈牙利命名法、驼峰式命名法、帕斯卡命名法 string table_name; // 下划线命名法（推荐） - 用下划线区分单词（推荐使用） string sTableName; // 匈牙利命名法 - 前缀字母用变量类型缩写，单词首字母大写 string tableName; // 驼峰命名法 - 混合大小写（不推荐使用） string TableName; // 帕斯卡命名法 - 每个单词首字母大写（不推荐使用) 下划线命名法：推荐使用 匈牙利命名法：目前 ABACUS 中有些变量（例如指针），首字母为数据类型（指针为 p），可以考虑用这种方式命名，但不推荐用大写字母 驼峰命名法/帕斯卡命名法：目前 ABACUS 大部分的代码不是用这种命名方式的，为了代码风格统一，所以不推荐使用 2. 函数命名 建议使用下划线命名法且所有字母全部小写，建议小于 18 个字符 void calculate_area() { // function body } 3. private 的类数据成员在最后以下划线结尾 private 的类数据成员和普通变量的命名方式一样，但要在最后以下划线结尾，以区分自己是 private 的类数据成员。 class TableInfo { ... private: string table_name_; // 好 - 后加下划线 string tablename_; // 好 static Pool* pool_; // 好 }; 4. 只有全局变量用全大写命名 在 ABACUS 中，例如 NBANDS（能带数），NLOCAL（局域轨道数目）这种全大写的变量名是全局变量，其它的不建议用大写字母给变量命名。另外，ABACUS 将通过重构或者删除的方式逐步淘汰全局变量，因此不建议增加新的全局变量。 二、关于头文件 1. 只有在真正需要使用某个库/头文件时才 #include 它们 不需要的 #include 删除。 2. #include避免使用快捷目录 . (当前目录) 或 .. (上级目录) 项目内头文件应按照项目源代码目录的树结构排列，避免使用 UNIX 特殊的快捷目录 . (当前目录) 或 .. (上级目录)。例如 source/module_hsolver/diago_cg.h 文件是这样引用 module_base 的头文件： #include \"diagh.h\" #include \"module_base/complexmatrix.h\" 3. #include 顺序（clang-format 可以自动） 使用标准的头文件包含顺序，这样可以可增强可读性，避免隐藏依赖。 foo.cpp 中包含头文件的次序如下： 与源文件对应的头文件：dir2/foo2.h（这种优先的顺序排序保证当 dir2/foo2.h 遗漏某些必要的库时， dir/foo.cpp 的构建会立刻中止） C 系统文件 C++ 系统文件 其他库的 .h 文件 本项目内 .h 文件 4. 头文件需要 #define 保护 #ifndef FOO_BAR_BAZ_H_ #define FOO_BAR_BAZ_H_ ... #endif // FOO_BAR_BAZ_H_ 5. 避免使用前置声明 使用 #include 包含需要的头文件，尽量避免使用前置声明（见以下例子解释什么是前置声明）。 // 什么是前置声明？ // MyClassB.h // Bad: Overuse of forward declarations class MyClassB; class MyClassA { public: void DoSomething(MyClassB* obj_b); }; void MyClassA::DoSomething(MyClassB* obj_b) { // ... } 在这段代码中，MyClassB 被声明为一个类，但没有给出其定义。这被称为前置声明（Forward Declaration），它告诉编译器 MyClassB 是一个存在的类，但不提供该类的详细信息。 6. 当函数只有 10 行甚至更少时，才将其定义为内联函数 只有当函数只有 10 行甚至更少时才将其定义为内联函数（关键字 inline）。 三、关于类（Class） 1. 先声明类的成员变量，再声类的成员函数 2. 将public 部分放在最前，之后是protected数据，最后是private 3. 不使用运算符重载 若要使用，建议提交 issue 讨论 4. 什么时候用 struct？ 只有数据成员、没有成员函数时可以用 struct 5. 类型转换使用static_cast<>() 建议使用 C++ 的类型转换，如 static_cast<>()。 不要使用 int y = (int)x 或 int y = int(x) 等转换方式。 用 static_cast 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时。 用 const_cast 去掉 const 限定符。 用 reinterpret_cast 指针类型和整型或其它指针之间进行不安全的相互转换。 仅在你对所做一切了然于心时使用。 6. 继承采用 public 继承 如果你想使用私有继承，你应该替换成把基类的实例作为成员对象的方式去定义类。 7. 不过度使用实现继承，可以考虑组合 例如，如下案例： class Engine { public: void start() { /* 启动引擎 */ } }; class Car { public: Car(const std::string& n, Engine& e) : name_(n), engine_(e) {} void drive() { engine_.start(); std::cout 四、关于函数（Function） 1. 函数传参：不变参数用 const 和 & 函数的输入参数与输出参数: 在一个函数中，不变的量，我们可以看作是函数的输入参数；变化的量，我们可以看作是函数的输出参数。 在输入参数中可以选择 const T* （指向常量对象的指针，不能通过这个指针来修改其指向的对象的值。然而，你可以改变指针本身的值）。 也可以使用 const T& （不能通过这个引用来修改其引用的对象的值，在其生命周期内不能重新引用另一个对象）。 所以，建议使用 const T&，若要使用 const T*，则应给出相应的理由，否则会使读者感到迷惑。 void Foo(const string &in, string *out); // 输入参数：in （const + 引用&） // 输出参数：out（指针变量） 2. 函数传参：会变的参数用指针 什么是引用参数: 在 C 中, 如果函数需要修改输入变量的值, 参数必须为指针, 如 int foo(int *pval)。 在 C++ 中, 函数还可以声明为引用参数: int foo(int &val)。 引用参数在语法上是值变量却拥有指针的语义（变量可以被改变！）。 3. 每个函数不超过 50 行 建议编写简短，凝练的函数，有特殊情况的除外。 4. 函数返回值（return 的值）多使用值返回和引用返回，避免使用指针返回 五、关于作用域 1. 变量要初始化 无初始化的变量可能会引起结果不稳定（例如出现随机数），因此建议养成习惯，对所有变量的值要初始化，见下面的例子： int i; i = f(); // 坏——初始化和声明分离 int j = f(); // 好——初始化时声明 vector v; // 坏——初始化和声明分离 v.push_back(1); v.push_back(2); vector v = {1, 2}; // 好——初始化时声明 2. 将局部变量置于最小作用域 在 if, while 和 for 语句中： 变量不是对象，则变量应当在内部声明与初始化，这样子这些变量的作用域就被限制在这些语句中了，举例而言： while (const char* p = strchr(str, '/')) { str = p + 1; } 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数。这会导致效率降低。建议将构造函数调用次数减少以提高程序效率。 Foo f; // 构造函数和析构函数只调用 1 次 for (int i = 0; i 3. 仅在局部作用域使用using namespace 使用 using namespace 语句来引入命名空间中的所有名称可能会导致名称冲突。因此，建议在需要时使用它并仅在局部作用域内使用（例如只在调用的时候使用）。 // 建议不在程序开头使用，而是在具体用到std库的函数内使用该语句 using namespace std; 4. 用全局函数要加命名空间 以下是两种建议的方式，或者用类，或者用 namespace // 类的静态成员函数 class MyMath { public: static int add(int a, int b) { return a + b; } static int sub(int a, int b) { return a - b; } }; // or // 命名空间内的非成员函数 namespace my_math { int add(int a, int b) { return a + b; } int sub(int a, int b) { return a - b; } } 5. 优先使用命名空间的非成员函数 能使用命名空间的非成员函数，就不用类的静态成员函数。 // 使用命名空间内的非成员函数 namespace my_math { int add(int a, int b) { return a + b; } int sub(int a, int b) { return a - b; } } int main() { int x = 3, y = 5; int z = my_math::add(x, y); // 调用 my_math 命名空间中的函数 return 0; } // 不要使用类的静态成员函数模拟命名空间 class MyMath { public: static int add(int a, int b) { return a + b; } static int sub(int a, int b) { return a - b; } }; int main() { int x = 3, y = 5; int z = MyMath::add(x, y); // 调用 MyMath 静态方法 return 0; } 六、其他 C++ 特性 1. 每个代码文件不超过 500 行 太长的代码阅读理解和维护的成本都太高，因此不建议一个文件太长。如果有文件超过 500 行，建议重构，把对象进一步的划分。 2. 禁止用 C++11 之后版本的语法 目前的主要考虑是用新语法会使得编译器编译成功的概率降低，另外提高开发者的开发门槛。因此，我们规定不能使用 C++11 之后的语法。 3. 多用前置自增 (++i) 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增，自减运算符。 不考虑返回值的话，前置自增 (++i) 通常要比后置自增 (i++) 效率更高。 4. 尽可能用 sizeof(a) 代替 sizeof(int) 这里 a 是一个参数名 原因：当代码中变量类型改变时会自动更新。 5. 多使用列表初始化 C++11 中，该特性得到进一步的推广，任何对象类型都可以被列表初始化。示范如下： // Vector 接收了一个初始化列表。 // 不考虑细节上的微妙差别，大致上相同。 // 可以任选其一。 vector v{\"foo\", \"bar\"}; vector v = {\"foo\", \"bar\"}; // 可以配合 new 一起用。 auto p = new vector{\"foo\", \"bar\"}; // map 接收了一些 pair, 列表初始化大显神威。 map m = {{1, \"one\"}, {2, \"2\"}}; // 初始化列表也可以用在返回类型上的隐式转换。 vector test_function() { return {1, 2, 3}; } // 初始化列表可迭代。 for (int i : {-1, -2, -3}) {} // 在函数调用里用列表初始化。 void TestFunction2(vector v) {} TestFunction2({1, 2, 3}); 6. 初始化时：整数用0，实数用0.0，指针用nullptr，字符 (串) 用'\\0' C++11 引入了一个新的关键字 nullptr，用来表示空指针。相对于传统的 NULL 或 0，nullptr 更加明确、类型安全。使用 nullptr 可以避免一些潜在的编程错误，比如将整数值误传给函数，导致出现不可预期的行为。 因此，建议在 C++11 及以上的版本中使用 nullptr 来表示空指针。 7. 少用 auto，使用前需对 auto 有更全面的了解 auto 是 C++11 引入的关键字，它可以让编译器自动推导出变量的类型。之后，C++14 和 C++17 对 auto 的使用也有了一些扩展和改进。 C++11：auto 只能用于定义局部变量，并且必须初始化。例如： auto i = 42; // 推导出 i 的类型为 int auto f = 3.14f; // 推导出 f 的类型为 float auto s = \"hello\"; // 推导出 s 的类型为 const char* C++14：auto 可以用于定义函数返回值类型，使得函数定义更加简洁。例如： auto add(int x, int y) { return x + y; } // 推导出返回类型为 int auto divide(double x, double y) { return x / y; } // 推导出返回类型为 double C++17：auto 进一步扩展为 auto 和模板结合使用时，可以直接指定模板类型参数，从而实现更加灵活的类型推导。例如： std::vector v{1, 2, 3}; auto it = v.begin(); // 推导出 it 的类型为 std::vector::iterator auto [first, second] = std::make_pair(1, 3.14); // 使用结构化绑定和 auto 推导出 first 和 second 的类型 但是大家注意，在 abacus 中，我们只支持 C++11 的标准，C++14/17 语法是不接受的。 8. auto 和 for 的混合使用时注意事项 在 C++11 中，auto 和 for 循环的结合使用已成为一种常见的编程范式，它可以让代码更加简洁、易读，并且减少了手动指定类型的错误。 int arr[] = {1, 2, 3}; for (auto i : arr) // 相当于复制 { std::cout 9. constexpr 替代宏定义和 const 常量 在 C++11 里，用 constexpr 来定义真正的常量，或实现常量初始化。（真正的常量在编译时和运行时都不变） #define PI 3.14159 // PI 是一个宏定义常量，它不会进行类型检查，容易出错； const double kE = 2.71828; // kE 是一个 const 常量，它不能用于编译期计算。 constexpr double kGravity = 9.8; constexpr 可以替代宏定义和 const 常量的主要原因是： 类型安全：使用 constexpr 定义的常量会进行类型检查，避免了宏定义可能带来的类型错误，同时也比 const 常量更加严格。 编译时计算：constexpr 声明的变量或函数在编译时就可以被求值，而不需要在运行时计算。这比宏定义和 const 常量更高效，尤其是在需要多次使用同一个值的情况下。 更好的可读性和可维护性：使用 constexpr 可以使代码更加清晰易懂，减少了宏定义可能导致的代码混乱问题。同时，由于 constexpr 可以使用函数、类等 C++ 语言特性，因此更加灵活，对于复杂的计算也更容易维护和修改。 因此，在 C++11 及以上的版本中，建议使用 constexpr 来替代宏定义和 const 常量，以提高代码的可读性、可维护性和效率。 七、关于 ABACUS 中常用的关键词缩写 有些名字很长，我们希望尽量言简意赅的表达出一些关键词的意思。原则是一般 3-5 个字母的范围下尽量说清楚一个变量的含义。这些统一的命名会出现在函数名或者变量名里。 1. 两个字符 pw：代表plane wave平面波 op：代表具有multi-device和multi-precision支持的算子（operator），和Operator模块含义不同 2. 三个字符 fft：快速傅里叶变换 kpt：布里渊区kpoint的缩写 nao：代表numerical atomic orbitals （nao经常用来表示number of atomic orbitals，不知道会不会混） orb：orbital，轨道 hmt：代表hamilt或者hamiltonian pot：代表potential chg：代表charge den：代表density（电荷密度尽量都用chg） scf：代表自洽迭代self consistent field thr：代表threshold tab：代表table kin：代表kinetic，动能的 cal：代表calculate opt：代表optimize gen：代表generate 3. 四个字符 iter：代表iteration init：代表初始化initializaiton read：读入 stru：代表structure veff：代表有效势 vloc：代表局域势 Reference Google C++ Style Guide Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-dox.html":{"url":"develop-dox.html","title":"ABACUS 注释规范：Doxygen 入门 (c++)","keywords":"","body":"ABACUS 注释规范：Doxygen 入门 (c++) 作者：金祖鑫，邮箱：jinzx@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/09/15 一、简介 开源密度泛函理论软件 ABACUS 目前由众多社区开发者共同开发，因此有一个统一的代码注释规范是非常重要的，本文主要推荐以 Doxygen 工具为辅助的代码注释格式。 1. 什么是 Doxygen Doxygen 是一款支持包括 C/C++, Python, Fortran 等多种语言的静态程序分析与文档生成工具。通过搜集并整理代码中的信息，包括但不限于 函数的调用/被调用 类的成员以及继承、协作关系 文件夹之间的依赖关系 头文件 include 关系 Doxygen 不仅能自动生成包含以上信息的图表与列表，也能将代码中采用特定格式的注释附到相应位置，最终生成内容翔实的文档。在适当的 Doxygen 配置与良好的代码注释下，Doxygen 自动生成的文档能为开发者提供诸多便利，降低阅读代码的难度，从而促进开发者社区的建设。 2. 功能与文档范例 Doxygen 可以生成某个函数的调用与被调用图(call & caller graph)。以开源密度泛函理论软件 ABACUS 代码为例，其中负责计算三次样条插值的函数 ModuleBase::CubicSpline::eval，doxygen 可将其调用关系自动可视化为如下图表： Doxygen 可以将类的继承关系生成图表。下图展示了 ModuleESolver::ESolver 的一系列继承 Doxygen 可以生成类的协作图（collaboration diagram）。下图展示了 container::Tensor 的成员以及成员的成员之间的关系： Doxygen 可以生成文件夹之间的依赖关系图。下图展示了 source/module_basis 及其内部成员文件夹与其他文件夹的耦合。 Doxygen 可以将头文件的 include 关系可视化成图表 (include dependency graph)。下图（部分地）展示了 module_basis/module_nao/numerical_radial.h 包含与被包含的情况： 大量项目使用 Doxygen 生成文档 (https://www.doxygen.nl/projects.html)。对科学计算开发者而言一个著名的例子是 LAPACK 的在线文档 https://www.netlib.org/lapack/explore-html/ 二、如何使用 Doxygen Doxygen 可以自动识别代码逻辑并生成以上例子中的函数调用、类的继承与协作、文件夹依赖以及头文件依赖等图表。但是，对理想的开发者文档而言代码注释中的信息亦不可或缺。在最终生成的文档中，除以上自动生成的图表外，Doxygen 会将类的成员与函数一一列举，并识别代码中特定格式的注释后将其附在对应位置。 1. 如何写能被 Doxygen 识别的注释 通常开发者会希望一部分精心撰写的注释——比如类的功能介绍或者函数参数的含义——出现在开发者文档里，而不希望文档充斥着临时变量的描述或某一行意义的解释。Doxygen 充分考虑了这一点。事实上，普通的注释均会被 Doxygen 忽略；只有特定格式的注释会被 Doxygen 识别。下面的代码是一个简单的例子。尽管其中各处都附上了注释，但这些均不会出现在最终生成的文档中： // A class that represents a circle. // This toy class will be used to demonstrate the usage of Doxygen. class Circle { public: // Initializes a Circle object with a given radius. // A unit circle is assumed by default. Circle(double r = 1.0); // Rescales a Circle object. // The radius of the given Circle object is multiplied by the given factor. static void rescale(Circle* circ, // pointer to the Circle object double factor // radius rescaling factor ); private: double r_; // radius of the Circle object static constexpr double PI = 3.14159265358979324; }; 以上代码生成的文档如下。Doxygen 会自动将成员变量和函数一一列举，但由于注释不符合特定格式，因而不会出现在文档相应位置。 下面介绍如何写能被 Doxygen 识别的注释以及一些基本用法。 1.1 基本格式 在 c++ 中 Doxygen 会识别以下三种注释格式： Javadoc-style /** * This is a Javadoc-style comment */ Qt-style /*! * This is a Qt-style comment */ Extended c++ style /// This is the so-called extended c++-style comment //! This also works! 以上三种格式本身均是合法的 C++ 注释，只是在 // 和 / / 的基础上添加了额外的 '*' ，'!' 或 '/' 。一旦文档中出现了以上三者之一，Doxygen 便会将之后的注释内容填入文档的相应位置。这三种基本格式是所有 Doxygen 用法的基础，所有的进阶功能（如 group，module，equation 等）均需在这三者之一开启的注释行/块内实现。这三种基本格式可以混用，开发者可以按自己的习惯选择一种或多种使用。 Doxygen 默认注释作用于之后的类、变量或函数（允许有空行）。如我们希望注释作用于之前的对象，则可在基本格式后立刻添加 ' //！ this comment line applies to print(), even though there's an empty line below void print(); /// 1.2 详细与简略描述 如之前例子所示，Doxygen 自动生成类的文档时会先把成员函数与变量罗列在开头，随后才是每个成员的介绍（当然，由于之前的例子里没有采用 doxygen 格式，详细描述为空）。只要使用了基本格式，Doxygen 就会自动将注释附在对应成员处。比如若将之前构造函数前的 // 注释替换为 /// : /// Initializes a Circle object with a given radius. /// A unit circle is assumed by default. Circle(double r = 1.0); 这些内容即会出现在原先为空的 Constructor & Destructor Documentation 下 Circle()的描述里: Doxygen 还允许让一些简略描述出现在类文档的开头部分。有两种方式可以实现这一目的。较为正式的方式是在注释块里添加 @brief 或者 \\brief。以这种方式指定的简略描述可以跨多行（如下面开头 Circle 类的注释）。另一种较为轻便的方式是使用单行的 extended C++ style 注释，如下面 Circle 的构造函数。【多行的 extended c++ style 注释只会被当做详细描述】 /** * @brief A class that represents * a circle. * * This toy class will be used to demonstrate the usage of Doxygen */ class Circle { public: /// Initializes a Circle object with a given radius. /*! * A unit circle is assumed by default. */ Circle(double r = 1.0); /*! * \\brief Rescales a Circle object. * * The radius of the given Circle object is multiplied by the given factor. * */ static void rescale(Circle* circ, double factor ); private: double r_; /// 以上代码生成的 Doxygen 文档在开头罗列部分会出现对应的简略描述；详细介绍部分则会包括所有的注释（包括 brief）。 1.3 函数参数 一个开发者写的函数经常会被很多其他开发者使用。除对函数整体功能的描述外，每个参数含义的注释也十分重要。Doxygen 支持两种给函数参数添加注释的方式。较为正式的方式是在注释块内添加 @param 或 \\param： /*! * \\brief Rescales a Circle object. * * The radius of the given Circle object is multiplied by the given factor. * * @param [in,out] circ Pointer to the Circle object to be rescaled. * @param [in] factor Radius rescaling factor. */ static void rescale(Circle* circ, double factor ); 较为轻便的方式是在函数声明的参数列表里直接添加（加在参数后注意要使用 ' /*! * \\brief Rescales a Circle object. * * The radius of the given Circle object is multiplied by the given factor. */ static void rescale(Circle* circ, /// [in], [out] 或 [in, out] 可以提示该参数是输入还是输出参数。这并非 Doxygen 的强制要求，但十分推荐。 以上两种参数注释方式对 Doxygen 而言是等价的，开发者可按习惯选择一种使用，生成的函数描述如下： 1.4 数学公式 有时一些函数严格对应了某个公式，这种情况下直接用数学公式作为注释的效果可能胜过大段的文字描述。Doxygen 允许开发者以 Latex 的语法实现公式注释。如有在文字中嵌入公式的需求，可以采用 \\f$ ... \\f$： /// A constant that represents the value of \\f$ \\pi \\f$. static constexpr double PI = 3.14159265358979324; 单行公式由 \\f[ ... \\f] 实现： /*! * @brief Returns the area of the current Circle object. * * The area of the a circle is given by * * \\f[ S = \\pi r^2 \\f] */ double area() const; 如有多行公式的需求，Doxygen 支持调用 eqnarray 等 latex 数学环境： /*! * @brief Returns the circumference of the current Circle object. * * The circumference of the a circle is given by * * \\f{eqnarray*}{ * L &= \\pi d \\\\ * &= 2 \\pi r * \\f} * */ double circumference() const; 【在配置文件中采用 “USE_MATHJAX = YES” 可以调用 mathjax 渲染公式得到更好的视觉效果】 1.5 列表 Doxygen 还有大量用法可供用户生成理想的文档。 对齐的 '-', '+' 或 '*' 可自动生成列表 (bullet list)；'-#'则可用来生成带序号的列表： /** * @brief A class that represents * a circle. * * This toy class will be used to demonstrate the usage of Doxygen * * List of functionalities: * -# initialize a Circle object with a given radius * - a unit circle is assumed by default * -# get the radius of the current Circle object * -# get the area of the current Circle object * -# get the circumference of the current Circle object * -# rescale a Circle object by a factor * */ class Circle */ */ 1.6 Member Group & Module 变量或函数可以由 @{ ... ``@} 归类为 member group 并附上相应注释，这能使文档更有层次感： ///@{ @name Properties /// Functions that return the properties of the current Circle object. /// Gets the radius of the current Circle object. double radius() const { return r_; } /*! * @brief Returns the area of the current Circle object. * * The area of the a circle is given by * * \\f[ S = \\pi r^2 \\f] */ double area() const; /*! * @brief Returns the circumference of the current Circle object. * * The circumference of the a circle is given by * * \\f{eqnarray*}{ * L &= \\pi d \\\\ * &= 2 \\pi r * \\f} * */ double circumference() const; ///@} 有共性的类之间亦可归类组成 Modules: /// @defgroup shape Shape Module /// @brief A module that contains various shape classes. /// /// This module contains the following classes: /// - Circle /// - Rectangle /// - Triangle /// @addtogroup shape /// @{ class Circle { ... }; ///@} /// @addtogroup shape /// @{ class Rectangle { ... }; ///@} /// @addtogroup shape /// @{ class Triangle { ... }; ///@} 更多用法可参考官方文档 Doxygen Manual: Overview 2. 如何生成文档 上一节介绍了 Doxygen 支持的注释格式以及一些常见的使用方式。以下以 Ubuntu 用户为例介绍让开发者在本地生成 html 文档的方法： 1. 安装 doxygen 与 graphviz sudo apt install doxygen graphviz 2. 生成 Doxygen 的配置文件 doxygen -g 默认的配置文件名为 Doxyfile。 3. 修改配置文件 配置文件内已经包含介绍各选项的注释。常用的选项包括： INPUT：用以生成文档的文件夹或文件路径 RECURSIVE：是否遍历给定路径下的所有子文件夹 EXCLUDE：是否要排除一些子文件夹或子文件 EXTRACT_PRIVATE, EXTRACT_STATIC, EXTRACT_PRIV_VIRTUAL：文档是否要包括私有成员/静态成员/私有虚函数 CALL_GRAPH, CALLER_GRAPH: 文档是否要包含函数调用/被调图 PREDEFINED：预编译宏 MACRO_EXPANSION：是否要展开宏定义 EXPAND_ONLY_PREDEF：是否只展开 PREDEFINED 的宏定义 一个可供参考的 Doxyfile 可见于 Doxygen 使用 （赵天琦） 完整的配置选项可参考官网 Doxygen Manual: Configuration 4. 运行 doxygen 假设配置文件叫 my_doxyfile： doxygen my_doxyfile 附录：Doxygen 与 VS Code Visual Studio Code 上有 doxygen 插件 Doxygen Documentation Generator - Visual Studio Marketplace 可供 VS Code 用户方便使用。 【注：前文中有提到对 doxygen 而言三种基本注释格式可以混用；混用的注释会合并在一起作用于注释后的对象。这个特性与 VS Code 中鼠标悬停于类或函数上时出现的预览窗口不兼容；如注释格式混用则会导致前一种格式的注释被忽略】 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-input.html":{"url":"develop-input.html","title":"ABACUS 线上文档输入参数撰写规范","keywords":"","body":"ABACUS 线上文档输入参数撰写规范 作者：刘建川，邮箱：liujianchuan2013@163.com 审核：陈默涵，邮箱：mohanchen@pku.edu.cn；韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 最后更新时间：2023/10/03 一、背景 ABACUS 代码仓库地址：https://github.com/deepmodeling/abacus-develop ABACUS 线上文档地址：https://abacus.deepmodeling.com/en/latest/ （ ABACUS 线上文档是包括开发者在内的所有用户了解 ABACUS 软件使用方法的重要渠道。） 本文档关注：“关键字”部分的文档 对应的文档地址：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html 对应的代码地址：https://github.com/deepmodeling/abacus-develop/blob/develop/docs/advanced/input_files/input-main.md 更新方式：目前对该文档的更新同样是通过 PR 的方式提交到 ABACUS 的 Github 仓库上，因此任何人都可以通过提交 PR 的方式对文档做出修改，我们也鼓励用户如果发现问题后可以主动修复文档。 二、规范格式 每个输入参数都应遵循以下格式： Name of Parameter Type: Availability: (可选) Description: Default: Unit: (可选) Example: (可选) 按照上述顺序排列，上述所有字段需加粗，后面使用英文冒号（不加粗），冒号后空一格开始写内容（不加粗） 上述关键字用黑色实心圆，关键字后的介绍不用加粗 错误示范：Type:Integer 错误示范：Type: integer 错误示范：Type: integer 正确示范：Type: Integer 错误示范：Default: 0 错误示范: Default: false 正确示范：Default: False 1. Name of Parameter 这个参数代表了参数的名称，建议起参数名称的时候遵从以下规范（xxx 由设定参数名的开发者指定）： 输出某物理量的参数：建议以 out_xxx 为参数名，其中 out 是 output 的缩写。可参考的变量名有 out_chg（输出电荷密度），out_pot（输出势函数），out_dm（输出密度矩阵 density matrix） 收敛阈值相关参数：建议以 xxx_thr 为参数名，其中 thr 是 threshold 的缩写。可参考的变量名有 scf_thr（电子自洽迭代的收敛阈值），force_thr（结构弛豫时原子中的最大受力域值），和 stress_thr(晶格优化时的应力收敛阈值) 计算某物理量的参数：建议以 cal_xxx 为参数名，其中 cal 是 calculate 的缩写 初始化某物理量的参数：建议以 init_xxx 为参数名，其中 init 是 initialize 的缩写。可参考的变量名有 init_wfc（初始化波函数）, init_chg（初始化电荷密度）, init_vel（初始化原子速度） 结构弛豫相关参数：建议以 relax_xxx 为参数名，其中 relax 代表（结构）弛豫 并行策略相关参数：建议以 xxxpar 为参数名，其中 par 是代表 parallel，即并行。可参考的变量名有 kpar（k 点并行），bndpar（能带并行） 其它参数：建议先寻找 ABACUS 目前支持的参数名来设计相关参数 2. Type Type：冒号之后首字母大写，输入参数的种类，有 Integer，Real 和 String 三种类型。对于 Boolean 类型，Default 字段后的内容统一写：True 或 False（首字母大写），且先写 True，再写 False 注意 Real 类型不要写成 double 或者 float 类型 3. Availability（Optional） 如果是完整的一句话就首字母大写，如果是单词或短语就小写 4. Description 冒号之后首字母大写 如果有 Note 的标注，可在 Description 字段下，单独写一个 Note，不用加粗。 Description 字段里如果有涉及到 1 和 0 是表示 True 或 False，统一改成 True 或 False。 字段如果是完整句子，末尾要加英文句号：\".\"，若是单词和短语则不加。其他字段均不加。 String 类型的参数 直接列出所有选项 当一个参数有多种取值时，按照从小到大顺序描述不同的取值，例如 propagator 这个参数，就在 description 里面描述参数是 0，1，2 三种情况下的波函数演化方法。 不写“when set to”、“if set to”，直接写参数后，再写该参数的描述 5. Default 参数默认的数值，分成有单位的和没有单位的两种。如果是小数，建议采用科学计数法表示，“e”一律小写，如: 2e-6 6. Unit（Optional） 如有需要使用 Unit 来标定输入参数的单位，紧接在 Unit 后面描述单位，另外内容里如果涉及到写单位，需要用空格隔开，如：U (eV) 单位撰写需符合标准： 错误示范：KBar 错误示范：ev 正确示范：kbar 正确示范：eV 7. Example（Optional） 如有案例，可添加相关例子的链接和简单描述。如果需要，可以添加上述的 Example 字段描述案例。 三、其他问题 所有简写应该大写，以及后面用括号写出全称，每一个关键字的描述出现了简写均需要写全称，如:“soc”改成“SOC（spin-orbital-coupling）”。即使最常见的如 PW、MD 等也均写出全称 对参数的描述保持客观，如：不写“An important parameter”这种话 相关的参数建议放在文档上靠近的地方。举例：symmetry 参数是控制是否打开对称性操作的参数，而 symmetry_prec 是用来控制对称性操作的精度，这两个参数就可以放在一起先后介绍，并且在介绍的时候，可以提及相关的参数 一些太长的输出，单独开辟一个专区去介绍 如关键字告诉了用户输出了文件，建议告诉用户文件名称和文件保存的路径 注意语法问题 标点符号格式要一致 注意不要出现乱码 以上若有问题或者建议，欢迎写信给作者！虽然我们邮箱基本不会收到类似邮件，但开源精神的意义就在于提供了这种可能性，然后坚信更好的事情会到来。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-rule.html":{"url":"develop-rule.html","title":"ABACUS 代码存放规范","keywords":"","body":"ABACUS 代码存放规范 作者：路登辉，邮箱：denghuilu@pku.edu.cn；赵天琦，邮箱：zhaotq13@tsinghua.org.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/11/09 一、背景 截止到 ABACUS 3.4 版本，ABACUS 的 Github 仓库（https://github.com/deepmodeling/abacus-develop）代码已超过 30万 行，涉及上千个源代码文件，有时一周内在 Github 仓库上就会 Merge 近 20 个 PR，涉及数千乃至上万行代码的修改。随着社区规模不断壮大，为了更好的在各个开发者之间协同合作，在过去已有的一些代码管理的共识的基础上，我们提出这个代码存放规范文档。 二、代码目录 进入主仓库之后，ABACUS 的源代码目录位于 source 文件夹下： $ tree source -d -L 1 source ├── module_base #基础模块 ├── module_basis #LCAO和PW基组模块 ├── module_cell #晶胞模块 ├── module_elecstate #电子波函数相关性质模块 ├── module_esolver #能量求解器模块 ├── module_hamilt_general #对于PW和LCAO基组共享的哈密顿量模块 ├── module_hamilt_lcao #LCAO基组下哈密顿量的相关模块 ├── module_hamilt_pw #PW基组下哈密顿量求解的相关模块 ├── module_hsolver #对角化求解矩阵特征值/特征向量等哈密顿求解器模块 ├── module_io #输入输出模块 ├── module_md #分子动力学模块 ├── module_psi #波函数模块 ├── module_relax #结构优化模块 ├── module_ri #Resolution of identity相关的Beyond DFT的模块 其中，14 个主模块的核心功能如上面注释所言，代码存放建议按照模块化管理，相关功能的代码存放到对应的模块当中。如果需要涉及到新建模块以及更新模块位置等需求，应该按照 ABACUS 的 Github 仓库 Issues 处理流程 · GitBook 中相关规范要求去 Github 仓库提交 ISSUE 并邀请开发者讨论来进行。 2.1 模块内部代码存放规范 以 module_base 目录为例，该目录下包含了 ABACUS 中内存管理，错误处理，基础通讯以及基础算法等等功能的代码实现，是 ABACUS 中最底层的代码，其他模块大多依赖于 module_base。该模块中的代码分布如下，相应文件夹功能如注释所言： $ tree source/module_base -d -L 1 source/module_base CMakeLists.txt ├── abfs-vector3_order.cpp #基础代码 ├── abfs-vector3_order.h #基础代码 ├── ... ├── CMakeLists.txt #负责module_base中cmake编译的CMakeLists.txt ├── kernels #module_base中的异构计算代码 ├── libm #libm模块，包含一些优化过后的数学库运算 ├── module_container #ABACUS中底层容器Tensor的实现 ├── module_mixing #charge-mixing实现 ├── test #module_base中的单元测试 ├── test_parallel #module_base中并行相关的单元测试 ├── ... ├── ylm.cpp #基础代码 └── ylm.h #基础代码 我们提出如下的模块代码存放规范： 基础代码存放规范：模块中的基础代码（除去部分特殊代码外的大部分代码）应直接存放到当前模块目录下，头文件以 .h 命名；源文件以 .cpp 命名；代码规范应该遵循 ABACUS 开源项目 C++ 代码规范 · GitBook 中的要求。 异构计算代码存放规范：模块中涉及到异构计算（CPU 结合GPU计算）部分的代码应直接存放于当前模块的 kernels 目录下；这部分代码的结构将会在稍后详细介绍。 子模块代码存放规范： 在主模块下同样可能存在一些子模块，它们通常是具有特定功能的代码的集合：以 module_base 举例，libm，module_container 以及 module_mixing 分别表示了 libm 模块（后续建议改成 module_libm 模块），ABACUS 中底层 Tensor 容器模块（用来方便在不同硬件上存放数据）以及 charge-mixing 相关的功能模块，它们为 module_base 模块下的子模块，子模块中同样也可能有类似于主模块的文件代码排布。 如果要在当前模块中新建或者调整子模块应当去 Github 仓库提交相关的 ISSUE 讨论。 单元测试代码存放规范： 模块中代码的单元测试应当存放到当前模块的 test 目录下，特殊情况可以存放到以 test 开头的目录下面。例如，test_parallel 存放了一些并行计算的单元测试，因为 test 目录下面的 CMakeList 文件有时候会把 MPI 宏定义去除，再比如 test_mpi 里面只测试了 mpi 代码，没有打开 OPENMP。module_base 下面还有一个针对数值精度的测试，命名成了 test_precision。 当前模块的子模块的单元测试应当存放到相应子模块的 test 目录下； CMakeLists.txt 存放规范：各个模块以及子模块通过各自目录中的 CMakeLists.txt 管理 CMake 编译结构，添加或修改代码要注意维护 CMake 编译的完备性，此外还应该维护 Makefile 编译的实现，确保代码可以通过 Github 的 CI 测试。 2.2 异构计算代码存放规范 当前 ABACUS 中 PW 部分代码已经实现了初步的 GPU 化，Source 目录中包含 GPU 的 module 如下，相应文件夹功能如注释所言： ├── module_base #基础模块 │ ├── kernels #module_base模块下的异构计算代码 │ │ ├── cuda #module_base/kernels中函数的CUDA实现 │ │ ├── rocm #module_base/kernels中函数的ROCm/DCU实现 │ │ └── test #module_base/kernels中函数的单元测试 │ ├── libm #子模块libm │ │ └── test #libm的单元测试 │ ├── module_container #子模块，负责实现ABACUS中的底层Tensor容器 │ │ ├── ATen #定义了Tensor容器的基本实现 │ │ ├── base #定义了一些Tensor对象无关的基础函数 │ │ └── test #module_container的单元测试 │ ├── test #module_base的单元测试 │ │ └── data #module_base的但愿测试依赖的数据 │ └── test_parallel #module_base的并行测试 ├── ... ├── module_elecstate #电子波函数相关性质模块 │ ├── kernels #module_elecstate中相关的异构计算代码 │ │ ├── cuda │ │ ├── rocm │ │ └── test │ ├── module_charge #charge子模块 │ ├── module_dm #dm子模块 │ │ └── test #module_dm的单元测试 │ ├── potentials #potentials子模块 │ ├── test #module_elecstate中的单元测试 │ │ └── support #放置单元测试需要的输入文件 │ └── test_mpi #只测试mpi并行代码的单元测试 ├── ... ├── module_hamilt_pw #PW基组下哈密顿量求解的相关模块 │ ├── hamilt_ofdft #OFDFT子模块 │ ├── hamilt_pwdft #PWDFT子模块 │ │ ├── kernels │ │ ├── operator_pw │ │ └── test │ └── hamilt_stodft ├── module_hsolver #对角化求解矩阵特征值/特征向量的模块 │ ├── genelpa │ ├── kernels │ │ ├── cuda │ │ ├── rocm │ │ └── test │ └── test ├── ... ├── module_psi #波函数存储模块 │ ├── kernels │ │ ├── cuda │ │ ├── rocm │ │ └── test │ └── test │ └── support └── ... 为了更进一步的规范异构计算代码在 ABACUS 中的维护和管理，以 module_base/kernels 举例，针对异构计算代码的位置和目录结构做出如下规范： module_base/kernels/ ├── cuda #存放算子的CUDA实现 │ └── math_op.cu #算子的CUDA实现存放于cuda目录下 ├── math_op.cpp #算子的CPU实现 ├── math_op.h #算子的声明 ├── rocm #存放算子的ROCM实现 │ └── math_op.hip.cu #算子的ROCM实现存放于rocm目录下 └── test #提供了算子的单元测试 ├── CMakeLists.txt └── math_op_test.cpp 异构计算代码存放规范：在每个 module 下，异构计算相关的代码都应该存放在 kernels 目录下。异构计算代码都是以算子（OP）的形式存在的，一个算子包含了：CPU，CUDA 以及 ROCM 的实现，使得该算子可以作为统一的计算接口供 ABACUS 调用。 算子的声明和 CPU 实现存放规范：以 module_base 目录举例：module_base/kernels 目录应该直接存放当前 module 中涉及到的异构计算算子的声明 .h 文件和其 CPU 实现 .cpp 文件； 算子的CUDA实现存放规范：kernels 目录下的 cuda 子目录中相应的 .cu 文件存放算子的 CUDA 实现； 算子的 ROCM 实现存放规范：kernels 目录下的 rocm 子目录存放算子的 ROCM 实现； 算子的单元测试存放规范：kernels 子目录下的 test 目录存放当前 kernels 中涉及到的全部算子的单元测试。 三、总结 我们提倡在 ABACUS 中将各个模块的代码按照上述规范建议进行存放，目录结构可以延续上述风格以便代码识别；涉及到代码目录的问题欢迎到 Github 仓库进行讨论交流。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-addinp.html":{"url":"develop-addinp.html","title":"如何在 ABACUS 中新增一个输入参数（截至 v3.5.3）","keywords":"","body":"如何在 ABACUS 中新增一个输入参数（截至 v3.5.3） 作者：周巍青，邮箱：zhouwq@aisi.ac.cn 单位：北京科学智能研究院（AISI） 最后更新日期：2024/2/29 如果遇到本文档无法解决的问题，欢迎给 ABACUS 提出 Issues，我们将持续更新这个文档 在 input 类中申明和定义 1.1 声明 路径：source/module_io/input.h 首先现在input.h中添加相关输入参数的定义，如 nelec_delta： //========================================================== // electrons / spin //========================================================== std::string dft_functional; // input DFT functional. double xc_temperature; // only relevant if finite temperature functional is used int nspin; // LDA ; LSDA ; non-linear spin double nupdown = 0.0; double nelec; // total number of electrons double nelec_delta; // change in the total number of electrons int lmaxmax; 1.2 设置初始值 路径：source/module_io/input.cpp 接下来你需要在 Input::Default(void) 和 Input::Default_2(void) 函数里对参数进行初始化，其中： Input::Default(void)——定义单个变量的初始值 Input::Default_2(void)——根据部分参数的值，对一些有关联的参数重新赋值，如 nelec_delta： //---------------------------------------------------------- // electrons / spin //---------------------------------------------------------- dft_functional = \"default\"; xc_temperature = 0.0; nspin = 1; nelec = 0.0; nelec_delta = 0.0; lmaxmax = 2; 1.3 读取 路径：source/module_io/input.cpp 在 Input::Read() 中定义从 INPUT 文件中读取相应的参数，例如： else if (strcmp(\"nelec_delta\", word) == 0) { read_value(ifs, nelec_delta); } 1.4 MPI 广播 路径：source/module_io/input.cpp 读取完之后，需要定义如何在 Input::Bcast() 将读取的参数广播到所有的节点，原因是 ABACUS 程序从一个进程读入参数，之后通过 MPI 的 Bcast 函数广播到其它的进程。例如： Parallel_Common::bcast_double(nelec_delta); 注意这里你需要根据参数的类型，使用不同的语句： Parallel_Common::bcast_bool(out_wannier_wvfn_formatted); Parallel_Common::bcast_string(dft_functional); Parallel_Common::bcast_double(xc_temperature); Parallel_Common::bcast_int(nspin); 1.5 输出 路径：source/module_io/write_input.cpp ABACUS 会在 Input::Print(const std::string &fn) 中做参数的输出，你也需要在这个函数中进行添加： ModuleBase::GlobalFunc::OUTP(ofs, \"nelec_delta\", nelec_delta, \"change in number of total electrons\"); 1.6 添加测试 路径： source/module_io/test/input_test_para.cpp source/module_io/test/write_input_test.cpp 1.6.1 参数默认值和 MPI 广播的测试 TEST_F(InputParaTest, Bcast) 既测试了初始值的设定，也同样测试了 Bcast 的有效性，你也要将新增参数加入： EXPECT_DOUBLE_EQ(INPUT.nelec_delta, 0.0); 这里同样需要考虑不同的数据类型： EXPECT_TRUE(INPUT.out_wannier_mmn); EXPECT_FALSE(INPUT.out_wannier_unk); EXPECT_DOUBLE_EQ(INPUT.nelec, 0.0); EXPECT_EQ(INPUT.basis_type, \"pw\"); 1.6.2 参数输出的测试 TEST_F(write_input, General1) 测试了 ABACUS 参数输出的正确性，例如： EXPECT_THAT(output, testing::HasSubstr(\"nelec 0 #input number of electrons\")); 这里一定要注意空格和对齐。 将 input 成员转换为全局变量 参数参与计算一般会先转换为全局变量 GlobalV，再通过传参赋值给负责计算的类（但是注意将来我们会逐步弃用 GlobalV，所以这部分将来可能会变化）。 2.1 声明 路径：source/module_base/global_variable.h 在 GlobalV 这个命名空间中申明新增的参数，例如： extern double nelec_delta; 2.2 设置初始值 路径：source/module_base/global_variable.cpp 为 GlobalV::var 设置初始值，例如： double nelec_delta = 0; 2.3 利用 Input 类的成员为 GlobalV 中成员赋值 路径：source/module_io/input_conv.cpp 在 Input_Conv::Convert(void) 中为 Global 的参数赋值，例如： GlobalV::nelec = INPUT.nelec; 注意：Input类一个全局类，只要调用了头文件即可使用。 2.4 添加测试 路径：source/module_io/test/input_conv_test.cpp 在 TEST_F(InputConvTest, Conv) 测试这一转换是否正确，例如： EXPECT_EQ(GlobalV::nelec_delta,0); 添加文档 路径：docs/advanced/input_files/input-main.md 每个新参数的 PR必须包含相应的文档，否则不会被接收。请在 input-main.md 中添加参数描述。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-addinp2.html":{"url":"develop-addinp2.html","title":"如何在 ABACUS 中新增一个输入参数（v3.7.0 后）","keywords":"","body":"如何在 ABACUS 中新增一个输入参数（v3.7.0 后） 作者：刘千锐，邮箱：terry_liu@pku.edu.cn 单位：北京大学 最后更新日期：2024/7/10 如果遇到本文档无法解决的问题，欢迎给 ABACUS 提出 Issues，我们将持续更新这个文档 开发者须知 1.1 声明参数并给出初始值 路径 module_parameter/input_parameter.h 首先现在input_parameter.h中添加相关输入参数的定义，如 nelec_delta： bool init_vel = false; /// 在声明的同时给出默认值，如 nelec 默认为 0.0。 注：对于任何类成员变量的 double, int, bool 等一般类型变量，在定义时就建议给一个初始值。如果类成员没有初始值，很可能会有难以察觉的 bug 注：string类型变量的初始值不能为\"\", 如果想自动设置，可以设置初始值为\"auto\", \"none\"等。 1.2 在参数列表中添加参数 路径 module_io/read_input_item_*.cpp （不同的参数分好了类，其对应不同文件，需要加到属于的文件里面），如 nelec 就在read_input_item_general.cpp中 添加 nelec 参数的 item Input_Item item(\"nelec\"); 之后依次添加：（*为必填） 注释（annotation*）：该注释会被打印在 OUT.*文件夹的 INPUT 中 item.annotation = \"input number of electrons\"; 读入函数（read_value*）：如何通过读入的 vector str_value 转化成想要的 parameter 参数，该函数只有在 INPUT 有相应参数的名字时才会执行。 item.read_value = [](const Input_Item& item, Parameter& para) { para.input.nelec = std::stoi(item.str_values[0]); }; 重新赋值函数（reset_value）：如果其他某些参数满足特定条件是，需要对当前参数（nelec）进行修改的函数，该函数一定会执行。书写规范要求：只把修改当前参数的函数部分定义在当前参数的 reset_value，如果要修改其他参数，请定义在其他参数的 reset_value 。 item.reset_value = [](const Input_Item& item, Parameter& para) { if(para.input.somecondition) { para.input.nelec = 0.0; } }; 检验函数（check_value）：用于检查目前参数是否合适，如果不合适就报错退出（warning_quit），该函数一定会执行。 item.check_value = [](const Input_Item& item, const Parameter& para) { if(para.input.nelec 获取最终打印值函数（get_final_value*）：用于给 stringstream final_value 赋值，最终 final_value.str()会被打印在 OUT.*的 INPUT 文件中，该函数一定会执行。 item.get_final_value = [](Input_Item& item, const Parameter& para) { item.final_value 以及如果是并行版，需要添加广播函数（bcastfuncs*）：如何调用 Parallel_Common 进行 bcast 的函数，该函数一定会执行。该函数不一定只传输该参数，还可以传输其他引入的非 INPUT 参数，例如 gamma_only_local 这个变量不是 INPUT 参数，但是其由 gamma_only 和 basis_type 共同决定取值，这种额外引入的参数也需要在 gamma_only 或 basis_type 处添加他的 bcast 函数。 #ifdef __MPI bcastfuncs.push_back([](Parameter& para) { Parallel_Common::bcast_bool(para.input.nelec); }); #endif 最后将 item 添加到参数列表中： this->add_item(item); 总结： { Input_Item item(\"nelec\"); item.annotation = \"input number of electrons\"; item.read_value = [](const Input_Item& item, Parameter& para) { para.input.nelec = std::stoi(item.str_values[0]); }; item.reset_value = [](const Input_Item& item, Parameter& para) { if(para.input.somecondition) { para.input.nelec = 0.0; } }; item.check_value = [](const Input_Item& item, const Parameter& para) { if(para.input.nelec add_item(item); } 以上是完整的参数添加实例，可以根据需要自己修改函数，然而实际上大部分参数的 bcastfuncs、get_final_value、read_value 函数填写是几乎一致的，他们有共同的形式，为了书写方便，可以利用 module_io/read_input_tool.h 定义的宏函数来进行书写的简化： 1. 对于形如 bcastfuncs.push_back([](Parameter& para) { Parallel_Common::bcast_bool(para.input.nelec); }); 的 bcastfuncs 函数书写可以分别使用 add_double_bcast, add_int_bcast, add_bool_bcast, add_string_bcast, add_doublevec_bcast, add_intvec_bcast, add_stringvec_bcast 函数进行代替 2. 对于形如 item.get_final_value = [](Input_Item& item, const Parameter& para) { item.final_value 的 get_final_value 与 bcastfuncs 函数的合并书写可以使用 sync_double, sync_int, sync_bool, sync_string, sync_doublevec, sync_intvec, sync_stringvec 函数进行代替 3. 对于形如 item.read_value = [](const Input_Item& item, Parameter& para) { para.input.nelec = std::stoi(item.str_values[0]); }; item.get_final_value = [](Input_Item& item, const Parameter& para) { item.final_value 的 read_value, get_final_value 与 bcastfuncs 函数的合并书写可以使用 read_sync_double, read_sync_string, read_sync_int, read_sync_bool 函数进行代替 因此添加 nelec 的代码可以简化成： { Input_Item item(\"nelec\"); item.annotation = \"input number of electrons\"; read_sync_double(nelec); item.reset_value = [](const Input_Item& item, Parameter& para) { if(para.input.somecondition) { para.input.nelec = 0.0; } }; item.check_value = [](const Input_Item& item, const Parameter& para) { if(para.input.nelec add_item(item); 1.2 参数的使用 目前已经舍弃使用 INPUT 与 GloablV::，请勿在里面添加新变量！ 需要用到参数的地方，请以只读的方式使用 int nbands = PARAM.inp.nbands; //只读的访问元素 而其不能作为修改的对象，这时编译不能通过： PARAM.inp.nbands = 0； //会报错 1.3 添加测试 A. 读入测试 路径：source/module_io/test/read_input_pteset.cpp source/module_io/test/support/INPUT 在 INPUT 中添加这一参数： nelec 10 #input number of electrons 在 TEST_F(InputParaTest, ParaRead) 测试这一读入是否正确，例如： EXPECT_EQ(PARAM.inp.nelec, 10); B. 特殊场景的 reset_value 和 check_value 测试 路径：source/module_io/test/read_input_item_test.cpp 在 TEST_F(InputTest, Item_test) 添加特定参数的 reset_value 函数和 check_value 的覆盖性测试。 1.4 添加文档 路径：docs/advanced/input_files/input-main.md 每个新参数的 PR必须包含相应的文档，否则不会被接收。请在 input-main.md 中添加参数描述。 设计文档参考 参考：林霈泽博士提的方案 github.com 2.1 背景 v3.7.0 之前添加参考如何在 ABACUS 中新增一个输入参数（截至 v3.5.3） 2.1.1 原 input.cpp 当添加一个新的 INPUT 参数，我们需在 input 类里做以下事情： A. 首先在 Default 函数中给初始值； B. 再在 read 函数中的 if 中加一个判断分支： if (strcmp(\"suffix\", word) == 0) // out dir { read_value(ifs, suffix); } C. 再在 Bcast 函数中添加 bcast D. （大部分）在 GlobalV 定义一个相同功能的变量，并给个初始值（实际上这个初始值没有任何用，还容易让人误解到底这个和 input.cpp 哪个是初始值） E. 再在 input_conv.cpp 中转化成 GlobalV 的变量 F. 再在 write_input.cpp 添加一行代码使其可以输出到 OUT.ABACUS 文件夹中 INPUT 痛点： 每加一个参数，对于 ABACUS 主代码需“翻山越岭”地添加代码，不易管理 input.cpp 的变量和 GlobalV 的变量大部分重复，没有必要，且容易误解 大量的 if 分支 改进思路： 将相同的参数代码集中起来 input 类只实现读的功能，不存储参数，参数由另一个类存储 2.1.2 GlobalV 其实代码有全局变量不可怕，可怕的是全局变量会在运行中改变，而部分 GlobalV 就是这样，因此需要限制他人在初始化参数之后改变的行为。 目前很多也使用了 public 的类静态成员变量，这其实和全局变量是一样的。 2.2 重构设计 2.2.1 Parameter 类 该类只存储 ABACUS 运行的参数，将代替 GlobalV 的功能，该类将成员设成私有变量，只给 ReadInput 类修改的权限，其他类只有访值权限，没有修改权限： class Parameter { public: Parameter(){}; ~Parameter(){}; public: // We can only read the value of input, but cannot modify it. const Input_para& inp = input; // We can only read the value of mdp, but cannot modify it. const MD_para& mdp = input.mdp; // We can only read the value of other parameters, but cannot modify it. const System_para& globalv = system; // Set the rank & nproc void set_rank_nproc(const int& myrank, const int& nproc); // Set the start time void set_start_time(const std::time_t& start_time); private: // Only ReadInput can modify the value of Parameter. friend class ModuleIO::ReadInput; // INPUT parameters Input_para input; // System parameters System_para system; }; 2.2 Input_Item 类 用于存储 input 参数的信息，每一个参数用 input_item 的一个对象存储，不同 input_item 用 vector 打包。 class Input_Item { public: Input_Item(const std::string& label_in) { label = label_in; } std::string label; /// str_values; /// read_value = [](const Input_Item& item, Parameter& param) {}; /// check value std::function check_value = nullptr; /// reset some values std::function reset_value = nullptr; /// get final_value function for output INPUT file std::function get_final_value = nullptr; // ====== !!! Do not add any more functions here. ====== }; 四个存储的变量： label: 参数的名字 annotation: 参数的注释，用于生成 INPUT 的注释 str_values: 读入的 raw 数据，一个参数可以有多个数据，因此用 vector 存储，例如：kspacing 3 3 3 final_value: 最终的取值，用于生成 INPUT 四个 std::function 成员： read_value（必填）: 当从 INPUT 读入参数后，需要进行的赋值操作 reset_value（选填）: 根据其读入的值，可能会修改其他参数的值时填入，例如 calculation 默认是 scf，当你读入 calculation 是 nscf 后，则需要将 init_chg 改成 file check_value（选填）：根据其读入的值进行判断参数是否合适，例如：读入 ecut 为-100，则需要 warning_quit() get_final_value（大部分必填）：此函数一定会执行（无论是否从 INPUT 读入这个参数），需要在此函数中给出 final_value 的赋值函数，这样用于打印 INPUT 文件 2.2 ReadInput 类 此类只负责读入 INPUT 文件，并赋值给 Parameter 类的对象，此类不负责存储参数 class ReadInput { public: /** * @brief read in parameters from input file * * @param param parameters of ABACUS * @param filename_in read INPUT file name */ void read_parameters(Parameter& param, const std::string& filename_in); /** * @brief write out parameters to output file * * @param param parameters of ABACUS * @param filename_out write output file name */ void write_parameters(const Parameter& param, const std::string& filename_out); private: std::vector> input_lists; //----These functions are done only when INPUT file has them.------ // read value if INPUT file has this item std::vector readvalue_items; /// bcast all values function /// if no MPI, this function will resize the vector std::vector> bcastfuncs; 主要两个 public 函数： read_parameters： 读入 INPUT 文件，赋值给 param write_parameters： 打印 INPUT 文件 3 个 vector: input_lists: 用于存储所有的 Input_Item，用于遍历调用 resetvalue, getfinalvalue readvalue_items: 用于存储读入 INPUT 中相应 Input_Item 指针，并进行读入赋值操作 bcastfuncs: 用于所有参数的 bcast 原则上bcastfuncs也可以用 vector 存储，一方面由于其不依赖 Input_Item，并且可能会 bcast 非 input 列表参数，另一方面但为了访存效率，用 vector存储更好 2.2.1 read_parameters 函数 对于 ReadInput 的 read_parameter，其执行的顺序是: 先确定 INPUT 对应哪些 Input_Item，然后将 INPUT 中读入的信息存入 item 的 str_values 中，之后依次执行 readvalue_items inputlist->resetvalue inputlist->checkvalue bcastfuncs 2.2.2 write_parameters 函数 如果要打印 INPUT，顺序执行 input_lists 的getfinalvalue 然后 for (auto& item: this->input_lists) { Input_Item* p_item = &(item.second); if (p_item->getfinalvalue == nullptr) continue; p_item->getfinalvalue(*p_item, param); ModuleBase::GlobalFunc::OUTP(ofs, p_item->label, p_item->final_value.str(), p_item->annotation); } Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-hetero.html":{"url":"develop-hetero.html","title":"如何在 ABACUS 中进行异构计算","keywords":"","body":"如何在 ABACUS 中进行异构计算 作者：张笑扬，邮箱：2100011024@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2025/03/02 一、前言 异构编程（Heterogeneous Programming）是一种利用不同类型计算单元协同工作来完成计算任务的编程模式。传统的同构系统中，所有计算任务都由单一类型的处理器（如 CPU）完成。但随着计算需求的不断增长，单一类型处理器在处理某些特定任务时效率有限。例如，CPU 虽然具有强大的通用性和控制能力，但在处理大规模并行计算任务时，性能表现不如专门的计算单元。因此，异构系统应运而生，它结合了不同类型的计算单元，如 CPU、GPU（图形处理器）、FPGA（现场可编程门阵列）、ASIC（专用集成电路）等，以充分发挥各计算单元的优势，提高计算效率，这里我们主要讨论 CPU 结合 GPU（或者类似 GPU）的异构编程。 在国产密度泛函理论软件 ABACUS（原子算筹）里，异构的主要对象之一是数学库。近期我们对数学库 blas 的调用进行了封装，相关文件我们称为 blas_connector。blas_connector 得到重构之后（在这个 PR 得到接收之后 https://github.com/deepmodeling/abacus-develop/pull/5799），可以通过直接调用 blas_connector.h 里面提供的算子，配合 device 和 memory 等基础模块即可直接编写异构代码。这套方案比起现在使用的方案来说，希望解决不同模块各自封装的问题，且对于新开发者来说可以避免使用模板和各自封装导致的理解困难。之后会逐渐使用这套方案替换原有的实现，从而实现整体异构方案的统一化与重构。用这种方法去除模板之后，能实现更灵活的计算，后续会用这个方式完成混合精度计算功能的实现。 下文将会介绍如何使用 ABACUS 现有的工具简单的进行异构计算的实现。 二、管理设备类型 ABACUS 目前使用这几种方式进行计算设备的标识。主要记录在 source/module_base/module_device/types.h 文件中。包括 struct 和 enum 两种方式 // !source/module_base/module_device/types.h #ifndef MODULE_TYPES_H_ #define MODULE_TYPES_H_ namespace base_device { struct DEVICE_CPU; struct DEVICE_GPU; struct DEVICE_DSP; enum AbacusDevice_t { UnKnown, CpuDevice, GpuDevice, DspDevice }; } // namespace base_device #endif // MODULE_TYPES_H_ 其中，DEVICE_XXX 是定义为结构体的标识符。这些结构体被作为模板参数使用，在之前是作为 ctx 这种标识符使用，使用方式有些反直觉。 另一个 AbacusDevice_t 就是一个枚举类型变量。是一个很早就出现在 ABACUS 的代码中但是几乎一直没有被使用的数据结构。在重构 blas_connector 之后会逐渐启用，用于提供一个更加简单清晰的设备标识。 除此之外，在 ABACUS 里的有些其他模块会存在自己的设计。如 source/module_basis/module_pw/module_fft/fft_base.h 的 fft 模块中，使用一个字符串来标记设备类型 std::string device = \"cpu\"; //或者是gpu 这个类简单的使用一个字符串来标记 device 类型。本质上和使用 AbacusDevice_t 没有区别。这里建议新开发者如果希望加入新的异构功能，尽量都是用 AbacusDevice_t 来标记。 三、数据内存管理（旧） 由于这些 Operator 的实现存在一些冗余的参数，因此会在近期的 Pull Request 中迎来对应的重构工作。因此暂时不建议使用这里的 Operator 进行内存管理，但是其仍然具有一定参考价值。 3.1 给指针分配内存 注：如果你需要进行大量数据的计算和转移（如需要储存一个矩阵），这里建议使用 ABACUS 提供的 Tensor 数据结构进行计算，见 Tensor 文档。你也可以用这种方式进行异构计算，它会更加灵活，但是你需要自己进行内存管理，防止内存溢出等问题。 现在可用的异构内存工具位于 source/module_base/module_device/memory_op.h 文件中。只需要包含这个头文件即可使用。目前这些算子的使用方式还是以模板为主。我们主要会使用以下 Operator。 template struct resize_memory_op { /// @brief Allocate memory for a given pointer. Note this op will free the pointer first. /// /// Input Parameters /// \\param size : array size /// \\param record_string : label for memory record /// /// Output Parameters /// \\param arr : allocated array void operator()(const Device* dev, FPTYPE*& arr, const size_t size, const char* record_in = nullptr); }; 这个算子的主要作用是给一个指定指针分配内存。你也可以使用这个算子给以及包含了一段数据的指针分配内存，这样的话原来的内存区域会被释放，然后重新分配一段内存。你可以这样使用这个算子 double* ptr = nullptr; base_device::memory::resize_memory_op()(ptr, sizeof(double)); 可以注意到，首先我们有两个模板参数叫 base_device::DEVICE_GPU 和 base_device::DEVICE_CPU，用于决定这个 Operator 会执行在哪个设备上。。 之后我们只要调用这个 Operator 来实现在不同设备分配内存。上文展示了在 CPU 的一个 double 指针上分配一定内存的方法。这个 Operator 的用法是这样的 base_device::memory::resize_memory_op()(pointer, size); 在尖括号模板参数中，TYPE 是需要分配的数据类型，如 float，double，std::complex 等。DEVICE 决定空间会被分配到哪个计算设备上，可以选填 base_device::DEVICE_CPU 或 base_device::DEVICE_GPU。在后面的参数中，pointer 是需要被分配内存的指针，size 是希望分配的空间大小，一般可以用 sizeof(TYPE) * count 的方式指定分配多少个数据。 3.2 初始化一片内存的值 memory_op.h 提供了以下算子来初始化一片内存区域的值 template struct set_memory_op { /// @brief memset for multi-device /// /// Input Parameters /// \\param var : the specified constant value /// \\param size : array size /// /// Output Parameters /// \\param arr : output array initialized by the input value void operator()(FPTYPE* arr, const int var, const size_t size); }; 同样的，可以这样使用这个 Operator base_device::memory::set_memory_op()(pointer, var, size) TYPE：被操作指针的数据类型 DEVICE：计算设备类型，可选 base_device::DEVICE_CPU 或 base_device::DEVICE_GPU pointer：被操作的指针 var：设置内存区域的值，只能为 0 或者-1 size：设置内存区域的大小 注意！由于底层实现的原因，这个算子只能用来将一片内存区域全部设置为 0 或者全部设置为-1，不能用于给这篇内存填充别的特定数值。一般情况下我们也不会需要使用这个来填充别的数值的使用场景。 3.3 在不同设备间转移数据 memory_op.h 提供了以下算子来在不同设备间转移数据 template struct synchronize_memory_op { /// @brief memcpy for multi-device /// /// Input Parameters /// \\param arr_in : input array /// \\param size : array size /// /// Output Parameters /// \\param arr_out : output array initialized by the input array void operator()(FPTYPE* arr_out, const FPTYPE* arr_in, const size_t size); }; template struct cast_memory_op { /// @brief memcpy for multi-device /// /// Input Parameters /// \\param arr_in : input array /// \\param size : array size /// /// Output Parameters /// \\param arr_out : output array initialized by the input array void operator()(FPTYPE_out* arr_out, const FPTYPE_in* arr_in, const size_t size); }; 这个算子的作用是在不同计算设备间转移数据。其中 synchronize_memory_op 会转移同种数据类型的数据，cast_memory_op 可以在设备间转移不同类型的数据，但是效率可能稍低。这个算子可以这么使用 base_device::memory::synchronize_memory_op(pointer_out, pointer_in, size); 这个函数会将 pointer_in 长度为 size 的内容拷贝到 pointer_out。要求这两个指针的数据类型 TYPE 要相同。如果选在相同的 DEVICE_OUT 和 DEVICE_IN，会在同一个计算设备上的两个指针之间移动数据，也就是起到一个拷贝的作用。 TYPE：被操作指针的数据类型 DEVICE_OUT：拷贝的目标计算设备类型，可选 base_device::DEVICE_CPU 或 base_device::DEVICE_GPU DEVICE_IN：被拷贝的计算设备类型，可选 base_device::DEVICE_CPU 或 base_device::DEVICE_GPU pointer_in：被拷贝的指针 pointer_out：拷贝的目标指针 size：拷贝内存区域的大小 另一个算子使用方法类似，但是会提供一个类型转换 base_device::memory::cast_memory_op(pointer_out, pointer_in, size); TYPE：被操作指针的数据类型 DEVICE_OUT：拷贝的目标计算设备类型，可选 base_device::DEVICE_CPU 或 base_device::DEVICE_GPU DEVICE_IN：被拷贝的计算设备类型，可选 base_device::DEVICE_CPU 或 base_device::DEVICE_GPU pointer_in：被拷贝的指针 pointer_out：拷贝的目标指针 size：拷贝内存区域的大小 使用这两个算子可以将 CPU 上的数据拷贝到 GPU 上，或者将 GPU 数据转移到 CPU 上。也可以在同一设备上使用实现内存区域的拷贝。 3.4 删除内存区域 为了防止内存溢出，一定要记得在开辟内存区域最后删除。在 memory_op.h 提供了以下算子来释放内存空间 template struct delete_memory_op { /// @brief free memory for multi-device /// /// Input Parameters /// \\param arr : the input array void operator()(const Device* dev, FPTYPE* arr); }; 这个使用方式非常简单，只需要 base_device::memory::delete_memory_op()(pointer); TYPE：被操作指针的数据类型 DEVICE：计算设备类型，可选 base_device::DEVICE_CPU 或 base_device::DEVICE_GPU pointer：需要删除内存区域的指针 3.5 使用别名 在一般使用的时候，为了避免算子名称过长导致的代码可读性下降，我们一般使用关键字 using 来缩短对应模板函数的名称，如 using resmem_sh_op = base_device::memory::resize_memory_op; // Then you can directly using resmem_sh_op to resize memory 在 memory_op.h 中，已经做好了大量这种定义 using resmem_sh_op = base_device::memory::resize_memory_op; using resmem_dh_op = base_device::memory::resize_memory_op; using resmem_ch_op = base_device::memory::resize_memory_op, base_device::DEVICE_CPU>; using resmem_zh_op = base_device::memory::resize_memory_op, base_device::DEVICE_CPU>; using resmem_sd_op = base_device::memory::resize_memory_op; using resmem_dd_op = base_device::memory::resize_memory_op; using resmem_cd_op = base_device::memory::resize_memory_op, base_device::DEVICE_GPU>; using resmem_zd_op = base_device::memory::resize_memory_op, base_device::DEVICE_GPU>; using setmem_sh_op = base_device::memory::set_memory_op; using setmem_dh_op = base_device::memory::set_memory_op; using setmem_ch_op = base_device::memory::set_memory_op, base_device::DEVICE_CPU>; using setmem_zh_op = base_device::memory::set_memory_op, base_device::DEVICE_CPU>; using setmem_sd_op = base_device::memory::set_memory_op; using setmem_dd_op = base_device::memory::set_memory_op; using setmem_cd_op = base_device::memory::set_memory_op, base_device::DEVICE_GPU>; using setmem_zd_op = base_device::memory::set_memory_op, base_device::DEVICE_GPU>; using delmem_sh_op = base_device::memory::delete_memory_op; using delmem_dh_op = base_device::memory::delete_memory_op; using delmem_ch_op = base_device::memory::delete_memory_op, base_device::DEVICE_CPU>; using delmem_zh_op = base_device::memory::delete_memory_op, base_device::DEVICE_CPU>; using delmem_sd_op = base_device::memory::delete_memory_op; using delmem_dd_op = base_device::memory::delete_memory_op; using delmem_cd_op = base_device::memory::delete_memory_op, base_device::DEVICE_GPU>; using delmem_zd_op = base_device::memory::delete_memory_op, base_device::DEVICE_GPU>; using syncmem_s2s_h2h_op = base_device::memory::synchronize_memory_op; using syncmem_s2s_h2d_op = base_device::memory::synchronize_memory_op; using syncmem_s2s_d2h_op = base_device::memory::synchronize_memory_op; using syncmem_d2d_h2h_op = base_device::memory::synchronize_memory_op; using syncmem_d2d_h2d_op = base_device::memory::synchronize_memory_op; using syncmem_d2d_d2h_op = base_device::memory::synchronize_memory_op; using syncmem_c2c_h2h_op = base_device::memory::synchronize_memory_op, base_device::DEVICE_CPU, base_device::DEVICE_CPU>; using syncmem_c2c_h2d_op = base_device::memory::synchronize_memory_op, base_device::DEVICE_GPU, base_device::DEVICE_CPU>; using syncmem_c2c_d2h_op = base_device::memory::synchronize_memory_op, base_device::DEVICE_CPU, base_device::DEVICE_GPU>; using syncmem_z2z_h2h_op = base_device::memory::synchronize_memory_op, base_device::DEVICE_CPU, base_device::DEVICE_CPU>; using syncmem_z2z_h2d_op = base_device::memory::synchronize_memory_op, base_device::DEVICE_GPU, base_device::DEVICE_CPU>; using syncmem_z2z_d2h_op = base_device::memory::synchronize_memory_op, base_device::DEVICE_CPU, base_device::DEVICE_GPU>; using castmem_s2d_h2h_op = base_device::memory::cast_memory_op; using castmem_s2d_h2d_op = base_device::memory::cast_memory_op; using castmem_s2d_d2h_op = base_device::memory::cast_memory_op; using castmem_d2s_h2h_op = base_device::memory::cast_memory_op; using castmem_d2s_h2d_op = base_device::memory::cast_memory_op; using castmem_d2s_d2h_op = base_device::memory::cast_memory_op; using castmem_c2z_h2h_op = base_device::memory:: cast_memory_op, std::complex, base_device::DEVICE_CPU, base_device::DEVICE_CPU>; using castmem_c2z_h2d_op = base_device::memory:: cast_memory_op, std::complex, base_device::DEVICE_GPU, base_device::DEVICE_CPU>; using castmem_c2z_d2h_op = base_device::memory:: cast_memory_op, std::complex, base_device::DEVICE_CPU, base_device::DEVICE_GPU>; using castmem_z2c_h2h_op = base_device::memory:: cast_memory_op, std::complex, base_device::DEVICE_CPU, base_device::DEVICE_CPU>; using castmem_z2c_h2d_op = base_device::memory:: cast_memory_op, std::complex, base_device::DEVICE_GPU, base_device::DEVICE_CPU>; using castmem_z2c_d2h_op = base_device::memory:: cast_memory_op, std::complex, base_device::DEVICE_CPU, base_device::DEVICE_GPU>; 在这个命名中，s,d,c,z 分别代表 float,double,std::complex,std::complex 这四种数据类型。而 h 代表 host，一般都指的是 CPU，d 代表 device，一般都指 GPU。 所以一个名为 syncmem_s2s_h2d_op 的别名指的是一个将 float 转换为 float（s2s），将数据从 CPU 拷贝到 GPU（h2d）的 synchronize_memory_op。 四、数据内存管理（新） 在 Pull Request https://github.com/deepmodeling/abacus-develop/pull/5861 合并之后，添加了直接进行内存管理的函数。这些函数本质上是对上述算子的封装，但是使用它可以使代码更加清晰，且避免了增加重构工作的工作量。因此建议使用这些函数进行内存管理。 4.1 给指针分配内存 template void resize_memory(FPTYPE* arr, const size_t size, base_device::AbacusDevice_t device_type = base_device::AbacusDevice_t::CpuDevice); 直接调用这个函数即可给指针 arr 分配内存。FPTYPE 可为包括 float, double, std::complex和 std::complex的任意数据类型。device_type 可选 base_device::AbacusDevice_t::CpuDevice 或者 base_device::AbacusDevice_t::GpuDevice。 4.2 初始化一片内存的值 template void set_memory(FPTYPE* arr, const int var, const size_t size, base_device::AbacusDevice_t device_type = base_device::AbacusDevice_t::CpuDevice); 直接调用这个函数即可给指针 arr 管理的一片内存区域初始化值。 其中，var 是需要赋的数值，只能为 0 或者-1！size 是这片内存区域的长度。device_type 可选 base_device::AbacusDevice_t::CpuDevice 或者 base_device::AbacusDevice_t::GpuDevice。 注意！由于底层实现的原因，这个算子只能用来将一片内存区域全部设置为 0 或者全部设置为-1，不能用于给这篇内存填充别的特定数值。一般情况下我们也不会需要使用这个来填充别的数值的使用场景。 4.3 在不同设备间转移数据 有如下两个函数可以用于在不同设备间转移数据。 template void synchronize_memory(FPTYPE* arr_out, const FPTYPE* arr_in, const size_t size, base_device::AbacusDevice_t device_type_out, base_device::AbacusDevice_t device_type_in); template void cast_memory(FPTYPE_out* arr_out, const FPTYPE_in* arr_in, const size_t size, base_device::AbacusDevice_t device_type_out, base_device::AbacusDevice_t device_type_in); 其中，synchronize_memory 负责转移同类型数据，cast_memory 可以转移不同类型的数据。 arr_out 是转移数据的目标指针，arr_in 是转移数据的原始指针。size 是转移数据的长度。 device_type_out 是目标设备类型，可选 base_device::AbacusDevice_t::CpuDevice 或者 base_device::AbacusDevice_t::GpuDevice。 device_type_in 是数据原本储存区域的设备类型，可选 base_device::AbacusDevice_t::CpuDevice 或者 base_device::AbacusDevice_t::GpuDevice。 如果 device_type_out 和 device_type_in 相同的话，则是进行一次简单的数据拷贝工作。 4.4 删除内存区域 为了防止内存溢出，一定要记得在开辟内存区域最后删除。只需要简单的执行这个函数即可 emplate void delete_memory(FPTYPE* arr, base_device::AbacusDevice_t device_type = base_device::AbacusDevice_t::CpuDevice); 这个函数会删除指定设备上的 arr 指针的内存区域。 五、执行数学计算 现在可以直接调用 Blas_connector 进行异构计算。只需要包含 source/module_base/blas_connector.h 这个头文件即可。 在 blas_connector.h 中，链接了 blas 的诸多函数（不建议直接使用），且都实现了对应的异构算子，只需要调整一个参数即可选择对应的异构设备进行计算。 要使用实现好的算子，只需要调用 BlasConnector 命名空间下的算子即可。具体有哪些算子直接查看 source/module_base/blas_connector.h。以最常用的 gemm 为例，这些算子一般是这么构成的 static void gemm(const char transa, const char transb, const int m, const int n, const int k, const float alpha, const float *a, const int lda, const float *b, const int ldb, const float beta, float *c, const int ldc, base_device::AbacusDevice_t device_type = base_device::AbacusDevice_t::CpuDevice); static void gemm_cm(const char transa, const char transb, const int m, const int n, const int k, const float alpha, const float *a, const int lda, const float *b, const int ldb, const float beta, float *c, const int ldc, base_device::AbacusDevice_t device_type = base_device::AbacusDevice_t::CpuDevice); 这个算子前面的所有参数都和标准 blas 算子的参数排列方式相同，只要以相同的方式传入参数即可。注意到最后一个参数是 base_device::AbacusDevice_t 类型的参数，这是一个来自上文所说的 source/module_base/module_device/types.h 的枚举类型，代表使用的计算设备。如果我们需要在 GPU 上调用对应的算子进行计算的话，就这么使用 BlasConnector::gemm(...parameters..., base_device::AbacusDevice_t::GpuDevice); 如果需要在 CPU 上进行计算，只需要把这个参数改成 base_device::AbacusDevice_t::GpuDevice 或者直接空着不写（不建议），因为默认值就是 CPU 参数。 可以注意到，对于相同的算子有时候会有两种类型的封装，其中一种有后缀 _cm，这代表这是一个列优先 的封装，如果没有后缀则为一个行优先 的封装。由于 blas 本身都是基于列优先实现的，所以部分算子可能没有行优先 的封装。 这样你就可以使用上文所述的内存管理工具和 Blas 计算库，在完全不使用专用的异构 API，如 CUDA，来进行异构代码的编写，实现功能在不同的设备上都能够运行。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-formatter2.html":{"url":"develop-formatter2.html","title":"ABACUS formatter-2.0 版本使用说明书","keywords":"","body":"ABACUS formatter-2.0 版本使用说明书 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 最后更新时间：2024 年 7 月 12 日 前言 为系统解决 ABACUS 对输出可读内容到屏幕和文件中的需求，2023 第三季度 ABACUS 开发团队进行了 ABACUS formatter library 1.0 版本的开发。随着后期 ABACUS 各功能的输出需求对 formatter library 的功能要求越来越多样化，我们对 formatter library 代码进行了全面重构，推出了 formatter-2.0 版本。相较于 1.0 版本（ABACUS formatter 库使用说明书），重构进行了大量冗余代码删减，如今已经轻量化成为只具有头文件、有明显“即插即用”性质的工具库。该工具库功能包括简单的字符串格式化、制表和部分 Python 字符串处理函数实现三部分。 字符串格式化 相较于 1.0 版本中只能对字符串加以 1)宽度、2)小数保留位数、3)正负号、4)左右对齐和 5)科学计数法的设定，2.0 版本基于 std::snprintf 函数（见 cppreference：https://en.cppreference.com/w/cpp/io/c/fprintf）实现了对 format string（例如 C++20 支持的 format library：https://en.cppreference.com/w/cpp/utility/format/format）的全面支持（如 %d, %o, %x, %u, %hd, %ld, %lu, %c, %s, %f, %e 等），弃置了基于 stream（iostream, ）的技术路线（见 https://stackoverflow.com/questions/15106102/how-to-use-c-stdostream-with-printf-like-formatting）。 另一方面，std::cout 是在 ABACUS 中最普遍出现，且经常被修改的全局变量。任何不刻意设置便输出的内容都将受到“上一次”对 std::cout 的 IOManipulator 的影响。 然而，使用新版的 formatter 需要注意数据类型，若数据类型出现不匹配，则很可能出现 undefined behavior（例如 issue #4540 中所报道），这一类型要求和 Python 自 3.12 版本开始功能健全且大范围流行和提倡的 f-string 一致。 static format 函数的使用 实际上，由于 formatter library 的轻量化重构，从单元测试中就足以可以明白 formatter library 这一基础函数的使用方法。又因为该函数是类中 static 函数，因此可以随时避免创建类对象而直接使用该函数。基本的使用方法展示在下面： TEST(FormatterTest, FmtCoreStaticFormat) { // const char* std::string result = FmtCore::format(\"Hello, %s!\", \"world\"); // remove the last '\\0' character EXPECT_EQ(result, \"Hello, world!\"); // std::string result = FmtCore::format(\"Hello, %s!\", std::string(\"world\")); EXPECT_EQ(result, \"Hello, world!\"); // int result = FmtCore::format(\"Hello, %d!\", 123); EXPECT_EQ(result, \"Hello, 123!\"); // float result = FmtCore::format(\"Hello, %f!\", 123.456); EXPECT_EQ(result, \"Hello, 123.456000!\"); // char result = FmtCore::format(\"Hello, %c!\", 'a'); EXPECT_EQ(result, \"Hello, a!\"); // invalid format result = FmtCore::format(\"Hello, %z!\", \"world\"); EXPECT_EQ(result, \"Hello, %!\"); // varadic template case result = FmtCore::format(\"Hello, %s, %d, %f, %c!\", \"world\", 123, 123.456, 'a'); EXPECT_EQ(result, \"Hello, world, 123, 123.456000, a!\"); } 下面我们对 ABACUS 中常用于输出的数据类型进行详细举例。 int 类型输出：%d #include \"module_base/formatter.h\" #include std::cout 如果想要修改其宽度，则需要在 d 之前设定数字，如设置宽度为 4： std::cout 如果需要输出左对齐而非右对齐的字符串，则在百分号 % 之后添加负号： std::cout float/double 类型输出：%f 和 %e 对于浮点型数据，最重要的是其是否使用科学计数法、保留位数和宽度各如何。请认真观察如下示例： const double rough_pi = 3.1415926535897932384; std::cout 不难发现如果 f（或者 e）前面只有一个数字，该数字默认为最小宽度。如果在数字前有小数点，则该数字意为保留小数位数，因此 %.0f 将直接对数字取整。 对于需要使用科学计数法的场景，只需要将 f 替换成 e 即可。需要注意的是科学计数法中诸如 e+00 也需要占位 4 个长度，需要在规定字符串输出长度时加以考虑。 std::string 类型输出：%s 对于字符串的输出最简单，另外一个具有相似功能的占位符为 %c，意为为 char 类型在格式化字符串（format string）中占位。 std::cout dynamic format 函数的使用 为应对大批量、重复使用同一 format string 的需求，可以首先建立一个 FmtCore 对象，之后调用对象中的成员函数 format 时，就不需要再每次输入 format string： FmtCore fmt(\"Hello, %s!\\n\"); std::cout 因此在功能角度和 static 函数中的 format 基本无异。单元测试可以辅助理解： TEST(FormatterTest, FmtCoreDynamic) { FmtCore fmt(\"Hello, %s!\"); EXPECT_EQ(fmt.fmt(), \"Hello, %s!\"); std::string result = fmt.format(std::string(\"world\")); EXPECT_EQ(result, \"Hello, world!\"); fmt.reset(\"Hello, %d!\"); EXPECT_EQ(fmt.fmt(), \"Hello, %d!\"); result = fmt.format(123); EXPECT_EQ(result, \"Hello, 123!\"); fmt.reset(\"Hello, %f!\"); EXPECT_EQ(fmt.fmt(), \"Hello, %f!\"); result = fmt.format(123.456); EXPECT_EQ(result, \"Hello, 123.456000!\"); fmt.reset(\"Hello, %c!\"); EXPECT_EQ(fmt.fmt(), \"Hello, %c!\"); result = fmt.format('a'); EXPECT_EQ(result, \"Hello, a!\"); // varadic template case fmt.reset(\"Hello, %s, %d, %f, %c!\"); EXPECT_EQ(fmt.fmt(), \"Hello, %s, %d, %f, %c!\"); result = fmt.format(std::string(\"world\"), 123, 123.456, 'a'); EXPECT_EQ(result, \"Hello, world, 123, 123.456000, a!\"); } 制表功能 formatter-1.0 的另一项亮眼功能为自动制表，在 formatter-2.0 版本中这一 feature 得以保留，并由 1.0 版本的 Table 类重构成为更加轻量级的 FmtTable 类，用于提供想要制作排列整齐的数据表，又不太清楚表格的列宽的场景。 由于 FmtTable 类的设计初衷为”每一个 FmtTable instance“代表了一个 Table，因此在 Table 中设计需要用户提供如下信息： 每列标题，组织成 std::vectorstd::string 每列 format string，组织成 std::vectorstd::string 每列数据 （可选）表中数据与表标题的左右对称 （可选）表格的各个边框 （可选）表格中每列的分隔符 形参表一览 /** * @brief Construct a new Fmt Table object * * @param titles titles, its size should be the same as the number of columns * @param nrows number of rows * @param aligns Alignments instance, can be constructed with initializer_list like {'r', 'c'}, for right and center alignment for values and titles * @param frames Frames instance, can be constructed with initializer_list like {'-', '-', '-', ' ', ' '}, for up, middle, down, left and right frames * @param delimiters Delimiters instance, can be constructed with initializer_list like {'-', ' '}, for horizontal and vertical delimiters */ FmtTable(const std::vector& titles, const size_t& nrows, const std::vector& fmts, const Alignments& aligns = {}, const Frames& frames = {}, const Delimiters& delimiters = {}): titles_(titles), fmts_(fmts), data_(nrows, titles.size()), aligns_(aligns), frames_(frames), delimiters_(delimiters) { assert(titles.size() == fmts.size()); }; 基于 RAII 原则，我们假设需要制表并进行输出的数据经常是已经全部准备好的状态，而非如同 SCF 的迭代信息一样，需要特别估算每列的大致宽度信息。 因此在 FmtTable 构造函数中，我们一定需要 titles, n_rows, fmts，并对 align 和 Delimiter 参数设置了默认值因此并非总是需要。如果想要特殊配置，则可以选择单元测试中例子 https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_base/test/formatter_test.cpp#L323，仿照其进行制表调整。 使用代码示例 除了单元测试（https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_base/test/formatter_test.cpp）外，目前 FmtTable 也已经用于 ABACUS 运行时间统计的输出（https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_base/timer.cpp#L280），但可进一步实现对表中数据区域的每列左右对齐控制。 static Python-style 字符串函数 函数功能简介 C/C++ 的文件读入功能也较为繁琐，尤其涉及需要进行字符串操作时，Python 中 str 的函数则更胜一筹。为了避免每次手动 parse 字符串，又注意到 std::string 同样是 STL 的标准容器，因此对标准容器支持的算法，也都能支持 std::string。目前出于个人使用习惯，实现了下列 Python-style static 函数： split：用于以固定分隔符切割字符串，返回 std::vectorstd::string，但也是因为该返回类型，注定 split 函数不会收录在 STL 中 startswith/endswith：返回 boolean，用于判断字符串是否以给定字符串开始，或者以给定字符串结束。 strip：用于消除出现在字符串行头行尾的空格、回车和\\0 等字符，返回 std::string。 center：为了支持下一步的 ABACUS 输出重构，首先实现 center 函数用于将字符串以某一个宽度居中，两段则填充以 center 函数第一个参数，使得 ABACUS 中所有内容都可以具有给定宽度的输出（即两端对齐） replace：用于消除字符串中存在的所有某个字符 join：split 的反函数 代码示例 以上函数的例子可见单元测试：https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_base/test/formatter_test.cpp Find a bug? Submit issue! 如果在使用 formatter 过程中发现了 bug 或者运行结果不达预期，可以在 deepmodeling/abacus-develop 仓库下提交 issue。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-format.html":{"url":"develop-format.html","title":"ABACUS 中使用格式化工具 clang-format","keywords":"","body":"ABACUS 中使用格式化工具 clang-format 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/10/23 一、引言 良好统一的代码风格在多人协同开发中至关重要，这一点在 ABACUS 团队里也尤其重要，特别是考虑到大部分的开发者都是研究生，没有经过特别系统的编程训练，那么好的代码风格能够降低阅读代码的障碍，加快开发效率，甚至可以防止一些不必要的 bug 的产生。 clang-format 是一个开源的代码格式化工具，它可以帮助程序员自动调整源代码的格式，以符合指定的编码风格规范。clang-format 可以在保持代码功能不变的情况下，自动处理缩进、空格、括号、逗号等细节，提高代码的可读性和一致性。 二、在 ABACUS 中使用 clang-format clang-format 支持包括 LLVM、Google、Chromium、Mozilla、WebKit 等在内的多种代码风格，如果不指定自定义的代码风格，每次对代码进行格式化时使用的将是 clang-format 默认的风格。 clang-format 还支持在已有的代码风格基础之上自定义一个名为 .clang-format 的代码风格文件，clang-format 就可以根据文件中定义的规则对代码进行格式化。 在 ABACUS 开源项目中，开发者已经制定了针对 ABACUS 项目的代码风格文件 .clang-format，其位于项目的根目录下。（https://github.com/deepmodeling/abacus-develop/blob/develop/.clang-format） 注意事项：ABACUS 开源项目中的.clang-format是依赖于 clang-format-14 标准的，因此请确保你的 clang-format 不低于 14 版本。 1. 在系统上安装 clang-format clang-format 有诸多版本可供使用，目前最新版本为 clang-format 18。不同版本所支持的格式化选项不尽相同，但向后兼容。 安装统一版本的 clang-format（ABACUS 项目中统一选择 clang-format-14） # Linux上，以Ubuntu为例： sudo apt install clang-format-14 # 验证是否安装成功，并查看安装的版本号： clang-format-14 --version ⚠ 这里应注意，不能通过 sudo apt install clang-format 命令进行安装，因为对于不同的 Ubuntu 发行版而言，通过该命令安装得到的 clang-format 版本是不同的。 安装完成后，我们能够使用的命令名是 clang-format-14，我们将其提级为 clang-format： sudo update-alternatives --install /usr/bin/clang-format clang-format /usr/bin/clang-format-14 100 后面当我们使用 clang-format 命令时，指代的即为 clang-format-14。 # 此时再次验证安装的版本号：（应为 14 版本） clang-format --version 2. 基于 vscode 使用 clang-format 基于 vscode 使用 clang-format，我们可以选择安装支持 clang-format 的插件，即可更方便的使用 clang-format。 但由于插件商场有很多插件都支持 clang-format 功能，且其支持的 clang-format 版本经常变化。所以我们应尽量选择支持更为稳定的插件进行使用。 通过 vscode 进行 C++ 开发时，我们一般会安装微软官方的 C/C++ 插件，打开该插件的安装目录我们会发现，该插件已经封装了一个内置的 clang-format。那为什么不直接使用这个 C/C++ 插件内置的 clang-format 呢？ 不同版本的 C/C++ 插件内置的 clang-format 版本往往不同，就带来不必要的麻烦。 为了使用统一的 clang-format-14，我们建议在 vscode 中安装 Clang-Format（Xaver Hellauer） 插件 。 安装完成后，打开“File -> Preferences -> Settings”，搜索“format”，如下图： 将 Default Formatter 刚换为新下载的 Clang-Format 插件。 之后在一个文件内，通过 \"option\" + \"shift\" + \"F\" 快捷键，即可实现对当前代码文件的格式化。 3. 基于命令行使用 clang-format 除了使用 vscode ，可能还会有使用命令行进行开发的开发者。 使用方式： clang-format -style=file -i demo.cpp 三、格式化时的注意事项： 由于直接对整个文件格式化会导致每一行的历史修改信息被覆盖，因此我们要求在您修改某文件相应的代码内容之后，先commit一次，然后再对该文件进行格式化，再提交一次专门对文件格式化的commit。 这样细化每一个commit具体的信息，更有利于PR的审核和项目的管理。 四、参考文献： 使用 clang-format 进行 C++ 代码风格管理 Clang-Format 用法详解 Clang-Format Style Options — Clang 14.0.0 documentation C++ programming with Visual Studio Code 基于 vscode 使用 clang-format（旧版） Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-vtune.html":{"url":"develop-vtune.html","title":"性能分析工具：vtune 快速上手教程","keywords":"","body":"性能分析工具：vtune 快速上手教程 作者：邓子超，邮箱：2301213154@pku.edu.cn 最后更新时间：2024 年 7 月 13 日 前言 vtune 是 intel 开发的性能分析工具，可以帮助开发者很方便的找到程序中的热点函数，进而优化程序效率。虽然 ABACUS 自带统计函数运行时间的 timer，但是 ABACUS 的 timer 比较粗糙，它自身会带来很大的运行开销，所以 ABACUS 的 timer 只适合用来看程序中各部分耗时的大概比例，不适合用来对大量调用的单个函数进行细致调优。 安装 下面的介绍都是基于 linux 系统 intel 的 oneapi 中自带了 vtune，如果没有下载 oneapi，可以先到官网下载安装。安装之后在 oneapi 文件夹下可以找到 vtune 的可执行文件： /opt/intel/oneapi/vtune/2024.2/bin64/vtune /opt/intel/oneapi/vtune/2024.2/bin64/vtune-gui 使用 如果配置好了 oneapi 环境，可以直接在命令行输入 vtune-gui 启动 vtune 的图形界面： 创建 Project 进入 vtune 之后先点击左上角的 Project Navigator 右边的 + 号创建一个 project，比如我打算优化格点积分的 fvl 部分，就可以创建一个 project 命名为 gint_fvl。 配置 profile 参数 在右边 Configure Analysis 中配置运行参数，首先要在 Application:中填写可执行文件，这里可以输入 ABACUS 软件地址，也可以自己写一个 ABACUS 运行脚本（感觉这样比较方便配置 openmp 线程数以及 mpi 进程数），脚本记得 chmod +x 加上可执行权限，下面是我自己写的一个简单脚本： #!/bin/bash abacus=\"${1:-abacus}\" cd tests/performance/P102_si64_lcao OMP_NUM_THREADS=12 mpirun -n 2 $abacus cd ../../.. 填完 Application 之后可以在下面的 Application parameter 中填写程序参数。 如果想要得到程序运行的火焰图，需要 在 Advanced 选项里面把”Select finalization mode“设置为”Full“，这里默认设置是”Fast“，默认设置下得不到火焰图 在右边 How 选项中选择\"Hotspot\"的 profile 方式 做完以上配置后，点击右下角的“start”按钮即可开始对程序进行 profile。 结果分析 profile 完成后 vtune 会输出一个程序报告： 报告中内容很多，大家可以自己慢慢探索，下面简单介绍两个比较实用的： 一个是火焰图: 点击其中某个具体函数，可以将更清楚看到这个函数里面每个自函数耗时占比： 第二是双击 Bottom-up 或者 Caller/callee 列出的函数，可以看到函数每行源代码耗时占比： 点击左上角的 Addembly，还可以看到源代码对应的汇编代码： 如果想知道 vtune 更深入用法，可以参考 intel 官方文档。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-linedete.html":{"url":"develop-linedete.html","title":"ABACUS 全局数据结构和代码行数检测","keywords":"","body":"ABACUS 全局数据结构和代码行数检测 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2025/04/01 一、背景 我们将从 ABACUS 的两个主要方面来介绍目前重构还需要进行的工作：一是全局变量和全局类。二是文件的大小和长度。这个文档的主要目的也是要呼吁更多的开发者能够有意识的，主动的对代码目前的一些问题进行重构，这有利于提升代码整体的质量。我们也欢迎更多的开源社区伙伴能够加入进来，提升 ABACUS 代码的质量。 第二部分，我们提供了一个测试 ABACUS 代码关于全局数据结构和代码行数的脚本。 第三部分，我们针对 ABACUS 3.4.2 版本和 3.10.0 版本进行了检测，检测结果和检测时间已列在文档中，可以看到在 3.4.2 版本里 GlobalV 出现了 7972 次，GlobalC 出现了 3504 次。而在 3.10.0 版本里， GlobalV 出现了 2673 次，而 GlobalC 出现了 556 次，在过去几个大版本的持续迭代中，GlobalV 和 GlobalC 的出现频率已经大幅度降低。 希望这个数据能够帮助到想要对代码进行相关重构的同学。我们会隔一段时间后再对本文档进行更新。 全局变量和全局类 ABACUS 代码里长期存在一些全局变量（程序里以 GlobalV：：开头的变量，V 代表 variables）和全局类（程序里以 GlobalC：：开头的类，C 代表 classes）。这里全局的含义说明这些变量和类可以在程序的任何一个角落调用，不需要通过函数的接口传递。 在程序发展早期，使用全局变量和全局类可以加速程序新功能的开发，使得开发者可以快速的调用到想要的模块，例如 ucell 代表原胞信息的类，那么只要需要使用到诸如原子位置和种类等信息，都可以直接调用，就显得很方便。 然而，随着 ABACUS 代码数量的增加，对一些全局变量和全局类不加控制的使用导致了严重的问题，即当某一个全局变量或者全局类被修改之后，会影响大量的代码，从而可能引发不同功能的 bug，另外也会给对全局变量或者全局类修改的开发者带来很多额外的工作量。 大多数的开发者会延用 ABACUS 目前的全局类和全局变量的使用，但我们认为这可能会慢慢的导致 ABACUS 的代码结构越来越变得不可维护，因此有必要做出一些代码结构上的调整甚至重构。 目前 ABACUS 开发团队觉得需要做两件事情来提升代码质量，一方面需要对全局变量和全局类的使用加以控制，不在特殊情况下一般不建议使用。另外一方面，对一些可以不成为全局变量或者全局类的代码加以修改和重构，逐步减少全局变量和全局类的使用次数，通过一些更规范的函数参数传递来进行替代。但是，这项工作涉及到的工作量较大，因此需要逐步的推进完成，甚至依赖开源的力量来推动它完成，从而根本上提升 ABACUS 的代码质量。 代码长度 在 ABACUS 开发的过程中，有些开发者倾向于将同一类功能的代码都放入到同一个代码文件，但后期我们发现如果对这个过程不加以一定条件的约束，会使得代码质量下降。首先，随着程序的不断发展，一个长的代码里可能会有一些代码可以被别的地方重用，但是这部分代码不容易被抽出来。其次，当要对一个长代码里的一些函数进行局部修改时，也会容易使得开发者难以聚焦到一个特定功能代码上。反之，如果把代码尽可能按照“一定的规则”分散开来，例如每个代码文件长度不超过 500 行，那会使得维护和更新变得更容易，因此我们倡导开发者持续的针对代码长度进行重构，目前软件里有不少超过 >500 行的程序。 二、测试脚本 此脚本功能： # --------------1. 计算总代码行数-------------- # --------------2. 统计每个文件夹内 GlobalV 和 GlobalC 出现的次数-------------- # --------------3. 输出行数大于 500 行的文件路径及其行数-------------- import os def count_lines_of_code(file_path): \"\"\" 计算文件的代码行数 :param file_path: 文件路径 :return: 代码行数 \"\"\" with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as file: lines = file.readlines() return len(lines) def count_lines_in_folder(folder_path): \"\"\" 计算文件夹中所有文件的代码行数 :param folder_path: 文件夹路径 :return: 总代码行数 \"\"\" total_lines = 0 for root, dirs, files in os.walk(folder_path): for file in files: # 构建文件的完整路径 file_path = os.path.join(root, file) # 跳过非文本文件 if not file_path.endswith((\".cpp\", \".c\", \".h\")): continue # 计算文件的代码行数并累加到总行数中 lines = count_lines_of_code(file_path) total_lines += lines return total_lines # ---------------------------------------------- def count_globals_in_file(file_path): \"\"\" 统计一个文件中出现了多少次 GlobalV 和 GlobalC :param file_path: 文件路径 :return: {'globalv_count': GlobalV 出现的次数, 'globalc_count': GlobalC 出现的次数} \"\"\" globalv_count = 0 globalc_count = 0 try: with open(file_path, 'r', encoding='utf-8', errors='ignore') as file: content = file.read() globalv_count = content.count('GlobalV') globalc_count = content.count('GlobalC') except FileNotFoundError: print(f\"File not found: {file_path}\") except Exception as e: print(f\"An error occurred: {e}\") return {'globalv_count': globalv_count, 'globalc_count': globalc_count} def count_globals_in_folder(folder_path): \"\"\" 统计一个文件夹中出现了多少次 GlobalV 和 GlobalC :param folder_path: 文件夹路径 :return: {'globalv_count': GlobalV 出现的总次数, 'globalc_count': GlobalC 出现的总次数} \"\"\" globalv_count = 0 globalc_count = 0 for root, dirs, files in os.walk(folder_path): for file in files: # 构建文件的完整路径 file_path = os.path.join(root, file) # 跳过非文本文件 if not file_path.endswith(('.cpp', '.c', '.h')): continue # 调用 count_globals_in_file 函数，统计文件中 GlobalV 和 GlobalC 的出现次数 file_counts = count_globals_in_file(file_path) globalv_count += file_counts['globalv_count'] globalc_count += file_counts['globalc_count'] return {'globalv_count': globalv_count, 'globalc_count': globalc_count} def count_globals_in_subfolders(main_folder_path): \"\"\" 统计一个文件夹内所有子文件夹的 GlobalV 和 GlobalC 出现次数 :param main_folder_path: 主文件夹路径 :return: 字典，包含每个子文件夹的 GlobalV 和 GlobalC 出现次数 \"\"\" subfolder_counts = {} for root, dirs, files in os.walk(main_folder_path): for folder in dirs: folder_path = os.path.join(root, folder) # 调用 count_globals_in_folder 函数，统计子文件夹中 GlobalV 和 GlobalC 的出现次数 folder_counts = count_globals_in_folder(folder_path) subfolder_counts[folder] = folder_counts return subfolder_counts def print_folder_tree_with_counts(folder_path, indent=\"\"): \"\"\" 输出文件夹树结构，同时统计每个文件夹内出现了多少次 GlobalV 和 GlobalC :param folder_path: 文件夹路径 :param indent: 缩进字符串，用于表示层级关系 \"\"\" folder_info = count_globals_in_folder(folder_path) # 输出当前文件夹的名称 print(indent + \"|-- \" + os.path.basename(folder_path)) # 输出当前文件夹内的 GlobalV 和 GlobalC 出现次数 print(indent + f\" GlobalV 出现了 {folder_info['globalv_count']} 次\") print(indent + f\" GlobalC 出现了 {folder_info['globalc_count']} 次\") # 获取文件夹中的所有项目（文件和子文件夹） items = os.listdir(folder_path) for item in items: # 构建项目的完整路径 item_path = os.path.join(folder_path, item) # 检查项目是否是文件夹 if os.path.isdir(item_path): # 递归调用，打印子文件夹的树结构 print_folder_tree_with_counts(item_path, indent + \" \") # 指定文件夹路径 folder_path = \"./abacus-develop/source\" # --------------1. 计算代码行数-------------- # 调用函数，获取文件夹中所有文件的代码行数 total_lines = count_lines_in_folder(folder_path) print(f\"整个文件夹中所有文件总共有 {total_lines} 行代码。\") # --------------2. 统计 GlobalV 和 GlobalC 出现的次数-------------- # 调用函数，输出文件夹树和统计 GlobalV 和 GlobalC 的出现次数 print_folder_tree_with_counts(folder_path) # --------------3. 出文件夹内行数大于 500 行的文件及其行数-------------- def count_lines(file_path): \"\"\" 统计一个文件的行数 :param file_path: 文件路径 :return: 文件的行数 \"\"\" try: with open(file_path, 'r', encoding='utf-8', errors='ignore') as file: lines = file.readlines() return len(lines) except FileNotFoundError: print(f\"File not found: {file_path}\") return 0 except Exception as e: print(f\"An error occurred: {e}\") return 0 def count_lines_in_folder(folder_path): \"\"\" 统计一个文件夹内行数大于 500 行的文件 :param folder_path: 文件夹路径 :return: 文件路径及其行数的字典 \"\"\" files_over_500_lines = {} for root, dirs, files in os.walk(folder_path): for file in files: # 构建文件的完整路径 file_path = os.path.join(root, file) # 跳过非文本文件 if not file_path.endswith(('.txt', '.py', '.java', '.cpp', '.c', '.html', '.css', '.js')): continue # 调用 count_lines 函数，统计文件的行数 lines_count = count_lines(file_path) # 检查行数是否大于 500 if lines_count > 500: files_over_500_lines[file_path] = lines_count return files_over_500_lines # 输入文件夹路径 folder_path = \"./abacus-develop/source\" # 调用函数，获取文件夹内行数大于 500 行的文件 files_over_500_lines = count_lines_in_folder(folder_path) # 出文件夹内行数大于 500 行的文件及其行数 if files_over_500_lines: print(\"行数大于 500 行的文件:\") for file_path, lines_count in files_over_500_lines.items(): print(f\"{file_path}: {lines_count} 行\") else: print(\"文件夹内没有行数大于 500 行的文件。\") import subprocess def get_git_info(folder_path): try: # 获取最新提交的版本号 commit_version = subprocess.check_output(['git', 'rev-parse', 'HEAD'], cwd=folder_path, text=True).strip() # 获取最新提交的时间 commit_time = subprocess.check_output(['git', 'show', '-s', '--format=%ci', 'HEAD'], cwd=folder_path, text=True).strip() # 获取最近一次标签的名称 latest_tag = subprocess.check_output(['git', 'describe', '--tags', '--abbrev=0'], cwd=folder_path, text=True).strip() return commit_version, commit_time, latest_tag except subprocess.CalledProcessError as e: print(f\"Error: {e}\") return None, None, None from datetime import datetime import pytz # 设置时区为东八区（北京时间） beijing_timezone = pytz.timezone('Asia/Shanghai') # 获取当前时间，并设置时区为北京时间 current_datetime_utc = datetime.utcnow() current_datetime_beijing = current_datetime_utc.replace(tzinfo=pytz.utc).astimezone(beijing_timezone) # 格式化输出 formatted_datetime_beijing = current_datetime_beijing.strftime(\"%Y-%m-%d %H:%M:%S\") print(\"东八区时间（北京时间）:\", formatted_datetime_beijing) # 指定要检查的文件夹路径 folder_path = './abacus-develop' # 获取Git信息 commit_version, commit_time, latest_tag = get_git_info(folder_path) if commit_version: print(f\"The latest commit version in the repository is: {commit_version}\") print(f\"The commit time is: {commit_time}\") print(f\"The latest tag is: {latest_tag}\") else: print(\"Failed to retrieve Git information.\") 三、检测结果 v3.4.2 检测结果 整个文件夹中所有文件总共有 324219 行代码。 |-- source GlobalV 出现了 7972 次 GlobalC 出现了 3504 次 |-- module_relax GlobalV 出现了 289 次 GlobalC 出现了 207 次 |-- relax_old GlobalV 出现了 244 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 130 次 GlobalC 出现了 0 次 |-- relax_new GlobalV 出现了 19 次 GlobalC 出现了 200 次 |-- test GlobalV 出现了 3 次 GlobalC 出现了 117 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_io GlobalV 出现了 2022 次 GlobalC 出现了 501 次 |-- test GlobalV 出现了 262 次 GlobalC 出现了 28 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test_serial GlobalV 出现了 20 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_basis GlobalV 出现了 101 次 GlobalC 出现了 7 次 |-- module_pw GlobalV 出现了 3 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 3 次 GlobalC 出现了 0 次 |-- test_serial GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_ao GlobalV 出现了 72 次 GlobalC 出现了 7 次 |-- test GlobalV 出现了 23 次 GlobalC 出现了 0 次 |-- GaAs GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- orb_obj GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- lcao_H2O GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- 1_Documents GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- doxygen GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- sphinx GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- source GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_nao GlobalV 出现了 26 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 17 次 GlobalC 出现了 0 次 |-- module_hamilt_pw GlobalV 出现了 704 次 GlobalC 出现了 620 次 |-- hamilt_pwdft GlobalV 出现了 492 次 GlobalC 出现了 527 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 6 次 GlobalC 出现了 36 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- operator_pw GlobalV 出现了 1 次 GlobalC 出现了 1 次 |-- hamilt_stodft GlobalV 出现了 124 次 GlobalC 出现了 93 次 |-- hamilt_ofdft GlobalV 出现了 88 次 GlobalC 出现了 0 次 |-- module_md GlobalV 出现了 57 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 50 次 GlobalC 出现了 0 次 |-- module_psi GlobalV 出现了 150 次 GlobalC 出现了 24 次 |-- test GlobalV 出现了 48 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 1 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_ri GlobalV 出现了 167 次 GlobalC 出现了 121 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test_code GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_elecstate GlobalV 出现了 896 次 GlobalC 出现了 88 次 |-- module_dm GlobalV 出现了 2 次 GlobalC 出现了 1 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 1 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 337 次 GlobalC 出现了 11 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test_mpi GlobalV 出现了 20 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 2 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- potentials GlobalV 出现了 73 次 GlobalC 出现了 11 次 |-- module_charge GlobalV 出现了 234 次 GlobalC 出现了 32 次 |-- module_cell GlobalV 出现了 885 次 GlobalC 出现了 129 次 |-- test GlobalV 出现了 290 次 GlobalC 出现了 100 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test_pw GlobalV 出现了 8 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_neighbor GlobalV 出现了 75 次 GlobalC 出现了 2 次 |-- test GlobalV 出现了 26 次 GlobalC 出现了 0 次 |-- module_paw GlobalV 出现了 54 次 GlobalC 出现了 2 次 |-- test GlobalV 出现了 3 次 GlobalC 出现了 0 次 |-- module_symmetry GlobalV 出现了 100 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_base GlobalV 出现了 488 次 GlobalC 出现了 1 次 |-- test GlobalV 出现了 74 次 GlobalC 出现了 0 次 |-- data GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test_parallel GlobalV 出现了 153 次 GlobalC 出现了 0 次 |-- module_container GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- ATen GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- ops GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- core GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- base GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- third_party GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- backward-cpp GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- macros GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- utils GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- core GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- libm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 1 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_mixing GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_esolver GlobalV 出现了 775 次 GlobalC 出现了 326 次 |-- test GlobalV 出现了 4 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_hamilt_lcao GlobalV 出现了 1088 次 GlobalC 出现了 1257 次 |-- module_tddft GlobalV 出现了 92 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_deepks GlobalV 出现了 186 次 GlobalC 出现了 2 次 |-- test GlobalV 出现了 67 次 GlobalC 出现了 0 次 |-- doxygen GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- sphinx GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- source GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- hamilt_lcaodft GlobalV 出现了 478 次 GlobalC 出现了 897 次 |-- operator_lcao GlobalV 出现了 8 次 GlobalC 出现了 48 次 |-- test GlobalV 出现了 1 次 GlobalC 出现了 0 次 |-- module_gint GlobalV 出现了 178 次 GlobalC 出现了 213 次 |-- module_hcontainer GlobalV 出现了 6 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 6 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_dftu GlobalV 出现了 142 次 GlobalC 出现了 145 次 |-- module_deltaspin GlobalV 出现了 6 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 4 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_hsolver GlobalV 出现了 154 次 GlobalC 出现了 23 次 |-- test GlobalV 出现了 35 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- genelpa GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_hamilt_general GlobalV 出现了 167 次 GlobalC 出现了 196 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_ewald GlobalV 出现了 19 次 GlobalC 出现了 6 次 |-- module_vdw GlobalV 出现了 2 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 2 次 GlobalC 出现了 0 次 |-- module_xc GlobalV 出现了 80 次 GlobalC 出现了 19 次 |-- test GlobalV 出现了 20 次 GlobalC 出现了 5 次 |-- module_surchem GlobalV 出现了 66 次 GlobalC 出现了 171 次 |-- test GlobalV 出现了 53 次 GlobalC 出现了 137 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 行数大于 500 行的文件: ./abacus-develop/source/module_relax/relax_old/ions_move_cg.cpp: 501 行 ./abacus-develop/source/module_relax/relax_old/test/ions_move_cg_test.cpp: 556 行 ./abacus-develop/source/module_relax/relax_old/test/lattice_change_basic_test.cpp: 526 行 ./abacus-develop/source/module_relax/relax_old/test/lattice_change_cg_test.cpp: 534 行 ./abacus-develop/source/module_relax/relax_new/relax.cpp: 616 行 ./abacus-develop/source/module_io/to_wannier90.cpp: 2091 行 ./abacus-develop/source/module_io/parameter_pool.cpp: 1633 行 ./abacus-develop/source/module_io/write_HS_sparse.cpp: 961 行 ./abacus-develop/source/module_io/numerical_basis.cpp: 792 行 ./abacus-develop/source/module_io/unk_overlap_lcao.cpp: 853 行 ./abacus-develop/source/module_io/cal_r_overlap_R.cpp: 645 行 ./abacus-develop/source/module_io/input.cpp: 4041 行 ./abacus-develop/source/module_io/berryphase.cpp: 717 行 ./abacus-develop/source/module_io/write_dos_lcao.cpp: 669 行 ./abacus-develop/source/module_io/input_conv.cpp: 748 行 ./abacus-develop/source/module_io/winput.cpp: 721 行 ./abacus-develop/source/module_io/write_HS.cpp: 1363 行 ./abacus-develop/source/module_io/test/input_conv_test.cpp: 540 行 ./abacus-develop/source/module_io/test/bessel_basis_test.cpp: 561 行 ./abacus-develop/source/module_io/test/write_input_test.cpp: 916 行 ./abacus-develop/source/module_io/test/input_test.cpp: 1691 行 ./abacus-develop/source/module_basis/module_pw/fft.cpp: 789 行 ./abacus-develop/source/module_basis/module_ao/ORB_atomic_lm.cpp: 772 行 ./abacus-develop/source/module_basis/module_ao/ORB_table_alpha.cpp: 550 行 ./abacus-develop/source/module_basis/module_ao/ORB_gen_tables.cpp: 1015 行 ./abacus-develop/source/module_basis/module_ao/ORB_table_phi.cpp: 880 行 ./abacus-develop/source/module_basis/module_ao/ORB_read.cpp: 589 行 ./abacus-develop/source/module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp: 755 行 ./abacus-develop/source/module_basis/module_ao/test/ORB_atomic_lm_test.cpp: 886 行 ./abacus-develop/source/module_basis/module_nao/beta_radials.cpp: 761 行 ./abacus-develop/source/module_basis/module_nao/test/gaunt.txt: 7242 行 ./abacus-develop/source/module_basis/module_nao/test/numerical_radial_test.cpp: 549 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp: 1841 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/stress_func_nl.cpp: 717 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/wf_atomic.cpp: 755 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/forces.cpp: 1100 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/wavefunc.cpp: 739 行 ./abacus-develop/source/module_hamilt_pw/hamilt_stodft/sto_iter.cpp: 638 行 ./abacus-develop/source/module_md/nhchain.cpp: 873 行 ./abacus-develop/source/module_psi/psi_initializer_nao.cpp: 522 行 ./abacus-develop/source/module_psi/test/psi_initializer_unit_test.cpp: 635 行 ./abacus-develop/source/module_psi/kernels/device.cpp: 654 行 ./abacus-develop/source/module_ri/exx_lip.cpp: 950 行 ./abacus-develop/source/module_elecstate/elecstate_pw.cpp: 527 行 ./abacus-develop/source/module_elecstate/occupy.cpp: 1007 行 ./abacus-develop/source/module_elecstate/module_dm/density_matrix.cpp: 823 行 ./abacus-develop/source/module_elecstate/test/potential_new_test.cpp: 646 行 ./abacus-develop/source/module_elecstate/test/elecstate_base_test.cpp: 699 行 ./abacus-develop/source/module_elecstate/test/support/WAVEFUNC1.txt: 4231 行 ./abacus-develop/source/module_elecstate/module_charge/charge.cpp: 748 行 ./abacus-develop/source/module_elecstate/module_charge/charge_mixing.cpp: 729 行 ./abacus-develop/source/module_cell/read_pp_upf201.cpp: 908 行 ./abacus-develop/source/module_cell/read_atoms.cpp: 1290 行 ./abacus-develop/source/module_cell/unitcell.cpp: 1764 行 ./abacus-develop/source/module_cell/klist.cpp: 1429 行 ./abacus-develop/source/module_cell/test/unitcell_test.cpp: 1573 行 ./abacus-develop/source/module_cell/test/klist_test.cpp: 778 行 ./abacus-develop/source/module_cell/test/read_pp_test.cpp: 705 行 ./abacus-develop/source/module_cell/module_neighbor/sltk_atom_input.cpp: 672 行 ./abacus-develop/source/module_cell/module_neighbor/sltk_grid.cpp: 1109 行 ./abacus-develop/source/module_cell/module_paw/paw_cell.cpp: 668 行 ./abacus-develop/source/module_cell/module_paw/paw_cell_libpaw.cpp: 719 行 ./abacus-develop/source/module_cell/module_symmetry/symmetry.cpp: 2118 行 ./abacus-develop/source/module_cell/module_symmetry/symmetry_basic.cpp: 1166 行 ./abacus-develop/source/module_base/math_sphbes.cpp: 810 行 ./abacus-develop/source/module_base/spherical_bessel_transformer.cpp: 546 行 ./abacus-develop/source/module_base/math_ylmreal.cpp: 706 行 ./abacus-develop/source/module_base/mcd.c: 884 行 ./abacus-develop/source/module_base/ylm.cpp: 1884 行 ./abacus-develop/source/module_base/opt_DCsrch.cpp: 644 行 ./abacus-develop/source/module_base/test/math_chebyshev_test.cpp: 536 行 ./abacus-develop/source/module_base/test/complexmatrix_test.cpp: 588 行 ./abacus-develop/source/module_base/test/global_function_test.cpp: 794 行 ./abacus-develop/source/module_base/test/complexarray_test.cpp: 511 行 ./abacus-develop/source/module_base/test/cubic_spline_test.cpp: 1468 行 ./abacus-develop/source/module_base/test/vector3_test.cpp: 749 行 ./abacus-develop/source/module_base/test/math_ylmreal_test.cpp: 513 行 ./abacus-develop/source/module_base/test_parallel/parallel_reduce_test.cpp: 558 行 ./abacus-develop/source/module_base/module_container/test/tensor_test.cpp: 536 行 ./abacus-develop/source/module_base/module_container/ATen/ops/einsum_op.cpp: 1048 行 ./abacus-develop/source/module_base/libm/sincos.cpp: 1262 行 ./abacus-develop/source/module_esolver/esolver_ks.cpp: 576 行 ./abacus-develop/source/module_esolver/esolver_ks_pw.cpp: 1129 行 ./abacus-develop/source/module_esolver/esolver_ks_lcao_tddft.cpp: 621 行 ./abacus-develop/source/module_esolver/esolver_ks_lcao_elec.cpp: 627 行 ./abacus-develop/source/module_esolver/esolver_ks_lcao.cpp: 970 行 ./abacus-develop/source/module_esolver/esolver_sdft_pw_tool.cpp: 1332 行 ./abacus-develop/source/module_esolver/esolver_of.cpp: 1380 行 ./abacus-develop/source/module_hamilt_lcao/module_tddft/propagator.cpp: 616 行 ./abacus-develop/source/module_hamilt_lcao/module_deepks/LCAO_deepks_pdm.cpp: 824 行 ./abacus-develop/source/module_hamilt_lcao/module_deepks/LCAO_deepks_torch.cpp: 769 行 ./abacus-develop/source/module_hamilt_lcao/module_deepks/test/klist_1.cpp: 604 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/FORCE_k.cpp: 1248 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/wavefunc_in_pw.cpp: 695 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/LCAO_matrix.cpp: 1003 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/LCAO_gen_fixedH.cpp: 1096 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/LCAO_nnr.cpp: 539 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp: 889 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/LCAO_hamilt.cpp: 930 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/operator_lcao/deepks_lcao.cpp: 507 行 ./abacus-develop/source/module_hamilt_lcao/module_gint/gint.cpp: 585 行 ./abacus-develop/source/module_hamilt_lcao/module_gint/gint_k_pvpr.cpp: 702 行 ./abacus-develop/source/module_hamilt_lcao/module_gint/gint_k_sparse1.cpp: 529 行 ./abacus-develop/source/module_hamilt_lcao/module_gint/gint_tools.cpp: 1376 行 ./abacus-develop/source/module_hamilt_lcao/module_gint/grid_technique.cpp: 529 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/hcontainer.cpp: 728 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/transfer.cpp: 671 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/func_transfer.cpp: 663 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/atom_pair.cpp: 737 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/test/test_hcontainer_complex.cpp: 577 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/test/test_hcontainer.cpp: 674 行 ./abacus-develop/source/module_hamilt_lcao/module_deltaspin/spin_constrain.cpp: 547 行 ./abacus-develop/source/module_hsolver/diago_david.cpp: 1080 行 ./abacus-develop/source/module_hsolver/diago_cg.cpp: 641 行 ./abacus-develop/source/module_hsolver/kernels/test/math_kernel_test.cpp: 736 行 ./abacus-develop/source/module_hamilt_general/module_vdw/vdwd3.cpp: 1435 行 ./abacus-develop/source/module_hamilt_general/module_vdw/vdwd3_parameters_tab.cpp: 33131 行 ./abacus-develop/source/module_hamilt_general/module_vdw/test/vdw_test.cpp: 610 行 ./abacus-develop/source/module_hamilt_general/module_xc/xc_functional_gradcorr.cpp: 725 行 ./abacus-develop/source/module_hamilt_general/module_xc/xc_functional_vxc.cpp: 776 行 ./abacus-develop/source/module_hamilt_general/module_xc/test/test_xc2.cpp: 519 行 ./abacus-develop/source/module_hamilt_general/module_xc/test/test_xc.cpp: 922 行 东八区时间（北京时间）: 2023-11-20 11:28:29 The latest commit version in the repository is: baccbe3356f81c9b349582e4b02fd723d77a50d9 The commit time is: 2023-11-17 22:22:05 +0800 The latest tag is: v3.4.2 v3.10.0 检测结果 整个文件夹中所有文件总共有 389895 行代码。 |-- source GlobalV 出现了 2673 次 GlobalC 出现了 556 次 |-- module_md GlobalV 出现了 28 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 24 次 GlobalC 出现了 0 次 |-- module_parameter GlobalV 出现了 2 次 GlobalC 出现了 0 次 |-- module_esolver GlobalV 出现了 197 次 GlobalC 出现了 83 次 |-- test GlobalV 出现了 2 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_relax GlobalV 出现了 173 次 GlobalC 出现了 1 次 |-- relax_old GlobalV 出现了 157 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 80 次 GlobalC 出现了 0 次 |-- relax_new GlobalV 出现了 10 次 GlobalC 出现了 1 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 1 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_ri GlobalV 出现了 8 次 GlobalC 出现了 22 次 |-- test_code GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_exx_symmetry GlobalV 出现了 6 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_hamilt_pw GlobalV 出现了 194 次 GlobalC 出现了 35 次 |-- hamilt_stodft GlobalV 出现了 47 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- hamilt_pwdft GlobalV 出现了 142 次 GlobalC 出现了 35 次 |-- operator_pw GlobalV 出现了 0 次 GlobalC 出现了 1 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 17 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- hamilt_ofdft GlobalV 出现了 5 次 GlobalC 出现了 0 次 |-- module_elecstate GlobalV 出现了 267 次 GlobalC 出现了 28 次 |-- module_dm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_charge GlobalV 出现了 76 次 GlobalC 出现了 7 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- potentials GlobalV 出现了 24 次 GlobalC 出现了 7 次 |-- test_mpi GlobalV 出现了 46 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 61 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_hamilt_lcao GlobalV 出现了 254 次 GlobalC 出现了 97 次 |-- hamilt_lcaodft GlobalV 出现了 67 次 GlobalC 出现了 90 次 |-- operator_lcao GlobalV 出现了 1 次 GlobalC 出现了 29 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 14 次 |-- module_dftu GlobalV 出现了 9 次 GlobalC 出现了 5 次 |-- module_tddft GlobalV 出现了 93 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_hcontainer GlobalV 出现了 6 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 6 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_deepks GlobalV 出现了 40 次 GlobalC 出现了 2 次 |-- sphinx GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- source GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 23 次 GlobalC 出现了 0 次 |-- doxygen GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_deltaspin GlobalV 出现了 7 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_gint GlobalV 出现了 32 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_hamilt_general GlobalV 出现了 44 次 GlobalC 出现了 133 次 |-- module_ewald GlobalV 出现了 7 次 GlobalC 出现了 8 次 |-- module_vdw GlobalV 出现了 2 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 2 次 GlobalC 出现了 0 次 |-- module_xc GlobalV 出现了 5 次 GlobalC 出现了 21 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 5 次 GlobalC 出现了 5 次 |-- module_surchem GlobalV 出现了 30 次 GlobalC 出现了 104 次 |-- test GlobalV 出现了 30 次 GlobalC 出现了 103 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_rdmft GlobalV 出现了 5 次 GlobalC 出现了 15 次 |-- module_io GlobalV 出现了 647 次 GlobalC 出现了 77 次 |-- json_output GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test_serial GlobalV 出现了 7 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 248 次 GlobalC 出现了 7 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_basis GlobalV 出现了 51 次 GlobalC 出现了 1 次 |-- module_nao GlobalV 出现了 24 次 GlobalC 出现了 1 次 |-- test GlobalV 出现了 19 次 GlobalC 出现了 0 次 |-- module_ao GlobalV 出现了 24 次 GlobalC 出现了 0 次 |-- 1_Documents GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- sphinx GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- source GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- doxygen GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 14 次 GlobalC 出现了 0 次 |-- orb_obj GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- GaAs GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- lcao_H2O GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_pw GlobalV 出现了 3 次 GlobalC 出现了 0 次 |-- test_serial GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 3 次 GlobalC 出现了 0 次 |-- module_fft GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_psi GlobalV 出现了 73 次 GlobalC 出现了 8 次 |-- test GlobalV 出现了 17 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_lr GlobalV 出现了 41 次 GlobalC 出现了 2 次 |-- ri_benchmark GlobalV 出现了 1 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- dm_trans GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- operator_casida GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- potentials GlobalV 出现了 6 次 GlobalC 出现了 0 次 |-- AX GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- utils GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_hsolver GlobalV 出现了 58 次 GlobalC 出现了 34 次 |-- module_pexsi GlobalV 出现了 3 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- genelpa GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 24 次 GlobalC 出现了 0 次 |-- module_base GlobalV 出现了 167 次 GlobalC 出现了 1 次 |-- grid GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test_parallel GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- libm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_mixing GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 1 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- dsp GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 52 次 GlobalC 出现了 0 次 |-- data GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_device GlobalV 出现了 2 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_container GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- base GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- core GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- third_party GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- macros GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- utils GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- ATen GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- core GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- ops GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- kernels GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- cuda GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- rocm GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- module_cell GlobalV 出现了 411 次 GlobalC 出现了 18 次 |-- module_paw GlobalV 出现了 58 次 GlobalC 出现了 2 次 |-- test GlobalV 出现了 2 次 GlobalC 出现了 0 次 |-- module_neighbor GlobalV 出现了 7 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 4 次 GlobalC 出现了 0 次 |-- module_symmetry GlobalV 出现了 82 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test_pw GlobalV 出现了 4 次 GlobalC 出现了 0 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 |-- test GlobalV 出现了 112 次 GlobalC 出现了 4 次 |-- support GlobalV 出现了 0 次 GlobalC 出现了 0 次 行数大于 500 行的文件: ./abacus-develop/source/module_md/md_func.cpp: 527 行 ./abacus-develop/source/module_md/nhchain.cpp: 887 行 ./abacus-develop/source/module_esolver/esolver_of.cpp: 561 行 ./abacus-develop/source/module_esolver/esolver_ks_lcao.cpp: 1315 行 ./abacus-develop/source/module_esolver/esolver_ks_pw.cpp: 967 行 ./abacus-develop/source/module_esolver/esolver_of_tool.cpp: 521 行 ./abacus-develop/source/module_esolver/esolver_ks.cpp: 730 行 ./abacus-develop/source/module_relax/relax_old/bfgs.cpp: 543 行 ./abacus-develop/source/module_relax/relax_old/ions_move_cg.cpp: 501 行 ./abacus-develop/source/module_relax/relax_old/test/lattice_change_cg_test.cpp: 535 行 ./abacus-develop/source/module_relax/relax_old/test/lattice_change_basic_test.cpp: 529 行 ./abacus-develop/source/module_relax/relax_old/test/ions_move_cg_test.cpp: 593 行 ./abacus-develop/source/module_relax/relax_new/relax.cpp: 701 行 ./abacus-develop/source/module_ri/exx_abfs-construct_orbs.cpp: 503 行 ./abacus-develop/source/module_hamilt_pw/hamilt_stodft/sto_iter.cpp: 762 行 ./abacus-develop/source/module_hamilt_pw/hamilt_stodft/sto_elecond.cpp: 1016 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/onsite_proj_tools.cpp: 1023 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/onsite_projector.cpp: 643 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/forces.cpp: 845 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/fs_nonlocal_tools.cpp: 830 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/VNL_in_pw.cpp: 1887 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/kernels/stress_op.cpp: 765 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/kernels/test/force_op_test.cpp: 3020 行 ./abacus-develop/source/module_hamilt_pw/hamilt_pwdft/kernels/test/vnl_op_test.cpp: 4126 行 ./abacus-develop/source/module_hamilt_pw/hamilt_ofdft/kedf_wt.cpp: 583 行 ./abacus-develop/source/module_elecstate/elecstate_pw.cpp: 569 行 ./abacus-develop/source/module_elecstate/occupy.cpp: 611 行 ./abacus-develop/source/module_elecstate/module_charge/charge.cpp: 811 行 ./abacus-develop/source/module_elecstate/module_charge/charge_mixing_rho.cpp: 620 行 ./abacus-develop/source/module_elecstate/test/potential_new_test.cpp: 673 行 ./abacus-develop/source/module_elecstate/test/elecstate_base_test.cpp: 574 行 ./abacus-develop/source/module_elecstate/test/charge_mixing_test.cpp: 1145 行 ./abacus-develop/source/module_elecstate/test/support/WAVEFUNC1.txt: 4231 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/LCAO_nl_mu.cpp: 585 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/LCAO_set_st.cpp: 554 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/record_adj.cpp: 507 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/FORCE_STRESS.cpp: 1101 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/hamilt_lcao.cpp: 517 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dftu_lcao.cpp: 539 行 ./abacus-develop/source/module_hamilt_lcao/hamilt_lcaodft/operator_lcao/dspin_lcao.cpp: 533 行 ./abacus-develop/source/module_hamilt_lcao/module_dftu/dftu_occup.cpp: 527 行 ./abacus-develop/source/module_hamilt_lcao/module_dftu/dftu_io.cpp: 519 行 ./abacus-develop/source/module_hamilt_lcao/module_dftu/dftu_force.cpp: 665 行 ./abacus-develop/source/module_hamilt_lcao/module_tddft/propagator.cpp: 615 行 ./abacus-develop/source/module_hamilt_lcao/module_tddft/td_current.cpp: 516 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/func_transfer.cpp: 663 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/atom_pair.cpp: 873 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/transfer.cpp: 672 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/hcontainer.cpp: 838 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/test/test_hcontainer_complex.cpp: 576 行 ./abacus-develop/source/module_hamilt_lcao/module_hcontainer/test/test_hcontainer.cpp: 673 行 ./abacus-develop/source/module_hamilt_lcao/module_deepks/LCAO_deepks_io.cpp: 610 行 ./abacus-develop/source/module_hamilt_lcao/module_deepks/test/klist_1.cpp: 605 行 ./abacus-develop/source/module_hamilt_lcao/module_deltaspin/cal_mw_from_lambda.cpp: 527 行 ./abacus-develop/source/module_hamilt_lcao/module_deltaspin/spin_constrain.cpp: 590 行 ./abacus-develop/source/module_hamilt_lcao/module_gint/grid_technique.cpp: 771 行 ./abacus-develop/source/module_hamilt_lcao/module_gint/gint_k_sparse1.cpp: 555 行 ./abacus-develop/source/module_hamilt_lcao/module_gint/kernels/cuda/code_gen.cpp: 4426 行 ./abacus-develop/source/module_hamilt_lcao/module_gint/test/test_sph.cpp: 597 行 ./abacus-develop/source/module_hamilt_general/module_vdw/vdwd3_autoset_xcparam.cpp: 581 行 ./abacus-develop/source/module_hamilt_general/module_vdw/vdwd3_parameters_tab.cpp: 33131 行 ./abacus-develop/source/module_hamilt_general/module_vdw/vdwd3_autoset_xcname.cpp: 606 行 ./abacus-develop/source/module_hamilt_general/module_vdw/vdwd3.cpp: 1538 行 ./abacus-develop/source/module_hamilt_general/module_vdw/test/vdw_test.cpp: 603 行 ./abacus-develop/source/module_hamilt_general/module_xc/xc_functional_gradcorr.cpp: 794 行 ./abacus-develop/source/module_hamilt_general/module_xc/test/test_xc.cpp: 923 行 ./abacus-develop/source/module_hamilt_general/module_xc/test/test_xc2.cpp: 519 行 ./abacus-develop/source/module_io/get_pchg_lcao.cpp: 551 行 ./abacus-develop/source/module_io/read_input_item_system.cpp: 794 行 ./abacus-develop/source/module_io/to_wannier90_lcao.cpp: 1214 行 ./abacus-develop/source/module_io/winput.cpp: 907 行 ./abacus-develop/source/module_io/write_dos_lcao.cpp: 692 行 ./abacus-develop/source/module_io/output_mulliken.cpp: 629 行 ./abacus-develop/source/module_io/get_wf_lcao.cpp: 759 行 ./abacus-develop/source/module_io/numerical_basis.cpp: 863 行 ./abacus-develop/source/module_io/to_wannier90_pw.cpp: 1057 行 ./abacus-develop/source/module_io/read_input_item_other.cpp: 530 行 ./abacus-develop/source/module_io/cal_r_overlap_R.cpp: 722 行 ./abacus-develop/source/module_io/read_input_item_elec_stru.cpp: 848 行 ./abacus-develop/source/module_io/to_wannier90.cpp: 517 行 ./abacus-develop/source/module_io/write_HS_sparse.cpp: 800 行 ./abacus-develop/source/module_io/to_qo_kernel.cpp: 605 行 ./abacus-develop/source/module_io/unk_overlap_lcao.cpp: 646 行 ./abacus-develop/source/module_io/read_input_item_output.cpp: 551 行 ./abacus-develop/source/module_io/berryphase.cpp: 756 行 ./abacus-develop/source/module_io/read_input.cpp: 502 行 ./abacus-develop/source/module_io/input_conv.cpp: 574 行 ./abacus-develop/source/module_io/cif_io.cpp: 529 行 ./abacus-develop/source/module_io/test_serial/read_input_item_test.cpp: 1768 行 ./abacus-develop/source/module_io/test/to_qo_test.cpp: 1563 行 ./abacus-develop/source/module_io/test/bessel_basis_test.cpp: 558 行 ./abacus-develop/source/module_io/test/read_wfc_lcao_test.cpp: 772 行 ./abacus-develop/source/module_basis/module_nao/numerical_radial.cpp: 518 行 ./abacus-develop/source/module_basis/module_nao/beta_radials.cpp: 764 行 ./abacus-develop/source/module_basis/module_nao/test/gaunt.txt: 7242 行 ./abacus-develop/source/module_basis/module_nao/test/numerical_radial_test.cpp: 589 行 ./abacus-develop/source/module_basis/module_ao/ORB_read.cpp: 613 行 ./abacus-develop/source/module_basis/module_ao/ORB_atomic_lm.cpp: 773 行 ./abacus-develop/source/module_basis/module_ao/test/ORB_nonlocal_lm_test.cpp: 758 行 ./abacus-develop/source/module_basis/module_ao/test/ORB_atomic_lm_test.cpp: 889 行 ./abacus-develop/source/module_basis/module_pw/pw_transform_k.cpp: 520 行 ./abacus-develop/source/module_psi/wf_atomic.cpp: 839 行 ./abacus-develop/source/module_psi/wavefunc.cpp: 513 行 ./abacus-develop/source/module_psi/psi.cpp: 508 行 ./abacus-develop/source/module_psi/test/psi_initializer_unit_test.cpp: 770 行 ./abacus-develop/source/module_lr/esolver_lrtd_lcao.cpp: 726 行 ./abacus-develop/source/module_hsolver/diago_iter_assist.cpp: 620 行 ./abacus-develop/source/module_hsolver/diago_david.cpp: 1133 行 ./abacus-develop/source/module_hsolver/hsolver_pw.cpp: 676 行 ./abacus-develop/source/module_hsolver/diago_cg.cpp: 642 行 ./abacus-develop/source/module_hsolver/diago_dav_subspace.cpp: 793 行 ./abacus-develop/source/module_hsolver/module_pexsi/dist_matrix_transformer.cpp: 765 行 ./abacus-develop/source/module_hsolver/kernels/test/math_kernel_test.cpp: 751 行 ./abacus-develop/source/module_base/cubic_spline.cpp: 566 行 ./abacus-develop/source/module_base/math_chebyshev.cpp: 772 行 ./abacus-develop/source/module_base/opt_DCsrch.cpp: 732 行 ./abacus-develop/source/module_base/memory.cpp: 501 行 ./abacus-develop/source/module_base/math_ylmreal.cpp: 721 行 ./abacus-develop/source/module_base/math_lebedev_laikov.cpp: 5401 行 ./abacus-develop/source/module_base/math_sphbes.cpp: 930 行 ./abacus-develop/source/module_base/ylm.cpp: 1878 行 ./abacus-develop/source/module_base/mcd.c: 884 行 ./abacus-develop/source/module_base/test_parallel/parallel_reduce_test.cpp: 611 行 ./abacus-develop/source/module_base/libm/sincos.cpp: 1262 行 ./abacus-develop/source/module_base/test/global_function_test.cpp: 768 行 ./abacus-develop/source/module_base/test/math_ylmreal_test.cpp: 514 行 ./abacus-develop/source/module_base/test/vector3_test.cpp: 749 行 ./abacus-develop/source/module_base/test/complexmatrix_test.cpp: 588 行 ./abacus-develop/source/module_base/test/complexarray_test.cpp: 511 行 ./abacus-develop/source/module_base/test/math_chebyshev_test.cpp: 648 行 ./abacus-develop/source/module_base/module_device/device.cpp: 714 行 ./abacus-develop/source/module_base/module_container/ATen/ops/einsum_op.cpp: 1048 行 ./abacus-develop/source/module_base/module_container/test/tensor_test.cpp: 536 行 ./abacus-develop/source/module_cell/unitcell.cpp: 953 行 ./abacus-develop/source/module_cell/read_pp_upf100.cpp: 529 行 ./abacus-develop/source/module_cell/klist.cpp: 1442 行 ./abacus-develop/source/module_cell/read_atoms.cpp: 1246 行 ./abacus-develop/source/module_cell/read_pp_upf201.cpp: 896 行 ./abacus-develop/source/module_cell/module_paw/paw_cell_libpaw.cpp: 951 行 ./abacus-develop/source/module_cell/module_paw/paw_cell.cpp: 774 行 ./abacus-develop/source/module_cell/module_symmetry/symmetry.cpp: 2326 行 ./abacus-develop/source/module_cell/module_symmetry/symmetry_basic.cpp: 1156 行 ./abacus-develop/source/module_cell/test/unitcell_test_readpp.cpp: 579 行 ./abacus-develop/source/module_cell/test/read_pp_test.cpp: 812 行 ./abacus-develop/source/module_cell/test/klist_test.cpp: 781 行 ./abacus-develop/source/module_cell/test/unitcell_test.cpp: 1834 行 东八区时间（北京时间）: 2025-04-01 10:35:20 The latest commit version in the repository is: 8eed91df69ac7734b7439f6c94d8b92de833ab6e The commit time is: 2025-03-28 23:14:54 +0800 The latest tag is: v3.10.0 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-04-01 14:52:59 "},"develop-test1.html":{"url":"develop-test1.html","title":"ABACUS 中的测试（一）：测试的重要性","keywords":"","body":"ABACUS 中的测试（一）：测试的重要性 作者：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/12/07 一、背景 1. 问题 在 ABACUS 软件的发展过程中，测试极其重要。 以下情景纯属虚构，但至少在 ABACUS 软件开发过程中时有发生： 故事一：小明是程序 ABC 的积极开发者，有一天他发现已经写好的新功能在之前版本可用，但在最新版本不能用了！这件事情影响了小明目前的进度，只好停下来维修。小明找上级说明事情缘由之后，开始找程序错误的原因，经过一段时间查找（可能是几个小时，可能是几天），发现是另一位开发者小强同学在几日前提交的代码中破坏了这个功能。小明比较郁闷，因为代码发生错误责任不在自己，是别人把它改错的。小强也是有责任心的开发者，收到反馈后尽快修改了错误。但从此小明总是担心自己的代码被破坏，而小强写代码时也更加谨小慎微。 故事二：有热心用户小风在用户群里提问，为什么照着文档跑程序，程序就崩了。有责任心的开发者小云看到后回答：“我自己的电脑上能跑，但为什么你的电脑上跑不了？”经过小云地毯式搜索验证（可能是几个小时，可能是几天）找到原因：“因为编译环境不一样导致的，某段语法在另外一个编译器上会得到错误的结果”。小云提出的解决方案是建议小风换个环境，或者等小云忙完手头的事情有空之后，再帮忙解决一下这个问题。小风有点不满这个程序带来的体验，遂决定弃坑。小云也被这额外多出来的工作量搞得身心俱疲。 以上第一个故事来自开发者和开发者，第二个故事来自开发者和用户，小明、小强、小风、小云的故事，就是 ABACUS 软件过去几年不断会上演的故事。当以上事情反复出现时，我们知道不管是开发者还是用户，这些老师同学从自身的角度出发都是积极参与的，那我们不禁要问： 到底是哪里出了问题？ 需要采取什么样的方法？ 是否可以防止这样的事情再发生？ 2. 结果 如果我们软件最终的目标还是希望这个功能能够被更多人更好的使用，而不是仅仅用来申请软件专利，发文章之类的，那么出现功能 bug 后，会产生两个结果。 第一：这些 bug 的发现和修复本质上是要消耗开发者大量时间的！例如小明和小云都花了很久时间去找问题，这个过程他（她）几乎得不到任何其他人的帮助！能否快速找到取决于开发者自身对算法和 bug 的认识程度。有人把复杂程序的排错认为更多是一门艺术而不是技术，“程序高手”可能会更快的定位到问题，但我们认为真正的程序高手可以避免出现这类问题。 第二：如果不采取更为有效的方式，那么修完一次还有可能要修第二次，例如小明的代码又被另一位开发者大强破坏了，或者小云修完之后发现另一位用户大风在别的环境又出错了。这件事情会反复出现，而开发者的热情会在这个过程被一点点磨光。 没有意识到以上两点的开发者（包括所谓的“程序高手”）建议阅读到这里自己静下来想一想。 3. 方案 究竟什么方法才是避免以上问题的最根本方法？答案是两个字，测试！只是如果直接说出来可能大家并不会意识到这个方法本身的重要性。 以上发生的结果其实是软件开发的流程出了问题，当一个软件庞大到一定程度时，许多代码互相影响之后，出 bug 是难免的，发生上面故事里的情节也是时有发生的。 所以，如果时间反正是要消耗的，我们是否可以劝说开发者意识到：在开发到“某个阶段”（什么阶段？）就让新功能的测试尽可能充分和完整，就可以减少将来“维修代码“带来的时间消耗？实际上简单的修复并不能做到一劳永逸。更糟糕的是，经过一段时间，开发者可能对当初开发算法的记忆也变淡了，因此整体修复的效果不见得会比当初做完整来得更好。经年累月的结果是，持续修复这些问题所花的精力和资源实际上是累加到原来功能开发的时间和资源成本上，这样不知不觉整个软件团队实际上需要为整个项目付出更高的时间甚至经济成本买单，而对任何软件资助方来讲，要解释清楚这个成本，解释成本是极高的（就是解释不清楚，理由也不充分）。所以 ABACUS 团队对所有开发者的建议是，尽可能的把写测试的工作乃至为了让代码减少错误所需的重构工作放入功能开发周期内执行，让一个软件的 feature 满足：功能正确、代码规范、框架合理，注释清楚、测试完整。 最后回答的一点是：什么时候添加测试合适？一般来讲，开发者能把一个新功能实现正确是可以带来巨大成就感的一件事情，是能类比打仗的时候把己方旗帜插上对方阵地山头的高光时刻。所以这个时候让开发者加测试一般是不愿意的，或者觉得没必要。在学术界，往往结果对了之后可以进入写文章投稿的阶段，至于程序的维护在发文章前面往往是排后面的。等到文章发完之后，马上又会进入一个新的课题。以上原因也导致一般在高校课题组很难维持发展一个大型软件。 所以添加测试合适的时间，我们对 ABACUS 开发者的建议是：开发完新功能之后，如果确认这个功能会有用，请添加测试，并且在这个整理代码的过程中把上一段话的最后四点补充做完： 代码规范，程序的各种命名、注释、代码行的格式等应符合程序开发的命名标准和编码规范。 框架合理，如果不合理就请重构代码，趁你的记忆还鲜活。 注释清楚，如果有些代码可能别人看不懂，不要吝惜你的语言，用英文注释！ 测试完整，最后把相应主要的功能函数加上测试，具体怎么加，请看这个系列的文档。 二、论测试的重要性 程序测试是软件开发过程中至关重要的一个环节，是一种实际输出和预期结果之间的客观对比，它保证软件能以预期的形式运行，得到预期的结果。软件测试试图最大程度上防范潜在的缺陷和错误。通过对软件进行有效测试，可以降低项目风险，确保软件功能在各种条件下的正确性，提高软件功能的稳定性，甚至提前发现和修复问题，节省软件的维护成本。 ABACUS 作为开源的密度泛函理论项目，涉及到的不同背景开发人员较多，每位开发人员负责开发代码的一部分功能。为了确保软件功能在持续更新的代码中保持正确，我们建议开发人员掌握测试的方法，对每个功能函数编写相应的测试函数。新添加的测试函数会被 ABACUS 加入整个软件的测试流程，一旦有新提交的代码对该功能产生破坏，代码审核人员和代码开发者可以快速得到反馈，从而避免错误或者漏洞的产生而留下隐患。 三、测试要满足的条件 我们从 https://google.github.io/googletest/primer.html 网页上把关于一个好的测试的标准进行了中文翻译，列举如下： 测试需要独立，以及可以被重复。调试一个因其他测试的结果而成功或失败的测试是很麻烦的。GoogleTest 通过在不同对象上运行每一个测试来隔离测试。当一个测试失败时，GoogleTest 允许你单独运行这个测试，以便快速调试。 测试需要被好好的组织起来，并且能够反映出被测试代码的结构。GoogleTest 将相关测试归组到测试套件中，这些测试套件可以共享数据和子程序。这种常见模式很容易识别，并且使得测试易于维护。当人们切换项目并开始工作在一个新的代码库上时，这种一致性尤其有帮助。 测试应该具有可移植性和可复用性。谷歌拥有大量与平台无关的代码；它的测试也应当是平台中立的。GoogleTest 能够在不同的操作系统上工作，配合不同的编译器，无论是否支持异常处理，因此 GoogleTest 的测试可以适用于多种配置。 当测试失败了，该测试应该尽可能多的提供错误信息。 GoogleTest 在遇到第一个测试失败时不会停止。相反，它只会停止当前的测试并继续执行下一个测试。你还可以设置测试以报告非致命性失败，此后当前测试将继续进行。因此，你可以在单次编辑-编译循环中检测并修复多个错误。 测试框架应该使编写测试的人摆脱杂务，让他们专注于测试内容。GoogleTest 会自动记录所有定义的测试，并且不需要用户列举它们就可以运行这些测试。 测试需要能快速运行。使用 GoogleTest，您可以跨测试重用共享资源，并且只需为设置/拆卸支付一次费用，而无需使测试相互依赖。 四、测试种类 测试里的几个术语解释： 黑盒测试：又叫功能测试，关注被测软件的功能实现，而不是内部逻辑。在测试中，被测对象的内部结构，运作情况对测试人员是不可见的。 白盒测试：称为结构测试或者透明盒测试，要求测试人员对软件的内部结构和工作原理（例如 ABACUS 的密度泛函理论算法）有深入的了解，也迫使测试人员去思考算法的实现过程，可以检测代码的每条分支和路径，揭示隐藏在代码中的错误。单元测试属于白盒测试的范畴。白盒测试可以识别难以在黑盒测试里发现的问题。缺点是昂贵，且花时间。 灰盒测试：混合着白盒和黑盒的测试方法。最常见的灰盒测试是集成测试。 单元测试：单元测试（Unit Test）是对软件最基本组成单元（例如函数）进行的测试。这里的单元就是指软件设计的最小单位。单元测试分为两个步骤： 人工静态检查法：是测试的第一步，通过不执行代码而检查程序的逻辑算法，尽可能的发现问题。例如检查算法的前后逻辑，函数和类的接口是否合理，包括输入参数个数、顺序、类型，以及返回值类型是否一致；检查全局变量和全局类的使用是否必须；检查所用语法是否在不同编译器下通用。 动态执行跟踪法：执行测试案例来看是否有预期故障，包括预期的错误提示都可以编写单元测试来覆盖。 测试出问题分下列四种情况： 错误：可以执行，结果错误。 缺陷：可以执行，但是实际的结果和期望的结果有偏差。 失效：执行功能的能力丧失。 故障：不能执行，可能由错误，缺陷和失效导致。 ABACUS 中主要包含单元测试和完整性测试两种。其中单元测试确保每个单元函数的正确性，完整性测试确保一些功能能够顺利跑完，得到正确的结果。 五、测试案例 测试案例（Test Case）是为检测程序的某个程序功能而准备的一组数据，包含测试的输入以及预期结果。随着测试案例数量的增加，开发者对产品质量和测试流程也就越有信心。除了对功能正确性的验证之外，建议也要考虑对程序不能运行，甚至错误的情况进行测试案例的编写，使得所有程序的行为都被测试所覆盖。 另外，我们积极的建议所有 ABACUS 的开发者采用“测试驱动开发”的方法来开发程序新功能，就是一个新功能在编写代码之前，就考虑清楚并且准备好测试案例来验证程序满足需求。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-test2.html":{"url":"develop-test2.html","title":"ABACUS 中的测试（二）：测试工具 gtest","keywords":"","body":"ABACUS 中的测试（二）：测试工具 gtest 作者：彭星亮，邮箱：pxlppq007@163.com；赵天琦，邮箱：zhaotq13@tsinghua.org.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/12/08 一、gtest 简介 手动编写和执行测试用例可能会非常繁琐和耗时，因此我们在 C++ 程序的开发流程中引入了 Google Test 框架（以下简称 gtest）。gtest 是一个由 Google 开发的 C++ 单元测试框架。它为开发者提供了一套强大的工具和功能，用于编写、组织和运行测试用例。通过使用宏和断言，开发者可以较为轻松地定义测试用例和验证预期结果。 测试套件（test suite）的设计可以反映程序的结构。测试套件内的测试所共享的数据可放入同一个文件夹。一个测试项目可以包括多个测试套件。 gtest 的使用需要定义好对应的 TEST，TEST_F，TEST_P 宏来自动运行算例，结果的对比主要通过使用 ASSERT_* 或者 EXPECT_* 宏来进行。 gtest 框架支持 C++11 及以上的 C++ 标准，支持 Linux、MacOS、Windows 等众多平台，支持 gcc 5.0+、clang5.0+、MSVC2015+ 编译器，支持 Bazel 以及 cmake 构建工具。 关于 gtest 的 User's Guide 的链接如下: GoogleTest User’s Guide | GoogleTest gtest 的 github 仓库地址：google/googletest: GoogleTest - Google Testing and Mocking Framework (github.com) 二、gtest 的安装及测试 在 Linux 环境下安装 gtest 的第一种方法：apt 安装（如果无效，请尝试后面的方法） sudo apt install googletest 第二种方法：从 github 下载并安装（需要有管理员 sudo 权限）： git clone [https://github.com/google/googletest](https://github.com.cnpmjs.org/google/googletest) cd googletest cmake . make sudo make install 使用如下的算例验证是否安装成功 //test.cpp #include \"gtest/gtest.h\" TEST(TestInt,TestTrue) { EXPECT_TRUE(2 == 2); } /* int main(int argc, char** argv) { testing::InitGoogleTest(&argc, argv); return RUN_ALL_TESTS(); } */ 以上算例可以不包含 main 函数（也可以写 main 函数），只要以下编译的时候加上 -lgtest_main，之后执行 g++ test.cpp -lgtest -lpthread -lgtest_main ./a.out 注意，如果 g++ 编译器版本太旧，需要添加参数 -std=c++14 才能编译通过。 运行之后，预期程序输出如下 三、gtest 的断言 gtest里有一个核心概念叫“断言”，是对预期程序是否正确的一种“逻辑判断”，并且返回判断结果。 gtest 提供了一个测试断言指令集。每个断言是宏，类似于函数调用。 测试断言会产生测试结果，分成 3 种情况： success（成功，代表测试通过） nonfatal failure（失败，非致命失败，程序不中断） fatal failure（失败，致命失败，程序中断）。 gtest 中有 2 种断言类型：ASSERT_* 和 EXPECT_*。 ASSERT_* 版本的断言失败会产生致命失败，并结束当前函数。 EXPECT_* 版本的断言产生非致命失败，不会终止当前函数。推荐使用 EXPECT_* 断言。 注意：当某个断言不通过时，开发者可以自定义输出的故障消息，只需在函数后面添加相应的 C++ 流运算符 四、gtest 的宏 1. TEST 宏 在测试文件里，可以直接定义 TEST（类似一个 C++ 的函数）来编写测试代码，TEST 是一个 gtest 里被经常使用的宏（TEST 的英文介绍），是 gtest 里最基本的组成单元，其代码格式如下： TEST(TestSuiteName, TestName) { ... statements ... } TestSuiteName是该 TestSuite 的名字，可以自己起名 TestName是在这个 TestSuite 里具体的测试的名字，可以自己起名 注意 TestSuiteName 和 TestName 的命名中不要包含“_”，当然如果你加了编译也不会报错，但是会有隐患，推荐使用首字母大写来分隔单词 在 TEST 宏里面定义的 statements 是要被执行的测试代码。 下面是一个例子： //test2.cpp #include #include TEST(TestABACUS,TestTrue) { using namespace std; EXPECT_TRUE(2 == 2) 编译后的运行结果是 可以看到，这里提示第二个测试是失败的。 2. TEST_F 宏 在测试中如果要对相同的数据进行不同的判断（不同的判断指不同的测试）时，可以使用 TEST_F 宏，此时需要在测试代码里额外定义一个类（从给定的基类派生出一个类），我们管它叫做 test fixture 类（Test Fixtures 英文介绍），这个类的作用是包含所要测试的数据，并且可以传到不同的 TEST_F“函数”里，下面例子是 TEST_F 宏使用的格式。 TEST_F(TestFixtureName, TestName) { ... statements ... } 第一个参数 TestFixtureName 是需要定义的类的名字，定义这个类的时候，它需继承自 ::testing::Test 类。第二个参数 TestName 是自己命名的任务名。 创建一个 test`` ``fixture 类需要注意的是： 从 testing::Test 派生一个类。在类的开始部分使用 protected:，因为我们希望在子类中访问固件成员。 在类里，定义你想使用的任何数据成员，这样这个类可以在多个 TEST_F 宏里使用。 在编写单元测试时，经常需要对测试中使用的对象进行初始化。这可以通过编写默认构造函数或 SetUp() 函数来实现。SetUp() 函数是 Google Test 测试框架中用于在每个测试用例开始前准备对象的一个函数。也可以用 C++ 的关键字 override 来标明覆盖了基类的同名虚函数 SetUp()。 如果需要，还可以在 Test Fixtures 类里面定义 TearDown() 函数，把分配的临时空间给释放掉。 如果需要，还可以在 Test Fixtures 类里面定义其它成员函数，以方便不同的 TEST_F 调用。 //test3.cpp #include #include class Positive : public testing::Test { protected: int a; int b; void SetUp() override { a = 1; b = -1; } }; TEST_F(Positive,TestA) { using namespace std; EXPECT_TRUE(a>0) 0) 编译执行，结果如下 五、gtest 的 mock 功能 在某些测试里，需要中间调用别的类（例如类 A）才能够完成接下去的程序运行，但是类 A 太复杂，不适合定义在类里，这个时候可以造一个假类（MockA）来模仿真正的类 A 的操作，这个过程就叫做 mock！但是要注意的是：虽然 mock 某个对象可以帮助你在测试中消除不必要的依赖关系，使它们变得快速和可靠，但在 C++ 中手动去写 mock 代码是困难的。因此，Google Test 提供了 gmock，它是 gtest 的一个库，一个辅助框架，用来创建 mock 类，使用时需要 include \"gmock/gmock.h\"。 实际写测试的时候，mock 的思想可以借鉴。然而实际上，目前 ABACUS 的大部分需要 mock 的地方都可以通过自己写一个空的类来实现替代功能，因此如果有同学老师感兴趣这部分内容，可以参考 Goolge Test 官网教程。这部分就不多做介绍了。 六、gtest 里的全局环境设置 在 Google Test 中，全局环境（Global Environment）是指一个测试程序的全局设置，它允许在整个测试程序开始前和结束后执行一些特定的代码。例如，全局测试资源的初始化和清理，全局状态的设置，运行只需要一次性执行的代码。 全局环境设置方法：可以通过继承 testing::Environment 类并实现 SetUp() 和 TearDown() 方法来使用全局环境。 下面是一个例子： // test environment #include #include class MyEnvironment : public ::testing::Environment { public: void SetUp() override { std::cout 编译后运行结果，可以看到测试开始前打印出的“ABACUS，Made in China”信息，以及测试结束后打印出来的“I clean up.”信息，分别对应的是上面的 MyEnvironment 类里 SetUp 和 TearDown 函数所执行的内容。 七、常用 ASSERT 和 EXPECT 语句 常用的 ASSERT 和 EXPECT 这两大类断言的相关语句如下，开发者可以在处理需要的数据类型时候灵活运用，例如布尔类型、二元值、字符串、浮点数等数据类型（附上这些语句的原文链接：Assertions Reference | GoogleTest)。 致命断言 非致命断言 通过条件 布尔类型 ASSERT_TRUE(condition) EXPECT_TRUE(condition) condition 为 true ASSERT_FALSE(condition) EXPECT_FALSE(condition) condition 为 false 二元值 ASSERT_EQ(val1, val2) EXPECT_EQ(val1, val2) val1 = val2 ASSERT_NE(val1, val2) EXPECT_NE(val1, val2) val1 != val2 ASSERT_LT(val1, val2) EXPECT_LT(val1, val2) val1 ASSERT_LE(val1, val2) EXPECT_LE(val1, val2) val1 ASSERT_GT(val1, val2) EXPECT_GT(val1, val2) val1 > val2 ASSERT_GE(val1, val2) EXPECT_GE(val1, val2) val1 >= val2 字符串(C string) ASSERT_STREQ(val1, val2) EXPECT_STREQ(val1, val2) val1 == val2 ASSERT_STRNE(val1, val2) EXPECT_STRNE(val1, val2) val1 != val2 ASSERT_STRCASEEQ(val1, val2) EXPECT_STRCASEEQ(val1, val2) 忽略大小写 val1 == val2 ASSERT_STRCASENE(val1, val2) EXPECT_STRCASENE(val1, val2) 忽略大小写 val1 != val2 浮点型 ASSERT_FLOAT_EQ(val1, val2) EXPECT_FLOAT_EQ(val1, val2) float 型 val1 和 val2 相等 ASSERT_DOUBLE_EQ(val1, val2) EXPECT_DOUBLE_EQ(val1, val2) double 型 val1 和 val2 相等 ASSERT_NEAR(val1, val2,abs_error) EXPECT_NEAR(val1, val2,abs_error) val1 和 val2 差的绝对值不大于 abs_error 异常检查 ASSERT_THROW(statement, exception_type); EXPECT_THROW(statement, exception_type); statement throws an exception of the given type ASSERT_ANY_THROW(statement); EXPECT_ANY_THROW(statement); statement throws an exception of any type ASSERT_NO_THROW(statement); EXPECT_NO_THROW(statement); statement doesn't throw any exception 死亡断言 Death Assertions ASSERT_DEATH(statement,matcher); EXPECT_DEATH(statement, matcher); statement 引起程序非 0 退出，并产生的 stderr 与 matcher 一致。matcher 为可设为“”表示任意的 stderr 都成立。 ASSERT_EXIT(statement,predict,matcher); EXPECT_EXIT(statement, predict, matcher); statement 产生的结束时的返回值与 predict 一致，产生的 stderr 与 matcher 一致 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-test3.html":{"url":"develop-test3.html","title":"ABACUS 中的测试（三）：测试方法","keywords":"","body":"ABACUS 中的测试（三）：测试方法 作者：陈默涵，邮箱：mohanchen@pku.edu.cn 作者：刘千锐，邮箱：terry_liu@pku.edu.cn 最后更新时间：2025/03/28 编写 ABACUS 代码常会遇到的问题：如何增加和修改目前程序已有的测试算例？本文档回答这个问题。 一、测试体系架构 1.1 单元测试分布 位置：source/module_*/test 系列目录 并行测试：test_parallel 文件夹 串行测试：test_serial 文件夹 覆盖范围：各基础模块（如 module_base、module_md 等） 1.2 集成测试分布 位置：tests/integrate 目录，里面包含数百个测试，注意测试的参数基本都是为了加快计算而设置的，不是真正用于应用所取的参数。 测试类型： 完整端到端功能计算 多模块协同测试 二、环境配置与编译 ABACUS 支持使用 CMake 中的 Ctest 工具进行代码的测试，详细使用方法可以搜索 Ctest 的教程，下面仅介绍常用、简单的使用方法。 2.1 编译配置 A. 首先需要使用 CMake 确定 abacus 的安装环境，在编译的时候加上 -DBUILD_TESTING=ON 指令，并将编译的缓存文件放入 build 文件中，进入 abacus 的代码文件夹，输入： cmake --build build -DBUILD_TESTING=ON Github 上的 CI 测试使用的是更详细的编译指令，如果需要进行全面测试需要执行： cmake -B build -DBUILD_TESTING=ON \\ -DENABLE_DEEPKS=ON -DENABLE_MLKEDF=ON \\ -DENABLE_LIBXC=ON -DENABLE_LIBRI=ON \\ -DENABLE_PAW=ON -DENABLE_GOOGLEBENCH=ON \\ -DENABLE_RAPIDJSON=ON -DCMAKE_EXPORT_COMPILE_COMMANDS=1 2.2 编译命令 编译 abacus 和所有测试文件（-j8 表示用 8 个线程编译，也可以选择更大） cmake --build build -j8 该指令等价于 cd build; make -j8 安装 abacus 和测试所需支持文件，如 test/support 文件夹 cmake --install build 该指令等价于 cd build; make install 三、测试执行流程 3.1 完整测试套件 接下来，可以选择进行全面的测试，包括集成测试和单元测试： cmake --build build --target test ARGS=\"-V\" 该指令等价于 cd build; ctest -V 3.2 选择性测试 在修改 ABACUS 代码中，往往只需要进行特定几个单元测试的修改与测试，而不需要进行全部单元测试，此时可以进入对应的 build/source/module_***/test 文件夹下， A. 使用 make -j8 编译测试文件， B. 对于部分测试可能需要依赖准备好的测试材料，一般会放在 support 文件夹中，如下面的 AtomPseudoTest 测试需要打开 support/C.upf 文件： 此时需要将 support 复制过来才能进行测试，可以使用 cp 指令复制，或者直接输入： make install C. 若要测试该文件夹下所有的单元测试，可以使用 ctest 该指令等价于 make test，但推荐使用 ctest，因为其还可以使用 Ctest 特有的指令，例如想在测试运行的时候看到细节，可以用如下命令： ctest -V 如果只需要测试特定的单元测试，可以直接运行改文件，例如测试 md_fire 文件： ./md_fire 如果测试失败了怎么办？首先在 build/source 的对应文件夹下运行测试程序，例如这是运行 module_md 下面的测试例子得到测试失败的算例： 上面这个截图说明 FIREtest.PrintMD 这个测试错了，找到这个错误信息源自测试程序中的函数 TEST_F： 把这个测试的最后一句话删掉 remove(\"running.log\");，再编译和运行测试，得到“标准答案”。 常用的 Ctest 指令： ctest -V：详细输出单元测试的每个小测试信息 ctest -R ：进行所有名称匹配该正则表达式的测试，例如： ctest -R base 会进行所有名字包含 base 的单元测试，而在单元测试命名的时候推荐以 模块名_测试名 的方式命名，例如 base_memory 就是 module_base 下的 memory 测试，此时 ctest -R base 就能执行 module_base 所有的测试 ctest -E ：排除所有名称匹配该正则表达式的测试 四、如何进行集成测试 4.1 完整测试 ABACUS 的 Github CI 测试，默认使用 2 个 omp 线程 export OMP_NUM_THREADS=2 编译好 abacus 之后，可以进入 build/tests/integrate，执行 ctest -V 即可，其本质是执行 abacus-develop/tests/integrate/Autotest.sh 脚本，开发者也可以手动执行该脚本或者进入相应文件夹进行测试。Autotest.sh 默认会执行 CASES_CPU.txt 列出的所有文件，如果想取消某个测试，可以加 # 进行注释： 如果想指定 CASES_GPU.txt，可以使用 Autotest.sh -f CASES_GPU.txt 指定。 4.2 选择性测试 可以进入某个文件夹，例如 cd 109_PW_CR 每个文件夹会有一个 jd 文件，是 job description 的意思，用于描述这个测试的目的，如果有不完整的地方，也欢迎补充。result.ref 是用于参考的“标准答案”，result.out 是运行后输出的“答案”。此时如果运行 ../Single_job.sh 即可执行这个测试。注意该脚本要执行需要在算例上一层存在一个文件叫 general_info，此文件包含三行，如果缺少信息则脚本不会顺利执行。 EXEC /xxx/abacus （abacus可执行文件的地址） CHECKACCURACY 2 （对比精度，此处取整数） NUMBEROFPROCESS 4 （用的并行核数） 另外大家如果有兴趣了解测试的具体步骤，可以顺着 Single_job.sh 看脚本里写的内容，主要是用到了 integrate 文件夹下有一个 tools 文件夹，该文件夹规定了如何将当前运算结果和“标准答案”进行对比（主要是通过一个叫 catch_properties.sh 的脚本） 五、结语 本指南参考 CMake 官方文档和 Google Test 最佳实践编写，建议结合 CMake 测试文档和 Google Test 指南 进行拓展学习。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-04-01 10:35:54 "},"develop-tensor1.html":{"url":"develop-tensor1.html","title":"Tensor 类文档 1：构造和使用说明","keywords":"","body":"Tensor 类文档 1：构造和使用说明 作者：路登辉，邮箱：denghuilu@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2025/03/02 一、背景介绍 在 ABACUS 项目中，我们引入了一种新的 Tensor 容器，其目的是为了统一底层数据容器并在此基础上构建一系列算子以执行复杂的计算操作。这一设计的引入基于以下两个主要考虑： 框架层面的考虑：在当今的机器学习和深度学习领域，几乎所有先进的框架，如 PyTorch 和 TensorFlow，都将张量作为基本的数据单元。这些框架的 Tensor 对象不仅支持复杂的数学运算和自动梯度计算，还能在不同的计算设备（例如 CPU 和 GPU）间灵活地转移数据和执行计算任务。我们的 Tensor 类借鉴了流行的深度学习框架如 PyTorch 和 TensorFlow 中的张量实现。这种设计选择使得该类不仅适用于传统的科学计算，也保留了将来集成到现代的机器学习框架中的可能性。未来如有需要也可在这一框架下更方便的引入自动微分算法，进一步完善 Tensor 容器。 科学计算程序的视角：在科学计算，尤其是密度泛函理论（DFT）的应用中，核心挑战在于处理和操作大量的数值数据。Tensor 类作为一种多维数据结构，在这方面提供了强大而灵活的支持。采用 Tensor 数据类型带来了以下几个显著优势： 统一底层数据容器：通过统一底层容器，我们显著提升了代码的可读性和可维护性。 多平台计算支持：Tensor 类设计支持多种计算设备，并且易于扩展以适应新的计算设备。 多精度计算的兼容性：支持多精度计算，增强了计算的灵活性和适应性。 综上所述，Tensor 容器在 ABACUS 项目中有助于增加计算的效率和灵活性，提升代码可读性和稳定性。 二、Tensor 对象 2.1 代码目录 代码目录位于 deepmodeling 下的 abacus-develop 仓库: abacus-develop/source/module_base/module_container at develop · deepmodeling/abacus-develop [denghui@LuDh-4090:module_base]$ tree -d module_container module_container #代码位置，位于module_base目录下 ├── ATen #ATen/Array-Tensor 存储了Tensor容器的方法 │ ├── core #存储了Tensor对象的核心方法，比如reshape，tensor_buffer以及Tensor对象的定义 │ ├── kernels #定义了异构计算的函数，比如矩阵乘法gemm/gemv等等 │ │ ├── cuda #提供了异构计算函数所需的CUDA实现 │ │ ├── rocm #提供了异构计算函数所需的ROCM实现 │ │ └── test #针对定义的异构计算函数的单元测试 │ └── ops #针对Tensor对象，定义了一系列算子 │ └── test #算子的单元测试 ├── base #Tensor无关的基础函数 │ ├── core │ ├── macros #常用的宏函数声明 │ ├── third_party #第三方软件，比如BLAS等的声明 │ │ └── backward-cpp #提供backtrace的实现 │ └── utils └── test #base模块的单元测试 2.2 概述 Tensor 类是一个基础类，用于处理不同数据类型和形状的张量，它提供了基本的张量操作功能以及异构计算的支持。 2.2.1 头文件引用 该类依赖以下头文件： #include // 存储管理模块 #include // 自定义类型 #include // Tensor维度管理 #include // 管理Tensor对象的数据存储 #include // Tensor对象的访问函数 #include // 内存操作函数 #include // 宏函数定义 2.2.2 类定义 Tensor 类的定义在 container 名称空间中，不是模板类： namespace container { class Tensor { // 成员变量和方法定义... }; } 2.3 公共方法和属性 以下是 Tensor 类的一些主要方法： 2.3.1 构造函数 Tensor()：无参数构造函数，构造一个空的 Tensor 对象； Tensor(DataType data_type)：接受给定数据类型作为参数，构造一个空的 Tensor 对象； Tensor(DataType data_type, TensorShape shape)：接受数据类型和形状作为参数，此构造函数为 Tensor 对象分配存储空间，大小和 shape 的维度相匹配，存储在 CPU 上； Tensor(DataType data_type, DeviceType device, const TensorShape& shape)：接受数据类型，计算设备参数和形状作为参数，此构造函数为 Tensor 对象分配存储空间，大小和 shape 的维度相匹配，存储在 device（这里的 device 可以为 CPU 也可以为 GPU 或者其他支持的设备）上； 此外还定义了相应的拷贝构造函数和移动构造函数，这里就不一一展示 2.3.2 成员方法 GetAllocator(DeviceType device)：根据设备类型获取存储分配器； zero()：将张量的所有元素设置为 0； reshape(TensorShape shape)：改变张量的形状； resize(const TensorShape& new_shape)：调整张量的大小； CopyFrom(const Tensor& other)：从另一个张量复制数据； CopyFrom(const Tensor& other, const TensorShape& shape)：设置特定的形状，并从另一个张量复制数据； AllocateFrom(const Tensor& other, const TensorShape& shape)：根据另一个张量和给定形状分配内存； sync(const Tensor& rhs)：同步两个张量的数据； template T* data() const：直接访问 Tensor 数据的指针接口； 此外也重载了输出运算符 ，现在可以直接使用 cout 输出。 2.4 示例用法 以下是 Tensor 对象的构造函数单元测试，可供参考： TEST(Tensor, Constructor) { // Test constructor with default allocator container::Tensor t1(container::DataType::DT_FLOAT, container::TensorShape({2, 3})); EXPECT_EQ(t1.data_type(), container::DataType::DT_FLOAT); EXPECT_EQ(t1.device_type(), container::DeviceType::CpuDevice); // EXPECT_EQ(t1.shape().dims(), std::vector({2, 3})); EXPECT_EQ(t1.NumElements(), 6); #if __CUDA || __ROCM // Test constructor with specified device type container::Tensor t2(container::DataType::DT_DOUBLE, container::DeviceType::GpuDevice, container::TensorShape({3, 4})); EXPECT_EQ(t2.data_type(), container::DataType::DT_DOUBLE); EXPECT_EQ(t2.device_type(), container::DeviceType::GpuDevice); EXPECT_EQ(t2.shape().dims(), std::vector({3, 4})); EXPECT_EQ(t2.NumElements(), 12); #endif // Test copy constructor container::Tensor t3 = t1; EXPECT_EQ(t3.data_type(), container::DataType::DT_FLOAT); EXPECT_EQ(t3.device_type(), container::DeviceType::CpuDevice); // EXPECT_EQ(t3.shape().dims(), std::vector({2, 3})); EXPECT_EQ(t3.NumElements(), 6); EXPECT_NE(t3.data(), t1.data()); // Test reference constructor std::vector vec{1.0, 2.0, 3.0}; container::TensorMap t4(&vec[0], container::DataType::DT_FLOAT, container::DeviceType::CpuDevice, container::TensorShape({1, 3})); EXPECT_EQ(t4.data_type(), container::DataType::DT_FLOAT); EXPECT_EQ(t4.device_type(), container::DeviceType::CpuDevice); // EXPECT_EQ(t4.shape().dims(), std::vector({1, 3})); EXPECT_EQ(t4.NumElements(), 3); EXPECT_EQ(t4.data(), vec.data()); } 单元测试中包含了所有 Tensor 类方法的测试，提供了使用参考，可以在这里查看：abacus-develop/source/module_base/module_container/test/tensor_test.cpp at develop · deepmodeling/abacus-develop . 2.5 其他待办事项和备注 添加日志系统； 添加异常处理系统； 重构 CMake 系统，使得 Tensor 对象可以独立编译。 三、算子（OP）的构建和使用 有了 Tensor 对象之后，如何基于 Tensor 对象进行相应的运算操作呢？这里我们引入算子的概念。 3.1 算子的声明 以加法操作举例，其声明定义在文件 linalg_op.h 中，我们以其中的 add_op 举例，其定义如下所示： /** * @brief A functor to perform add operation on a Tensor. * * This functor adds two Tensors element-wise, resulting in a new Tensor with the same * shape as the input Tensors. */ struct add_op { /** * @brief Perform add operation on the input Tensors. * * This function adds two Tensors element-wise, resulting in a new Tensor with the same * shape as the input Tensors. * * @param x The first input Tensor. * @param y The second input Tensor. * @param z The output Tensor that will hold the result of the add operation. * It must have the same shape as the input Tensors. */ void operator()( const Tensor& x, const Tensor& y, Tensor& z); template void operator()( const T& alpha, const Tensor& x, const T& beta, const Tensor& y, Tensor& z); }; 可以看到，这个结构体 add_op 的声明中重载了括号运算符，一共提供了两种加法操作： // z = x + y void operator()( const Tensor& x, const Tensor& y, Tensor& z); 以及： // z = alpha * x + beta * y template void operator()( const T& alpha, const Tensor& x, const T& beta, const Tensor& y, Tensor& z); 3.2 算子的实现 对应的 add_op 的实现位于 linalg_op.cpp 中： void add_op::operator()(const Tensor &x, const Tensor &y, Tensor &z) { // check the shape REQUIRES_OK(x.shape() == y.shape() && x.shape() == z.shape(), \"add: the shape of the two input Tensors must be the same\") REQUIRES_OK(x.data_type() == y.data_type() && x.data_type() == z.data_type(), \"add: the data type of the two input Tensors must be the same\") REQUIRES_OK(x.device_type() == y.device_type() && x.device_type() == z.device_type(), \"add: the device type of the two input Tensors must be the same\") // allocate memory for the result TEMPLATE_ALL_LAMBDA_2(x.data_type(), x.device_type(), [&](){ T_ alpha = static_cast(1); T_ beta = static_cast(1); kernels::add()( x.NumElements(), alpha, x.data(), beta, y.data(), z.data()); }) } template void add_op::operator()(const T& alpha, const Tensor &x, const T& beta, const Tensor &y, Tensor &z) { // check the shape REQUIRES_OK(x.shape() == y.shape() && x.shape() == z.shape(), \"add: the shape of the two input Tensors must be the same\") REQUIRES_OK(x.data_type() == y.data_type() && x.data_type() == z.data_type(), \"add: the data type of the two input Tensors must be the same\") REQUIRES_OK(x.device_type() == y.device_type() && x.device_type() == z.device_type(), \"add: the device type of the two input Tensors must be the same\") // allocate memory for the result TEMPLATE_ALL_LAMBDA_2(x.data_type(), x.device_type(), [&](){ kernels::add()( x.NumElements(), alpha, x.data(), beta, y.data(), z.data()); }) } 针对 add_op 的两个运算函数分别给出实现：可以看到其实现进一步依赖于外部的 kernels:add 结构体，该结构体为模板类，TEMPLATE_ALL_LAMBDA_2 宏函数是事先封装的函数，可以通过它得到此时应当调用的结构体参数。 关于 kernels::add 的声明和实现可以在 container/ATen/kernels 目录下的 linalg.h 以及 linalg.cpp 中找到。kernels 目录结构可以参考：ABACUS 代码存放规范 · GitBook 文档。 3.3 算子的使用 算子的使用同样可以参照对应的单元测试：linalg_op_test.cpp。 同时以重构后的 CG 方法中的 orthogonal_gradient 函数举例如下： 其前后对比如下： template void DiagoCG::orthogonal_gradient(hamilt::Hamilt *phm_in, const psi::Psi &eigenfunction, const int m) { if (test_cg == 1) { ModuleBase::TITLE(\"DiagoCG\", \"orthogonal_gradient\"); } // ModuleBase::timer::tick(\"DiagoCG\",\"orth_grad\"); phm_in->sPsi(this->gradient, this->scg, (size_t)this->dim); // int inc = 1; //()( this->ctx, 'C', this->dim, m, this->one, eigenfunction.get_pointer(), this->dmx, this->scg, 1, this->zero, this->lagrange, 1); Parallel_Reduce::reduce_pool(this->lagrange, m); // (3) orthogonal |g> and |scg> to all states (0~m-1) //()( this->ctx, 'N', this->dim, m, this->neg_one, eigenfunction.get_pointer(), this->dmx, this->lagrange, 1, this->one, this->gradient, 1); gemv_op()( this->ctx, 'N', this->dim, m, this->neg_one, eigenfunction.get_pointer(), this->dmx, this->lagrange, 1, this->one, this->scg, 1); } template void DiagoCG_New::orth_grad( const ct::Tensor& psi, const int& m, ct::Tensor& grad, ct::Tensor& scg, ct::Tensor& lagrange) { this->spsi_func_(grad, scg); // scg = S|grad> ct::EinsumOption option( /*conj_x=*/true, /*conj_y=*/false, /*alpha=*/1.0, /*beta=*/0.0, /*Tensor out=*/&lagrange); lagrange = ct::op::einsum(\"ij,i->j\", psi, scg, option); // TODO: add Tensor operators for communications Parallel_Reduce::reduce_pool(lagrange.data(), m); // (3) orthogonal |g> and |scg> to all states (0~m-1) option = ct::EinsumOption( /*conj_x=*/false, /*conj_y=*/false, /*alpha=*/-1.0, /*beta=*/1.0, /*Tensor out=*/&grad); grad = ct::op::einsum(\"ij,j->i\", psi, lagrange, option); option = ct::EinsumOption( /*conj_x=*/false, /*conj_y=*/false, /*alpha=*/-1.0, /*beta=*/1.0, /*Tensor out=*/&scg); scg = ct::op::einsum(\"ij,j->i\", psi, lagrange, option); } 四、总结 总结 Tensor 对象的引入具有如下的主要作用： 统一底层容器： Tensor 对象的构造函数中可以传递 DataType 以及 DeviceType 作为参数控制该对象实例化的精度（例如 int,float,double,complex以及 complex等等）和设备（DEVICE_CPU 以及 DEVICE_GPU）等等。这确保了 Tensor 对象对于广泛的数据类型和计算设备提供了支持，能够适应于 ABACUS 的底层容器需求； Tensor 对象中封装了对于裸指针的操作，包括数据访问，内存分配等等现在都基于规范统一的接口，有利于代码维护 使用算子（op）的形式来支持异构计算： 通过定义算子（op）的形式，将基于 Tensor 的逻辑运算从主分支分离出去，主分支代码现在只需要调用一个统一的接口即可实现对应精度以及对应计算设备的逻辑运算。 保留了后续扩展的可能性 参照 Torch 的实现，可以很方便的在现有的架构基础上引出包括自动微分等等框架的支持。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-tensor2.html":{"url":"develop-tensor2.html","title":"Tensor 类文档 2：使用和拓展","keywords":"","body":"Tensor 类文档 2：使用和拓展 作者：陈诺，邮箱：cn037@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2025/03/02 一、概述 Tensor 是一种底层数据容器，提供了跨平台的数据管理和计算操作。 通过异构内存管理和算子构建，实现“一套代码跨平台运行”，能够在不同平台（如 CPU，GPU 和 DCU）上通过 Tensor 对象分配和管理内存，并使用不同平台上的库和代码展开异构计算。 在密度泛函理论（DFT）为代表的科学计算中，Tensor 可以作为单纯的统一底层多维数据结构，为跨平台的算法开发提供支持；同时，Tensor 的设计参考了当今最流行的深度学习框架如 PyTorch 和 TensorFlow 中的张量(Tensor)实现，保留了引入自动微分等现代深度学习框架其他功能的可能性。 1.1 代码结构 代码目录： abacus-develop/source/module_base/module_container at develop · deepmodeling/abacus-develop ➜ module_base git:(develop) ✗ tree -d module_container module_container #代码位置，位于module_base目录下 ├── ATen #ATen/Array-Tensor 存储了Tensor容器的方法 │ ├── core #存储了Tensor对象的核心方法，比如reshape，tensor_buffer以及Tensor对象的定义 │ ├── kernels #定义了异构计算的函数，比如矩阵乘法gemm/gemv等等 │ │ ├── cuda #提供了异构计算函数所需的CUDA实现 │ │ ├── rocm #提供了异构计算函数所需的ROCM实现 │ │ └── test #针对定义的异构计算函数的单元测试 │ └── ops #针对Tensor对象，定义了一系列算子 │ └── test #算子的单元测试 ├── base #Tensor无关的基础函数 │ ├── core │ ├── macros #常用的宏函数声明 │ ├── third_party #第三方软件，比如BLAS等的声明 │ │ └── backward-cpp #提供backtrace的实现 │ └── utils └── test #base模块的单元测试 Tensor 代码目录中唯一的外部依赖为 \"module_base/module_device/types.h\"，用于和现有 HSolver 模块中使用的 Device 模板参数交互。 1.2 头文件 该类依赖以下头文件： #include // 存储管理模块 #include // 自定义类型 #include // Tensor维度管理 #include // 管理Tensor对象的数据存储 #include // Tensor对象的访问函数 #include // 内存操作函数 #include // 宏函数定义 二、Tensor 对象的构造和生命周期 Tensor 对象可以自行分配所需设备上的内存空间，也可以暂时管理一块内存（不负责分配、释放），相当于提供了一个“视图”。 2.1 DeviceType Tensor 是一种异构容器，在构造对象时，需要指明所处的位置。 Tensor不是模板类。不同于基于模板的类，Tensor 对象接收一个 ct::DeviceType 类型的 device_type 参数，以参数形式决定数据存储位置。 可选择的设备类型有： （Tensor 内部的 device） // source/module_base/module_container/ATen/core/tensor_types.h namespace container { enum class DeviceType { UnKnown = 0, /// 外部的设备类型标识符，如HSolver模块中使用的模板参数计算设备标识符base_device::AbacusDevice_t // ./ATen/core/tensor_types.h:#include \"module_base/module_device/types.h\" namespace base_device { enum AbacusDevice_t { UnKnown, CpuDevice, GpuDevice, DspDevice }; } 在使用Tensor时应转化为Tensor内部的container::DeviceType： // 在当前调用 Tensor 的 HSolver 模块中，如果接收到的 Device 为外部的base_device::AbacusDevice_t 类型， // 需要转化为 Tensor 内部的设备类型。 using ct_Device = typename ct::PsiToContainer::type; // 此处的 ct: namespace ct = container; tensor.h 中定义的别名 // source/module_base/module_container/ATen/core/tensor_types.h template <> struct PsiToContainer { using type = container::DEVICE_CPU; /**. */ }; template <> struct PsiToContainer { using type = container::DEVICE_GPU; /**. */ }; 此处的PsiToContainer即为针对HSolver中base_device::AbacusDevice_t的转化，由于设备类型命名和Tensor完全相同，需要特别注意。 其他基于模板参数指定设备类型的转化，可仿照该函数实现。 2.2 DataType Tensor是一种多精度容器，支持不同类型不同精度的原始数据。 可选择的数据类型有： // source/module_base/module_container/ATen/core/tensor_types.h enum class DataType { DT_INVALID = 0, /// 构造方式 container::Tensor t(container::DataType::DT_DOUBLE, container::DeviceType::GpuDevice, container::TensorShape({3, 4})); 2.3 TensorShape 指定 Tensor 形状的类型。 在调用时，一般以 std::initializer_list 的形式构造和使用，见“构造”部分。 TensorShape(std::initializer_list dims); 2.4 构造 Tensor 的构造函数定义在 source/module_base/module_container/ATen/core/tensor.h 中。 Tensor() 默认构造函数。创建一个 1 维，0 个元素的空的 float Tensor 对象。 explicit Tensor(DataType data_type) 构造一个给定 data_type 数据类型的 Tensor。 必须显式（explicit）调用，不会用于隐式的类型转换。 Tensor(DataType data_type, const TensorShape& shape) 构造一个给定数据类型 data_type 和形状 shape 的 Tensor。 在指定形状时，可以使用TensorShape的基于 std::initializer_list 的构造函数，传入一个由维度构成的列表： Tensor(t_type, {dim1, dim2}); Tensor(DataType data_type, DeviceType device, const TensorShape& shape) 构造一个给定数据类型data_type和形状shape的Tensor。 数据存放在指定的device上。 Tensor(const Tensor& other) 复制构造函数，deep copy另一个Tensor的数据域。 Tensor(Tensor&& other) noexcept 移动构造函数。 用于临时对象，通过std::move避免不必要的资源复制，资源的所有权从一个对象转移到另一个对象。 也可作为从头开始构造一个Tensor的一种形式： work = std::move(ct::Tensor(t_type, device_type, {dim1, dim2})); 此外，还有其他的构造方式，如： bool AllocateFrom(const Tensor& other, const TensorShape& shape) 从 other 复制数据，并根据传入的 shape 重新分配内存。原先拥有的内存块会被释放。 如果复制和分配成功则返回 true。 2.5 复制 对于 Tensor 对象，我们也希望重用其中的数据。有时希望在某些操作后保留原始数据而非就地修改，这时就需要以某种方式“复制”一个 Tensor 对象。 Tensor 类有“浅”和“深”两种数据共享方式。 实际上，我们使用的对象一般不直接存放原始数据，而是提供了一个针对大块内存的“引用”（reference）或指针（pointer）；实际传参时，引入的参数也是这样的引用而非大批量原始数据。当多个引用（如 A 和 B）指向同一块原始数据时，基于 A 对原始数据做出的改变，自然也会在通过 B 访问数据时看见这些改变，因为它们引用的实际上是同一块内存。 以下，从另一个 Tensor“复制数据”指的是： data_type device shape “浅拷贝”(Shallow copy) 创建一个新的对象，复制原始对象的各字段（field）和引用（数据域指针的值），但不复制引用指向的实际原始数据域。这将导致新旧两个对象共享相同的内存数据。 快速和节省空间，提高性能，特别是在处理大对象时；必须时刻注意自己在操作的实际上是某个对象的“引用”。 在 Tensor 中，CopyFrom 函数提供了这一功能。 // ATen/core/tensor.h // 以下所有方法 复制数据，但是共享原始内存。 class Tensor { // 复制成功返回 true bool CopyFrom(const Tensor& other); // 复制的同时 reshape 到传入的TensorShape，如果复制和 reshape 都成功则返回 true。 bool CopyFrom(const Tensor& other, const TensorShape& shape); } 此外，如果我们需要直接“接管”一个临时对象，Tensor的赋值运算符可以接受一个右值，并获得该Tensor对象的内容和所有权。这实质上是一个浅拷贝。参数other是源Tensor对象的右值引用，表示临时对象或将要被移动的对象。 // ATen/core/tensor.h Tensor& operator=(Tensor&& other) noexcept; // 例如 // source/module_hsolver/diago_bpcg.cpp this->eigen = std::move(ct::Tensor(r_type, device_type, {this->n_band})); “深拷贝”(Deep copy) 创建一个新的对象，递归复制原始对象的所有字段，会创建所有属性和嵌套对象的独立副本，获得一个和原始对象完全独立的全新对象。 这意味着开辟一块和原对象相同大小的内存，逐个复制其中的全部元素。安全，但是慢且消耗内存。 在 Tensor 中，这一操作由赋值运算符“=”实现。 // ATen/core/tensor.h // 这个赋值操作会进行内存分配和复制。 Tensor& operator=(const Tensor& other); 当赋值的右端是一个右值rvalue时，请参考“浅拷贝”中的重载。 此外，如果不创建新对象，想要复制数据域，可以使用sync： // 确保当前Tensor的数据和rhs同步。 void sync(const Tensor& rhs); // module_hsolver/hsolver_pw.cpp ct::TensorMap(psi.get_pointer(), psi_tensor, {psi.get_nbands(), psi.get_nbasis()}).sync(psi_tensor); 2.6 其他成员函数 template T* data() const 直接数据域的接口。可以和其他的自定义算子等基于 T * 的接口交互。 例如： const Real eh = hsolver::dot_real_op()(ctx_, this->n_basis_, sphi.data(), grad.data()); 不常用，见 Tensor 类文档 1：构造和使用说明 部分使用方法可见单元测试 abacus-develop/source/module_base/module_container/test/tensor_test.cpp 三、TensorMap TensorMap 类是一个特殊的 Tensor 类，它提供了一种方式来映射一个已经存在的数据指针到一个 Tensor 对象，而不是拥有和管理自己的内存。这种设计使得 TensorMap 可以引用和操作存储在其他地方的数据，而不需要复制数据。因此，TensorMap 对它托管对象的生命周期不负责任，也不应该析构外部传入的数据域。 在我们把波函数初猜等来自外界的非空数据纳入 Tensor 框架时，可能需要使用这种方式。需要注意的是，必须获取可靠的外部维度信息，并在使用 Tensor 时保持维度的一致性。 3.1 构造 TensorMap(void *data, DataType data_type,DeviceType device, const TensorShape &shape) 把一块数据域 data 映射到一个 Tensor 对象 TensorMap(void *data, const Tensor& other, const TensorShape& shape) 创建一个 TensorMap 对象，它引用由 data 指针指向的数据，并将其与给定 Tensor 对象 other 和 shape 关联。允许以指定的形状访问数据，而不拥有数据。 TensorMap(void *data, const Tensor& other) 数据的形状由 other 的形状决定。 3.2 使用 TensorMap 可以在和外界交互时，将返回的结果写入外部内存。 // source/module_hsolver/hsolver_pw.cpp ct::TensorMap(psi.get_pointer(), psi_tensor, {psi.get_nbands(), psi.get_nbasis()}).sync(psi_tensor); 这段代码将一个外部的指针包装成 TensorMap，并使用 Tensor 的 sync 复制了数据块。 四、算子 利用异构的 Tensor 对象，进行相应的异构计算操作。 为了实现“一套代码，八方通行”，针对一个统一的接口，在底层需要进行不同设备、不同精度的重载。 (base) ➜ module_container git:(develop) ✗ tree -L 2 . ├── ATen │ ├── core │ ├── kernels │ ├── ops │ └── tensor.h ├── base │ ├── core │ ├── macros │ ├── third_party │ └── utils ├── CMakeLists.txt └── test ├── ... └── tensor_utils_test.cpp 例如，对于常用的底层计算（kernels），定义在 ATen/kernels 中 blas.*： # ATen/kernels kernels ├── blas.cpp ├── blas.h ├── CMakeLists.txt ├── cuda │ ├── blas.cu │ ├── lapack.cu │ ├── linalg.cu │ └── memory.cu ├── lapack.cpp ├── lapack.h ├── linalg.cpp ├── linalg.h ├── memory.h ├── memory_impl.cpp ├── rocm │ ├── blas.hip.cu │ ├── lapack.hip.cu │ ├── linalg.hip.cu │ └── memory.hip.cu └── test ├── blas_test.cpp ├── CMakeLists.txt ├── lapack_test.cpp ├── linalg_test.cpp └── memory_test.cpp 在 .h 文件中声明后，需要实现对应的异构支持： .h 声明 面向算法实现者的统一接口 template struct blas_gemv { void operator()( const char& trans, const int& m, const int& n, const T* alpha, const T* A, const int& lda, const T* x, const int& incx, const T* beta, T* y, const int& incy); }; .cpp CPU实现，位于对应的cpp中 调用CPU Blas LAPACK库等 此处在.cpp中实现了针对DEVICE_CPU 的重载 通过下一层函数重载支持不同数据类型（BlasConnector::gemv） template struct blas_gemv { void operator()( const char& trans, const int& m, const int& n, const T* alpha, const T* A, const int& lda, const T* x, const int& incx, const T* beta, T* y, const int& incy) { BlasConnector::gemv(trans, m, n, *alpha, A, lda, x, incx, *beta, y, incy); } }; cuda/.cu GPU 实现 调用 CuBLAS 库等，包括对于 handle 等平台代码的处理和包装 template struct blas_gemv { void operator()( const char& trans, const int& m, const int& n, const T* alpha, const T* A, const int& lda, const T* x, const int& incx, const T* beta, T* y, const int& incy) { cuBlasConnector::gemv(cublas_handle, trans, m, n, *alpha, A, lda, x, incx, *beta, y, incy); } }; rocm/.hip.cu DCU实现 类似GPU的CUDA实现 随着DCU平台增加对CUDA的支持，不用再手动维护DCU专用版本代码 算子在底层用多套代码实现了异构，开发算法时，可以对不同的计算设备和精度，用统一的接口调用。 更高层的线性代数操作，可以在简单kernels的基础上进行。 例如，Tensor中有对于einsum的实现，位于ATen/ops中： // Make the conj params only works for the matmul equations. inline static Tensor einsum(const std::string& equation, const Tensor& A) { const EinsumOption& option = {}; return std::move(op::einsum_impl(equation, option, A)); } inline static Tensor einsum(const std::string& equation, const Tensor& A, const Tensor& B, const EinsumOption& option = {}) { return std::move(op::einsum_impl(equation, option, A, B)); } 该算子基于多个中间层操作最终调用 Tensor 定义的 gemm 接口。 kernels::blas_gemm() Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"algorithm-delta.html":{"url":"algorithm-delta.html","title":"在 ABACUS 中进行差分测试","keywords":"","body":"在 ABACUS 中进行差分测试 作者：金祖鑫，邮箱：jinzx@aisi.ac.cn；彭星亮，邮箱：pengxl@aisi.ac.cn；周巍青，邮箱：zhouwq@aisi.ac.cn 工作单位：北京科学智能研究院 最后更新时间：2024/3/29 背景 对 DFT（Density Functional Theory）电子结构计算软件而言，数值计算的精度是软件质量的重要一环。纸面上，一个完整的 DFT 计算只包含构建例如哈密顿矩阵、对角化、最优化等寥寥几步，但在代码层面，很多数学操作的数值实现并非如纸上的公式一般平凡：一些基本的数值算法可能无法兼顾性能与精度；开发者可能需要采用专门的算法以同时满足两者，或者将一些控制参数交给用户设置自行权衡。不难想象，在一定计算资源下获得的精度一般受限于算法中精度最薄弱的一环。 从开发者的角度，单元测试固然是一种可将整体精度问题分割后方便逐个分析的有力措施，但在程序模块较多、部分环节不便于单元测试的情况下，集成测试亦是一种有效的检测方法。从使用者的角度，集成测试也能更为直接地反映软件的整体质量。 在 DFT 计算中能量与力的计算占据核心地位。通常能量会在自洽场收敛后依照能量泛函的表达式计算获得，而力的计算则会依赖 Hellmann-Feynman 定理，采用与能量计算不同的路径。由于两者存在密切的关联而在实现上又迥然不同，能量与力的一致性测试往往被视作最基本的数值集成测试。 能量的数值微分 记第 i个原子的坐标 R^i_\\alpha(\\alpha=x,y,z)，其沿 \\alpha方向的受力为 F^i_{\\alpha}，根据定义有 F^{i}_\\alpha(\\mathbf{R}^1,\\ldots,\\mathbf{R}^N) = -\\frac{\\partial}{\\partial{}R_{\\alpha}^{i}} E(\\mathbf{R}^1,\\ldots,\\mathbf{R}^N) 在最低阶的差分近似下 \\frac{\\partial}{\\partial{}R_{\\alpha}^{i}} E(\\mathbf{R}^1,\\ldots,\\mathbf{R}^N) \\approx \\frac{E(\\ldots,\\mathbf{R}^i+\\Delta{}R\\hat{\\mathbf{e}}_{\\alpha},\\ldots) - E(\\ldots,\\mathbf{R}^i-\\Delta{}R\\hat{\\mathbf{e}}_{\\alpha},\\ldots)}{2\\Delta{}R} 其中 \\hat{\\mathbf{e}}_{\\alpha}表示 \\alpha方向的单位向量。 数值微分的步长与误差 差分公式本身作为近似会带来离散化误差。对于上述一阶导的最低阶差分，误差随步长关系为 O((\\Delta{}R)^2)。 【更高阶的差分及相应的误差项可参考 https://en.wikipedia.org/wiki/Finite_difference_coefficient】 虽然离散化误差会随着差分步长的减小而降低，但这并不意味着差分步长越小越好。由于数值计算中的数不可避免地只具有有限的精度，当步长小于一定程度后数值微分的整体误差反而会上升。例如，双精度浮点数有大约 16 位有效数字，这意味着即使对正弦函数这样简单、平滑的函数做数值微分，当步长取到 10^{-16}时只会得到纯粹的噪音。不仅如此，由于浮点数减法在“大数减大数得到小数”情况下存在有效位数丢失，理想的步长应远大于 10^{-16}。 以正弦函数为例，若能进行足够精度的计算，有 \\begin{aligned} \\sin(1+10^{-10}) &= {0.841470984}861926737235108938446263127449290359072...\\\\ \\sin(1-10^{-10}) &= {0.841470984}753866276061480994966255906729317751565...\\\\ \\Delta &= {0.000000000}108060461173627943480007220719972607507...\\\\ &=1.08060461173627943480007220719972607507... × 10^{-10} \\end{aligned} 我们得到 \\sin x在 x=1处的数值差分导数 \\begin{aligned} \\frac{\\sin(1+10^{-10})-\\sin(1-10^{-10})}{2 \\times 10^{-10}} &={0.540302305868139717400}0361035998630375...\\\\ \\cos{}x &={0.540302305868139717400}9366074429766037... \\end{aligned} 与理论上的 \\cos x对比，有 20 位左右的有效数字。然而，在双精度浮点数的运算下， \\begin{aligned} \\sin(1+10^{-10}) &= {0.841470984}86192673\\\\ \\sin(1-10^{-10}) &= {0.841470984}75386628\\\\ \\Delta &= ~~~~~~~~~~~~~~~~~~~~1.080604{494774206614}\\times 10^{-10}\\\\ \\frac{\\sin(1+10^{-10})-\\sin(1-10^{-10})}{2 \\times 10^{-10}} &=  {0.540302}{247387103307} \\end{aligned} 10 位有效数字在两个三角函数值的减法中丢失，由浮点运算规则补齐的位数（蓝色数字）只是一些噪音，最后导致数值微分结果只有 6 位有效数字。 在上述三角函数例子中，浮点运算带来的精度误差主导了最终结果中的误差。事实上，如步长取为 10^{-7}则能获得8-9位有效数字，优于步长为 10^{-10}的情况。但若取为 10^{-3}，则离散化误差将变为主导，最终只能得到约6位有效数字。实践中，为得到尽可能小的数值微分误差，步长的选择应当在离散化误差与精度误差间取得一个均衡。例如，https://en.wikipedia.org/wiki/Numerical_differentiation 中介绍了一个进行前向差分【(f(x+\\Delta{}x)-f(x))/\\Delta{}x】时的推荐步长。当采用不同的差分方案时，最优步长的估计方式也不尽相同。 由于 DFT 的能量源于一个自洽场计算，本身受到 SCF 收敛阈值等参数的影响，因此做数值微分时其精度不应直接视作相应的浮点数精度，而需综合多方面考量。 利用 ABACUS 自动工作流进行差分测试 ABACUS（原子算筹）是一款国产的开源密度泛函理论软件。 在软件中，我们可以直接使用 abacustest 进行原子受力（force）的差分测试。 应用地址（需要 Bohrium 账号获得本文档提供的差分工作流，但实际上差分测试程序也可以自己写）：https://app.bohrium.dp.tech/abacustest?request=GET%3A%2Fapplications%2Fabacustest 以下是该自动工作测试流的使用说明。 1. 准备算例 在进行测试之前，需要自己准备需要进行测试的算例，每个算例需要把 ABACUS 计算需要的所有文件（包括赝势和轨道文件）都放在一个文件中。同时需要额外准备一个 info.txt 文件，用于指定需要进行差分测试的原子以及 xyz 方向，每一行是对一个需要测试的原子的设置，格式为 ... >>> ls Fe #假设你的算例你有一个Fe的算例，并且把计算需要的所有文件已经准备在Fe文件夹中 Fe_gga_7au_100Ry_4s2p2d1f.orb Fe_ONCV_PBE-1.2.upf info.txt INPUT KPT STRU >>> cat Fe/info.txt Fe 1 x y Fe 2 y >>> zip -r fe.zip Fe # 对算例文件夹进行压缩 比如上述设置，表明对第一个 Fe 原子的 x 和 y 方向进行测试，以及对第二个 Fe 原子的 y 方向进行测试。 2. 打开应用登入账号 打开应用地址，填入自己的 bohrium 账号密码进行登入 3. 选择 abacustesst 的模式 点击 Form，并在 Select Sub Model 处选择 Reuse model 4. 上传算例 在 Upload files locally 处，上传准备好的算例压缩包。完成后在页面的最后处点击 Next,进入下一页的设置。 5. 选择 force 差分计算模式 在 Model 处选择 005-finite_diff_force 进行 force 的差分测试 6. 计算细节设置 Predft Command 可以对差分的细节进行设置，此处不填会使用默认值：python prepare.py -d 0.0001 -n 2，其中，-d 定义差分点的步长，单位是 bohr，-n 定义每个正负方向改变的构型数量。 Rundft Image 可以对进行 abacus 计算使用的镜像进行设置，此处不填会使用默认的 abacus 的 intel latest 镜像：registry.dp.tech/deepmodeling/abacus-intel:latest。 Rundft Command 可以设置进行 abcus 计算的命令，此处不填会使用默认值：OMP_NUM_THREADS=1 mpirun -np 16 abacus | tee out.log。需要注意的是测试使用的机型是固定为 ali c32_m64_cpu（此机型的实际物理机为 16，所有使用 16 核并行计算），如果自己设置计算命令时需注意并行的核数。 其他选项不需要额填写。点击页面最后的 Next，再点击 Next 进入最后的计算提交页面 7. 提交计算 在最后的 Review 页面的最后部分，点击 I agree to the terms and conditions 后点击 Submit 进行提交。 8. 查看结果 计算完成后会在页面中显示差分值和解析值的作图结果。 图. 对第一个 Fe 原子的 x 方向的差分测试结果。图最上方的 FD-Ana RMSD 是差分值和解析值得均方差。此算例表明 Fe_1_x force 得解析误差~1.28e-03 eV/A。此测试设置的步长为 0.01，差分点个数为 10（predft_command: python prepare.py -d 0.01 -n 10)，任务地址：https://app.bohrium.dp.tech/abacustest?request=GET%3A%2Fapplications%2Fabacustest%2Fjobs%2Fjob-abacustest-v0.3.97-770b66 ABACUS 能量差分与解析力结果不一致的可能原因及解决方案 原因 1：差分的步长选取过小/SCF 收敛不充分 差分与解析解之间的误差来源于两部分，一部分 SCF 基态与真实基态之间的误差；二是差分操作本身导致的数值误差。前者与 SCF 计算的收敛判据（scf_thr）、k 点采样（kspacing）、平面波基组个数（ecutwfc）等有关；而后者与差分的步长选取有关。具体的讨论可以参考本文第一部分的背景介绍。相关的问题也在 Issue#3645 中被较为详细的讨论。 解决方案 1 SCF 参数不变，重新预估一个合理的差分步长。 解决方案 2 调小 SCF 计算的收敛判据（scf_thr）、k 点采样（kspacing）；增大平面波基组个数（ecutwfc），使得 SCF 的计算更为准确。 原因 2：LCAO 计算中的“egg box effect” 当差分不一致发生在 LCAO（采用数值原子局域轨道）的计算之中时，出现例如 Issue#3685 中展示的周期性波动的时候，那么有可能是因为 LCAO 中格点积分部分导致的“egg box effect”（此效应形容由于格点离散化带来的周期性平移对称性的破缺，原子在空间平移，会产生计算出来的能量和受力的规律性震荡，就像装鸡蛋的鸡蛋盒所呈现出来的形状）。 为了确认这一点，你可以设置 basis_type=lcao_in_pw。因为 LCAO_IN_PW 的计算避开了格点积分，可以帮助确认是否是格点积分导致的数值误差。 解决方案 1 使用 basis_type=lcao_in_pw 避开格点积分。 解决方案 2 加密实空间的格点，减小“egg box effect”误差的量级。 参考文献 Issue #3645 https://github.com/deepmodeling/abacus-develop/issues/3645 Issue #3685 https://github.com/deepmodeling/abacus-develop/issues/3685 Force 差分测试 （LCAO）（这个文档只有飞书有权限才可以浏览） Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-memory.html":{"url":"develop-memory.html","title":"ABACUS 如何处理内存 bug？","keywords":"","body":"ABACUS 如何处理内存 bug？ 作者：刘千锐，邮箱：terry_liu@pku.edu.cn 最后更新时间：2024.12.25 一、前言 在 ABACUS 的开发和重构过程中，段错误、内存泄漏等内存问题不可避免。这些问题通常由变量的未初始化、地址的无效读写、内存分配未释放、内存双重释放等原因引起。为了在出现这些问题后能够快速定位并解决，可以借助 AddressSanitizer、Valgrind、Compute Sanitizer 等工具进行问题排查。 二、AddressSanitizer 的使用 相比 Valgrind，AddressSanitizer 的运行速度更快。它能够有效地检测指针越界、内存未释放等明显的内存问题，但无法发现由未初始化变量引起的错误。因此，AddressSanitizer 适用于第一步的快速检测。 AddressSanitizer 仅支持 GNU 编译器。使用时，只需在编译时通过 gcc、g++、gfortran 等命令添加 -fsanitize=address 等选项即可。在 ABACUS 中，只需将 CMake 中的 ENABLE_ASAN 变量设置为 ON，即可启用该功能。可以通过执行 cmake -DENABLE_ASAN=ON 或直接修改主目录下的 CMakeLists.txt 文件（不推荐这种方式）来实现。编译完成后，直接运行 ABACUS 或单元测试的可执行文件，即可开始检测内存问题。 这里倡议每位开发者新加的单元测试，或者集成测试都应该至少要通过 AddressSanitizer 的检测~ 以下为一些检测示例： 1. 内存泄漏： ==3802922==ERROR: LeakSanitizer: detected memory leaks Direct leak of 40 byte(s) in 1 object(s) allocated from: #0 0x7f938ed35787 in operator new[](unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cc:107 #1 0x556d75ea6897 in UnitCell::read_atom_species(std::basic_ifstream >&, std::basic_ofstream >&) /home/qianrui/github/reconstruction/hotfix/source/module_cell/read_atoms.cpp:25 #2 0x556d75e898b2 in UnitCell::setup_cell(std::__cxx11::basic_string, std::allocator > const&, std::basic_ofstream >&) /home/qianrui/github/reconstruction/hotfix/source/module_cell/unitcell.cpp:521 #3 0x556d765e788a in Driver::driver_run() /home/qianrui/github/reconstruction/hotfix/source/driver_run.cpp:49 #4 0x556d765e0e76 in Driver::atomic_world() /home/qianrui/github/reconstruction/hotfix/source/driver.cpp:180 #5 0x556d765e6667 in Driver::init() /home/qianrui/github/reconstruction/hotfix/source/driver.cpp:37 #6 0x556d75c8006f in main /home/qianrui/github/reconstruction/hotfix/source/main.cpp:43 以上输出说明了read_atoms.cpp:25处分配的内存未释放： this->atom_label = new std::string[ntype]; //atom labels 需要在析构函数中加入该内存的释放。 2. 双重释放/释放后使用： ==3805185==ERROR: AddressSanitizer: heap-use-after-free on address 0x604000012510 at pc 0x5580e4711320 bp 0x7fff1f0e03b0 sp 0x7fff1f0e03a0 READ of size 8 at 0x604000012510 thread T0 #0 0x5580e471131f in UnitCell::~UnitCell() /home/qianrui/github/reconstruction/hotfix/source/module_cell/unitcell.cpp:46 #1 0x5580e4e7e11e in Driver::driver_run() /home/qianrui/github/reconstruction/hotfix/source/driver_run.cpp:42 #2 0x5580e4e76ff6 in Driver::atomic_world() /home/qianrui/github/reconstruction/hotfix/source/driver.cpp:180 #3 0x5580e4e7c7e7 in Driver::init() /home/qianrui/github/reconstruction/hotfix/source/driver.cpp:37 #4 0x5580e451606f in main /home/qianrui/github/reconstruction/hotfix/source/main.cpp:43 #5 0x7f4f44dde082 in __libc_start_main ../csu/libc-start.c:308 #6 0x5580e457b54d in _start (/home/qianrui/github/reconstruction/hotfix/build2/abacus+0x31c54d) 0x604000012510 is located 0 bytes inside of 40-byte region [0x604000012510,0x604000012538) freed by thread T0 here: #0 0x7f4f4e8556ef in operator delete[](void*) ../../../../src/libsanitizer/asan/asan_new_delete.cc:168 #1 0x5580e4710ae9 in UnitCell::~UnitCell() /home/qianrui/github/reconstruction/hotfix/source/module_cell/unitcell.cpp:38 #2 0x5580e4e7e11e in Driver::driver_run() /home/qianrui/github/reconstruction/hotfix/source/driver_run.cpp:42 #3 0x5580e4e76ff6 in Driver::atomic_world() /home/qianrui/github/reconstruction/hotfix/source/driver.cpp:180 #4 0x5580e4e7c7e7 in Driver::init() /home/qianrui/github/reconstruction/hotfix/source/driver.cpp:37 #5 0x5580e451606f in main /home/qianrui/github/reconstruction/hotfix/source/main.cpp:43 previously allocated by thread T0 here: #0 0x7f4f4e854787 in operator new[](unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cc:107 #1 0x5580e473ca17 in UnitCell::read_atom_species(std::basic_ifstream >&, std::basic_ofstream >&) /home/qianrui/github/reconstruction/hotfix/source/module_cell/read_atoms.cpp:25 #2 0x5580e471fa32 in UnitCell::setup_cell(std::__cxx11::basic_string, std::allocator > const&, std::basic_ofstream >&) /home/qianrui/github/reconstruction/hotfix/source/module_cell/unitcell.cpp:522 #3 0x5580e4e7da0a in Driver::driver_run() /home/qianrui/github/reconstruction/hotfix/source/driver_run.cpp:49 #4 0x5580e4e76ff6 in Driver::atomic_world() /home/qianrui/github/reconstruction/hotfix/source/driver.cpp:180 #5 0x5580e4e7c7e7 in Driver::init() /home/qianrui/github/reconstruction/hotfix/source/driver.cpp:37 #6 0x5580e451606f in main /home/qianrui/github/reconstruction/hotfix/source/main.cpp:43 以上输出表明，在read_atoms.cpp:25分配的内存，在unitcell.cpp:38释放后，又在unitcell.cpp:46处二次使用造成内存错误。 3. 读写越界 ==3810456==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000d18 at pc 0x5589923553a9 bp 0x7ffd0a71e2c0 sp 0x7ffd0a71e2b0 WRITE of size 8 at 0x603000000d18 thread T0 #0 0x5589923553a8 in void Mixing_Test::solve_linear_eq(double*, double*, bool) /home/qianrui/github/reconstruction/hotfix/source/module_base/module_mixing/test/mixing_test.cpp:90 #1 0x55899233583c in Mixing_Test_BroydenSolveLinearEq_Test::TestBody() /home/qianrui/github/reconstruction/hotfix/source/module_base/module_mixing/test/mixing_test.cpp:162 #2 0x5589925e2c47 in void testing::internal::HandleSehExceptionsInMethodIfSupported(testing::Test*, void (testing::Test::*)(), char const*) (/home/qianrui/github/reconstruction/hotfix/build2/source/module_base/module_mixing/test/test_mixing+0x2e4c47) 0x603000000d18 is located 0 bytes to the right of 24-byte region [0x603000000d00,0x603000000d18) allocated by thread T0 here: #0 0x7f8c23365587 in operator new(unsigned long) ../../../../src/libsanitizer/asan/asan_new_delete.cc:104 #1 0x558992335737 in __gnu_cxx::new_allocator::allocate(unsigned long, void const*) /usr/include/c++/9/ext/new_allocator.h:114 #2 0x558992335737 in std::allocator_traits >::allocate(std::allocator&, unsigned long) /usr/include/c++/9/bits/alloc_traits.h:443 #3 0x558992335737 in std::_Vector_base >::_M_allocate(unsigned long) /usr/include/c++/9/bits/stl_vector.h:343 #4 0x558992335737 in std::_Vector_base >::_M_create_storage(unsigned long) /usr/include/c++/9/bits/stl_vector.h:358 #5 0x558992335737 in std::_Vector_base >::_Vector_base(unsigned long, std::allocator const&) /usr/include/c++/9/bits/stl_vector.h:302 #6 0x558992335737 in std::vector >::vector(unsigned long, std::allocator const&) /usr/include/c++/9/bits/stl_vector.h:508 #7 0x558992335737 in Mixing_Test_BroydenSolveLinearEq_Test::TestBody() /home/qianrui/github/reconstruction/hotfix/source/module_base/module_mixing/test/mixing_test.cpp:161 以上输出表明该单元测试在mixing_test.cpp:161分配的内存，在代码mixing_test.cpp:90处调用的对其进行了越界的赋值。 三、Valgrind 的使用 Valgrind 的检测更为细致，虽然运行速度较慢，但能够捕捉到更多的错误。不过，有时它也可能会“误报”一些问题。通常情况下，Intel 编译器可能会报告更多错误，而切换到 GNU 编译器后，这些问题可能就不再出现。此类问题往往与字符串操作函数、MPI、OpenMP 等相关，可以适当忽略。 valgrind 支持多种编译器，只需正常编译代码，在运行时加上 valgrind 即可，例如： valgrind ./abacus mpirun -np 4 valgrind ./abacus 1.未初始化的变量 ==3806036== Conditional jump or move depends on uninitialised value(s) ==3806036== at 0x4991432: std::ostreambuf_iterator > std::num_put > >::_M_insert_int(std::ostreambuf_iterator >, std::ios_base&, char, long) const (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28) ==3806036== by 0x499FD8E: std::ostream& std::ostream::_M_insert(long) (in /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28) ==3806036== by 0x109287: main (test.cpp:34) 表明test.cpp:34使用了未初始化的变量。 注意: 在 ABACUS 中之前有许多类成员变量未初始化，造成使用了未初始化的变量，造成其他位置的段错误，如果只使用 AddressSanitizer 工具检测，就只能定位到段错误的位置，而不能找到造成段错误的原因是使用了未初始化的变量，因此在用 AddressSanitizer 工具检测后无法看出错误原因之后，一定要用 Valgrind 检测 2.其他问题 无效写入：Invalid write of size 4 无效读取：Invalid read of size 4 双重释放：Invalid free() / delete / delete[] / realloc() 四、Compute Sanitizer 的使用 Compute Sanitizer 仅用于检测 GPU 代码，当前两种方法检测不出来时使用。 使用方法于 Valgrind 类似，在命令前面加 compute-sanitizer 例如当将 CPU 分配的内存传入 GPU 函数时： T* sum = new T[PARAM.inp.nbands * nchipk]; hsolver::gemm_op()(ctx, transC,transN, PARAM.inp.nbands, nchipk,npw, &ModuleBase::ONE, &psi(ik, 0, 0), npwx, wfgout, npwx, &ModuleBase::ZERO, sum, PARAM.inp.nbands); valgrind 可能无法报出准确出错的位置，而 compute-sanitizer 就可以： ========= Program hit cudaErrorInvalidValue (error 1) due to \"invalid argument\" on CUDA API call to cudaFree. ========= Saved host backtrace up to driver entry point at error ========= Host Frame: [0x418db6] ========= in /lib/x86_64-linux-gnu/libcuda.so.1 ========= Host Frame:cudaFree [0x4f21e] ========= in /usr/local/cuda/lib64/libcudart.so.11.0 ========= Host Frame:/home/qianrui/github/reconstruction/hotfix/source/module_base/module_device/cuda/memory_op.cu:202:base_device::memory::delete_memory_op, base_device::DEVICE_GPU>::operator()(base_device::DEVICE_GPU const*, std::complex*) [0x789200] ========= in /home/qianrui/github/reconstruction/hotfix/tests/integrate/187_PW_SDFT_MALL_GPU/../../../build-cuda/abacus ========= Host Frame:/home/qianrui/github/reconstruction/hotfix/source/module_hamilt_pw/hamilt_stodft/sto_iter.cpp:114:Stochastic_Iter, base_device::DEVICE_GPU>::orthog(int const&, psi::Psi, base_device::DEVICE_GPU>&, Stochastic_WF, base_device::DEVICE_GPU>&) [0x5ccf76] ========= in /home/qianrui/github/reconstruction/hotfix/tests/integrate/187_PW_SDFT_MALL_GPU/../../../build-cuda/abacus 五、其他方法 如果上述三种方法都无法提供有效的报错位置信息，说明问题可能比较复杂。此时，通常需要将断点处的代码提取成简化版本。例如，可以先将出问题的函数（如 func1）单独提取出来，并以单元测试的形式进行验证，查看是否能重现相同的报错。 如果没有报错，接下来需要扩大范围，将调用 func1 的函数（如 func2）也加入进来，逐步增加代码范围，直到报错复现，并分析是哪个部分的代码导致了内存问题。 如果有报错发生，则可以逐步移除其他部分的代码，找到最小化的代码集，这样就能定位问题的根本原因。 这种类型的 bug 通常较为棘手，解决过程需要开发者保持耐心，并不断尝试和调整。 以下是 ABACUS 解决相关问题的实例，供参考： #2351， FFTWissue #5497 (comment) Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-cifparser.html":{"url":"develop-cifparser.html","title":"文件输出功能的实现代码结构设计建议：以 ABCUS CifParser 为例","keywords":"","body":"文件输出功能的实现代码结构设计建议：以 ABACUS CifParser 为例 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024 年 9 月 6 日 输入输出功能并不是软件开发的边角任务。良好的输入输出设计不仅能便捷用户的使用，提升用户体验，使得软件能够无缝地结合 community 已有成熟工作范式，也会在必要时为以 disk I/O 解决内存问题发挥明显作用 背景 随着 ABACUS 的功能持续增加，对感兴趣物理量输出的需求也随之增加，且从 running_log 中抓取信息愈加困难 随着 ABACUS 的用户群体增加，越来越多的 ABACUS 与各种具有结构化文件接口的后处理软件不兼容的 issue/报告数量也在增加 将积分表和其他非高频访问（计算次数有限，但每次计算成本较高）数据写入文件来减轻内存使用，是模拟更大尺度体系的常见和成熟技术路线之一 规范化文件输出-读入功能开发流程 第一步：对输出内容的重新思考 在设计和编写输出代码之前，我们必须再次明确至少以下两个方面： 这种输出功能的用途是什么？是给人读还是机器读？ 从原则上讲，所需输出物理量，在输出过程中产生的精度损失是否应该发生？ 实际上，ABACUS 目前的确存在“具有有限保留位数，但用于被期望进行数值误差尽可能小的计算”这一情况中，例如： LCAO 波函数：out_wfc_lcao 关键词可赋值 1 输出为 plaintext，赋值 2 输出二进制格式。但 plaintext 文件用于 restart SCF 计算 电荷密度：out_chg 关键词可赋值 1 输出实空间电荷密度为 Gaussian cube，该文件默认只保留 3 位小数，且在 PR#4958 之前无法更改，用于 restart SCF 计算 H(k), S(k)：out_mat_hs 关键词可赋值 1 输出 H(k)和 S(k)为 plaintext。该类文件默认只保留 6 位小数，且在 PR#3468 之前无法更改，联合 out_wfc_lcao 1 所输出的波函数文件，数值误差达到1e-5数量级，已经无法用于精度要求稍高的后处理计算 ... 这些情况的出现，反映了 ABACUS 涉及文件输入输出的一致性并未良好设计，且经常出现一种文件承担了人读和机器读，定性和严格定量两种场景需求。 第二步：输出文件格式调研 基于第一步对输入/输出目的的再次明确，之后考虑储存在文件中数据的结构问题。 实际上，整个计算化学/计算物理领域的软件已经对相当多的数据结构就“应当如何输出”、“输出为何种格式”凝聚出共识，如实空间三维格点数据以 Gaussian Cube/xsd 文件输出，稀疏矩阵使用 csr 格式输出，绘图数据使用 gnuplot 可读格式输出，结构文件使用 cif/(ext-)xyz/pdb 等格式输出。也不断有新的格式被推广，如三维格点数据使用具有更高压缩比的 BQB，因为 Python 的大范围应用因此支持输出 npy, npz 等。因此具有输出和读入物理量的需求时，如果希望该功能对用户可见且被高度信任地使用，应当首先对数据格式和标准进行调研。 举例： https://www.quantum-espresso.org/Doc/INPUT_PP.html#idm124 https://manual.cp2k.org/trunk/CP2K_INPUT/FORCE_EVAL/DFT/PRINT.html 特别地，例如对于 restart 所需文件和 MD 轨迹的存储，应当在软件间进行广泛调研。对于 restart，如 QE 默认输出电荷密度、波函数的二进制文件，CP2K 默认输出最新三步的波函数二进制文件，GROMACS 将轨迹保存在二进制格式的 trr 中，LAMMPS 可以设置 dump 关键词将指定信息输出在文件中，CP2K 默认将 AIMD 轨迹保存在 xyz 文件中，且他们支持根据 suffix/prefix 来批量设置各种输出文件的文件名。 对于 MD 轨迹则应当调研常见的轨迹分析后处理软件和可视化软件的可接受格式，如 Visual Molecular Dynamics (VMD)、OVITO，分别在蛋白模拟、材料模拟领域久负盛名，各自具有庞大的用户群体： 第三步：写一个好用的工具库 不得不承认，文件读写代码的实现在实际功能开发时是“dirty work”，因此我们应当尽可能减少“dirty work”占用所有开发者的时间。基于这种目的，我们需要对需要输出的量其数据结构进行抽象的认识，之后根据精度要求选择合适的格式进行输出，因此所有真正对输入-输出的实现都应当具有库的性质，而非总是 case-by-case 地去编写代码，如 ABACUS 之前版本中出现的 STRU_SIMPLE.cif 和 STRU_READIN_ADJUST.cif，两文件具有相同的扩展名，但实际上两文件都不具有完整的 cif 文件规定的结构。 设计原则零：100% 明确封装的必要性 多人协作开发 C++ 程序时，有时会出现开发者起手就要把自己将要写的代码用“class XXX {}”套起来的情况，但至于为什么如此做却不能给出令人满意的回答，即“面向对象”其“对象”究竟为何物的意义不明确。就当前语境而言，将 ABACUS 中数据写入文件中，这一过程理想情况下不应该涉及任何数据的复制和存储，即输入输出函数并不应当在 ABACUS 功能模块和文件之间将数据存储在“其他地方”，而大部分 C++ 开发者在编写类声明时，又格外自然地将数据放在 private 域中，这无疑在设计上是错上加错的实现方式。 因此对于 ModuleIO::CifParser，尽管 CifParser 参考 pymatgen.CifParser 设计成类，但实际上对 cif 文件的读写均为 static 函数实现，封装成类的意图仅仅为对齐 pymatgen.CifParser 以文件名为输入参数构建对象的方式使用，此时类具有唯一数据成员“raw”，其被赋值是在调用构造函数构造对象，构造函数直接 static read 函数时，这实际上也符合了 RAII（Resource Acquisition Is Initiallization）原则，见扩展阅读材料。 class CifParser { public: CifParser() = delete; // I cannot see any necessity to have a default constructor CifParser(const std::string& fcif); // read the cif file and store the information ~CifParser() {} // actually do not need to do anything explicitly static void write(//... ); static void read(//... ); std::vector get(const std::string& key); private: // interface to ABACUS UnitCell impl. static void _unpack_ucell(//... ); // stores the information of the cif file std::map> raw_; }; 设计原则一：核心函数尽可能避免对 STL 容器和基本数据类型之外的任何类有依赖 我们总应当尽可能低耦合地编写代码，否则对于单元测试和代码调试都会造成极大的困难。原先对 cif 文件输出的函数实现作为 UnitCell 的成员函数，这实际上意味着“如果需要输出 cif 文件，则需要首先构造一个 UnitCell 对象”——这显然从原则上是荒谬的，在程序实现上，UnitCell 中只有少部分数据是 cif 文件写入所需要的。 static void write(const std::string& fcif, const double* abc_angles, const int natom, const std::string* atom_site_labels, // the one without numbers const double* atom_site_fract_coords, const std::string& title = \"# generated by ABACUS\", const std::string& data_tag = \"data_?\", const int rank = 0, const double* atom_site_occups = nullptr, // may be this will be useful after impementation of VCA? const std::string& cell_formula_units_z = \"1\"); static void read(const std::string& fcif, std::map>& out, const int rank = 0); 如此对两个核心函数的单元测试可以完全不构建 UnitCell 对象，使得该单元测试的编写相当容易。 之后因为当前 ABACUS 的程序结构原因，重载一个形参表具有 UnitCell 对象， static void write(const std::string& fcif, const UnitCell& ucell, const std::string& title = \"# generated by ABACUS\", const std::string& data_tag = \"data_?\", const int rank = 0); ，实际上只需要从 UnitCell 对象中获取需要的信息，之后调用核心函数。这使得 cif 的写入由 ucell.print_cell_cif(\"STRU.cif\"); 变化为 ModuleIO::CifParser::write(GlobalV::global_out_dir + \"STRU.cif\", ucell); 。另外出于对 ABACUS Python 化的考虑（pybind 对数据类型的支持范围，具体见 https://pybind11.readthedocs.io/en/stable/advanced/cast/overview.html#list-of-all-builtin-conversions），另设置一“write”函数的重载如： static void write(const std::string& fcif, const std::vector& abc_angles, const std::vector& atom_site_labels, // the one without numbers const std::vector& atom_site_fract_coords, const std::string& title = \"# generated by ABACUS\", const std::string& data_tag = \"data_?\", const int rank = 0, const std::vector& atom_site_occups = {}, // may be this will be useful after impementation of VCA? const std::string& cell_formula_units_z = \"1\"); 设计原则二：读写一致性 一般地，我们希望使用“write”将数据写入文件后，以“read”函数再读入的数据和原先完全相同，如单元测试： TEST(CifParserTest, WriteTest) { int rank = 0; #ifdef __MPI MPI_Comm_rank(MPI_COMM_WORLD, &rank); #endif const std::string fcif = \"test.cif\"; std::ofstream ofs(fcif); const std::vector abc_angles = {2.46637620, 2.46637620, 24.84784531, 90.0, 90.0, 120.0}; const int natom = 4; const std::vector atom_site_labels = {\"C\", \"C\", \"C\", \"C\"}; const std::vector atom_site_fract = {0.0, 0.0, 0.75, 0.0, 0.0, 0.25, 0.333333, 0.666667, 0.75, 0.666667, 0.333333, 0.25}; ModuleIO::CifParser::write(fcif, abc_angles.data(), natom, atom_site_labels.data(), atom_site_fract.data(), \"# Generated during unittest of function ModuleIO::CifParser::write\", \"data_test\"); std::map> data; ModuleIO::CifParser::read(fcif, data); // ... 设计建议一：不要总是指望 rank 0 实际上，如果在运行过程中已经对部分数据进行分发，则可以通过不同的 rank 同时进行不同文件的读写，来减轻单一 rank（ABACUS 通常指定为 rank 0）的读写负担，因此在 read 和 write 函数中有如下字段： void ModuleIO::CifParser::write(const std::string& fcif, const double* abc_angles, const int natom, const std::string* atom_site_labels, const double* atom_site_fract_coords, const std::string& title, const std::string& data_tag, const int rank, const double* atom_site_occups, const std::string& cell_formula_units_z) { #ifdef __MPI // well...very simple... int myrank; if (rank != 0) { return; } #endif // ... } void ModuleIO::CifParser::read(const std::string& fcif, std::map>& out, const int rank) { // okey for read, cannot just use if rank != 0 then return, because need to broadcast the map out.clear(); #ifdef __MPI int myrank; if (rank == 0) // only the rank assigned to read the cif file will read the file { #endif std::ifstream ifs(fcif); // ... } 此时我们可以按照任意的规则，例如基于通讯域和具体 processor 的划分，在调用 read 或者 write 时将“rank”指定为 0，而并不一定绑定例如 GlobalV::MY_RANK == rank。 设计建议三：并非所有数据都可以收集在一个 rank 再进行文件写入 尽管在当前 CifParser 的案例中不涉及，但有时我们会遇到需要输出大规模数据的情况，例如对 PW 波函数等信息的输出。为避免多个 MPI 进程写文件时发生冲突，ABACUS 中常常使用“收集到 rank0”-“rank 0 打开文件并写入”的方式进行。然而，并非所有数据都可以被单个 rank 的内存所承受，当数据量非常大时，通常需要数据在每个 rank 独立写入，而非进行收集。 扩展阅读 C++ 程序设计的一些想法：https://mcresearch.github.io/abacus-user-guide/develop-design.html Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-design.html":{"url":"develop-design.html","title":"C++ 程序设计的一些想法","keywords":"","body":"C++ 程序设计的一些想法 作者：金祖鑫，邮箱 jinzx@aisi.ac.cn 单位：北京科学智能研究院（AISI） 最后更新日期：2024 年 3 月 5 日 欢迎提出建议，本文将持续更新 一、内存管理 C++ 语言的设计理念之一是给开发者最大程度的信任与自由。这也意味着很多因疏忽导致的漏洞并不会在语法层面被阻止，因而也不会被编译器过滤。在一个复杂的程序中，内存管理是最常见的问题之一。比如，以下情况在实践中时有发生： 通过 new 为某指针申请了内存，在该指针生命周期结束前既没有其他指针接管，也没有 delete【内存泄漏】 A, B 两指针指向同一对象，A delete 后 B 继续访问【悬空指针（dangling pointer）】 这些问题无法被编译器过滤，很多时候也不会导致程序运行停止。然而，如果一段会泄漏内存的代码被反复执行，泄漏的内存量积累到一定程度就可能导致内存不足进而程序中断；被 delete 的内存块在被操作系统回收前依然可以访问【回收前访问是未定义行为 (undefind behavior)；回收后访问会 segmentation fault】：这片内存既可能保留原有数据不变，也可能已被挪作他用，写上了新的数据。这些问题往往构成巨大隐患。此外，还有一些会导致程序立即中断的内存问题，比如重复 delete、访问 nullptr 等。这些问题虽容易发现，也会耗费开发者不少精力。 C++ 社区与标准委员会很早就意识到了这些问题。出于“信任与自由”这一理念以及对过往代码的兼容性，语言并没有往“编译期确保内存安全”这一方向发展。此外，出于“零开销”（zero overhead）原则，也没有引入垃圾回收机制。时至今日，内存问题依然困扰大量 C++ 开发者。不过，自 Stroustrup 提出\"Resource Acquisition Is Initiallization\" (RAII) 的资源管理理念以来，截至 C++11，借由智能指针等工具的引入，整个语言已具备了实现方便、可靠的内存管理的条件。简而言之，C++ 给愿意自觉遵守 RAII 的开发者足够的工具以便捷、安全地管理内存，同时也不阻止开发者以完全自由、“后果自负”的方式进行开发。 1. RAII 原则 RAII 中的 R 并不单指内存，也可以指文件、线程或其他广义的资源。字面上 RAII 仅指一个对象的初始化需要与其资源获取绑定，但其完整的含义其实是“对象持有的资源有效期与对象的生命周期完全绑定”。以内存为例，这种“绑定”并不是指类的设计者给使用者提供一个用来释放内存的 public 函数，而是指类要做到从设计上就保证无论使用者如何使用，对象管理的内存有效期都不超过其生命周期。【异常处理不在本文的考虑范围内】 最常见的违背 RAII 原则的对象是裸指针。裸指针作为一个对象，其本身的生命周期并不与其指向的资源绑定。当然，这并不意味着使用裸指针与 RAII 概念互斥。当裸指针作为类的成员时，只要通过合适的设计，也可以让这个类满足 RAII。实际上，C++ 标准库容器均符合 RAII，而内部实现均使用了裸指针。 读者可能会有疑问：既然底层都是一样的裸指针，RAII 这个概念有什么意义？表面上 RAII 对单个类的设计来说似乎不值一提，但在复杂的程序中却有难以忽视的价值：对于非派生的类，如果其成员变量都满足 RAII，则这个类自动满足 RAII（析构函数可以直接写“=default”）。对于派生类，只要成员变量与基类满足 RAII，基类有虚析构函数，则这个类也自动满足 RAII。如此一来，即使一个模块由几十、上百个组件构成，开发者在内存安全上付出的精力也将止于那些最基本的、真正需要使用裸指针的组件。考虑到标准库已经提供了很多基本的数据结构，如果开发者正确使用，需要手动管理内存的场合并不多。 【注：标准库容器没有采用虚析构函数，所以一般不继承标准库容器】 从另一个角度来看，RAII 其实点出了一项程序设计的基本原则：面对复杂的资源调度需求，开发者应当在设计时对独立的、能够“自我管理”的概念进行提炼，以这些概念整体——而非这些概念背后具体的资源细节——为零件搭建更为复杂的对象。 2. 所有权 虽然 RAII 确立了对象生命周期与其所管理资源间的基本原则，一个重要问题仍未解决：当对“指针”这一概念的需求不可避免，如何确保内存安全？具体来说，若资源在不同对象间有传递、共享等交互需求，该由什么机制来明确一片资源的管理（比如释放）由哪个对象负责？这个问题实际上引出了“所有权”的概念。 考虑以下一个简化的例子： class Engine {/* a lot of stuff */}; class Car { public: Car(): engine_(nullptr) {} ~Car() { delete engine_; } void install(Engine* new_engine) { delete engine_; engine_ = new_engine; } private: Engine* engine_; }; 从概念上，一辆车可能有一台引擎，也可能处于引擎被拆下的状态。若 Engine 类占用很多空间不便复制，似乎成员使用指针，用 nullptr 和非 nullptr 代表不同状态是一种合理的选择。 【另一种可能的选择是全部存对象然后配合 move 使用。这样虽然能避免复制，但是会要求对象拥有移动构造/赋值函数。此外，这种设计下“汽车引擎被卸下”这一状态也需额外处理：要么增加一个 bool 成员用来标记，要么规定 Engine 存在一个\"null\"状态，两者似乎都不如使用指针自然】 上述代码看似无懈可击，却有一个潜在的问题：install 函数拿到了一个 Engine 的裸指针，这个指针背后的对象生命周期由谁控制？从逻辑来看，当 Car 装上 engine 后，就应当由 Car 来管理 engine 的生命周期。但是，若有粗心的开发者写下以下代码： void installer(Car* car) { Engine engine; car.install(&engine); // bad! should be car.install(new Engine); } 程序依然能编译通过，甚至可能运行。在上述函数中，Engine 对象的生命周期在函数结束时也将结束，但 Car 对象对此完全没有察觉，因此内部 engine_成员将变成悬空指针。该问题不仅在编译阶段无法被过滤，即使在运行期，由于访问悬空指针是未定义行为，也不一定能稳定复现。 尽管上面的例子非常浅显，类似的情况在更复杂的流程中却不一定容易识别。在复杂程序中，变量在开发者设想中的生命周期与实际情况不匹配是内存问题的一大来源。实践中，以下情况并不罕见： 对象 x 原本由对象 A 创建、使用、释放。需求新增后另一个对象 B 需要同 A 共享 x，开发者直接将 A 中 x 的指针复制给了 B。然而 B 的生命周期长于 A，在 A 析构后 B 中存放的 x 指针成为了悬空指针； 多个开发者协作完成某工作，初步讨论后决定某对象 a 由开发者 X 创建，开发者 Y 释放。程序几经迭代后 a 生命周期发生变化，Y 负责的部分已不适合释放 a，但开发者们并未重新明确内存释放的责任，代码合并后产生了内存泄漏。 不难发现，如果能在代码中明确“所有权”这一概念，类似的问题将大大减少。在基于裸指针的对象操作中，“所有权”并不存在于语法层面，只存在于开发者的心中：任意相同类型的指针都可以指向同一片内存，开发者实际上是依据自己对程序逻辑的理解决定哪个指针在哪一步 delete。尽管修复内存问题往往只是增改一两行的工作量，定位问题所消耗的时间与精力却通常不成比例。究其原因，裸指针本身携带的信息过于匮乏，也不主动承担任何管理功能，内存管理的成本必须由开发者通过阅读代码、文档、举行讨论等方式支付。 2.1 智能指针 C++11 引入的智能指针正是针对“所有权”所提出的工具。三种智能指针分别对应以下含义： 【注：auto_ptr 在 C++17 中已被废除，此处不再介绍】 unique_ptr: 专属的所有权； shared_ptr：与其他 shared_ptr 共享的所有权； weak_ptr：对 shared_ptr 所管理资源的“访问权”；本身并不具有所有权。 unique_ptr 独有其所指向的资源，相应负有全权管理职责：当一个 unique_ptr 的生命周期结束或被 reset 时，其管理对象的析构函数会被自动调用。此外，unique_ptr 的\"=\"运算符是移动(move)而非拷贝：对于 p1, p2 两个 unique_ptr，运行 \"p1 = p2;\" 这条命令的后果是(1) p1 原先的对象被释放；(2) 原先 p2 所管理的对象交由 p1 管理，(3) p2 变成空指针。这种设计保证了 unique_ptr 对其所属资源的专属性。unique_ptr 也可通过调用 release()释放这种专属性：返回一个裸指针的同时自身变为空指针。 shared_ptr 与其他指向同一处的 shared_ptr 共同拥有资源。与裸指针相似的是一个 shared_ptr 可以通过\"=\"赋值给另一个 shared_ptr，这时两个 shared_ptr 会指向同一份资源。与裸指针不同的是 shared_ptr 内部有自动计数，在复制时计数加一，在 reset 或生命周期结束时计数减一，计数到零时自动调用析构函数释放资源。 weak_ptr 辅助 shared_ptr 的使用，以“观察者”（不影响计数）的方式指向其他 shared_ptr 的资源。使用 weak_ptr 前需调用 lock()以转化成 shared_ptr。如其他 shared_ptr 依然有效，lock()后将会得到一个非空的 shared_ptr，否则 lock()的结果是一个空的 shared_ptr。 值得注意的是 unique_ptr 与 shared_ptr 都会自动调用析构函数，因此只要原对象满足 RAII，与智能指针结合后将得到一个满足 RAII 的指针，在绝大多数场合可视作裸指针的安全替代。回到先前 Car 与 Engine 的例子中。一种增加程序安全性的方法是采用 unique_ptr 明确 Engine 的所有权转移： class Car { public: Car() = default; // engine_ defaults to nullptr ~Car() = default; // no need to delete void install(std::unique_ptr new_engine) { engine_ = new_engine; } private: std::unique_ptr engine_; }; 如此一来，install()的函数签名将给其他开发者足够的提示： void installer(Car* car) { std::unique_ptr engine; engine = std::unique_ptr(new Engine); // or, in c++14, engine = std::make_unique(); car.install(engine); } 在上述代码中，engine 作为一个被 uniqueptr 管理的对象，在作为 install 函数的参数时即完成了所有权的传递【注意到参数类型不包含引用】，在 install 函数内部进一步传递给了 car 的成员变量 engine。这些信息由语法本身直接提供。 借助智能指针，标准库容器与多态也能完美结合成满足 RAII 的多态容器。比如考虑如下两个容器： std::vector std::vector> 虽然 std::vector 会自动调用成员的析构函数，但在成员是指针时只会释放指针本身，而不会触及指针指向的对象。因此第一个容器不满足 RAII，释放时需要手动 delete。第二个容器经由 unique_ptr 的析构将自动调用 BaseClass 的析构函数，因而释放时无需额外代码。 【更多关于智能指针的讨论与用法可参考 Scott Meyers 的 Effective Modern C++ 以及 Herb Sutter 的博客： https://herbsutter.com/2013/05/29/gotw-89-solution-smart-pointers/ https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/ 】 2.2 注意事项 需要注意的是，智能指针只有正确使用才能实现安全的内存管理；在 C++ 自由的语法下有足够可以让智能指针出错的用法。例如，一个常见的错误是用裸指针来初始化智能指针： int* raw = new int[100]; std::unique_ptr p(raw); // bad! should be std::unique_ptr p(new int[100]) 上述代码虽然“合法”，但完全破坏了 unique_ptr 的本意。若用户手动 delete raw，在智能指针 p 结束生命周期时会出现重复 delete 的错误。一般而言，智能指针只能管理从一开始就由智能指针管理的内存；将普通创建的对象的指针用来初始化智能指针会引起严重的内存问题。有时人们在设计类时会特意设采用如下模式： class Test { public: static std::shared_ptr create() { std::shared_ptr ptr(new Test); return ptr; } private: Test(); }; 通过将构造函数设置为 private，Test 类无法正常创建或者 new 对象，只能通过 create 函数获得由智能指针管理的对象。但即使如此，用户依然可以在调用 create 得到智能指针管理的对象后再通过 get 得到裸指针： std::shared_ptr ptr = Test::create(); Test* bad = ptr.get(); // bad practice, but legal delete bad; // will cause error when ptr expires 上述例子只是说明单纯看到智能指针并不意味着代码的内存安全。事实上，几乎没什么工具能做到在 C++ 语法的自由度下保证不会被用坏。但反过来，即使不使用智能指针，若开发者群体能够自觉遵守一定的规范，代码也可以具有很高的安全性。归根结底，内存的安全管理在实践中并不单取决于一两个工具，更重要的往往是开发者群体的共识。 二、面向对象的设计 1. 封装、内聚与耦合 在面向对象的程序设计中经常出现“封装”这个概念。很多时候，当一个类大致符合以下情况： 包含一系列相互关联的成员变量与函数 一些成员变量有访问限制 我们即会认为做了“封装”。尽管大多数开发者都会写出符合上述条件的代码，但在程序不断演化、代码量逐渐增大时还是十分容易陷入程序结构日益复杂的困境，以至于在进一步开发前不得不重构。 当然，代码的复杂化是功能增多所不可避免的代价，在软件的持续发展中一定次数的重构不可避免。然而，一个并不鲜见的情况是代码在重新设计后不仅比最早的代码更为精简，功能还更为强大。有时我们会意识到，一些需求从一开始就存在更简洁、自然的设计；一部分重构工作在设计之初就有机会避免。诚然，这种想法有事后诸葛之嫌：人们无法预测未来所有的需求，因而也无从设计一个一劳永逸的框架。但是，“不存在一劳永逸的设计”并不能作为所有重构的借口。若我们回顾过去重构的经历，其实不难发现一些高度相似或反复出现的困境。若将一些困境与封装的概念结合起来加以推敲，可以发现至少一部分重构的需求其实与封装的选择密不可分。对于这个因素导致的重构，或许是在今后的开发中较为容易避免且应当避免的。 1.1 封装选择的影响 在设计类或模块时一个不可回避的问题是，应当包含哪些成员与哪些 public 函数？这个问题同时蕴含了其反问题：不应该包含哪些成员与 public 函数？对这两个问题的忽视是导致代码结构不合理地复杂的常见成因之一。以下情况在实际代码中并不罕见： 单一概念所对应的变量同时是多个类的成员 几个高度关联的变量被分别存放在不同类或模块里 一个类有大量（比如几十个）成员变量 1 与 2 的后果都是使用者每次更新一个变量都需要相应修改多个对象。如果这些关联变量位于不同模块，就可能出现两个模块间双向的数据传输。对使用者而言，这种设计不仅增加了理解程序的成本，还造成了一组对象中修改其中一个就必须同步给其他几个的局面。若使用者有所疏忽，写出的程序就可能出错。最糟糕的情况是未正确同步的变量在当前代码流程下未被使用，测试也没能覆盖，而在日后某次新增需求时才被触发。此时可能代码已迭代多轮，故障排查成本极高。 将高度关联的变量分散在各处固然有隐患，可若走向另一极端，将众多变量不假思索地装进一个类里，亦会产生不良的后果。一个拥有大量成员变量的对象往往功能众多，或被多处访问、修改。如果类的维护者选择对所有成员的所有可能情况都负起责任，那他的任务就不仅是几个高度关联变量组的组内同步，还需要负责组间的协调。若这些关联变量组之间是串联关系，工作量尚且只是线性；若这些变量组之间存在灵活的耦合，工作量就会呈指数上升。一种不算少见的情况是，类的设计者原本计划了一个成员众多、功能强大的类，但在开发过程中因精力有限而逐渐放弃对所有计划功能的全权负责，选择将一部分成员的修改权开放给使用者。此时，使用者就不得不追踪并理清其关心的部分成员在整个程序流程中的变化——这对于一个被多处访问、修改的对象是十分繁重且容易出错的任务。 以上讨论其实只指向了一个众所周知的事实：仅在字面上遵循封装往往并不能减轻多少开发者的负担，因而也称不上是好的设计。好的设计需要以“高内聚(high cohesion)，低耦合(low coupling)”为目标，直面“应该封装什么”这个问题。 1.2 概念与对象的状态 在尝试回答这个问题前，我们需将之前的例子与面向对象编程中“状态”这一概念结合起来。一个对象的状态通常被定义成这个对象所有成员变量的值；一个程序在某一时刻所有对象内所有成员的值定义了这个程序在此刻的状态。当开发者构思某个功能的实现时，一方面需要理清各个量在概念上的演化，另一方面需要让程序中的实际对象在状态上与概念中的对象对齐。 从这个角度，概念中的对象演化对应了一组关联变量的全体同步；关联变量的不完全同步则不对应任何有意义的概念。如果在程序中一个概念被分散到多个对象，则开发者需要付出“从大量无意义的状态中找到正确状态”的成本。将修改成员变量的权限开放则等于告诉使用者这个类有无数可能的状态，使用者需要自己摸索找到正确的状态。如果没有从设计上确保概念与对象的状态锁定，为使程序正确地在状态间运行，所有欠缺的工作只能由开发者承担。 反过来，如果一个类能做到“状态”与概念严格绑定，其复杂度就可大大降低。以“状态”的视角进行开发，不同开发者的责任分工也得以明确： 设计者需根据需求与程序流程定义出一些细粒度的“状态”，将那些与“状态”的定义最契合的变量打包成类，将不同“状态”间的切换操作定义为 public 函数； 维护者需要理解设计者对状态的定义，同时根据新的需求调整，同时保证类在任何 non-const public 接口调用下只能处于某个预设的状态； 使用者在理解这个类所有可能状态的基础上以黑箱的方式使用，将精力专注于工作流的搭建。 当然，以上的讨论可能过于宽泛或者抽象，也不能涵盖所有的问题。但不可否认的是，仅仅在字面上做到封装对构建复杂软件而言是不够的；开发者值得从更细致的角度进行分析后做出选择（例如不同设计下的耦合强度）。此外，如“高内聚，低耦合”等基本原则也应是开发者不断追求的目标。对于一个类而言，或许下面的要求不算过分： 包含一组且只包含一组高度关联的成员变量 负责修改成员变量的函数应设计成一次性完成所有相关成员变量的同步； 修改成员的操作只能经由采用上述设计的函数完成。 2. 抽象与解耦 在开发 DFT 软件时，类的设计者会很自然地借鉴物理与化学概念，甚至将一些概念直接翻译成类。从程序设计的角度，这种思路下的类一般天然与概念中的类契合，因而往往能满足“高内聚，低耦合”的要求。对于一些具有独特数据结构的量来说，这种做法无可指摘。然而需注意的是，对于一些不同概念的物理量，其数据结构与数学操作也可能存在相当大的共性；即使对于一些整体结构和功能较为独特的量，其部分成员和操作也可能相当常见。当这些情况发生时，基于物理概念的类的设计可能需要一定的调整。 比如，数值原子轨道与赝势的非局域投影子当然是截然不同的物理概念，但两者在数学上都是【数值径向函数】x【球谐函数】的形式，且在 LCAO 计算中需要的数学操作基本相同。基于这些原因，较之于分别定义“数值原子轨道径向函数类”和“赝势投影子径向函数类”，抽象出一个“数值径向函数类”，然后将原子轨道与投影子当作这个类的不同具体对象的做法似乎是更理想的设计。此外，在科学计算中恐怕最为普遍的抽象是对线性代数对象的抽象。C++ 社区内各种线性代数库不胜枚举，熟练使用这些库往往能显著加速开发。 抽象并不局限于对数学概念的提炼。从程序设计角度，有一些类（或者一些类的大部分成员变量）实际上可视作“异质容器” （即存放不同类型变量的容器），其本身并不包含太多操作。遗憾的是，截至 C++11，标准库并不直接提供符合这个概念的工具。【标准库容器配合 boost 的 variant 或 any 可以实现异质容器；C++ 标准库直到 17 才引入 std::variant/any】 除了降低重复代码，抽象对于程序设计的另一大帮助是解耦。若 A 与 B 模块间的接口直接使用 B 模块内的类型，A 模块的编译与测试将无法独立于 B 模块存在。若能将接口替换为更为一般、抽象的对象（比如线性代数对象或者一些标准库容器），A 对 B 模块的依赖就能被去除。 三、宏的使用 1. MPI 当前 module_base 中 MPI 相关函数（parallel_commons/reduce/global)使用宏的方式基本是放在函数外，即当MPI 未定义时这些 MPI 相关的函数完全不会出现在预处理后的源文件里。这样固然逻辑清晰，但也使得外部每一处 MPI 函数的调用亦需被MPI 宏包裹，比如 // module_basis/module_nao/atomic_radials.cpp #ifdef __MPI Parallel_Common::bcast_int(lmax_); Parallel_Common::bcast_int(nzeta_max_); // the rest bcasts are omitted #endif if (rank != 0) { nzeta_ = new int[lmax_ + 1]; index_map_ = new int[(lmax_ + 1) * nzeta_max_]; } #ifdef __MPI Parallel_Common::bcast_int(nzeta_, lmax_ + 1); Parallel_Common::bcast_int(index_map_, (lmax_ + 1) * nzeta_max_); #endif 在以上例子中我们需要 bcast 数组 nzeta与 index_map。由于这些数组的大小仅为 rank-0 所知，这个信息需要首先被 bcast，其余 rank 在得知大小后申请内存，随后才能 bcast 数组。这个过程中 MPI 函数的调用分为了两段。如果 MPI 函数被集中调用，则尚且只需在头尾分别加上#ifdef 与#endif；如果有间隔地使用 MPI 函数，就需要重复这些宏指令，一定程度上影响了代码的观感。另外，由于程序中使用 MPI 的地方众多，所有文件中重复的#ifdef __MPI ... #endif 数量亦不可小觑。 一种可选的替代方案是只把函数定义的函数体用宏包裹： // parallel_commons.h #ifdef __MPI #include #endif namespace Parallel_Commons { void bcast_int(int &object); // the rest are omitted } // parallel_commons.cpp void Parallel_Common::bcast_int(int &object){ #ifdef __MPI MPI_Bcast(&object, 1, MPI_INT, 0, MPI_COMM_WORLD); #endif } // test.cpp void test() { int i = 5; Parallel_Common::bcast_int(&i); // no need to be wrapped in __MPI } 如此一来，无论MPI 是否被定义，外部都能使用这些函数，且使用时无需逐块加上#ifdef... #endif。在MPI 未定义时，MPI 函数的函数体为空，编译器在开启-O2 或更高级别优化下会将这些空函数的调用优化掉，由此实现与当前相同的效果。这个方案要求每个 MPI 函数定义时都分别将函数体用宏包裹，一定程度增加了 parallel_common/reduce/global.cpp 三个文件的代码，但方便了外部的使用。 2. Debug C++ 各个版本的 标准 中均提到与 的行为取决于“NDEBUG”宏：只要编译时加上-DNDEBUG，所有 assert 都会成为空函数。 当前 ABACUS 中一方面存在大量标准定义的 assert，同时也存在自定义的“DEBUG”。虽然新代码中的 assert 被建议使用DEBUG 包裹，但目前依然存在许多旧有的 assert 并没有被__DEBUG 包裹，这种未统一的状态可能会引起一些开发者的困惑。 此外，目前所有 debug 代码依然需要手动用DEBUG 包裹，这与MPI 的情况类似。一种可能的替代方案是 #ifndef __DEBUG_UTILITY_H__ #define __DEBUG_UTILITY_H__ #ifdef __DEBUG // or #ifndef NDEBUG #include #define DEBUG_PRINT_LINE_AND_FILE() std::cout 如此一来，debug 代码可以在开发中被任意使用，而仅在控制 debug 的宏打开时才起具体作用。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-grid.html":{"url":"develop-grid.html","title":"以格点积分程序为例：一些代码开发习惯小贴士","keywords":"","body":"以格点积分程序为例：一些代码开发习惯小贴士 作者：张昊翀，邮箱：zhc@iai.ustc.edu.cn 单位：合肥综合性国家科学中心人工智能研究院 日期：2024 年 7 月 14 日 前言 在 ABACUS 的代码开发的实际过程中，会遇到很多技术和非技术的问题。这里我们结合数值原子轨道的格点积分功能 GPU 化的代码开发经历，介绍相关的编程、开发、调试经验，希望对初入 ABACUS 的开发者有所启发和帮助。 一、格点积分的调试技巧 先易后难的调试过程 bx,by,bz 先都设成 1，1 能跑通再设成 2 等等 同步算法和异步算法优先调通同步的。异步算法不要一次性的全异步化，事先根据代码结构，分块异步化。 多 stream 并行先从 stream 数=1 开发调试。 针对格点积分的问题特点构造例子，我调试的顺序 一个很大的（大于截断半径）晶胞中心一个铜原子，不考虑周期性边界条件 把原子放到晶胞的一个面上，只考虑一个面的周期性边界条件 缩小晶胞，考虑多个面的周期性边界条件 一个很大的（大于截断半径）晶胞中心两个铜原子，不考虑周期性边界条件 缩小晶胞 一个很大的（大于截断半径）晶胞中心一个铜原子和一个氧原子，不考虑周期性边界条件，考虑多种类型的原子 以上都调通基本上也没发现 bug 了 尽量构建更小规模的单元测试 对格点积分 GPU 开发来说，我构建了批量矩阵乘的单元测试。测试方法主要是和 CPU 矩阵乘比较计算结果。 对 GPU 开发来说，构建单元测试的一个有效方法是开发完 cuda 之后再写一份 CPU 的代码，然后比较计算结果。 对于 abacus 来说，和 GPU 输出相同算法相同的 CPU 代码往往可以利用现有的 CPU 代码重构得到。 二、开发节奏 小步快跑，快速积累和迭代。 多提交 每次完成一个小的原子改动就应该 commit 一下。 每次 commit 应该只包含一个功能点相关的改动。 每次 commit 的代码改动量最好不要超过 150 行。 每次 pr 可能是过去几个月 commit 的积累。 多测试 每次 commit 前先用两到三个有代表性的小例子做个快速的测试，尽量保证自己 commit 的代码都是能跑对的，如果 commit 会临时造成计算结果错误那么要在 message 里注明。 每天晚上可以对当日积累的提交做个比较全面的全量测试。如果有例子测试不过可以单独挑出来回退版本看是哪个 commit 引起的。 多交流 要充分利用他人的碎片时间来对自己的代码进行 Code review。每次 commit 的代码尽量让别人在 10 分钟的时间内完成 code review。 好好写 message，写给别人看，也写给自己看。一般人三天以后是看不懂自己写了啥的。 三、内存错误怎么调试 先启用调试信息和编译 debug 版本 cmake -B build -DUSE_CUDA=ON -DCMAKE_BUILD_TYPE=Debug -DDEBUG_INFO=ON cmake --build build -j`nproc` 如果 debug 版本能跑对，但是 release 版本跑不对……那事情就大条了。这种情况有一些是多线程或者代码异步执行导致的。 core dump 请参考以下的教程： https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/developer_guide/debugging-crashed-application https://developer.toradex.com/software/linux-resources/linux-features/enable-and-analyse-core-dumps-in-linux/ gdb 或 cuda-gdb gdb 执行程序调试，直接 run，正常情况下出现内存错误的时候就会停住。然后使用 bt 命令可以查看调用栈，可以定位代码。 Valgrind 内存泄露等错误的利器 https://valgrind.org/docs/manual/quick-start.html 善用 assert 断言 有效帮助我们规范内存使用逻辑 例如： hamilt::AtomPair* tmp_ap = hR->find_pair(iat1, iat2); #ifdef __DEBUG assert(tmp_ap!=nullptr); #endif 最好和__DEBUG 选项配合使用。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-ESolver.html":{"url":"develop-ESolver.html","title":"ESolver 模块介绍","keywords":"","body":"ESolver 模块介绍 作者：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2024 年 11 月 15 日 一、ESolver 模块介绍 1. 物理模型 原子算筹的 ESolver 模块（Energy Solver，简称 ESolver，代表能量求解器）是在给定原子位置的前提下，通过计算该体系的总能量、得到原子的受力、原胞的应力等关键物理量。 无论是密度泛函理论计算还是分子动力学模拟，都是在给定晶格形状和大小，给定好原子坐标后计算体系的总能量。唯一较大的区别是，密度泛函理论把原子拆分成电子和离子两部分开处理，通过计算电子-电子、电子-离子、和离子-离子相互作用来获得体系总能量，而传统分子动力学方法（例如 LJ 势）一般是通过解析的势函数直接计算原子-原子间的相互作用。如果是基于机器学习的分子动力学方法，例如 DPMD 方法，则是通过神经网络来代替原子间的势函数。 在 ESolver 模块中，原子算筹提供了多种能量求解器，包括在 DFT 中通过对角化的方式求解 Kohn-Sham 方程，从而计算系统的基态电子性质。其中 Kohn-Sham 方程的求解又要区分在平面波和局域轨道两种基矢量情况下的代码。此外，ESolver 还提供诸如随机波函数密度泛函理论（Stochastic DFT）、无轨道密度泛函理论（Orbital-Free DFT）、以及随时间演化的含时密度泛函理论（rt-TDDFT）等其他电子结构的求解器。最后，ESolver 还提供了给定 LJ 势或者 DPMD 势来计算体系总能量的功能。 2. 设计思路 ESolver 在 ABACUS 中起着非常重要的作用，属于 ABACUS 的“顶层框架设计”，从 ESolver 会分出不同的基矢量（PW 或者 LCAO），不同的能量求解方法（KSDFT、OFDFT、Stochastic DFT、real-time TDDFT 和 Linear-response TDDFT 方法等），此外还有一些经验势场，包括 DP 方法都在 ESolver 的层次实现了调用，因此有必要规范 ESolver 的写法。 二、ESolver 的设计规范 建议开发者在 ESolver 中采用以下 11 个函数为成员函数，其它新提交的 PR 中若包含这些函数以外的成员函数，将不会被接收。 // 函数1 before_all_runners:在程序初始，离子位置开始变化之前之前需要执行的操作 ESolver::before_all_runners(); for(i=0; i 在 runner()函数内部，一般来讲有以下一些成员函数。如果以下函数不满足需求，可以重载 runner 函数 ESolver::runner() { //函数7 before_scf: 电子自洽迭代循环之前做的操作，包括检查离子位置变化 // 带来的一些物理量的更新 ESolver::before_scf(); // 电子迭代循环 for(iter=0; iter 注：所谓的 nscf，其实就是重载 runner，把电子迭代次数设成 1，或者去掉 scf 的循环。如果最后输出不一样，可以适当调用一些自由函数来输出相关信息。 注：before_scf()包含求 Ewald 能量。 三、代码介绍 1. 代码位置 ESolver 代码的位置在/source/module_esolver/ 整个模块的名字空间（namespace）为 ModuleESolver 2. 代码框架图 图：能量求解器 ESolver 的框架图。ESolver 分成两大部分：第一性原理的能量求解器 ESolver_FP 和经验势的求解器。其中 ESolver_FP 又派生出无轨道密度泛函理论求解器 ESolver_OF（用平面波基矢量）和 Kohn-Sham 密度泛函理论求解器 ESolver_KS。其中 ESolver_KS 需要波函数 Psi，电子信息 ElecState，和电子哈密顿量求解器 HSolver 作为输入，同时可以派生出不同基矢量的能量求解器。 3. 模块关系图 图：a. IO 模块提供 ESolver 需要的输入参数和物理量输出接口; b. Cell 模块作为 ESolver 模块的核心输入，是 ESolver 的求解目标，ESolver 中的 Cell 模块对象是只读的; c. ESolver 模块; d. ESolver 提供 MD 和 Relax 模块需要的系统势能和原子受力、应力的计算; 四、主要功能 每个功能里可以加关键算法和参考文献。 1. esolver.h 父类，其子类只能使用其定义的虚函数接口。 2. esolver_ks_pw 继承了 ESolver_KS，采用平面波求解 KS 方程。 3. esolver_ks_lcao 采用数值原子轨道来构建体系的哈密顿量，通过对角化厄密矩阵的方法来求解 Kohn-Sham 方程，获得系统基态电子密度和总能量。 4. esolver_ks_lcao_tddft 支持采用数值原子轨道进行 real-time TDDFT 计算。 5. esolver_sdft_pw 支持采用平面波进行 stochastic DFT 的计算[2]。采用切比雪夫展开和随机波函数的方法进行电子密度的计算，之后还是采用自洽迭代的方法求出体系的基态电子密度。 6. esolver_of 支持采用平面波进行 OFDFT 的计算。 7. esolver_dp 基于机器学习的分子动力学 DPMD 方法。如果预处理定义了__DPMD，则可以支持 ABACUS+DPMD 的计算 8. esolver_lj 支持 LJ 经验势的计算。 五、ESolver 重构计划 原来在 init_after_vc()函数里的内容应该移入 before_scf() 将会根据上面的原则，逐步去除不合规定的函数（挪到别的模块）。 规范成员变量和成员函数所属层级以及访问权限，关于 ESolver 允许的成员变量的规范仍在制定之中，之后会重新设计成员变量。 ESolver 是否采用模板，以及哪些是模板参数，需要重新评估。 将 ESolver 的继承关系转化为组合的形式，删除没必要的继承。 根据新功能添加更多的 ESolver，例如基于 LCAO 轨道的 DFPT 方法，基于 PW 的 DFPT 方法等等。 六、参考文献 Pengfei Li, Xiaohui Liu, Mohan Chen*, Peize Lin, Xinguo Ren, Lin Lin, Chao Yang, and Lixin He, \"Large-scale ab initio simulations based on systematically improvable atomic basis\", Comp. Mater. Sci., 112, 503 (2016). Qianrui Liu and Mohan Chen*, \"Plane-wave-based stochastic-deterministic density functional theory for extended systems\", Phys. Rev. B, 106, 125132 (2022). Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-HSolver.html":{"url":"develop-HSolver.html","title":"HSolver 模块介绍","keywords":"","body":"HSolver 模块介绍 作者：韩昊知，邮箱：haozhi.han@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 单位：北京大学 最后更新时间：2024/11/15 一、HSolver 模块介绍 1. 物理模型 从密度泛函理论（Density Functinoal Theory，简称 DFT）理论可以推导出 Kohn-Sham 方程，求解 Kohn-Sham 方程是大多数 DFT 软件最核心的功能。由于 Kohn-Sham 方程是非线性特征值问题，因此需要采用自洽场（self-consistent field，简称 SCF）方法进行迭代求解。 求解 Kohn-Sham 方程是一个迭代过程，我们称之为“SCF 迭代”，而对于迭代过程中的每一步叫做“单步 SCF”。 对于单步 SCF，其求解过程等价于对角化描述单电子体系的哈密顿量矩阵 H。 Hsolver 负责单步 SCF 过程中 KS 方程的求解，即：对角化给定的哈密顿矩阵 H。国产开源密度泛函理论软件 ABACUS（原子算筹）里提供了专门的 Hsolver 模块，叫做：module_hsolver。该模块（意为 H 矩阵求解器）聚焦于对角化线性代数里的对称矩阵（或厄密矩阵）问题。 在一次 SCF 内，KS 方程的形式可以写为为\\mathrm{H_k}|\\Psi_{ik}\\rangle=E_{ik}|\\Psi_{ik}\\rangle。这里H代表的是电子系统的哈密顿量，E代表的是能级，|\\Psi\\rangle代表的是 Kohn-Sham 单电子波函数。 2. 数学模型 多次求解特征对 对每一个布里渊区的 k 点，都需要求解一个对应 k 点的 KS 方程。 对于自旋（nspin 参数）为 2 的计算，ABACUS（原子算筹）软件是把两个不同自旋方向的计算当作两组不同的 k 点来处理。 广义特征对问题 在 DFT 中，如果选用正交的基矢量（如：平面波，简称 PW），则待求解方程的形式为：\\mathrm{H_k}|\\Psi_{ik}\\rangle=E_{ik}|\\Psi_{ik}\\rangle。 在 DFT 中，如果选用不正交的基矢量（如：数值原子局域轨道，简称 LCAO），则待求解方程的形式为：\\mathrm{H_k}|\\Psi_{ik}\\rangle=E_{ik} S_{ik}|\\Psi_{ik}\\rangle。其中S矩阵称为基矢量的 Overlap 矩阵。该方程还是求解特征值和特征向量，但是有另一个名称叫广义特征值求解问题。普通的特征值求解问题是广义特征值求解问题的一个特例，即 Overlap 矩阵为单位矩阵的时候。 总结：Hsolver 负责求解一系列个（一个或多个）方程的（广义）特征对。 3. 设计思路 HSolver 在 ABACUS 中起着非常重要的作用，属于 ABACUS 的“顶层框架设计”。Hsolver 主要分为两种不同的求解方式：一种是广泛用于 LCAO 基组的直接求解法；一种是主要用于 PW 基组的迭代求解法。 直接求解法需要调用很多不同的数学库，因此如何统一调用方式是 Hsolver 设计的中重要问题。 迭代求解法也包含很多种方法，如：CG，BPCG，Davidson，Dav-subspace，LOBPCG 等方法。 二、HSolver 的设计规范 1. Hsolver 模块的设计 同时支持迭代法求解广义特征值与调用成熟数学库求解广义特征值两种求解方案。 ABACUS 支持两种基组，它们有着显著不同的特点。 由 PW 基组构造的 H 矩阵拥有超级大的维度，难以存储在计算机内存中，因此需要选用迭代求解的方案求得特征对。 由 LCAO 基组构造的 H 矩阵维度较小，可以存储在计算机内存中，调用成熟的数学库更加快速高效。 module-hsolver 理论上不包含任何物理的知识，仅需高性能计算与线性代数的知识即可。因此其不应该出现物理的内容。 module-hsolver 应该支持多底层硬件的异构，使其可以快速迁移到新的硬件设备上。 2. Diag 模块的设计要求 记录对⻆化消耗的最大内存。 对⻆化的通信域可以被调用者指定，在调用函数中传入。 调用的时候可以指定使用单精度还是双精度（通过模版）。 3. 设计规范 解耦 不包含全局变量和全局函数：Hsolver 本质上并不涉及更多的物理知识，Hsolver 本身是可以独立于 ABACUS 的，因此 Hsolver 内部不需要出现 ABACUS 中包含的全局变量或者全局函数。 Hsolver 及时构造及时销毁：Hsolver 与 ABACUS 的关系只是 ABACUS 会在每次 SCF 的时候调用一次 Hsolver。不同 SCF 之间并没有必要的联系，其本质只是对角化两个不同的矩阵，因此 ABACUS 调用 Hsolver 的方式应该是需要时构造，调用完立刻析构。Hsolver 的对象不应该存在于 ABACUS 非 SCF 的计算流程中。 内存敏感性 在 Hsolver 的求解过程中，会出现内存峰值，为了软件更好的维护与易用，Hsolver 应该提供整个计算过程中其最大内存使用量。 将额外需要申请内存的操作统一到一起进行管理。 把所有大块内存的 malloc 放到构造函数；free 放到析构函数。 通讯域显示化 Hsolver 的求解一定会需要并行，对于开发者来说，清楚当前 Hsolver 采用的并行策略是十分重要的。因此我们的代码应该显示的表现当前 Hsolver 的并行方式。 易用性 Hsolver 会被 ABACUS 调用。因此能否为 ABACUS 提供方便可用的对角化接口是至关重要的。 例如：ABACUS 想要实现混合精度，Hsolver 就必须既能提供单精度求解的接口，又能提供双精度求解的接口。这是 Hsolver 易用性的体现。 三、代码介绍 1. 代码位置 HSolver 代码的位置在/source/module_hsolver/ 整个模块的名字空间（namespace）为 Hsolver ./diag*：Diag 相关类代码。 ./hsolver*：HSolver 相关类代码。 ./genelpa/：ELPA 对角化接口辅助库，用于 DiagoElpa 类。 ./``kernels``/：定义和实现了 Hamitonian 模块中涉及到的多设备支持算子（multi-device operator），目前只对 PW 基组进行了支持。 ./test/：一些 HSolver 的测试数据，持续更新中 2. 代码框架图 HsolverPW 类：负责 PW 基组构造的 H 矩阵的求解。 HsolverPW_SDFT：负责 SDFT 中 PW 基组构造的 H 矩阵的求解。 HsolverLCAO 类：负责 LCAO 基组构造的 H 矩阵的求解。 HsolverLIP 类：负责 lcao-in-pw 的求解过程。 迭代求解法： diago_cg：band-by-band CG（共轭梯度）方法 diago_david: block davidson 方法 diago_bpcg: all band CG 方法 diago_dav_subspace：参考 QE，改进的 davidson 方法 调用数学库求解法： diago_lapack：基于 lapack 数学库求解，不能并行，只能串行。 diago_scalapck：基于 scalapck 数学库求解，只能多核并行（仅 CPU）。 diago_cusolver：基于 Nvidia cusolver 数学库求解，仅能用于 Nvidia GPU 硬件上。且只能用于单 GPU。 diago_cusolvermp：基于 Nvidia cusolver 数学库求解，仅能用于 Nvidia GPU 硬件上。用于多 GPU 并行求解。 diago_elpa 和 diago_elpa_native：基于 ELPA 数学库求解。diago_elpa 是 基于旧版的 ELPA 实现的，diago_elpa_native 是基于新版的 ELPA 实现的。且 diago_elpa_native 同时支持 CPU 并行求解和 GPU 求解。 四、主要功能 Diag 与 Hsolver Hsolver 模块内还有一个子模块叫做 Diag。 Hsolver 负责求解一系列个（一个或多个）方程的（广义）特征对。 Diag 负责求解一个方程的（广义）特征对。 Diag 与 Hsolver 的调用关系 一次 SCF 调⽤⼀次 hsolver ⼀次 hsolver 调用一次或者多次 diag 1. hsolver.h 包含 Hsolver 模块的一些辅助函数。如：set_diagethr_ks，set_diagethr_sdft，reset_diag_ethr，cal_hsolve_error 2. hsolver_pw PW 基组采用迭代法求解 H 矩阵的特征值和特征向量。目前支持的迭代法有：CG，BPCG，Davidson，Dav-subspace。 3. hsolver_pw_sdft 继承自 hsolver_pw，stochastic DFT 中 PW 基组采用迭代法求解 H 矩阵的特征值和特征向量。 4. hsolver_lcao LCAO 基组采用直接求解法求解 H 矩阵的特征值和特征向量。目前支持的直接求解方法有：lapack，scalapack，cusolver，elpa，cusolver。cusolvermp，pexsi 等。 5. hsolver_lcaopw 调用 lcao-in-pw、即将 LCAO 轨道展开成平面波的求解过程。 6. diago_cg 调用 Band-by-band CG 迭代求解法的实现过程。 7. diago_david 调用 Davidson 迭代求解法的实现过程。 8. diago_dav_subspace 调用 Davidson subspace 迭代求解法的实现过程。 9. diago_bpcg 调用多条能带一起运算的 CG 迭代求解法的实现过程。 10. diago_elpa 调用 genELPA（https://github.com/pplab/GenELPA）直接求解广义特征值问题的实现过程。 11. diago_elpa_native 调用 ELPA 原生 API 直接求解广义特征值问题的实现过程。 12. diago_lapack 调用 Lapack 单 CPU 核求解广义特征值问题的实现过程。 13. diago_scalapack 调用 scalapck 通过 2D 块循环（https://www.netlib.org/scalapack/slug/node75.html）的并行方式多 CPU 核求解广义特征值问题的实现过程。 14. diago_cusovler 调用 Nvidia cuSolver 库在 GPU 上快速求解广义特征值问题的实现过程。 15. diago_cusolvermp 调用 Nvidia cuSolverMp 库在多 GPU 上以 2D 块循环并行方式快速求解广义特征值问题的实现过程。 16. diago_pexsi 调用 PEXSI 库求解的实现过程。 五、参考 https://www.netlib.org/lapack/ https://www.netlib.org/scalapack/ https://elpa.mpcdf.mpg.de/ https://docs.nvidia.com/cuda/cusolver/index.html https://docs.nvidia.com/cuda/cusolvermp/ https://github.com/pplab/GenELPA https://www.netlib.org/scalapack/slug/node75.html Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-HContainer.html":{"url":"develop-HContainer.html","title":"HContainer 模块介绍","keywords":"","body":"HContainer 模块介绍 作者 1：郑大也，单位：北京科学智能研究院 作者 2：吴尔杰，单位：北京大学 最后更新时间：2025-03-13 概述 HContainer 是 ABACUS 软件中的一个重要组件，用于存储和操作描述电子体系的哈密顿量矩阵的数据结构，适用于处理基于原子轨道基组建立的具有稀疏性的哈密顿量。由于该数据结构的存储逻辑为对所有可能的原子对（原子 i，原子 j 及二者位置对应的布拉维格矢 R）存储相应的矩阵，因此也适用于存储其它需要按原子对索引的矩阵信息。 代码地址：/source/module_hamilt_lcao/module_hcontainer/ 包含的文件：atom_pair.h, atom_pair.cpp, base_matrix.h, base_matrix.cpp, transfer.h, transfer.cpp, hcontainer_funcs.h, func_transfer.cpp, func_folding.cpp, output_hcontainer.h, output_hcontainer.cpp, hcontainer.h, hcontainer.cpp 特点 模板化：HContainer 目前支持 double 和 std::complex 两种数据类型。 结构化：HContainer 采用三层结构实现，最外层为 HContainer 类，中间层为 AtomPair 类，内存为 BaseMatrix 类，数据可通过该三层结构灵活管理 稀疏性处理：针对数值原子轨道基组下哈密顿量矩阵的稀疏特性，HContainer 提供了专门的存储和访问机制。 并行支持：HContainer 支持 MPI 并行，可以高效地在多处理器上进行数据分配和收集。 灵活的内存管理：HContainer 允许用户自定义内存分配策略，支持内存池的使用，以提高内存使用效率。 使用场景 需要按原子对（AtomPair 数据结构）存储的矩阵信息，例如实空间数值原子轨道基组（LCAO）哈密顿量、交叠矩阵等。 需要按块稀疏矩阵形式存储的对象，比如 LCAO 基组密度矩阵等。 主要组件 HContainer 类 HContainer 类是本模块的核心，提供以下关键功能： 初始化：支持多种初始化方式，包含 通过 Parallel_Orbitals 类的实例对象初始化原子对，适用于轨道并行 从旧的 Hcontainer 对象复制（仅 AtomPair 等结构信息，不包含数据）或移动 利用总原子数创建，不包含任何 AtomPair 信息 从 unitcell 创建，包含所有可能的 AtomPair 信息，可包含 Parallel_Orbitals 信息 内存分配： 存储结构：HContainer 类内部使用 std::vector> 对象 atom_pairs 来存储原子对的信息（AtomPair），这些原子对按照原子序号的矩阵 (i, j) 排序。 稀疏表：HContainer 包含两个成员变量 sparse_ap 和 sparse_ap_index，这两个 std::vector> 用作稀疏表，以快速定位原子对。 内存池：提供 allocate 方法，允许用户指定内存池或由 HContainer 自行分配内存，通过 allocate() 函数第一个传入参数指定（传入指针指定或传入 nullptr 自动分配），第二个 bool 型参数用于指定是否初始化底层 BaseMatrix 矩阵元为 0。可利用 get_memory_size 方法获取总内存占用信息。 数据访问和操作：支持多种数据访问和操作方式，其中加粗字体为主要使用方式。 数据访问： 通过data方法获取特定原子对（i,j,R）的哈密顿量矩阵数据指针 通过 find_matrix 方法获取特定原子对（i,j,R）的哈密顿量矩阵（BaseMatrix）指针 通过 find_matrix_offset 方法获取特定原子对（i,j,R）的数据在内存池中的相对位置 通过 find_pair 方法获取特定原子对（i,j）的 AtomPair 类型指针 通过 get_ijr_info 方法将 HContainer 内所有 AtomPair 的 ijr 信息输出到 std::vector 对象 数据操作： 通过insert_pair方法将特定 AtomPair 加入 HContainer 中 通过 insert_ijrs 方法利用 ijr_info 信息将一系列 AtomPair 批量加入 HContainer 中 通过 add 方法将另外的 HContainer 数据加到当前 HContainer 通过 set_zero 方法将所有矩阵元设置为 0 原子对操作：提供 insert_pair、find_pair、get_atom_pair、find_matrix 和 size_atom_pairs 等方法，方便用户操作原子对。 insert_pair方法： 将 AtomPair 对象添加到 HContainer 中，存储于 atom_pairs 成员变量 能够根据原子对是否已经存在自动处理，保证 atom_pairs 中信息严格有序 能够对 fix_gamma 模式自动执行 merge 操作 find_pair 方法： 根据原子索引 atom_i 和 atom_j，find_pair 方法可以快速定位并返回一个指向 AtomPair 的指针。 由于 atom_pairs 容器中的原子对是排序的，find_pair 可能使用二分查找算法来实现快速搜索。 get_atom_pair 方法： 这个方法返回一个对 AtomPair 的引用，基于原子序号 atom_i 和 atom_j。 与 find_pair 类似，这个方法也依赖于原子对的排序来快速定位。 find_matrix 方法： 这个方法可以根据原子索引和 R 指标来查找 BaseMatrix。 它首先使用 find_pair 找到相应的 AtomPair，然后在 AtomPair 中搜索具有匹配 R 指标的 BaseMatrix。 size_atom_pairs方法： 这个方法用于确定当前 HContainer 对象内包含的 AtomPair 总数，在 fix_R 模式下为当前布拉维格矢对应的 AtomPair 总数。 针对布拉维格矢R 指数的操作： 固定布拉维格矢：通过 fix_R 和 unfix_R 方法，用户可以固定或解除对特定布拉维格矢 R 的哈密顿量矩阵的操作。在 HContainer 内部，fix_R 方法通过将特定布拉维格矢 R（存储于 current_R，可利用 get_current_R 获取）下的原子对信息暂存于 std::vector*> 对象 tmp_atom_pairs，此时可通过 get_atom_pair 方法针对该临时变量进行操作。 布拉维格矢索引循环：在某些情况下，用户可能会需要针对布拉维格矢进行循环操作（例如稀疏矩阵输出）。用户可通过调用 size_R_loop 方法初始化 tmp_R_index 对象并存储 HContainer 内所有 AtomPair 可能的取值，通过返回值获得其大小（注意存储顺序并未按照 R 的取值排序）。用户可通过 find_R 方法获得指定布拉维格矢在 tmp_R_index 对象中的 index，或通过 loop_R 方法从 index 获取特定的布拉维格矢信息。 Gamma 模式：fix_gamma 方法允许 HContainer 进入 Gamma 模式，该模式下只处理 R=(0,0,0) 的哈密顿量矩阵。外部可通过 is_gamma_only 方法获取当前 HContainer 对象是否启用了该模式。 AtomPair 类 AtomPair 类是 HContainer 内主要存储的对象，用于按原子对整理矩阵信息，提供以下功能： 初始化：支持多种初始化方式，包含 通过 Parallel_Orbitals 类的实例对象初始化原子对（i,j，可选择包含 R），适用于轨道并行 利用原子对的轨道矩阵序数初始化原子对（i,j，可选择包含 R） 仅使用原子对序（i,j）初始化 从旧的 AtomPair 对象复制或移动 内存分配： 存储结构：AtomPair 类内部使用 std::vector> 对象 values 来存储矩阵信息，这些矩阵没有严格排序，vector 中每一个值对应某个布拉维格矢 R 下的 BaseMatrix，布拉维格矢 R 信息则对应存储于 std::vector> 对象 R_index。 内存池：提供 allocate 方法，允许用户指定内存池或由 AtomPair 自行分配内存，通过 allocate() 函数第一个传入参数指定（传入指针指定或传入 nullptr 自动分配），第二个 bool 型参数用于指定是否初始化底层 BaseMatrix 矩阵元为 0。可利用 get_memory_size 方法获取该 AtomPair 内存占用信息。 数据访问和操作：支持多种数据访问和操作方式。 数据访问： 通过 get_row_size、get_col_size 或 get_size 获取底层矩阵的维度信息 通过 get_atom_i 和 get_atom_j 获取当前原子对序数信息 通过 identify 方法判断其它原子对或 AtomPair 对象与当前对象是否属于相同原子对 通过 get_HR_values 获取给定布拉维格矢 R 的底层矩阵 BaseMatrix 通过 find_matrix 获取给定布拉维格矢 R 的底层矩阵 BaseMatrix 对象指针 通过 get_matrix_values 获取布拉维格矢序和底层矩阵数据指针的元组 通过 get_value 获取当前固定布拉维格矢 R 模式下特定矩阵元的数据 通过 get_pointer 获取指定卜拉维格式下底层矩阵的数据指针 数据操作： 通过 set_zero 方法将所有矩阵元设置为 0 通过 set_size 方法设置底层矩阵的维度（默认情况下为两个原子的基组长度），需要在 allocate 方法调用前执行以保证内存正确分配 通过 convert_add 将其它 BaseMatrix 值加入指定布拉维格矢 R 对应的底层 BaseMatrix 中 通过 merge 方法将其它 AtomPair 信息加入到当前 AtomPair 中 通过 metge_to_gamma 将所有信息添加到 R=(0,0,0)的 BaseMatrix 中，对应于 HContainer 的 Gamma 模式 通过 add_to_matrix、add_from_matrix 和 add_to_array 将带特定相位的信息存入或读出 针对布拉维格矢 R 指数的操作： 固定布拉维格矢：通过 find_R 方法寻找并指定特定布拉维格矢 R 并存储于 current_R，之后针对特定矩阵的操作将针对在该布拉维格矢下的原子对矩阵进行操作。用户可通过 get_R_size 获取所有可能的 R 取值的大小。 BaseMatrix 类 BaseMatrix 是底层的矩阵类，操作简单，包含： 初始化：指定矩阵行列大小和数据指针（可选）创建，支持使用其它 BaseMatrix 复制或移动创建 内存分配：提供 allocate 方法，允许用户指定内存池或由 AtomPair 自行分配内存，通过 allocate() 函数第一个传入参数指定（传入指针指定或传入 nullptr 自动分配），第二个 bool 型参数用于指定是否初始化矩阵元为 0。可通过 get_memory_size 方法获取当前 BaseMatrix 的内存占用。 数据访问和操作：支持多种数据访问和操作方式。 数据访问： 通过 get_value 方法获取矩阵特定位置的值 通过 get_col_size 和 get_row_size 获取矩阵维度 数据操作： 通过 set_size 方法设置矩阵的列和行（注意顺序）大小，需要在分配内存前指定（在 HContainer 类内矩阵的大小会 AtomPair 自动设置成原子轨道数的大小，但用户可以通过该方法重新设置） 通过 set_zero 方法将所有矩阵元设置为 0 通过 add_array 方法将一个 array 对应的数据按序加到矩阵对应位置 通过 add_element 方法为矩阵特定位置的元素加上某个值 通过 get_pointer 方法获取整个 BaseMatrix 的数据指针头 Output_HContainer 类 Output_HContainer 类独立于 HContainer 类存在，主要用于将信息以稀疏矩阵以 csr 格式输出。 初始化：要求传入 HContainer 对象和输出流（std::ostream）对象，并设定稀疏阈值和输出精度 使用方式：通过直接调用 write 方法按布拉维格矢 R 序（Rx，Ry，Rz 依次从小到大）输出，或使用 write 方法传入特定（Rx，Ry，Rz）输出指定布拉维格矢 R 下的稀疏矩阵信息。输出将直接利用传入的 std::ostream 对象实现 使用示例 Hcontainer 类的使用一般依次包含以下基本操作： 初始化 HContainer 对象（创建对象） 向 HContainer 内加入所有原子对信息（创建 AtomPair 对象并添加）并指定底层矩阵的维度大小（可选） 为 HContainer 分配内存空间并初始化数据 向 HContainer 内添加数据或其他操作 （如果使用了复制创建的方式，则相当于直接执行了前三步，可以直接进行数据操作） 初始化 HContainer HContainer 作为一个类，可以用于实例化存储局域原子轨道基组下的哈密顿量矩阵、重叠矩阵等矩阵。 _// 假设ucell是已经初始化的UnitCell对象，此时HContainer中将包含所有原子对，仅用于构建单元测试_ HContainer HR(ucell); _// 或者使用Parallel_Orbitals对象__paraV来对HContainer初始化__，此时HContianer中不包含任何原子对_ HContainer HR(paraV); // 使用确定的原子对数组初始化 HContainer HR(paraV, data_pointer, ijr_info)； 插入原子对 在初始化 HContainer 的对象时有一个重要步骤，即插入原子对信息。当收集完所有原子对信息之后，即可对 HContainer 的对象进行内存分配。 // double是数据类型，这里0和1代表原子序号i和j（在所有原子中的序数） AtomPair atom_ij(0, 1, paraV); // 不包含R，用于Gamma-only AtomPair atom_ij(0, 1, dRx, dRy, dRz, paraV) // 包含R的信息，也可以用ModuleBase::Vector3对象 // 设定底层矩阵的维度大小（可选，在不执行时默认创建大小为两原子在当前进程的轨道基数） atom_ij.set_size(ncol, nrow); // 在HContainer中插入原子对的信息 HR.insert_pair(atom_ij); 内存分配 在对 HContainer 分配内存时使用 allocate() 函数。此时可以让 HContainer 自身来管理内存空间，也可使用自定义的数组（如这里给出的例子） // 方法一：使用自定义内存空间并初始化为零 double* custom_memory = new double[custom_size]; HR.allocate(custom_memory, true); // 方法二：自动分配内存并初始化为零 HR.allocate(nullptr, true); 数据访问 由于 HContainer 按照块稀疏矩阵格式存储数据，其中的所有数据连续存储在一个一维数组中，直接获取该完整数组的接口为 get_wrapper 函数： double* data_pointer = HR.get_wrapper(); 通过 原子对信息获取目标的小矩阵的接口为 data 函数，其参数为原子 I 和 J 的指标，以及布拉维格子 R，返回的是一个类型 T（doube 或者 complex）的指针 double* data_ijr_pointer = HR.data(i, j, r_index); 其它方法可参考第二章相关部分对照代码使用。 R 指数循环 固定布拉维格子 R，对原子对进行循环操作。 此时 HContainer 中会生成临时 AtomPair 指针数组，用于按顺序遍历包含该布拉维格子 R 的原子对，需要注意的是完成计算后需要手动调用 unfix_R 函数删除该临时指针数组。 HR.fix_R(0, 0, 0); for (int i = 0; i 并行数据传输 HTransPara 和 HTransSerial 类 这两个类用于处理 HContainer 在并行环境下的数据传输： HTransPara：负责并行处理器间的数据打包、发送和接收。 HTransSerial：负责串行处理器与并行处理器间的数据传输。 在 func_transfer.cpp 文件里定义了一系列用于并行数据同步的接口，目前支持 5 种传输功能： transferSerial2Parallels 单进程上完整 HContainer 对象往多进程上 2D 块并行存储 HContainer 对象数据传输；（典型应用场景：暂无） transferParallels2Serial 多进程上 2D 块并行存储 HContainer 对象往单进程上完整 HContainer 对象数据传输；（典型应用场景：gatherParallels） transferSerials2Parallels 多进程上每进程各一个未并行存储的 HContainer 对象往多进程上 2D 块并行存储的 HContainer 对象数据传输并求和（典型应用场景：格点积分 transfer_pvpR）； transferParallels2Serials 多进程上 2D 块并行存储 HContainer 对象往多进程上传输目标进程需要的稀疏特征的未进行并行存储的 HContainer 对象（典型应用场景：格点积分 transfer_DM2DtoGrid）。 gatherParallels 多进程上 2D 块并行存储 HContainer 对象往单进程上未并行且为空的 HContainer 对象数据传输（典型应用场景：write_dmr） 并行模式下的注意事项 并行程序编写：HContainer 中内置了 2D 块轨道并行方案，通过指针 const Parallel_Orbitals* paraV 控制具体的并行方案，每个原子对的稠密矩阵在任何核数并行下都依然是稠密矩阵，调用 HContainer 时不需要手动判断轨道的并行方式，可以结合 Parallel_Orbitals 类中提供的获取 local 轨道指标的功能函数辅助完成高效的并行程序编写。 数据同步：由于 HContainer 中采用了 2D 块轨道并行方案，一个矩阵元数据只唯一存储在其中一个进程的 HContainer 对象上，不需要进行手动同步，数据格式转换或并行方案切换时，可以手动调用 hcontainer_funcs.h 中提供的功能函数。 注 1：目前已开发的基于 HContainer 的功能函数有限，有更多对 HContainer 的接口需求请提交 Issue。 注 2：更多详细 Demo 代码和设计思路详见飞书文档 HContainer 类设计文档 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-19 20:54:48 "},"develop-psi.html":{"url":"develop-psi.html","title":"Psi 模块介绍","keywords":"","body":"Psi 模块介绍 作者：韩昊知，单位：北京大学 最后更新时间：2025-03-13 一、基本简介 Psi 类是 ABACUS 软件里存储电子波函数的模块，实际上存储的是电子波函数在某个特定基组下的系数，是电子结构软件中最基本、最常用、但也耗内存最大的一种数据结构。 另外，Psi 类是一个模板类，用于支持不同设备、不同精度的 Psi 类的构造。 代码地址：/source/module_psi/ 二、Psi Class 支持的基本功能与特点 支持异构存储 Psi 的三维数据： 多设备支持：Psi 类通过模板参数 typename Device 控制 Psi 类在不同底层计算设备上的对象管理和操作。当前支持的异构设备分别是：base_device::DEVICE_CPU、base_device::DEVICE_GPU。 多精度支持：Psi 类通过模板参数 typename T 控制 Psi 类中核心数据的数据类型。当前支持的数据类型包括：double、float、complex、complex。 快速、方便的定位到 Psi 内部的数据： 通过 fix_k 函数固定 k 维度，使后续访问波函数数据更加便捷和高效。 使用运算符函数 (ikb1, ikb2, ibasis) 直接访问目标元素。 三、成员变量 全局信息: T* psi = nullptr: psi 数据的初始位置的指针 Device* ctx = {}: 用于获取设备变量的上下文标识符 bool k_first = true: 表示当前 psi 的存储方式是否是 k 点优先 bool allocate_inside = true: 表示当前 psi 的内存空间是否在当前 psi 对象内部被分配 int npol = 1: 表示当前 nspin 是否等于 4 如果 npol 为 1, nspin 不等于 4 如果 npol 为 2, nspin 等于 4 维度信息: const int* ngk = nullptr: 使用数组表示不同 k 点的对应的 basis 的数量。 nk：psi 第一个维度的长度 nbands：psi 第二个维度的长度 nbasis：psi 第三个维度的长度 可变信息: mutable int current_k = 0: 表示当前 k 点维度索引 mutable int current_b = 0: 表示当前 band 维度的索引 mutable int current_nbasis = 1: 表示当前 basis 维度的索引 mutable T* psi_current = nullptr: 表示 当前 psi 数据的指针 mutable int psi_bias = 0: 表示 当前 psi 数据 与 psi 初始位置 的偏移量 mutable 相关变量的数值会根据 fix 相关函数而改变 四、成员函数 4.1 构造函数 第一类构造函数 (最常用的构造函数) // Constructor 1-1: Psi(const int nk_in, const int nbd_in, const int nbs_in, const int* ngk_in, const bool k_first_in); // Constructor 1-2: Psi(const int nk_in, const int nbd_in, const int nbs_in, const std::vector& ngk_in, const bool k_first_in); 最常用的构造方式 通过 nk_in，nbd_in，nbs_in，ngk_in 构造 psi ngk_in 对应的数组大小应该与 nk_in 相同 分配内存空间 设置 psi 的初始值都为 0 NOTE: Constructor 1-1 在后续的重构中都会被替换为 Constructor 1-2. 请开发者都使用 Constructor 1-2 NOTE: 非必要不构造 k_first_in==false 的 Psi 对象 第二类构造函数 (构造 nk==1 的 Psi 类) // Constructor 2-1: Psi(const int nk_in, // nk-in == 1 const int nbd_in, const int nbs_in, const int current_nbasis_in, const bool k_first_in); 对于这个构造函数 nk-in 永远等于 1 分配内存空间 初始化 psi 的数据为 0 // Constructor 2-2: Psi(T* psi_pointer, const int nk_in, const int nbd_in, const int nbs_in, const int current_nbasis_in, const bool k_first_in); 对于这个构造函数 nk-in 永远等于 1 不需要分配空间 不需要初始化 psi 多用于以零成本的方式将 Tensor / 裸指针 的数据转化为 Psi 类。 第三类构造函数 (拷贝构造函数) // Constructor 3-1: Psi(const Psi& psi_in); // Constructor 3-2: template Psi(const Psi& psi_in); NOTE: Constructor 3-1 在后续的重构中都会被替换为 Constructor 3-2. 4.2 赋值函数 void set_all_psi(const T* another_pointer, const std::size_t size_in); 根据输入指针的数据, 初始化当前 psi 的数据. void zero_out(); 将当前 psi 对象的数据都赋值为 0 4.3 Fix 函数 void fix_k(const int ik) const; 根据 ik 修改 Psi 对象中 5 个 mutable(可变变量)的值 4.4 运算符函数 (ikb1, ikb2, ibasis) T& operator()(const int ikb1, const int ikb2, const int ibasis) const; 该运算符 operator()(ikb1, ikb2, ibasis) 用于访问 Psi 波函数的特定元素，索引方式取决于 k_first 标志的设定： 若 k_first = true，数据按照 k 维度优先存储，ikb1 表示 k 点索引，ikb2 表示能带索引。 若 k_first = false，数据按照能带维度优先存储，ikb1 表示能带索引，ikb2 表示 k 点索引。 该运算符提供了一种灵活的方式，以适应不同存储布局下的高效数据访问。 4.5 其他成员函数 获取指针变量 psi_current： T* get_pointer() const; 获取维度信息 nk const int& get_nk() const; 获取维度信息 nbands const int& get_nbands() const; 获取维度信息 nbasis const int& get_nbasis() const; 获取当前 k 索引 current_k int get_current_k() const; 获取当前 band 索引 current_b int get_current_b() const; 获取当前 k 点的 basis 维度 current_nbasis int get_current_nbas() const; 获取当前是否是 k 维度优先 const bool& get_k_first() const; 五、易混淆概念辨析 5.1 nbasis vs current_nbasis vs ngk Nbasis 表示 Psi 对象 实际内存空间中第三个维度的大小. 当 nspin != 4 的时候, nbasis = ngk 数组中的最大值 当 nspin == 4 的时候, nbasis = (ngk 数组中的最大值 的 2 倍) current_nbasis 表示 当前 k 点的 ngk 变量 无论 nspin 为多少, current_nbasis 总 = ngk[current_k] Ngk 表示 存储 不同 k 点的 basis 变量 的数组指针 5.2 k_first 概念解释 强烈建议开发者在非必要的时候不要使用 k_first = false 的 Psi 设置。目前在 ABACUS 相关代码中，仅在 module_lr 内存在 k_first = false 的 Psi 用法。因此，对于绝大多数的 Psi 使用场景，默认的 k_first = true 即可应对。 在 Psi 类中，k_first 变量决定了数据的存储顺序，影响索引计算和访问方式。当 k_first = true 时，波函数数据按照 k 维度优先 进行存储。在这种情况下，相同 k 点的数据是连续存储的，适用于基于 k 点的计算。 相反，当 k_first = false 时，数据按照 band 维度优先 进行存储，即先存储所有 band 的数据，再存储不同的 k 点，最后是 basis。在这种情况下，相同 band 之间的数据是连续存储的，适用于逐个能带的计算。 六、使用场景 6.1 在指定硬件设备上构造特定精度的 Psi 的对象 在 GPU 上构造数据类型为 std::complex 的 Psi 对象，其中 Psi 三个维度的值分别为 nk = 16, nbands = 24，nbasis = 1024。ngk 表示 16 个 k 点分别对应的有效 basis 的值。 psi::Psi, base_device::DEVICE_GPU> psi = new psi::Psi, base_device::DEVICE_GPU>(16, 24, 1024, ngk, true); 6.2 输出 Psi 的所有值 // 打印所有值 void print_all_values(const psi::Psi& psi) const { for (int ik = 0; ik 6.3 构造 nk==1 的 Psi 类 该需求经常用于构造一个临时的 Psi 对象，用于存储单个 k 点的 psi 数据，常用于 module_hsolver 内部。对于这种需求，我们推荐使用第二类构造函数。 psi::Psi, base_device::DEVICE_GPU> psi = new psi::Psi, base_device::DEVICE_GPU>(1, 24, 1024, 1024, true); 第二类构造函数与第一类构造函数的主要区别在于原本传 ngk 的地方只需要传 const int current_nbasis_in。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-04-01 10:57:06 "},"develop-path1.html":{"url":"develop-path1.html","title":"Introduction to ABACUS: Path to PW calculation - Part 1","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 1 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 1 &#x1F4A1;写在前面 作为 SIAB（Systematically Improvable Atomic orbital Basis, link）数值原子轨道生成程序的数据上游，本系列文档将首先从平面波基组/SCF（Self-Consistent Field，即自洽场迭代）讲起，将《从 SIAB 到 ABACUS》的讲述延续下去，之后再探索 SIAB 的下游，即涉及 NAOs 的 LCAO method（basis_type = 'lcao'）。 本系列文档的预期受众：新晋 ABACUS 开发者 &#x1F3A8;写在前面 实际上，在 2023 Q1（第一季度），ABACUS 发布了面向团队内部的代码编程规范，因此在代码阅读过程中可能遇到各种还没有被更正的变量命名，请格外注意。代码的缩进与其他格式则由 2023.5 发布的新 Pull request 标准，采用clang-format-16标准执行。 &#x1F4C3;写在前面 本系列文档内容的组织原则为： 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 首先通过位于根目录下的 main.cpp 进入程序： int main(int argc, char **argv) { ModuleIO::parse_args(argc,argv); Parallel_Global::read_mpi_parameters(argc,argv); Driver DD; DD.init(); // Driver 在本文档中，我们跳过所有关于记录时间的函数，只关心最主要的部分。在 main.cpp 中定义的 Driver 类对象 DD，其类成员函数 Driver::init() 在根目录 driver.cpp 下被定义： void Driver::init() { this->reading(); this->atomic_world(); INPUT.close_log(); } Driver::reading() 首先从 Driver::init() 来到其所调用第一个函数 Driver::reading()： void Driver::reading(void) { INPUT.Init(GlobalV::global_in_card); .... } Input 便发现 Driver 类可能有数据成员 INPUT，查看头文件 driver.h，并没有关于 Input INPUT 的声明，并且 Driver 类实际上并无任何数据成员，因此需要从 #include 中寻找： #include \"driver.h\" #include \"module_io/input.h\" #include \"module_io/input_conv.h\" #include \"module_hamilt_pw/hamilt_pwdft/global.h\" #include \"module_base/memory.h\" #include \"module_base/timer.h\" #include \"module_esolver/esolver.h\" #include \"module_io/cal_test.h\" #include \"module_io/print_info.h\" #include \"module_io/winput.h\" 追踪到 input.h，发现外部变量声明： extern Input INPUT; 在 input.cpp 中则有 Input INPUT; 这一 INPUT 的变量定义。类似地，我们在更多的被 include 文件中寻找 extern 变量，这些变量都会在程序运行一开始被定义，直到程序结束时才会销毁： // module_hamilt_pw/hamilt_pwdft/global.h namespace GlobalC { // line 284 extern pseudopot_cell_vnl ppcell; // line 292 extern UnitCell ucell; extern Parallel_Grid Pgrid; extern Parallel_Kpoints Pkpoints; extern Restart restart; // Peize Lin add 2020.04.04 即是说例如对于 UnitCell ucell，其数据成员全部会在程序运行一开始被创建。 Input::init() Driver 首先调用的 INPUT 的成员函数 Input::Init()（ABACUS 中很多类都具有 init() 函数，但存在函数名无法体现其功能的问题，可能会在后续工作中修改），该成员函数定义在 source/module_io/input.cpp，同时也发现了 Input INPUT 的定义： //source/module_io/input.cpp Input INPUT; void Input::Init(const std::string &fn) { this->Default(); bool success = this->Read(fn); this->Default_2(); #ifdef __MPI Parallel_Common::bcast_bool(input_error); Parallel_Common::bcast_bool(success); Bcast(); #endif bool out_dir = false; if(!out_app_flag && (out_mat_hs2 || out_mat_r || out_mat_t || out_mat_dh)) out_dir = true; ModuleBase::Global_File::make_dir_out(this->suffix, this->calculation, out_dir, GlobalV::MY_RANK, this->mdp.md_restart, this->out_alllog); Check(); } Input::init() 唯一参数为 fn，实际被传入参数 GlobalV::global_in_card（这里 GlobalV 代表 Global Variables，是全局变量的意思，一般用全大写的变量名，C++ 区分字母大小写，Fortran 不区分）。这一参数在 module_base/global_variable.cpp 中被定义，类似的文件还有 stru_file 和 global_kpoint_card： //source/module_base/global_variable.cpp std::string global_in_card = \"INPUT\"; std::string stru_file = \"STRU\"; std::string global_kpoint_card = \"KPT\"; 因此 Input::init() 函数实际上将要打开 INPUT 文件。 Input::Default() Input::init() 调用 Input::Default() 函数， //source/module_io/input.cpp void Input::Init(const std::string &fn) { this->Default(); // Read(fn); this->Default_2(); .... 其定义为： //source/module_io/input.cpp void Input::Default(void) { suffix = \"ABACUS\"; stru_file = \"\"; // xiaohui modify 2015-02-01 kpoint_file = \"\"; // xiaohui modify 2015-02-01 pseudo_dir = \"\"; orbital_dir = \"\"; // liuyu add 2021-08-14 read_file_dir = \"auto\"; wannier_card = \"none\"; latname = \"none\"; calculation = \"scf\"; esolver_type = \"ksdft\"; pseudo_rcut = 15.0; // qianrui add this parameter 2021-5 pseudo_mesh = false; // qianrui add this pararmeter ntype = 0; ... 即 Input::Default() 函数为所有变量赋默认值。当前所展示的这些变量实际上均为 Input 类的数据成员，而非 GlobalV 等全局类。全局类的存在是为了避免出现巨大的形参表。在 Input::Default() 之后，调用 Input::Read() 函数读取 INPUT 文件，并确定是否读取成功。 Input::Read() //source/module_io/input.cpp void Input::Init(const std::string &fn) { this->Default(); bool success = this->Read(fn); // Default_2(); .... Input::Read() 函数： //source/module_io/input.cpp bool Input::Read(const std::string &fn) { .... std::ifstream ifs(fn.c_str(), std::ios::in); ifs.clear(); ifs.seekg(0); char word[80]; char word1[80]; .... while (ifs.good()) { ifs >> word1; if (ifs.eof()) break; strtolower(word1, word); if (strcmp(\"suffix\", word) == 0) read_value(ifs, suffix); else if (strcmp(\"stru_file\", word) == 0) read_value(ifs, stru_file); ... &#x1F527;重构思考 Input::read() 函数的功能为读取 INPUT 文件（创建 ifstream 类对象 ifs），之后使用对 N 行参数定义，使用最多 N 次 if 判断 strcmp 的方法进行参数读取，若参数读取成功，被传递给 Input 类的数据成员（覆盖）。 由于我们现在考察针对 PW（Plane Wave，平面波）的相关功能，因此额外注意包含 pw 的相关字段： bool Input::Read(const std::string &fn) { .... if (basis_type == \"pw\" && gamma_only != 0) // pengfei Li add 2015-1-31 { gamma_only = 0; GlobalV::ofs_running 这里 \"gamma_only\" 不为 0，是因为目前 ABACUS 不支持只计算单个布里渊区 k=（0，0，0）（通常称为 Gamma 点）的算法，只用 Gamma 点的算法可以把平面波基矢量减少一半，但目前 ABACUS 还不支持。 Input::Default_2() //source/module_io/input.cpp void Input::Init(const std::string &fn) { this->Default(); bool success = this->Read(fn); this->Default_2(); // 接下来 Input 类成员调用其 Input::Default_2() 方法： //source/module_io/input.cpp void Input::Default_2(void) // jiyy add 2019-08-04 { if (GlobalV::MY_RANK != 0) return; if (vdw_s6 == \"default\") { if (vdw_method == \"d2\") vdw_s6 = \"0.75\"; else if (vdw_method == \"d3_0\" || vdw_method == \"d3_bj\") vdw_s6 = \"1.0\"; } if (vdw_s8 == \"default\") { if (vdw_method == \"d3_0\") vdw_s8 = \"0.722\"; else if (vdw_method == \"d3_bj\") vdw_s8 = \"0.7875\"; } ... if (calculation == \"scf\") { if (mem_saver == 1) { mem_saver = 0; ModuleBase::GlobalFunc::AUTO_SET(\"mem_saver\", \"0\"); } this->relax_nmax = 1; } else if (calculation == \"relax\") { if (mem_saver == 1) { mem_saver = 0; ModuleBase::GlobalFunc::AUTO_SET(\"mem_saver\", \"0\"); } cal_force = 1; if (!this->relax_nmax) this->relax_nmax = 50; } 在首先设置 Default，即参数默认值后再覆盖，然后再调用 Default_2 的好处是可以再次覆盖某些参数的实际取值，并根据 case-by-case 地，调整某些值。实际上，此处暗示了一些已经成熟的参数搭配方式，即是说根据特征的任务，实际上都有其一套参数赋值方案。 void Input::Default_2(void) // jiyy add 2019-08-04 { .... if (basis_type == \"pw\") { if (ks_solver == \"default\") { ks_solver = \"cg\"; ModuleBase::GlobalFunc::AUTO_SET(\"ks_solver\", \"cg\"); } else if (ks_solver == \"cg\") { GlobalV::ofs_warning 考虑到一般而言第一性原理软件分支功能众多，且对于 ABACUS，其功能的扩展需要入侵性修改众多代码，行数过多，易扩展性有待提高（关于程序的易扩展性设计方案，见之后单独文档）。因此以下我们首先假设情景为使用 PW 进行 SCF 计算。 ModuleBase::Global_File::make_dir_out() //source/module_io/input.cpp .... void Input::Init(const std::string &fn) { .... bool out_dir = false; if(!out_app_flag && (out_mat_hs2 || out_mat_r || out_mat_t || out_mat_dh)) out_dir = true; ModuleBase::Global_File::make_dir_out(this->suffix, this->calculation, out_dir, GlobalV::MY_RANK, this->mdp.md_restart, this->out_alllog); // 区别于之前的 Input 类中成员函数，这里突然调用的函数变成了 ModuleBase 类。这个函数的功能为读取 INPUT 文件之后，在 INPUT 中定义的 out_dir、suffix 等，在这里可以拼合成为完整路径，并使用 C++/Linux interface 来根据具体任务创建不同的具体输出路径（jump to the code）： //source/module_io/input.cpp void ModuleBase::Global_File::make_dir_out(const std::string &suffix, const std::string &calculation, const bool &out_dir, const int rank, const bool &restart, const bool out_alllog) { std::string prefix ; #ifdef __EPM #ifdef __MPI prefix = \"OUT_EPM_MPI.\"; #else prefix = \"OUT_EPM.\"; #endif #else prefix = \"OUT.\"; #endif GlobalV::global_out_dir = prefix + suffix + \"/\"; GlobalV::global_stru_dir = GlobalV::global_out_dir + \"STRU/\"; GlobalV::global_matrix_dir = GlobalV::global_out_dir + \"matrix/\"; #ifdef __MPI MPI_Barrier(MPI_COMM_WORLD); #endif int make_dir = 0; std::string command0 = \"test -d \" + GlobalV::global_out_dir + \" || mkdir \" + GlobalV::global_out_dir; if(calculation == \"md\") { int make_dir_stru = 0; std::string command1 = \"test -d \" + GlobalV::global_stru_dir + \" || mkdir \" + GlobalV::global_stru_dir; ....} if((out_dir) && calculation == \"md\") { int make_dir_matrix = 0; std::string command1 = \"test -d \" + GlobalV::global_matrix_dir + \" || mkdir \" + GlobalV::global_matrix_dir; times = 0; ....} std::stringstream ss,ss1; if(out_alllog) { ss &#x1F527;重构思考 这部分定义出了相当多的输出文件和目录，然而多个输出文件往往不利于对 ABACUS 新上手使用者，容易在繁多的文件中迷路，因此可以考虑重新设计输出信息。 最后调用 Input::check() 函数对某些参数进行核对。 Input_Conv 返回 Driver::reading()，来到 Input_Conv::Convert(). void Driver::reading(void) { INPUT.Init(GlobalV::global_in_card); Input_Conv::Convert(); // Input_Conv::Convert() 这个函数实现了从 Input 类对象的数据成员到 GlobalV 和 GlobalC 等全局变量集合的转换。相当于从 Input 到 GlobalV 和 GlobalC，以及其他直接的类的参数上载： 其他内容见 ABACUS 第一版开发手册（02. IO 模块，目前暂为飞书内部文档）： void Input_Conv::Convert(void) { .... else if (INPUT.stru_file != \"\") { GlobalV::stru_file = INPUT.stru_file; } GlobalV::global_wannier_card = INPUT.wannier_card; if (INPUT.kpoint_file != \"\") GlobalV::global_kpoint_card = INPUT.kpoint_file; .... GlobalC::ucell.setup(INPUT.latname, INPUT.ntype, INPUT.lmaxmax, INPUT.init_vel, INPUT.fixed_axes); if (INPUT.calculation == \"relax\" || INPUT.calculation == \"cell-relax\") { if (INPUT.fixed_ibrav && !INPUT.relax_new) { ModuleBase::WARNING_QUIT(\"Input_Conv\", \"fixed_ibrav only available for relax_new = 1\"); } .... GlobalV::fixed_atoms = INPUT.fixed_atoms; } for(int i=0;i &#x1F527;重构思考 对模拟体系的完全与分层次描述，是每个模拟软件包的核心设计要求。INPUT 的数据成员不仅录入到 GlobalV, GlobalC，还录入到 BFGS_Basic, Ions_Move_Basic 等类中，或许部分扰乱了这种层级。 winput &#x1F4DD;开发者旁注 本部分内容已经过时，在未来发行版中将会完全弃用 void Driver::reading(void) { INPUT.Init(GlobalV::global_in_card); Input_Conv::Convert(); .... winput::Init(GlobalV::global_wannier_card); // 接下来来到 Wannier 函数计算部分，调用 Init()函数，传入参数为 wannier 文件的具体路径（winput 相关的这部分功能目前已经基本不使用，相关读入参数都在 INPUT 里面实现，后续版本会把这部分代码删除）。 在 Input::Default() 中，该量被设置为 \"none\"，在 Input::Read() 中，该量对应于关键词 wannier_card 被读入。实际上，一般将 wannier_card 赋值为 INPUTw。 winput::Init() void winput::Init(const std::string &fn) { Default(); Read(fn); Check(); #ifdef __MPI Bcast(); #endif } winput::Default() wannier_card 部分同样具有 Default() 函数， void winput::Default() { //======================== // part1 : control //======================== target = \"test\"; wlmr_dir = \"./\"; rcut = 10; before_iter = false; after_iter = false; begin_stop_flag = false; end_flag = false; ... } 其中各变量均为 winput 中数据成员，类型附加 static 关键词。 winput::Read() &#x1F527;重构思考 此处仍然使用 if(strcmp()) 方法读入输入文件中参数 void winput::Read(const std::string &fn) { if(GlobalV::MY_RANK!=0) return; std::ifstream ifs(fn.c_str(), std::ios::in); ifs.clear(); ifs.seekg(0); char word[80]; .... while (ifs.good()) { ifs >> word; for(auto &i : word) { i = tolower(i); } //parameters for users if (strcmp(\"target\", word) == 0) {read_value(ifs, target);} else if (strcmp(\"trial\", word) == 0) {read_value(ifs, trial);} ... winput::check() 则同样地，进行一些检查。 变量分发举例：winput::Bcast()和 Input::Bcast() 和 Input 一样，winput::Bcast() 对读入所有参数进行节点间广播： #include \"module_base/parallel_common.h\" #ifdef __MPI void winput::Bcast(void) { Parallel_Common::bcast_string( target ); Parallel_Common::bcast_bool( before_iter ); ... Parallel_Common::bcast_double( rcut ); ... Parallel_Common::bcast_string( wlmr_dir ); ... Parallel_Common::bcast_int( imp_pao ); ... 同理在 Input::Bcast() 中： #ifdef __MPI void Input::Bcast() { Parallel_Common::bcast_string(suffix); Parallel_Common::bcast_string(stru_file); // xiaohui modify 2015-02-01 Parallel_Common::bcast_string(pseudo_dir); // Parallel_Common::bcast_string(pseudo_type); // mohan add 2013-05-20 (xiaohui add 2013-06-23) Parallel_Common::bcast_string(orbital_dir); Parallel_Common::bcast_string(kpoint_file); // xiaohui modify 2015-02-01 Parallel_Common::bcast_string(wannier_card); ... Prallel_Common 属于 module_base 中 parallel_common.h 中声明的自建命名空间，其声明大致如下： namespace Parallel_Common { void bcast_complex_double( std::complex *object, const int n); ... void bcast_complex_double( std::complex &object); ... } 举例其中 Prallel_Common::bcast_int()： void Parallel_Common::bcast_int(int &object) { MPI_Bcast(&object, 1, MPI_INT, 0, MPI_COMM_WORLD); } 其中 MPI_Bcast() 为 MPI 内部函数，其参数表中分别传入了需广播数据的内存地址、、数据类型，以及。 ▶ 离开 winput，回到 source/driver.cpp Driver::reading()，只剩下如下内容： std::stringstream ss1; ss1 Driver::atomic_world() Driver::atomic_world() 函数中执行的内容其实只有 Driver::driver_run() 函数： void Driver::atomic_world(void) { this->driver_run(); } 不要忘记我们已经完成 Driver::reading() 函数内容，到达 Driver::atomic_world()。这一点从本文档设置的分级目录中也可以看得到。 void Driver::init() { this->reading(); this->atomic_world(); // Driver::driver_run() esolver ESolver 是 ABACUS 内部工作流的驱动，根据当前模拟任务所属阶段，按顺序调用各个所需模块， &#x1F4DD;开发者旁注 原则上讲，ESolver 不应当含有 Device 和 FPTYPE 模板参数，未来将会被舍弃 Driver::driver_run() 定义在 source/driver.cpp 文件中，是实际驱动 ABACUS 各模块的驱动（driver）。首先创建 ESolver 类指针，并利用 ModuleESolver::init_esolver() 将其初始化： void Driver::driver_run() { ModuleESolver::ESolver *p_esolver = nullptr; ModuleESolver::init_esolver(p_esolver); ... ModuleESolver::init_esolver() 我们目前只关注 pw 基的方法，首先调用 ModuleESolver::determine_type() 函数，读取具体在 INPUT 中定义的计算类型（GlobalV::ESOLVER_TYPE 和 GlobalV::BASIS_TYPE）： void init_esolver(ESolver*& p_esolver) { std::string esolver_type = determine_type(); 作为回溯，GlobalV::ESOLVER 和 GlobalV::BASIS_TYPE 的赋值在 module_io/input_conv.cpp： GlobalV::BASIS_TYPE = INPUT.basis_type; // line 320 GlobalV::ESOLVER_TYPE = INPUT.esolver_type; // line 273 其在 INPUT 中关键词为（module_io/input.cpp）： else if (strcmp(\"basis_type\", word) == 0) //line 843 { read_value(ifs, basis_type); ... else if (strcmp(\"esolver_type\", word) == 0)// line 685 { read_value(ifs, esolver_type); } ... ModuleESolver::determine_type() 接下来根据 basis_type 和 esolver_type 两关键词对 esolver_type 进行赋值（❗ 此处已经出现 esolver 一词多义，在 ModuleESolver 域中实际上是 [能量计算方法]_[基组](_[任务类型]） 的合并）： std::string determine_type() { std::string esolver_type = \"none\"; if (GlobalV::BASIS_TYPE == \"pw\") { if(GlobalV::ESOLVER_TYPE == \"sdft\") esolver_type = \"sdft_pw\"; else if(GlobalV::ESOLVER_TYPE == \"ofdft\") esolver_type = \"ofdft\"; else if(GlobalV::ESOLVER_TYPE == \"ksdft\") esolver_type = \"ksdft_pw\"; } else if (GlobalV::BASIS_TYPE == \"lcao_in_pw\") { #ifdef __LCAO if(GlobalV::ESOLVER_TYPE == \"sdft\") esolver_type = \"sdft_pw\"; else if(GlobalV::ESOLVER_TYPE == \"ksdft\") esolver_type = \"ksdft_pw\"; #endif } else if (GlobalV::BASIS_TYPE == \"lcao\") { #ifdef __LCAO if(GlobalV::ESOLVER_TYPE == \"tddft\") esolver_type = \"ksdft_lcao_tddft\"; else if(GlobalV::ESOLVER_TYPE == \"ksdft\") esolver_type = \"ksdft_lcao\"; #endif } else { if(GlobalV::ESOLVER_TYPE == \"lj\") esolver_type = \"lj_pot\"; else if(GlobalV::ESOLVER_TYPE == \"dp\") esolver_type = \"dp_pot\"; else if(esolver_type == \"none\") { ModuleBase::WARNING_QUIT(\"ESolver\", \"No such esolver_type combined with basis_type\"); } } return esolver_type; } 得到 esolver_type，返回 ModuleESolver::init_esolver()，之后根据其由 esolver_type 定义的不同内容，为创建的 p_esolver 指定对应类型的内存空间，此时注意到各类 ESolver_* 实际上都是对 ModuleESolver::ESolver 父类的继承，而 p_esolver 为父类指针： if (esolver_type == \"ksdft_pw\") { #if ((defined __CUDA) || (defined __ROCM)) if (GlobalV::device_flag == \"gpu\") { if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); return; } #endif if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); } #ifdef __LCAO else if (esolver_type == \"ksdft_lcao\") p_esolver = new ESolver_KS_LCAO(); else if (esolver_type == \"ksdft_lcao_tddft\") p_esolver = new ESolver_KS_LCAO_TDDFT(); #endif else if (esolver_type == \"sdft_pw\") p_esolver = new ESolver_SDFT_PW(); else if (esolver_type == \"ofdft\") p_esolver = new ESolver_OF(); else if (esolver_type == \"lj_pot\") p_esolver = new ESolver_LJ(); else if (esolver_type == \"dp_pot\") p_esolver = new ESolver_DP(INPUT.mdp.pot_file); } 各种 esolver 的继承关系如下所示。例如 ESolver_KS_PW 和 ESolver_KS_LCAO，均公有继承自 ESolver_KS： // module_solver/esolver_ks_pw.h namespace ModuleESolver { template class ESolver_KS_PW : public ESolver_KS // module_esolver/esolver_ks_lcao.h namespace ModuleESolver { class ESolver_KS_LCAO : public ESolver_KS ESolver_KS 则公有继承自 ESolver_FP： // module_solver/esolver_ks.h namespace ModuleESolver { template class ESolver_KS : public ESolver_FP ESolver_FP 公有继承自 ESolver： // module_solver/esolver_fp.h namespace ModuleESolver { class ESolver_FP : public ESolver 而 p_esolver 为 ModuleESolver::ESolver 类指针，自然可以如此赋值。其他关于各种 ESolver 的层级关系，可见第一版开发者手册的 09. ESolver 模块 （目前暂为飞书内部文档) 。接下来我们假设 esolver_type == \"ksdft_pw\"，则我们需要关注前面已经展示过的（module_esolver/esolver.cpp ModuleESolver::init_esolver(): line 93）： if (esolver_type == \"ksdft_pw\") { #if ((defined __CUDA) || (defined __ROCM)) if (GlobalV::device_flag == \"gpu\") { if (GlobalV::precision_flag == \"single\") { p_esolver = new ESolver_KS_PW(); } else { p_esolver = new ESolver_KS_PW(); } return; } #endif if (GlobalV::precision_flag == \"single\") { p_esolver = new ESolver_KS_PW(); } else { p_esolver = new ESolver_KS_PW(); } } 我们首先只关注 p_esolver = new ESolver_KS_PW();，即精度为浮点双精度，使用 cpu 为计算设备的情况。 不难发现，关于 ESolver_KS_PW 类的具体实现，同时使用数据类型和设备作为模板： namespace ModuleESolver { template ESolver_KS_PW::ESolver_KS_PW() { this->classname = \"ESolver_KS_PW\"; this->basisname = \"PW\"; this->device = psi::device::get_device_type(this->ctx); #if ((defined __CUDA) || (defined __ROCM)) if (this->device == psi::GpuDevice) { hsolver::createBLAShandle(); hsolver::createCUSOLVERhandle(); } #endif } 其代入的设备类型 psi::DEVICE_CPU，是 psi 命名空间的变量。 至此，ModuleESolver::init_esolver() 退出，p_esolver 有值 &ESolver_KS_PW()，来到设置模拟体系的结构部分。 附录 配置便捷高效 Vscode C++ 工作环境（Windows） 在大型程序的代码阅读过程中，往往遇到变量和函数数量大，源文件、头文件不计其数的情况。因此高效、快速寻找当前感兴趣变量/函数/类/命名空间的上下游就十分重要。Vscode 是由 Microsoft 开发的集成开发环境，具有轻量、灵活、功能健全、插件开发者活跃、程序迭代较快等优点，因此推荐 Vscode 作为 ABACUS 的编辑器。 Vscode 下载链接：Download Visual Studio Code - Mac, Linux, Windows 在选择“是否把 vscode 添加到 PATH 环境变量”时，如无特殊需求，建议选择“是”，同时在选择“是否将 vscode 添加到右键菜单”时，选择“是”。 相关资料：新人教程文档（目前暂为飞书内部文档) Vscode C++ 插件 配置完成 Vscode 后，在其扩展商店搜索“C/C++”，即可顺利一并安装三个插件，用于 C++ 程序的开发工作。 Mingw64 GNU compilers 为了让 C++ 开发环境变得更加智能，需要联合编译器，让编译器寻找变量、函数、类、命名空间等之间跨文件的引用关系。为了实现这一点，见 Microsoft Vscode 关于 C++ 编译器的官方配置教程： Get Started with C++ and Mingw-w64 in Visual Studio Code 之后在 vscode setting.json 添加 “C_Cpp.default.compilerPath” 值，且可选 \"C_Cpp.default.cppStandard\" 值，对于 ABACUS，通常选择 \"c++11\" 或 \"c++14\"。 Mingw64 fftw3, mpi and googletest libraries 为了能够尽可能多避免 vscode 浏览 ABACUS 代码过程中报错，可以选择安装发行在 msys2 系列平台上的 fftw3 和 msmpi 库： fftw3: https://packages.msys2.org/package/mingw-w64-i686-fftw?repo=mingw32 msmpi: https://packages.msys2.org/package/mingw-w64-x86_64-msmpi Googletest: https://packages.msys2.org/base/mingw-w64-googletest 其他常见的库也可以在 https://packages.msys2.org/进行搜索后，复制命令在 msys2 prompt 进行下载安装 CMake ABACUS 使用 CMake 便捷编译，因此也可以在本地配置 CMake。 下载、安装 CMake：Download | CMake 将安装好的 CMake 一并放入 PATH 环境变量，之后在 Vscode setting.json 中添加 “cmake.generator”，以及 \"cmake.cmakePath\" 值，设置 \"cmake.additionalCompilerSearchDirs\"。 将本地 Vscode 连通 Bohrium 平台进行高效编译开发 Bohrium 平台提供在线云计算服务，对于 ABACUS 开发工作，可以在其服务器上进行软件编译。 Bohrium 网站： 之后请 follow 单元测试环境搭建教程：新人教程文档 （目前暂为飞书内部文档) 变量、函数、类的声明、定义、调用快捷跳转 对准想要查看其声明、定义和调用（引用）的量，点击鼠标右键： 若跳转到声明（.h 文件），发现其声明旁未添加注释，或注释并非 Doxygen 格式，可以在 Vscode 扩展应用商店下载 Doxygen 插件后，发现菜单出现“生成 Doxygen 注释”，将注释内容复写为 Doxygen 格式。 相关材料：自动文档 Doxygen 使用说明 （目前暂为飞书内部文档) 给你的开发加点魔法：Github.copilot vscode 部署 首先进行 Github 学生认证：https://education.github.com/pack 然后在 vscode 上 Extension 界面下载 Github copilot 插件。vscode 通过最下角 Github 账号登录来验证 Github.copilot 的使用权限（完成学生认证后自动拥有 Github.copilot 的使用权限）。 系列链接 上篇：从 SIAB 到 ABACUS（一）：准备工作（施工中 &#x1F6A7;） 下篇：Introduction to ABACUS: Path to PW calculation - Part 2 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-path2.html":{"url":"develop-path2.html","title":"Introduction to ABACUS: Path to PW calculation - Part 2","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 2 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 2 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 承接上篇对 INPUT 文件的解析，本篇延续 ABACUS workflow，介绍和 STRU 文件中信息读取紧密相关的 UnitCell 类。 Driver Driver::atomic_world() Driver::driver_run() ucell 在 driver_run.cpp 中直接调用了 GlobalC 的数据成员 UnitCell ucell 的成员函数 UnitCell::setup_cell()， // driver_run.cpp void Driver::driver_run() { .... GlobalC::ucell.setup_cell(GlobalV::stru_file, GlobalV::ofs_running); 则自然回忆回溯在何时 ucell 被声明、定义、初始化的（尽管在上篇中已经明确提到）。寻得在 module_hamilt_pw/hamilt_pwdft/global.h 中，有关于 ucell 为 extern 变量的声明： namespace GlobalC { extern UnitCell ucell; 同时在 module_hamilt_pw/hamilt_pwdft/global.cpp 中，有其定义： namespace GlobalC { UnitCell ucell; 则对于需要使用到 UnitCell 对象 ucell 的场合，只需要包含 module_hamilt_pw/hamilt_pwdft/global.h 头文件即可，其中 ucell 为全局类（将来可能会把这个全局类去掉，换成指定范围内可以使用的模块）。 UnitCell:setup_cell() ucell 的一些数据成员在 Input_Conv::Convert() 函数中赋值： // line 266 GlobalC::ucell.setup(INPUT.latname, INPUT.ntype, INPUT.lmaxmax, INPUT.init_vel, INPUT.fixed_axes); GlobalC::UnitCell::setup() 函数除了导入前四个量外，根据最后一个传入参数，控制 UnitCell ucell 中晶格矢量的约束条件 lc[0], lc[1] 和 lc[2]。可见 lc[i] 实际上可能会出现在晶格矢量的 rescale factor 里，额外使用 lc[i] 作为变化量的 factor，若为 0，固定，则该晶格矢量在程序运行中不会有变化。 void UnitCell::setup(const std::string& latname_in, const int& ntype_in, const int& lmaxmax_in, const bool& init_vel_in, const std::string& fixed_axes_in) { this->latName = latname_in; this->ntype = ntype_in; this->lmaxmax = lmaxmax_in; this->init_vel = init_vel_in; if (fixed_axes_in == \"None\") this->lc[0] = 1; this->lc[1] = 1; this->lc[2] = 1; else if (fixed_axes_in == \"volume\") { this->lc[0] = 1; this->lc[1] = 1; this->lc[2] = 1; if (!GlobalV::relax_new) { ModuleBase::WARNING_QUIT( \"Input\", \"there are bugs in the old implementation; set relax_new to be 1 for fixed_volume relaxation\"); } } else if (fixed_axes_in == \"shape\") { if (!GlobalV::relax_new) { ModuleBase::WARNING_QUIT(\"Input\", \"set relax_new to be 1 for fixed_shape relaxation\"); } this->lc[0] = 1; this->lc[1] = 1; this->lc[2] = 1; } else if (fixed_axes_in == \"a\") this->lc[0] = 0; this->lc[1] = 1; this->lc[2] = 1; ....//omit b and c else if (fixed_axes_in == \"ab\") this->lc[0] = 0; this->lc[1] = 0; this->lc[2] = 1; ....//omit without b and c else if (fixed_axes_in == \"abc\") this->lc[0] = 0; this->lc[1] = 0; this->lc[2] = 0; else ....//warning and quit return; } 回到 Driver::driver_run() 的 line 33（Link），其所调用 UnitCell::setup_cell() 函数首先根据前文提到在 Input_Conv::Convert() 中调用的 UnitCell::setup() 函数，确定了 UnitCell::ntype，因此使用 ntype 重新为 magnet.start_magnetization 分配内存空间。UnitCell::magnet 成员变量在 module_cell/unitcell.h 中被声明。类似的还有 ucell.atoms 等。 void UnitCell::setup_cell(const std::string &fn, std::ofstream &log) { delete[] magnet.start_magnetization; magnet.start_magnetization = new double[this->ntype]; this->atoms = new Atom[this->ntype]; this->set_atom_flag = true; class UnitCell { public: Magnetism magnet; // magnetism Yu Liu 2021-07-03 在 Driver::driver_run() 中调用 UnitCell::setup_cell() 时，传入参数 GlobalV::stru_file 和文件流对象 GlobalV::ofs_running，前者具有默认值 STRU（Introduction to ABACUS: Path to PW calculation - Part 1 Input::init()），后者同样具有默认值，见 global_file.cpp。 STRU file parse 若 STRU 文件存在，读取其中内容： const int error = this->read_atom_species(ifa, log); ok2 = this->read_atom_positions(ifa, log, GlobalV::ofs_warning); ifa 即为打开 STRU 的 ifstream 文件流对象，log 为 GlobalV:ofs_running 变量。 Basic structure of STRU file: examples 在开始阅读 STRU 文件解析程序部分之前，首先展示几种 STRU 文件样例： // with latname = 'fcc' in INPUT file ATOMIC_SPECIES Si 28.00 Si_ONCV_PBE-1.0.upf // label; mass; pseudo_file NUMERICAL_ORBITAL Si_gga_8au_60Ry_2s2p1d.orb //numerical_orbital_file LATTICE_CONSTANT 10.2 // lattice scaling factor (Bohr) ATOMIC_POSITIONS Direct //Cartesian or Direct coordinate. Si // Element type 0.0 // magnetism 2 // number of atoms 0.00 0.00 0.00 0 0 0//the position of atoms and other parameter specify by key word 0.25 0.25 0.25 1 1 1 // with latname = 'none' or do not set it in INPUT file ATOMIC_SPECIES Si 28.00 Si_ONCV_PBE-1.0.upf upf201 // label; mass; pseudo_file; pseudo_type NUMERICAL_ORBITAL Si_gga_8au_60Ry_2s2p1d.orb //numerical_orbital_file LATTICE_CONSTANT 10.2 // lattice scaling factor (Bohr) LATTICE_VECTORS 0.5 0.5 0.0 // latvec1 0.5 0.0 0.5 // latvec2 0.0 0.5 0.5 // latvec3 ATOMIC_POSITIONS Direct //Cartesian or Direct coordinate. Si // Element type 0.0 // magnetism(Be careful: value 1.0 refers to 1.0 bohr mag, but not fully spin up !!!) 2 // number of atoms 0.00 0.00 0.00 0 0 0 0.25 0.25 0.25 1 1 1 ATOMIC_SPECIES Pt 195.08 Pt_ONCV_PBE-1.0.upf LATTICE_CONSTANT 1.8897259886 // 1 Angstrom, but unit required is Bohr, so it is this value LATTICE_VECTORS 8.4359998703 0.0000000000 0.0000000000 -4.2179999352 7.3057901940 0.0000000000 0.0000000000 0.0000000000 25.1919994354 ATOMIC_POSITIONS Cartesian // Cartesian (Unit is LATTICE_CONSTANT) Pt 0.0 27 0.000000000 0.000000000 3.288052246 1.405985941 0.811746362 1.643526123 0.000000000 1.623492723 0.000000000 2.811971882 0.000000000 3.287052246 ... // directly start after ATOMIC_POSITIONS' title Fe 1.0 2 0.0 0.0 0.0 m 0 0 0 mag 1.0 angle1 90 angle2 0 0.5 0.5 0.5 m 1 1 1 mag 1.0 angle1 90 angle2 180 &#x1F527;重构思考 将来可以增添 xyz 格式的原子信息文件到 ABACUS 的接口以增强易用性。 UnitCell::read_atom_species() ⚙UnitCell::read_atom_species() 函数实际上读取除原子坐标外的所有信息，如晶格矢量 latvec 等。这些变量都是 UnitCell 的数据成员。具体读取的 section 有 ATOMIC_SPECIES, NUMERICAL_ORBITAL, NUMERICAL_DESCRIPTOR, ABFS_ORBITAL, LATTICE_CONSTANT, LATTICE_VECTORS, LATTICE PARAMETERS 等。 int UnitCell::read_atom_species(std::ifstream &ifa, std::ofstream &ofs_running) { int error = 0; delete[] atom_label; this->atom_mass = new double[ntype]; delete[] atom_mass; this->atom_label = new std::string[ntype]; delete[] pseudo_fn; this->pseudo_fn = new std::string[ntype]; delete[] pseudo_type; this->pseudo_type = new std::string[ntype]; delete[] orbital_fn; this->orbital_fn = new std::string[ntype]; ... if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"ATOMIC_SPECIES\") ) { ... #ifdef __LCAO if(GlobalV::BASIS_TYPE==\"lcao\" || GlobalV::BASIS_TYPE==\"lcao_in_pw\") { if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"NUMERICAL_ORBITAL\") ) { for(int i=0; i> orbital_fn[i]; } if(GlobalV::deepks_setorb) { if (ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"NUMERICAL_DESCRIPTOR\")) { ifa >> descriptor_file; } } else descriptor_file = GlobalV::global_orbital_dir + orbital_fn[0]; } ... #ifdef __EXX if( GlobalC::exx_info.info_global.cal_exx ) { if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"ABFS_ORBITAL\") ) { for(int i=0; i> ofile; GlobalC::exx_info.info_ri.files_abfs.push_back(ofile); } } } if (GlobalV::rpa_setorb) { if (ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"ABFS_ORBITAL\")) { GlobalV::rpa_orbitals.resize(ntype); for (int i = 0; i > GlobalV::rpa_orbitals[i]; } } .... if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_CONSTANT\") ) { ModuleBase::GlobalFunc::READ_VALUE(ifa, lat0); lat0_angstrom = lat0 * 0.529177 ; this->tpiba = ModuleBase::TWO_PI / lat0; this->tpiba2 = tpiba * tpiba; } ... if(latName==\"none\"){ if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_VECTORS\") ) { ifa >> latvec.e11 >> latvec.e12; ModuleBase::GlobalFunc::READ_VALUE(ifa, latvec.e13); ifa >> latvec.e21 >> latvec.e22; ModuleBase::GlobalFunc::READ_VALUE(ifa, latvec.e23); ifa >> latvec.e31 >> latvec.e32; ModuleBase::GlobalFunc::READ_VALUE(ifa, latvec.e33); // read e(i)3 in this way is to change to the next line } if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_PARAMETERS\") ) { ModuleBase::WARNING_QUIT(\"UnitCell::read_atom_species\",\"do not use LATTICE_PARAMETERS without explicit specification of lattice type\"); } } else{ if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_VECTORS\") ) { ModuleBase::WARNING_QUIT(\"UnitCell::read_atom_species\",\"do not use LATTICE_VECTORS along with explicit specification of lattice type\"); } if(latName==\"sc\"){//simple-cubic, ibrav = 1 latvec.e11 = 1.0; latvec.e12 = 0.0; latvec.e13 = 0.0; latvec.e21 = 0.0; latvec.e22 = 1.0; latvec.e23 = 0.0; latvec.e31 = 0.0; latvec.e32 = 0.0; latvec.e33 = 1.0; else if(latName==\"fcc\"){//face-centered cubic, ibrav = 2 ...} else if(latName==\"bcc\"){//body-centered cubic, ibrav = 3 ...} ... else if(latName==\"triclinic\"){//triclinic, ibrav = 14 double bba = 0.0; double cba = 0.0; double cosab = 0.0; double cosac = 0.0; double cosbc = 0.0; double sinab = 0.0; double term = 0.0; if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifa, \"LATTICE_PARAMETERS\") ) { ifa >> bba >> cba >> cosab >> cosac; ModuleBase::GlobalFunc::READ_VALUE(ifa, cosbc); sinab = sqrt(1.0-cosab*cosab); } latvec.e11 = 1.0; latvec.e12 = 0.0; latvec.e13 = 0.0; latvec.e21 = bba * cosab; latvec.e22 = bba * sinab; latvec.e23 = 0.0; latvec.e31 = cba * cosac; latvec.e32 = cba * (cosbc - cosac*cosab) / sinab; term = 1.0 + 2.0 * cosab*cosac*cosbc - cosab*cosab - cosac*cosac - cosbc*cosbc; term = sqrt(term)/sinab; latvec.e33 = cba * term; } else{ std::cout 我们约定，LATTICE_CONSTANT无量纲，LATTICE_VECTORS有量纲，STRU文件中原子坐标无量纲。 UnitCell::read_atom_positions() &#x1F527;重构思考 同样地，UnitCell::read_atom_positions() 函数也不仅仅读取原子的位置，还额外读取各种具体涉及每个原子的速度、固定、磁化等等信息。 首先来到读取 STRU ATOMIC_POSITIONS 部分： bool UnitCell::read_atom_positions(std::ifstream &ifpos, std::ofstream &ofs_running, std::ofstream &ofs_warning) { if( ModuleBase::GlobalFunc::SCAN_BEGIN(ifpos, \"ATOMIC_POSITIONS\")) { ModuleBase::GlobalFunc::READ_VALUE( ifpos, Coordinate); STRU 第二行指定坐标类型，被读取为 UnitCell::Coordinate。UnitCell::Coordinate 在 STRU 里有不同选项，⚙ 决定原子的具体位置和单位： if(Coordinate != \"Cartesian\" && Coordinate != \"Direct\" && Coordinate != \"Cartesian_angstrom\" && Coordinate != \"Cartesian_au\" && Coordinate != \"Cartesian_angstrom_center_xy\" && Coordinate != \"Cartesian_angstrom_center_xz\" && Coordinate != \"Cartesian_angstrom_center_yz\" && Coordinate != \"Cartesian_angstrom_center_xyz\" ) { ModuleBase::WARNING(\"read_atom_position\",\"Cartesian or Direct?\"); ofs_warning 这将决定最后实际的原子坐标： // module_cell/read_atom.cpp: line 695 if(Coordinate==\"Direct\") { atoms[it].taud[ia] = v; atoms[it].tau[ia] = v * latvec; } else if(Coordinate==\"Cartesian\") { atoms[it].tau[ia] = v ; } else if(Coordinate==\"Cartesian_angstrom\") { atoms[it].tau[ia] = v / 0.529177 / lat0; } else if(Coordinate==\"Cartesian_angstrom_center_xy\") { latcenter.x = (latvec.e11 + latvec.e21 + latvec.e31)/2.0; latcenter.y = (latvec.e12 + latvec.e22 + latvec.e32)/2.0; latcenter.z = 0.0; atoms[it].tau[ia] = v / 0.529177 / lat0 + latcenter; ... &#x1F527;重构思考 ABACUS 代码中现在分原子类型导入数据，尽管在代码中分种类管理原子是十分自然的选择，但 ABACUS 将这种选择表露在用户端，因此 STRU 中关于原子位置的定义也必须按类型分开输入。 接下来是按原子种类循环 ATOMIC_POSITIONS section: int na = 0; this->nat = 0; assert(ntype>0); for (int it = 0;it &#x1F527;重构思考 进入循环体，检查在 ATOMIC_POSITIONS section 中原子定义的顺序是否和 ATOMIC_SPECIES 相同 &#x1F4DD;开发者旁注 已在重构计划中 ModuleBase::GlobalFunc::READ_VALUE(ifpos, atoms[it].label); bool sequence_match = false; for(int it2=0; it2atoms[it].label == this->atom_label[it2] ) { if (it2 == it) sequence_match = true; } } if(!sequence_match) { ... return 0; } 读取当前原子类型的 starting_magnetization、原子总数 na ModuleBase::GlobalFunc::READ_VALUE(ifpos, magnet.start_magnetization[it] ); ... ModuleBase::GlobalFunc::READ_VALUE(ifpos, na); this->atoms[it].na = na; .... this->nat += na; .... 在当前 type 下刷新 type-specific 的原子性质： // positions and positional constraints delete[] atoms[it].tau; delete[] atoms[it].taud; delete[] atoms[it].mbl; atoms[it].tau = new ModuleBase::Vector3[na]; atoms[it].taud = new ModuleBase::Vector3[na]; atoms[it].mbl = new ModuleBase::Vector3[na]; // evoluation delete[] atoms[it].vel; delete[] atoms[it].dis; atoms[it].vel = new ModuleBase::Vector3[na]; atoms[it].dis = new ModuleBase::Vector3[na]; // magnetization delete[] atoms[it].mag; delete[] atoms[it].angle1; delete[] atoms[it].angle2; delete[] atoms[it].m_loc_; atoms[it].mag = new double[na]; atoms[it].angle1 = new double[na]; atoms[it].angle2 = new double[na]; atoms[it].m_loc_ = new ModuleBase::Vector3[na]; ⚙ 然后在 ATOMIC_POSITIONS 中读取： atoms[it].mass = this->atom_mass[it]; ❗ 此处的 atoms[it].mass 与 this->atom_mass[it] 的用法与 atomis[it].label 与 this->atom_label[it] 不同：传值 vs 核对。 接下来读取类中每个原子的速度信息，在做分子动力学模拟的时候可能需要用到： for (int ia = 0;ia > v.x >> v.y >> v.z; 然而，当前 STRU 文件在 ATOMIC_POSITIONS 的设计比较复杂，其可以包括任何一组 atom-specific 数据，且数量和顺序均不受限制，这导致判断条件变得复杂，详见 module_cell/read_atoms.cpp:line 536 - 567（link）。 atoms[it].mag 的赋值并非直接读取： else if ( tmpid == \"mag\" || tmpid == \"magmom\") { set_element_mag_zero = true; double tmpamg=0; ifpos >> tmpamg; tmp=ifpos.get(); while (tmp==' ') tmp=ifpos.get(); // ASCII code 48 to 57 are 0 to 9 the Arabic number if((tmp >= 48 && tmp > atoms[it].m_loc_[ia].y>>atoms[it].m_loc_[ia].z; atoms[it].m_loc_[ia].x=tmpamg; atoms[it].mag[ia]=sqrt(pow(atoms[it].m_loc_[ia].x,2) +pow(atoms[it].m_loc_[ia].y,2) +pow(atoms[it].m_loc_[ia].z,2) ); input_vec_mag=true; } else { ifpos.putback(tmp); atoms[it].mag[ia]=tmpamg; } } ⚙ 若 mag/magmom 后有一个值，则读取其值赋给 atoms[it]::mag[ia]，将 input_vec_mag 置为 false，若有三个值，则三个值依次被传入 atoms[it].m_loc_[ia].x, atoms[it].m_loc_[ia].y 和 atoms[it].m_loc_[ia].z，并将 input_vec_mag 置为 true，之后其向量模长为 atoms[it]::mag[ia]，然后在使用 angle1, angle2 来重新生成 mag。 if(GlobalV::NSPIN==4) { if(GlobalV::NONCOLIN) { if(input_angle_mag) { atoms[it].m_loc_[ia].z = atoms[it].mag[ia] * cos(atoms[it].angle1[ia]); if(sin(atoms[it].angle1[ia]) > 1e-10 ) { atoms[it].m_loc_[ia].x = atoms[it].mag[ia] * sin(atoms[it].angle1[ia]) * cos(atoms[it].angle2[ia]); atoms[it].m_loc_[ia].y = atoms[it].mag[ia] * sin(atoms[it].angle1[ia]) * sin(atoms[it].angle2[ia]); .... else if (input_vec_mag) { double mxy=sqrt(pow(atoms[it].m_loc_[ia].x,2)+pow(atoms[it].m_loc_[ia].y,2)); atoms[it].angle1[ia]=atan2(mxy,atoms[it].m_loc_[ia].z); if(mxy>1e-8) { atoms[it].angle2[ia]=atan2(atoms[it].m_loc_[ia].y,atoms[it].m_loc_[ia].x); .... else { // isn't this corresponds to common unrestricted case? atoms[it].m_loc_[ia].x = 0; atoms[it].m_loc_[ia].y = 0; atoms[it].m_loc_[ia].z = atoms[it].mag[ia]; } .... else if(GlobalV::NSPIN==2) { atoms[it].m_loc_[ia].x = atoms[it].mag[ia]; atoms[it].m_loc_[ia].y = 0; atoms[it].m_loc_[ia].z = 0; ... &#x1F914;批判性思考 然而，在 Quantum ESPRESSO 中，并不允许出现 nspin=4 且 noncolinear=.false. 的情况，在 ABACUS≤3.3.0 中是允许的，你怎么看？ Quantum ESPRESSO 相关信息：pw.x input description ABACUS 对 nspin=4 情况的参数处理： //module_io/input_conv.cpp line 376 if (INPUT.noncolin || INPUT.lspinorb) { GlobalV::NSPIN = 4; } if (GlobalV::NSPIN == 4) { GlobalV::NONCOLIN = INPUT.noncolin; // wavefunctions are spinors with 2 components GlobalV::NPOL = 2; // set the domag variable to make a spin-orbit calculation with zero magnetization GlobalV::DOMAG = false; GlobalV::DOMAG_Z = true; GlobalV::LSPINORB = INPUT.lspinorb; GlobalV::soc_lambda = INPUT.soc_lambda; if (INPUT.cal_force || INPUT.cal_stress) { ModuleBase::WARNING_QUIT(\"input_conv\", \"force & stress not ready for soc yet!\"); } if(INPUT.gamma_only_local) { ModuleBase::WARNING_QUIT(\"input_conv\", \"soc does not support gamma only calculation\"); } } else { GlobalV::LSPINORB = false; GlobalV::NONCOLIN = false; GlobalV::DOMAG = false; GlobalV::DOMAG_Z = false; GlobalV::NPOL = 1; } Input::noncolin 等变量使用默认值初始化为： //input.cpp line 409 noncolin = false; lspinorb = false; soc_lambda = 1.0; Summary 经过 UnitCell::read_atom_species() 和 UnitCell::read_atom_positions()，以下量被赋值： // lattice info. // unit UnitCell::Coordinate; // lattice constant (real space) UnitCell::lat0; UnitCell:: lat0_angstrom; // lattice constant (reciprocal space) UnitCell::tpiba; UnitCell::tpiba2; // lattice vectors UnitCell::latvec; UnitCell::latcenter; UnitCell::a1; UnitCell::a2; UnitCell::a3; // atoms overall info. UnitCell::nat; // types UnitCell::ntype; UnitCell::atom_mass; UnitCell::atom_label; // supplementary element-specific info. // pseudopotential UnitCell::pseudo_fn; UnitCell::pseudo_type; // numerical orbital UnitCell::orbital_fn // atom type specific info. // atom type overall info. UnitCell::atoms::label; UnitCell::atoms::na; // atom position info. （constraint included） UnitCell::atoms::taud; UnitCell::atoms::tau; UnitCell::atoms::mbl; // atom move info. (velocities and displacements) UnitCell::atoms::vel; UnitCell::atoms::dis; // atom magnetization info. UnitCell::magnet::starting_magnetization; UnitCell::atoms::mag; // nspin = 4; noncolinear case UnitCell::atoms::m_loc_; UnitCell::atoms::angle1; UnitCell::atoms::angle2; UnitCell::setup_cell(): the rest, and an example of backtracking unclear variable 离开 STRU 文件的解析部分，接下来计算了初始磁化强度： //after read STRU, calculate initial total magnetization when NSPIN=2 if(GlobalV::NSPIN == 2 && !GlobalV::TWO_EFERMI) { for(int it = 0;itntype; it++) { for(int ia = 0; iaatoms[it].na; ia++) { GlobalV::nupdown += this->atoms[it].mag[ia]; } } } 由于 INPUT 中参数众多，因此在前文中对参数有所遗漏。但基于前文已有内容介绍，关于 GlobalV::TWO_EFERMI 变量，可以通过如下方式查找其意义： 在 module_io/input_conv.cpp 中寻找该变量，是何变量赋其值，发现： if (std::abs(INPUT.nupdown) > 1e-6) { GlobalV::TWO_EFERMI = true; GlobalV::nupdown = INPUT.nupdown; } 因此 GlobalV::TWO_EFERMI 变量实际依赖于 INPUT.nupdown。 接下来在 module_io/input.cpp 中寻找含 INPUT.nupdown 的 if(strcmp(...)) 单元，查看在 INPUT 文件中是何参数赋予其具体值： else if (strcmp(\"nupdown\", word) == 0) { read_value(ifs, nupdown); } 即 INPUT.nupdown 在 INPUT 中也为 nupdown。接下来打开 Full keyword list 寻找其解释。 得到结果，即 nupdown 为 spin up 和 spin down 电子数量差值： 因此该部分逻辑为：若未使用 nupdown 来指定单电子数量，则对每种原子内每个原子，累加其 mag/magmom，即磁矩模长，赋予 GlobalV::nupdown。❗ 但对于两种方式均赋予，但值不一致的情况未进行处理。 接下来根据在 STRU 中读取的晶胞参数，计算晶胞体积，并计算倒空间矢量（在上篇中已经对 latvec, G, GT, GGT 有所介绍，invGGT 的意义也不言自明）： this->omega = std::abs( latvec.Det() ) * this->lat0 * lat0 * lat0 ; this->GT = latvec.Inverse(); this->G = GT.Transpose(); this->GGT = G * GT; this->invGGT = GGT.Inverse(); this->GT0 = latvec.Inverse(); this->G0 = GT.Transpose(); this->GGT0 = G * GT; this->invGGT0 = GGT.Inverse(); 然后建立从[原子索引]到[原子种类]和[种类内原子索引]的映射： this->set_iat2itia(); 即该函数的函数名实际应该写为：set_iat2ia_iat2it()： void UnitCell::set_iat2itia(void) { delete[] iat2it; delete[] iat2ia; this->iat2it = new int[nat]; this->iat2ia = new int[nat]; int iat = 0; for (int it = 0; it iat2it[iat] = it; this->iat2ia[iat] = ia; ++iat; } } return; } 至此，UnitCell::setup_cell() 函数的内容全部结束。 回溯：how many objects are created when we see \"init_esolver()\"? 在阅读整个程序的过程中，还有一个重要的方面需要注意：伴随变量的创建，尤其是创建类对象时，其中同样非简单数据类型的数据成员又是在何时初始化，拥有具体数值？由于 Driver.h 中并无任何变量的声明（如前所述，有变量直接被声明为 extern），且 Input.h 中声明变量的值分别靠 Input::Default()、Input::Read() 和 Input::Default2() 给定，且关系简单直接，因此只剩下 ESolver 和其派生类需要注意。 Constructor: ESolver() class ESolver { .... ESolver() { classname = \"ESolver\"; } ESolver 类的构造函数非常简单，因为其是所有具体 ESolver_* 的抽象基类，所以本身的操作设计原则应该尽可能抽象且共通。关于设计抽象基类和编程范式的问题，请见文档（暂缺失） Constructor: ESolver_FP() ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); pw_big = static_cast(pw_rho); pw_big->setbxyz(INPUT.bx, INPUT.by, INPUT.bz); sf.set(INPUT.nbspline); this->symm.epsilon = this->symm.epsilon_input = INPUT.symmetry_prec; } check 其头文件中变量声明： namespace ModuleESolver { class ESolver_FP : public ESolver { public: ModulePW::PW_Basis* pw_rho; ModulePW::PW_Basis_Big* pw_big; ....// constructor and destructor declarations omitted elecstate::ElecState* pelec = nullptr; Charge chr; ModuleSymmetry::Symmetry symm; psi::Psi>* psi = nullptr; psi::Psi* psid = nullptr; Structure_Factor sf; K_Vectors kv; private: ....// member function(s) omitted }; 创建当前类和子类对象时，该构造函数被调用，Charge 类对象 chr、ModuleSymmetry::Symmetry 类对象 symm、Structure_Factor 类对象 sf，以及 K_Vectors 类对象 kv 被创建并分配内存，而 ModulePW::PW_Basis 类 pw_rho、ModulePW::PW_Basis_Big 类 pw_big、elecstate::ElecState 类 pelec、psi::Psi> 类 psi，以及 psi::Psi 类 psid 则为指针，只创建但并未调用其所属类的构造函数。 Special topic: 继承与多态 在 ESolver_FP 的构造函数中有两行格外醒目： ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); pw_big = static_cast(pw_rho); 对于 ESolver 本身，其指针对象 p_esolver 实际上也有类似操作： //Some API to operate E_Solver void init_esolver(ESolver*& p_esolver) { //determine type of esolver based on INPUT information std::string esolver_type = determine_type(); //initialize the corresponding Esolver child class if (esolver_type == \"ksdft_pw\") { #if ((defined __CUDA) || (defined __ROCM)) if (GlobalV::device_flag == \"gpu\") { if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); return; } #endif if (GlobalV::precision_flag == \"single\") p_esolver = new ESolver_KS_PW(); else p_esolver = new ESolver_KS_PW(); } #ifdef __LCAO else if (esolver_type == \"ksdft_lcao\") p_esolver = new ESolver_KS_LCAO(); else if (esolver_type == \"ksdft_lcao_tddft\") p_esolver = new ESolver_KS_LCAO_TDDFT(); #endif else if (esolver_type == \"sdft_pw\") p_esolver = new ESolver_SDFT_PW(); else if(esolver_type == \"ofdft\") p_esolver = new ESolver_OF(); else if (esolver_type == \"lj_pot\") p_esolver = new ESolver_LJ(); else if (esolver_type == \"dp_pot\") p_esolver = new ESolver_DP(INPUT.mdp.pot_file); } “为基类指针分配派生类内存空间，以降低代码复写、提高代码复用率”这种操作称为 C++ 的多态编程，举简单例子如下： //a.cpp #include class a{ public: a() {}; ~a() {}; void TestFunction(); void AnotherFunction(); int GetPrivate(){return this->private_;} bool SetPrivate(int p){this->private_ = p; return true;} void GetPrivateAddress(){std::coutprivate_) //b.cpp #include \"a.cpp\" class b: public a{ public: b() {}; ~b() {}; void TestFunction(); void AnotherFunction(); int GetPrivate(){return this->private_;} bool SetPrivate(int p){this->private_ = p; return true;} void GetPrivateAddress(){std::coutprivate_) //main.cpp #include \"b.cpp\" using namespace std; int main() { a* p_a; p_a = new b(); coutTestFunction(); b* p_tmp = static_cast(p_a); coutTestFunction(); coutTestFunction(); coutAnotherFunction(); coutAnotherFunction(); coutSetPrivate(10); coutGetPrivate()GetPrivate()SetPrivate(20); coutGetPrivate()GetPrivate()GetPrivateAddress(); p_tmp->GetPrivateAddress(); delete p_a; return 0; } //result /* call p_a's member function before static_cast This is a function of a Memory address of p_a is 0x55ee8123beb0 Memory address of p_tmp is 0x55ee8123beb0 call p_tmp's member function after static_cast This is a function of b call p_a's member function after static_cast This is a function of a call p_a's member function This is another function of a call p_tmp's member function This is another function of b now test member variable accessibility p_a's private member is 10 p_tmp's private member is 0 p_a's private member is 10 p_tmp's private member is 20 Re-check memory address of p_a and p_tmp: Memory address of p_a is 0x55ee8123beb0 Memory address of p_tmp is 0x55ee8123beb0 Check private member variables' address 0x55ee8123beb0 0x55ee8123beb4 */ 为基类指针分配派生类内存空间，使得基类和派生类指针指向同一个内存地址（基派生类对象的起始内存位置, line 21, 22: 0x55ee8123beb0），但对于上例，基类需要 4 个字节存储基类对象，而派生类需要 4+4 个字节存储基类对象：因为派生类对象创建时会首先创建其中的基类部分，而实际上即使不进行如此操作，单一创建派生类对象时，在派生类中访问基类数据成员则需要额外以基类的名称作为域标识加以区分。此时基类指针相当于切换成对派生类内存空间的基类视角，即基类指针只能看到派生类存储中的基类部分，但看不到派生类所额外派生的部分，也因此上例共占用内存空间 4+4 字节而非 4+4+4 字节。 举例对于不使用基类指针的情况，在派生类的方法中直接访问其基类数据成员，需要写为： void b::PrintBaseAndDerivedClassVariable() { std::coutprivate_ 而使用指针方法则应该写为： std::coutprivate_private_ 另一点需要注意的是虚函数。实际上，因为基类指针使用派生类指针进行初始化，因此其“语境”为派生类，所以对于虚函数而言，调用的基函数实际为派生类的相应函数。如果使用基类指针调用非虚函数，则调用的是基类的同名函数（examples provided by New Bing Creative）。 注意：不能使用基类指针（即使已经申请派生类内存空间）访问派生类中声明和定义（但基类中无虚函数声明）的函数。 // polymorphism_example.cpp#include using namespace std; class A { public: virtual void f() { cout (p_a); // 以B* p_b=static_cast(p_a)给p_b初始化 p_a->f(); // 调用B::f()，因为f()是虚函数，会根据实际类型进行动态绑定 p_a->g(); // 调用A::g()，因为g()不是虚函数，会根据声明类型进行静态绑定 p_b->f(); // 调用B::f()，因为f()是虚函数，会根据实际类型进行动态绑定 p_b->g(); // 调用B::g()，因为g()不是虚函数，会根据声明类型进行静态绑定delete p_a; // 释放内存空间return 0; } //result /* B::f() A::g() B::f() B::g() */ 当释放内存空间时，则可以使用基类指针为柄，也可以使用派生类指针为柄，编译器将自主判断实际内存占用情况并进行释放（如果声明析构函数为虚函数，则会动态连接并达到如此期望，否则不能）。因此对于 PW_Basis 类对象 pw_rho 而言，其中被声明为虚函数的有： //file module_basis/module_pw/pw_basis.h class PW_Basis { public: .... virtual ~PW_Basis(); .... virtual void initgrids( const double lat0_in, //unit length (unit in bohr) const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors (unit in lat0) const double gridecut //unit in Ry, ecut to set up grids ); .... virtual void initgrids( const double lat0_in, const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors const int nx_in, int ny_in, int nz_in ); .... protected: .... virtual void distribute_r(); //file module_basis/module_pw/pw_basis.h class PW_Basis_Big: public PW_Basis { public: .... virtual void initgrids(const double lat0_in,const ModuleBase::Matrix3 latvec_in, const double gridecut){ .... } .... virtual void initgrids( const double lat0_in, const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors const int nx_in, int ny_in, int nz_in ){ .... } .... protected: .... virtual void distribute_r(){ .... } 派生类的析构函数也可以声明为 virtual。这些函数实际上调用 PW_Basis_Big 此派生类中声明和定义的版本。 其余的数据成员在构造函数中进行初始化均总结于下表： 数据成员 所属类 是否在当前类（ESolver_FP）的构造函数中被调用构造函数 chr Charge 是 symm ModuleSymmetry::Symmetry 是 sf Structure_Factor 是 kv K_Vectors 是 pw_rho ModulePW::PW_Basis 是 pw_big ModulePW::PW_Basis_Big 是 ⚙ 然而，PW_Basis_Big 和 PW_Basis 的关系（后文也有 PW_Basis_K 和 PW_Basis_K_Big）实际并不符合程序设计的抽象理念，这一点将在随后介绍。 变量 声明时赋初值 调用构造函数所赋初值 Charge 类 rho, rho_save, rhog, rhog_save, kin_r, kin_r_save, rho_core, rhog_core, rhopw nulllptr nrxx, nxyz, ngmc, nspin allocate_rho, allocate_rho_final_scf false prenspin 1 Symmetry 类 symm_flag available true s1, s2, s3, a1, a2, a3, p1, p2, p3 ntype, nat, na, istart, itmin_type, itmin_start newpos, rotpos, ptrans, ncell, index cel_const, pcel_const, pre_const symflag_fft, sym_test, pbrav, real_brav, ilattname, plattname gmatrix,kgmatrix, gtrans symop, nop, s_flag, nrot, pgnumber, spgnumber, pgname, spgname optlat,plat nrotk,max_nrotk -1 tab 12 Structure_Factor 类 nbspline, strucFac, eigts1, eigts2, eigts3 c_eigts1, c_eigts2, c_eigts3, z_eigts1, z_eigts2, z_eigts3 nullptr K_Vectors 类 kvec_c, kvec_d, kvec_d_ibz, wk, wk_ibz, ngk, isk, ibz2bz, nmp nspin, nks, nkstot, nkstot_ibz,k_nkstot 0 koffset kc_done, kd_done false k_kword PW_Basis 类 classname \"PW_Basis\" ig2isz, istot2ixy, is2fftixy, d_is2fftixy, fftixy2up, nst_per, npw_per, startz, numz, numg, numr, startg, startr, gdirect, gcar, gg, startnsz_per, ig2igg, gg_uniq nullptr device \"cpu\" precision \"double\" nst, nstnz, nstot, npw, npwtot, nrxx, startz_current, nplane, ngg, ggecut, gridecut_lat, full_pw_dim, poolrank, fftnx, fftny, fftnz, fftnxyz, fftnxy, nx, ny, nz, nxyz, nxy, liy, riy, lix, rix, ng_xeq0, nmaxgr 0 ig_gge0 -1 lat0, tpiba, tpiba2, omega, distribution_type, poolnproc, 1 xprime false PW_Basis:public PW_Basis_big 类 bx, by, bz 1 bxyz, nbx, nby, nbz, nbzp, nbxx, nbzp_start 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 1 下篇：Introduction to ABACUS: Path to PW calculation - Part 3 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-path3.html":{"url":"develop-path3.html","title":"Introduction to ABACUS: Path to PW calculation - Part 3","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 3 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 3 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class Trigger: ESolver_FP::Init() 承接上篇中已经导入的结构信息，以及了解到构造函数及其伴随的变量初始化和 ABACUS 里应用到的 C++ 多态编程，接下来即将（逐渐）步入 ABACUS 的核心内容。我们暂时跳过位于 source/driver_run.cpp:driver_run() 的： // 3. For these two types of calculations // nothing else need to be initialized if(GlobalV::CALCULATION == \"test_neighbour\" || GlobalV::CALCULATION == \"test_memory\") { p_esolver->Run(0, GlobalC::ucell); ModuleBase::QUIT(); } 直接来到第 44 行，ModuleESolver::ESolver::Init() 函数对 esolver 进行更多的设置： // driver_run.cpp: line 44 p_esolver->Init(INPUT, GlobalC::ucell); 然而查找该函数的定义和声明时，发现该函数在 module_esolver/esolver.h 被声明为纯虚函数，类似的还有 un(), cal_Energy(), cal_Force(), cal_Stress() 等。 namespace ModuleESolver { class ESolver { public: .... virtual void Init(Input& inp, UnitCell& cell) = 0; virtual void Run(int istep, UnitCell& cell) = 0; virtual void cal_Force(ModuleBase::matrix& force) = 0; virtual void cal_Stress(ModuleBase::matrix& stress) = 0; .... 考虑到我们之前已经根据 basis_type 和 esolver_type 确定基类（ESolver）指针 p_esolver 所指向内存空间所存储变量为 ESolver_KS_PW，因此我们首先只关注该纯虚函数在 esolver_ks_pw 的实例化。 查看 module_esolver/esolver_ks_pw.cpp 中该函数的定义： namespace ModuleESolver { .... template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { ESolver_KS::Init(inp, ucell); 从上篇中可知，ESolver_KS_PW 有从 ESolver_KS 的继承，ESolver_KS 是从 ESolver_FP（FP 代表 First-Principles）的继承，ESolver_FP 是从 ESolver 的继承，因此 ESolver 各子类中 Init() 函数均保持结构统一，且第一行为父类的 Init() 函数： module_esolver/esolver_ks.cpp： namespace ModuleESolver { .... template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { ESolver_FP::Init(inp,ucell); module_esolver/esolver_fp.cpp： namespace ModuleESolver { .... void ESolver_FP::Init(Input& inp, UnitCell& cell) { cell.read_pseudo(GlobalV::ofs_running); 同时由于多层的继承关系，p_esolver 现在具有所有的数据成员，ESolver_FP 具有数据成员： namespace ModuleESolver { class ESolver_FP : public ESolver { public: ModulePW::PW_Basis* pw_rho; ModulePW::PW_Basis_Big* pw_big; elecstate::ElecState* pelec = nullptr; Charge chr; ModuleSymmetry::Symmetry symm; psi::Psi>* psi = nullptr; psi::Psi* psid = nullptr; Structure_Factor sf; K_Vectors kv; }; } 同理，ESolver_KS 的数据成员，也被 ESolver_KS_PW 继承。ESolver_FP::Init() 首先调用 UnitCell::read_pseudo() 函数进行赝势文件读取，而将赝势文件读取任务放在 FP 层级下，也暗示对于 ABACUS 的第一性原理方法实现来讲，都需要使用赝势。 Pseudopotential import: UnitCell::read_pseudo() void UnitCell::read_pseudo(std::ofstream &ofs) { read_cell_pseudopots(GlobalV::global_pseudo_dir, ofs); 在解读赝势文件读取功能之前，首先需要对赝势文件的结构和信息做一定程度的了解。 ONCV pseudopotential file Section 0: Norm-conserving conditions, generation of pseudopotential and header of exact UPF file 赝势的意义不言自明，其中模守恒赝势需满足如下条件： \\epsilon^\\text{ps}_l=\\epsilon_l（赝势得到的能级和全电子方法求解的能级一样，这里 ps 代表 pseudopotentials） \\phi^\\text{ps}_l(r)无节点（赝波函数没有结点，nodeless） 在截断半径之外（r>r_c）有\\phi^\\text{ps}_l(r)=\\phi_l(r)（赝波函数在截断半径之后一致） \\int_{r（电子数守恒，即模守恒） 生成赝势的步骤如下： -\\frac{\\hbar^2}{2m}\\frac{d^2}{dr^2}\\phi_{l}(r)+[\\frac{\\hbar^2}{2m}\\frac{l(l+1)}{r^2}+V(r)]\\phi_l(r)=\\epsilon_l\\phi_l(r)，解得(\\phi_l(r)-\\epsilon_l) pair 满足上述四个模守恒条件前提下生成(\\phi^\\text{ps}_l(r)-\\epsilon^\\text{ps}_l) pair，使得-\\frac{\\hbar^2}{2m}\\frac{d^2}{dr^2}\\phi^\\text{ps}_{l}(r)+[\\frac{\\hbar^2}{2m}\\frac{l(l+1)}{r^2}+V(r)]\\phi^\\text{ps}_l(r)=\\epsilon^\\text{ps}_l\\phi^\\text{ps}_l(r)成立 V_l(r)=\\frac{1}{\\phi^\\text{ps}_l(r)}[\\epsilon^\\text{ps}_l-\\frac{\\hbar^2}{2m}\\frac{l(l+1)}{r^2}+\\frac{\\hbar^2}{2m}\\frac{d^2}{dr^2}]\\phi^\\text{ps}_l(r)，解得V_l(r)。 扣除V_l(r)中 Hartree、xc 部分，得到V^\\text{ps}_l(r)：V^\\text{ps}_l(r)=V_l(r)-V^\\text{H}[\\rho^\\text{ps}(r)]-V^\\text{xc}[\\rho^\\text{ps}(r)]。\\rho^\\text{ps}(r)=\\frac{1}{4\\pi}\\sum_i^\\text{occ}{f_{i}|\\phi^\\text{ps}_l(r)|^2} 更多细节见：www.tcm.phy.cam.ac.uk 从 UPF 文件（注意 UPF 文件也有不同的版本，目前 ABACUS 都支持，若有不支持的，可以提 Github 的 issues 进行讨论）开始，截止到 之前，提供了赝势文件的作者信息，引用信息以及生成赝势文件所使用的程序和相应输入文件，并附带输入文件参数中的解释。由于此块内容对实际计算并不起作用，因此暂时略过。 Section 1: 部分尽管已经位于所谓“not human readable”区域，但也并非如此。这部分“标签”（HTML 语境）/block 实际上包含了众多精简过的信息，如元素名称（element）、赝势类型（pseudo_type，模守恒，norm-conserving，NC），相对论效应（relativistic），是否为超软赝势等等信息。当前 Al 理论上其原子序数 13，因此有 13 个电子，但此处 z_valence 参数为 11，即有两个 1s 电子被赝化，只留下 2s, 2p, 3s, 3p 电子共 2+6+2+1 个。对于某些元素，甚至有大核赝势与小核赝势之分，根据赝化电子数量不同进行区分。显而易见地，赝化电子数量越多，则计算量越小，但计算结果的精确程度可能更低。 Section 2: 0.0000 0.0100 0.0200 0.0300 0.0400 0.0500 0.0600 0.0700 5.9200 5.9300 5.9400 5.9500 5.9600 5.9700 5.9800 5.9900 6.0000 6.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 0.0100 这部分开始出现了关于实空间格点相关量的定义。在 tag 中不仅指定数据类型为实数，也指定当前数据的长度（size），以及数据存储的列数（columns = 8）。PP_R 为格点坐标，PP_RAB 则为格点间距。 Section 3: -4.5793174225E+01 -4.5788454271E+01 -4.5774276797E+01 -4.5750659428E+01 -3.6912752197E+00 -3.6850921941E+00 -3.6789298138E+00 -3.6727880140E+00 -3.6666666933E+00 -3.6605657501E+00 从 部分开始，正式开始写入赝势的具体数值，建立在 和 所描述的实空间格点上。\\hat{V}=\\hat{V}^\\text{loc}+\\hat{V}^\\text{NL}。 正是赝势的局域势部分。 Section 4: 0.0000000000E+00 8.1959788337E-02 1.6389680452E-01 2.4578292762E-01 -1.2623857798E-05 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 5.3707838603E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 -8.2930195943E-01 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 -6.5836757852E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 0.0000000000E+00 -4.6797927123E+00 完全非局域部分，\\hat{V}^\\text{NL}=\\sum_{ij}{|\\beta_i\\rangle D_{ij}\\langle\\beta_j|}。其中|\\beta_i\\rangle一般被称为非局域势投影子（projector）。 Section 5: and 0.0000000000E+00 3.6337392512E-03 1.4532726686E-02 3.2690254089E-02 为赝波函数， 则为赝电荷密度在实空间格点上的数据。一个简单的赝势文件信息提取脚本： ParseUpfWordByWord.py &#x1F914; 玩玩看！ Quantum ESPRESSO 官网上提供了更多关于 UPF 文件格式的信息：Unified Pseudopotential Format - QUANTUMESPRESSO ❗注意 读入的投影子 projector |\\beta\\rangle和 pswfc \\tilde{\\phi}(r)已经乘径向坐标r。 UnitCell::read_cell_pseudopots() link to Github -> link void UnitCell::read_cell_pseudopots(const std::string &pp_dir, std::ofstream &log) { std::stringstream ss; ss pseudo_fn[i]; error = upf.init_pseudo_reader( pp_address, this->pseudo_type[i] ); 赝势文件的读取 type-by-type，每次创建 Pseudopot_upf 类对象 upf，之后调用 upf.init_pseudo_reader() 对文件进行读取，需要指定文件的地址（pp_address）和赝势类型（UnitCell::pseudo_type[i]）。Pseudopot_upf::init_pseudo_reader() 为每种赝势文件进行判断，之后进行不同的解析。为方便起见，这里我们只关注 ABACUS 的常用赝势类型，即模守恒 upf。跟随“转到定义”，来到 module_cell/read_pp.cpp 文件（link）： int Pseudopot_upf::init_pseudo_reader(const std::string &fn, std::string &type) { std::ifstream ifs(fn.c_str(), std::ios::in); if (type == \"auto\") { set_pseudo_type(fn, type); } if (type == \"upf\") { int info = read_pseudo_upf(ifs); return info; } else if (type == \"vwr\") { int info = read_pseudo_vwr(ifs); return info; } else if (type == \"upf201\") { int info = read_pseudo_upf201(ifs); return info; } else if (type == \"blps\") { int info = read_pseudo_blps(ifs); return info; } return 0; } 选择 read_pseudo_upf() 函数，跳转到位于 module_cell/read_pp_upf100.cpp 的该函数定义。read_pseudo_upf() 函数分标签读取 upf 格式赝势文件中信息，每个标签都有单独的解析器： while (ifs.good()) { ifs >> dummy; if(dummy==\"\") { ierr = 1; read_pseudo_header(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); break; } } if ( ModuleBase::GlobalFunc::SCAN_BEGIN(ifs, \"\") ) { read_pseudo_mesh(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); } if (this->nlcc) { ModuleBase::GlobalFunc::SCAN_BEGIN(ifs, \"\"); read_pseudo_nlcc(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); } ModuleBase::GlobalFunc::SCAN_BEGIN(ifs, \"\"); read_pseudo_local(ifs); ModuleBase::GlobalFunc::SCAN_END(ifs, \"\"); 与 类似的还有 , , , 从 则可以读取旋轨耦合相关信息： if (has_so) { ModuleBase::GlobalFunc::SCAN_BEGIN (ifs,\"\"); read_pseudo_so (ifs); ModuleBase::GlobalFunc::SCAN_END (ifs,\"\"); } 每个具体 tag 的解析函数 Pseudopot_upf::read_pseudo_xxx() 均赋值于数据成员，声明在 module_cell/read_pp.h 中（link）。 Functions in Pseudopot_upf class Variables value assgined explain void read_pseudo_header(std::ifstream &ifs); this->nv``this->psd``this->tvanp``this->nlcc``this->xc_func``this->zp``this->etotps``this->ecutwfc``this->ecutrho``this->lmax``this->mesh``this->nwfc``this->nbeta``this->els``this->lchi``this->oc Version numberElement labelIf ultrasoft pseudopotentialIf noncolinear correction addedXc functionalAtomic chargesTotal energySuggested energy cutoff for wavefunctionSuggested energy cutoff for charge densityMaximal angular momentum includedNumber of points in radial meshNumber of wavefunctionsNumber of projectorsDim nwfc, labels of orbitalDim nwfc, angular momentum of orbitalDim nwfc, occupation of orbital void read_pseudo_mesh(std::ifstream &ifs); this->r``this->rab Dim this->mesh, realspace mesh of radiusDim this->mesh, void read_pseudo_nlcc(std::ifstream &ifs); this->rho_atc Dim this->mesh, void read_pseudo_local(std::ifstream &ifs); this->vloc Dim this->mesh, Vlocal void read_pseudo_nl(std::ifstream &ifs); this->kkbeta this->lll this->beta``this->dion``this->nd Dim this->nbeta, number of mesh points of projectors.Dim this->nbeta, angular momentum for projectors.Dim this->nbetathis->mesh.Dim this->nbetathis->nbeta.Number of nonzero D_{ij} void read_pseudo_pswfc(std::ifstream &ifs); this->chi Dim this->nwfc*this->mesh, void read_pseudo_rhoatom(std::ifstream &ifs); this->rho_at Dim this->mesh, atomic electron density on realspace mesh void read_pseudo_addinfo(std::ifstream &ifs); Not implemented Not implemented void read_pseudo_so(std::ifstream &ifs); this->nn this->jchi``this->jjj Dim this->nwfc, quantum number of wavefunctionDim this->nwfc, j=l+s, where s=\\pm\\frac{1}{2}.Dim this->nbeta, j=l+s, where s=\\pm\\frac{1}{2}, for projector. 我们假设 ONCV.upf 格式赝势文件顺利读取完毕，upf.init_pseudo_reader() 返回 0（error == 0），来到条件判断： if(error==0) { if(this->atoms[i].flag_empty_element) upf.set_empty_element(); error_ap = upf.average_p(GlobalV::soc_lambda); } Pseudopot_upf::set_empty_element() 的作用为设置 Vloc、dion 和 rho_at 均为 0，Pseudopot_upf::average_p() 则属于自旋轨道耦合（spin-orbital coupling）功能，这里先不介绍。 我们来到 line 82, if(GlobalV::MY_RANK==0) { atoms[i].ncpp.set_pseudo_nc( upf ); .... } 实际上 ABACUS 目前只能处理模守恒的赝势类型。显然该行实现的为将赝势信息从upf到atoms[i].ncpp的拷贝，而 upf 的意义也不言自明：UPF file parser。解析 UPF 文件后传值给 atoms[i].ncpp void pseudo_nc::set_pseudo_nc(const Pseudopot_upf &upf) { this->set_pseudo_h(upf); this->set_pseudo_atom(upf); this->set_pseudo_vl(upf); delete[] lll; lll = new int[nbeta]; for (int i = 0;i kkbeta = 0; for (int nb = 0;nb kkbeta = (upf.kkbeta[nb] > kkbeta) ? upf.kkbeta[nb] : kkbeta; } this->betar.create(upf.beta.nr, upf.beta.nc); this->betar = upf.beta; this->dion.create(nbeta, nbeta); this->dion = upf.dion; } 该函数属于类 pseudo_nc，而 pseudo_nc 对象为 atom 的数据成员，atoms 则为 UnitCell 的数据成员。pseudo_nc::set_pseudo_h()，pseudo_nc::set_pseudo_atom 和 pseudo_nc::set_pseudo_vl 的内容在此省略，但其分别为将 Hamilton, 原子性质和 Vlocal 相关数据从 upf 对象拷贝。之后(1)使用 lll 刷新为 upf 对象的 projectors 的角动量，然后计算出磁角动量区分时的 projector 个数。(2)取所有 projector 衰减到 0 时候的最大最普适半径。 赝势信息后处理 回到 module_cell/unitcell.cpp line 663，接下来为每个原子创建目录，在目录中写 [原子label].NONLOCAL 文件。[label].NONLOCAL 文件中内容包含 , 和 三个 tag。 中包含内容： ofs \" label ncpp.pp_type ncpp.lmax \" 中包含内容为 projector 数量 atom->ncpp.nbeta、对应于每个原子的 projector 的角动量为指标的 dion 矩阵： ofs \" ncpp.nbeta ncpp.nbeta; ib++) { for(int ib2=0; ib2ncpp.nbeta; ib2++) { ofs ncpp.lll[ib] ncpp.lll[ib2] ncpp.dion(ib,ib2)\" 中包含内容为 projector 仅其值大于 1.0e-10 的值。首先仍然输出当前原子的 projector 索引，以及角动量，然后截断 projector: int cut_mesh = atom->ncpp.mesh; for(int j=atom->ncpp.mesh-1; j>=0; --j) { if( std::abs( atom->ncpp.betar(i,j) ) > 1.0e-10 ) { cut_mesh = j; break; } } if(cut_mesh %2 == 0) ++cut_mesh; 之后按照截断后的网格重新存储 projector 的 realspace grid, projector value, rab 数据，分三列分别存储： for(int j=0; jncpp.r[j] ncpp.betar(i, j) ncpp.rab[j] \" 赝势信息分发：UnitCell::bcast_unitcell2(void) #ifdef __MPI 接下来对赝势信息进行MPI进程（processor）间的分发： #ifdef __MPI bcast_unitcell2(); #endif // module_cell/unitcell.cpp:bcast_unitcell2() void UnitCell::bcast_unitcell2(void) { for (int i = 0; i // module_cell/atom_spec.cpp:Atom::bcast_atom2() void Atom::bcast_atom2() { this->ncpp.bcast_atom_pseudo(); } // module_cell/atom_pseudo.cpp::Atom_pseudo::bcast_atom_pseudo() void Atom_pseudo::bcast_atom_pseudo(void) { .... Parallel_Common::bcast_int( lmax ); .... Parallel_Common::bcast_double( etotps ); .... Parallel_Common::bcast_bool( tvanp ); .... Parallel_Common::bcast_string( psd ); .... // below two 'bcast_double' lines of codes seem to have bugs, // on some computers, the code will stuck here for ever. // mohan note 2021-04-28 Parallel_Common::bcast_double( dion.c , nbeta * nbeta); Parallel_Common::bcast_double( betar.c, nr * nc ); } #endif 赝势信息核对 接下来跨原子种类检验泛函是否一致： for(int it=0; it STRU 结构检查：UnitCell::check_structure() 检验结构中任意两原子之间距离是否大于其固定倍数（ check_structure(GlobalV::MIN_DIST_COEF); 计算轨道数：UnitCell::cal_natomwfc() UnitCell::cal_natomwfc() 函数计算所有种类的原子轨道数量加和，对于非 nspin=4，即非 soc（自旋轨道耦合）情况，角量子数 l 和 s 非耦合，l 单独可以作为好的量子数来区分量子态，因此对于每个赝势中定义的 wfc，若其对应 occupation 大于等于 0（即有效 wfc），则对应于其角量子数 l，轨道数量增加 2l+1，即计数其磁量子数 m，也相当于对 alpha 和 beta spin 的单独计数。对于 nspin=4 的情况，若考虑 soc，则轨道数对 j=l+s 的情况，当前原子种类当前角量子数对应轨道数量记为 2l+1+1，否则为 2l+1。对于非 soc 但 nspin=4，当前原子种类轨道当前角量子数对应轨道数量记(2l+1)*2： void UnitCell::cal_natomwfc(std::ofstream &log) { this->natomwfc = 0; for (int it = 0;it = 0) { if(GlobalV::NSPIN==4) { if(atoms[it].ncpp.has_so) { tmp += 2 * atoms[it].ncpp.lchi[l]; if(fabs(atoms[it].ncpp.jchi[l] - atoms[it].ncpp.lchi[l] - 0.5) 接下来调用 UnitCell::cal_nwfc() 函数，计算并赋值 波函数 index 到角动量，zeta 和磁量子数的表格， 跨原子种类的最大原子数，以及最大 wfc 数量， 轨道数量和： GlobalV::NLOCAL = 0; for(int it=0; it 建立 UnitCell::itia2iat（种类 index，种类内原子 index）->（原子全局 index）映射表、UnitCell::iat2iwt（原子全局 index）->（波函数全局 index）映射表、UnitCell::iwt2iw（波函数全局 index）->（波函数种类内 index）映射表、UnitCell::iwt2iat（波函数全局 index）->（原子全局 index）映射表、UnitCell::iwt2iw（波函数全局 index）->（波函数种类内 index）映射表。 计算跨原子种类最大角量子数 UnitCell::lmax 和某 l 对应最大 zeta 数 UnitCell::nmax，以及跨原子种类的类内 zeta 数总和最大值 UnitCell::nmax_total 寻找赝势中最大角量子数 UnitCell::lmax_ppwf。 价电子数核对 核对赝势中定义的价电子数与 ABACUS 预置库中原子的最小价电子数 获取最大格点数量：UnitCell::cal_meshx() 计算跨原子种类的最大格点数量，存储在 UnitCell::meshx 中，目前 ABACUS 代码中变量命名后缀 x 可能代表 max，正如之前看到 npwx 等。 至此，我们离开函数 UnitCell::read_pseudo()，回到 ModuleESolver::ESolver_FP::Init() 函数。 &#x1F4C3;和 Quantum Espresso 对齐的赝势参数 读入 UPF 格式的模守恒赝势之后，如果要和 QE 的结果做 apple-to-apple 的比较，使得总能量受力等性质计算一致，可以把基矢量调成平面波(basis_type 设成 pw)，然后在 INPUT 文件中，把 pseudo_rcut 设成 10（默认是 15），pseudo_mesh 设成 1 即可（默认是 0）。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 2 下篇：Introduction to ABACUS: Path to PW calculation - Part 4 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-path4.html":{"url":"develop-path4.html","title":"Introduction to ABACUS: Path to PW calculation - Part 4","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 4 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 4 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class Trigger: ESolver_FP::Init() 平面波格点初始化：PW_Basis:: initgrids() 完成了 INPUT 和 STRU，以及赝势文件的读取环节，接下来我们来到平面波的初始化设置相关部分。 void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... if (inp.nx * inp.ny * inp.nz == 0) this->pw_rho->initgrids(inp.ref_cell_factor * cell.lat0, cell.latvec, inp.ecutrho); else this->pw_rho->initgrids(inp.ref_cell_factor * cell.lat0, cell.latvec, inp.nx, inp.ny, inp.nz); ⚠️ 注意，PW_Basis::initgrids() 为虚函数（virtual），尽管使用基类指针（pw_rho），实际调用的函数也是与之同名但不同内容的派生类（PW_Basis_Big）成员函数。这一点靠 ESolver_FP 的构造函数实现： ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); pw_big = static_cast(pw_rho); pw_big->setbxyz(INPUT.bx, INPUT.by, INPUT.bz); sf.set(INPUT.nbspline); this->symm.epsilon = this->symm.epsilon_input = INPUT.symmetry_prec; } 在 INPUT 文件中，nx, ny 和 nz 为 FFT 网格大小相关参数，但一般应用场景而言，几乎无用户亲自设置它（对于用户主动设置 nx, ny 和 nz 的情况，ecutrho/ecutwfc 值的设置无效，将会根据格点情况被重新赋值）。在 Input::Default() 中，三个变量的默认值均为 0，因而常规来讲实际唤起 PW_Basis::initgrads() 函数的版本计算了 nx, ny 和 nz，其算法和 SIAB 程序完全相同（view source code: https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_basis/module_pw/pw_init.cpp#L156）： INPUT 中 ecutrho 确定以动量\\mathbf{k}=(0,0,0)为球心的球半径 在倒空间确定所有在“球”中的格点（均为整数坐标，因现在最小可分辨距离为倒格子矢量长度，见下 Fig.1），其中每个点都对应一个平面波 以倒空间内 x/y/z 最大/小值为边界组成正方形盒子，进行（2, 3, 5）质数分解，得到可能更大的盒子尺度（nx, ny 和 nz） 相较于 PW_Basis::initgrids()，PW_Basis_Big::initgrids() 还初始化了 nbx, nby 和 nbz 的值，尽管对于平面波而言整个 PW_Basis_Big 都是冗余功能（PW_Basis_Big 只是在 LCAO 里面做格点积分的时候会用到）： virtual void initgrids(const double lat0_in,const ModuleBase::Matrix3 latvec_in, const double gridecut) { // generation of nx, ny and nz are omitted here .... if(!this->bz) { this->autoset_big_cell_size(this->bz, ibox[2], this->poolnproc); } if(!this->bx) { if(ibox[0] == ibox[2]) this->bx = this->bz; else this->autoset_big_cell_size(this->bx, ibox[0]); } if(!this->by) { if(ibox[1] == ibox[2]) this->by = this->bz; else this->autoset_big_cell_size(this->by, ibox[1]); } this->bxyz = this->bx * this->by * this->bz; if(ibox[0]%this->bx != 0) ibox[0] += (this->bx - ibox[0] % this->bx); if(ibox[1]%this->by != 0) ibox[1] += (this->by - ibox[1] % this->by); if(ibox[2]%this->bz != 0) ibox[2] += (this->bz - ibox[2] % this->bz); .... this->nbx = this->nx / bx; this->nby = this->ny / by; this->nbz = this->nz / bz; delete[] ibox; } 回忆 PW_Basis_Big::bx, by 和 bz 的值则在 namespace ModuleESolver { ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); .... pw_big->setbxyz(INPUT.bx, INPUT.by, INPUT.bz); 设置。回溯 INPUT.bx，在 input.cpp 就可以发现： //line 2664 if (basis_type == \"pw\") // xiaohui add 2013-09-01 { .... bx = 1; by = 1; bz = 1; } 接下来从 Input 对象中拷贝了平面波类 PW_Basis 的数据成员， void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->initparameters(false, inp.ecutrho); void PW_Basis:: initparameters( const bool gamma_only_in, const double pwecut_in, const int distribution_type_in, const bool xprime_in ) { this->xprime = xprime_in; this->gamma_only = gamma_only_in; // if use gamma point only, when convert real function f(r) to F(k) = FFT(f), // we have F(-k) = F(k)*, so that only half of planewaves are needed. this->fftny = this->ny; this->fftnx = this->nx; if (this->gamma_only) { if (this->xprime) this->fftnx = int(this->nx / 2) + 1; else this->fftny = int(this->ny / 2) + 1; } this->fftnz = this->nz; this->fftnxy = this->fftnx * this->fftny; this->fftnxyz = this->fftnxy * this->fftnz; this->ggecut = pwecut_in / this->tpiba2; //ggecut should be no larger than gridecut if(this->ggecut > this->gridecut_lat) this->ggecut = this->gridecut_lat; this->distribution_type = distribution_type_in; } ❗ 注意：这里还完成了倒空间格点数量 fftnx, fftny 和 fftnz 的赋值。因为 FFT 变换前后的格点数量一般相同，因此 fftnx = nx，fftny = ny，...。 然后对平面波在 MPI 进程间进行分发： //module_esolver/esolver_fp.cpp void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->setuptransform(); void PW_Basis::setuptransform() { ModuleBase::timer::tick(this->classname, \"setuptransform\"); this->distribute_r(); this->distribute_g(); this->getstartgr(); this->ft.clear(); if(this->xprime) this->ft.initfft(this->nx,this->ny,this->nz,this->lix,this->rix,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); else this->ft.initfft(this->nx,this->ny,this->nz,this->liy,this->riy,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); this->ft.setupFFT(); ModuleBase::timer::tick(this->classname, \"setuptransform\"); } PW_Basis::setuptransform()（link） 并行机制简述 并行池 到这里，我们不得不开始对平面波的 MPI 并行机制有一个大致的认识。在 ABACUS 中，CPU（=processor）首先根据不同的布里渊区 k 点分组被划分成不同的并行池（parallelizaiton pool），每个 pool 都包含几个 k 点，在每个 pool 里面会有完整的对该 k 点求解 Kohn-Sham 方程的过程。因此，在每个 pool 中采用一定数量的 CPU 进程来完成计算。在 INPUT 文件中，KPAR 参数决定了并行池的数量（即 pool 的个数）。换句话说，ABACUS 的 k 点并行机制为，将 k 点（设其数量为 nkpt）分配在 KPAR 个 pool 中，若一共有 nproc 个 processor，则： 每个 pool 有 nproc/KPAR 个 processor 每个 pool 均分得到 nkpt/KPAR 个 k 点进行计算-> 最多有多少个 k 点同时进行计算（因为均分到每个 pool 的 kpt 将串行计算） KPAR：defines the number of groups the k points are divided into, or the number of kpts on which wavefunctions are solved simultaneously. 另外注意，自旋是通过 k 点这个 index 被包含进计算的。即对同 1 个 k 点的自旋上下是通过在程序里设置两个 k 点来完成计算的。例如，我们采用 444=64 个 k 点进行运算，如果不开对称性，那么 nspin=1 时程序执行的是 64 个 k 点，npsin=2 时程序执行的是 64*2=128 个 k 点。 MPI 进程编号：rank rank 是一个在 MPI 并行里常被用到的变量。在拥有不止一个 processor 的时候，每个 processor 都具有唯一的编号，称为 rank。如果在每个 processor 都有 rank 的基础上还定义了 pool，以及在每个 pool 中的 processor 数量，则 processor 除了有跨 pool 的全局 rank，也可以有 pool 之内的局部 rank，这部分内容见 module_base/global_variable.cpp: int NPROC = 1; int KPAR = 1; int MY_RANK = 0; int MY_POOL = 0; int NPROC_IN_POOL = 1; int RANK_IN_POOL = 0; .... 在 ABACUS 中，部分文件 I/O 操作仅使用 rank0 的 processor 执行（module_cell/read_cell_pseudopots.cpp: line 32）： if(GlobalV::MY_RANK==0) { pp_address = pp_dir + this->pseudo_fn[i]; error = upf.init_pseudo_reader( pp_address, this->pseudo_type[i] ); //xiaohui add 2013-06-23 if(error==0) // mohan add 2021-04-16 { if(this->atoms[i].flag_empty_element) // Peize Lin add for bsse 2021.04.07 { upf.set_empty_element(); } //average pseudopotential if needed error_ap = upf.average_p(GlobalV::soc_lambda); //added by zhengdy 2020-10-20 } } 并行策略 于是问题便到来：在并行条件下，代码究竟是如何执行的？ 对于多核 CPU，是否运行在其上的所有程序都进行了并行化？ 答：否。对于运行在常见操作系统上的软件，并不需要进行显式的并行化，因为系统具有分配算法，会根据当前硬件情况，自动把软件的执行在不同核间进行分配和任务调度。但究竟并行效率和结果如何，取决于操作系统自身。 一个自编程序如果没有进行显式的并行化，直接使用 mpirun 等方式运行，会发生什么？ 答：相同的代码会在每个 processor 上运行一遍。 CPU 和 processor 的关系是什么？ 答：CPU=processor，在并行计算的语境下。 特别地，对于 C++ 而言，没有显式并行化却使用 mpirun 方式运行的程序，若其中包括创建对象等操作，是否意味着每个 processor 都创建了单独的对象，并且都放在了各自的内存空间？ 答：取决于并行策略。对于 OpenMP，processor 间内存共享，即只创建一个对象，之后每个 processor 同时往同一个内存区域读写内容。对于 MPI，processor 间内存相互独立，即每个 processor 在各自隔离的内存上都创建相同对象，之后每个 processor 再独立进行内存区域的读写。 5w. 进程、线程之间是什么关系？ 进程（process）包含线程（thread）。以下为 ChatGPT 生成内容： A process is an instance of a program that is being executed. It has its own memory space, system resources, and execution context. A process can contain multiple threads, each of which can execute independently and concurrently within the same process. Processes are managed by the operating system and can communicate with each other through inter-process communication mechanisms. A thread, on the other hand, is a lightweight unit of execution within a process. It shares the same memory space and system resources as the process it belongs to, but has its own execution context. Multiple threads within a process can execute concurrently and share data and resources within the process. Threads are managed by the operating system or by the application itself, depending on the programming language and platform. OpenMP-MPI 混合编程 通常来讲，尽管 OpenMP 提供了线程并行，但由于共享内存可能并不存在于 processors 之间，或 computer, nodes 之间，且没有适合的内存共享系统（multi-socket server），此时如果以 OpenMP 放心运行，则可能得出错误结果或直接报错——因为内存无法访问。对于这种情况，需要使用 MPI（Message passing interface）来维持无内存共享处理单元之间的信息交换，以及信息分发和分布计算，而在处理单元内部，即可以共享内存的域内，则可以通过 OpenMP 技术来进行线程级并行。 实空间格点分发 在简单介绍完并行机制后，我们知道，对于未显式以并行方式实现的函数，其运行将在每一个 processor。在接下来的平面波分发过程中，请始终牢记这一理念，尤其在 processor-local 变量和 processor-global 变量的传值过程中。 稍加回溯： void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->setuptransform(); void PW_Basis::setuptransform() { this->distribute_r(); this->distribute_g(); .... 而 ModuleESolver::ESolver_FP::Init() 为 ModuleESolver::ESolver_KS::Init() 所调用，ModuleESolver::ESolver_KS::Init() 为 ModuleESolver::ESolver_KS_PW::Init() 所调用，ModuleESolver::ESolver_KS_PW::Init()则为 p_esolver 所调用，p_esolver 虽然属于 ModuleESolver::ESolver 类指针，但由于 basis_type 和 esolver_type 被划定指向 ModuleESolver::ESolver_KS_PW 类内存空间，因此其原本纯虚函数 ModuleESolver::ESolver::Init() 的调用指向 ModuleESolver::ESolver_KS_PW::Init()。p_esolver 在 driver_run 中被创建，driver_run 来源于 atomic_world() 函数，atomic_world() 函数则在 driver.cpp 中被调用。 回到正题： 实空间：PW_Basis::distribute_r() ❗Attention 注意，此时实际调用的也是 PW_Basis_Big 而非 PW_Basis 的 distribute_r() 函数。 namespace ModulePW { class PW_Basis_Big: public PW_Basis { public: virtual void distribute_r() { delete[] this->numz; this->numz = new int[this->poolnproc]; delete[] this->startz; this->startz = new int[this->poolnproc]; ModuleBase::GlobalFunc::ZEROS(this->numz, this->poolnproc); ModuleBase::GlobalFunc::ZEROS(this->startz, this->poolnproc); int npbz = this->nbz / this->poolnproc; int modbz = this->nbz % this->poolnproc; this->startz[0] = 0; for(int ip = 0 ; ip poolnproc ; ++ip) { this->numz[ip] = npbz*this->bz; if(ip numz[ip]+=this->bz; if(ip poolnproc - 1) this->startz[ip+1] = this->startz[ip] + numz[ip]; if(ip == this->poolrank) { this->nplane = numz[ip]; this->startz_current = startz[ip]; } } this->nbzp = this->nplane / this->bz; this->nrxx = this->numz[this->poolrank] * this->nxy; this->nbxx = this->nbzp * this->nbx * this->nby; this->nbzp_start = this->startz[this->poolrank] / this->bz; return; } 基于上一部分简单介绍的并行机制，ABACUS 使用 mpirun 运行，因此上述代码会被每个 processor 所单独运行。直至上述代码片段的第 25 行 if(ip == this->poolrank) {.... 该判断不会 always true。因此 PW_Basis::distribute_r() 将 3D 实空间格点，按照 z 方向进行分发，分给了不同的 processors，并赋值 this->npz，this->nplane, this->startz_current 和 this->nrxx，意义分别为当前 processor 的 z 方向格点数量、xy 平面数量、z 格点的起始索引以及当前 processor 所分得实空间格点总数（分配后 z 方向格点 ×xy 平面格点）。 图 1. PW_Basis::distribute_r()：设一个pool中有5个processors 倒空间：PW_Basis::distribute_g() 倒空间格点的分发采用了和实空间不同的方式，这主要是因为倒空间“球”的存在（ecutwfc 和 ecutrho），使得非空间中所有点都需要考虑在内，而实空间则并非如此。更一般而言，有限的实空间带来无限的倒空间（即实空间 delta 函数需要无限数量的平面波展开）延展，而有限的倒空间（倒空间 delta 点）带来无限的实空间延展（如一个平面波）。 &#x1F527;重构信息 由于目前所考虑基函数为平面波，因此需要同时追踪平面波所属 processor，平面波的 Direct (x, y, z)坐标等信息，ABACUS 现有版本通过多个繁杂的函数，建立了许多映射关系，而从 2d 到 1d 的索引 fold 让代码可读性和代码扩展编写难度进一步上升。实际上，映射关系所携带的信息本质上是“属性”，因此仅需为“属性”寻找正确的归属主体，或平面波或 processor。而 2d 到 1d 的索引映射同样可以进行封装。 倒空间的分发策略现有两种实现： void PW_Basis::distribute_g() { ModuleBase::timer::tick(this->classname, \"distributeg\"); if(this->distribution_type == 1) { this->distribution_method1(); } else if(this->distribution_type == 2) { .... } 由于 PW_Basis::initparameters() 对其有默认调用 method1，因此这里我们先只关心 method1。 void PW_Basis::distribution_method1() { int *st_bottom2D = new int[fftnxy]; int *st_length2D = new int[fftnxy]; .... if (poolrank == 0) { .... this->count_pw_st(st_length2D, st_bottom2D); .... int* st_i = new int[this->nstot]; int* st_j = new int[this->nstot]; int* st_length = new int[this->nstot]; this->collect_st(st_length2D, st_bottom2D, st_i, st_j, st_length); .... this->startnsz_per = new int[this->poolnproc]; this->divide_sticks_1(st_i, st_j, st_length); .... this->get_istot2ixy(st_i, st_j); .... delete[] st_length; delete[] st_i; delete[] st_j; delete[] this->startnsz_per; this->startnsz_per=nullptr; } this->npw = this->npw_per[this->poolrank]; this->nst = this->nst_per[this->poolrank]; this->nstnz = this->nst * this->nz; this->get_ig2isz_is2fftixy(st_bottom2D, st_length2D); delete[] st_bottom2D; delete[] st_length2D; } 分发最小单元：“棍子” - 准备工作 穿过布里渊区的整数点（2pi/a 的整数倍）都代表一个三个 index 的平面波，而一系列的点在截断半径以内沿着某个方向就组成了所谓的“stick”（代表平面波集合的“棍子”，一个“棍子”包含了多个平面波，简称就叫“棍子”）。 PW_Basis::count_pw_st() 函数（Link）计算了每个(x,y)对应的“棍子”的底部和“长度”，即对倒空间只分辨(x,y)，则会得到沿 z 方向的点的集合，被称为“棍子”。而“棍子”区域内部每一个点都代表一个平面波。“棍子”的底部对应于最小的 iz 值，“根子”的长度则为当前(x,y)所包含的平面波数量： for (int ix = ix_start; ix nx; if (y ny; int index = x * this->fftny + y; int length = 0; for (int iz = iz_start; iz GGT * f); if (modulus ggecut || this->full_pw) { if (length == 0) st_bottom2D[index] = iz; ++this->npwtot; ++length; .... } } if (length > 0) { st_length2D[index] = length; ++this->nstot; } } } count_pw_st(st_length2D, st_bottom2D)\">图 2. this->count_pw_st(st_length2D, st_bottom2D) 在倒空间分发平面波时，由于 x/y/z 均等在正负半轴 span，因此常常会涉及到 C++ 不支持负数索引的问题（btw: Python 和 FORTRAN 支持负数索引，但支持方式不同），ABACUS 当前所采取的策略是： if (xnx; if (yny; if (znz; 而在 gamma_only 情况下，由于 F(-k)=F^\\dagger(k) \\\\ 因此倒空间可以缩减（reduce），此两种情况均对倒空间 xy 平面上格点采样有所影响： “棍子”的分发和分发记录 PW_Basis::collect_st() 和 PW_Basis::divide_sticks_1() 分别排序与分发“棍子”到不同 processor： 按照棍子从长到短顺序进行排序，即 st_length2D 由大到小排序，然后适用于 st_bottom2D 等变量 将排在最前面的“棍子”对应平面波分配给任意一个 processor， 如此直到所有 processor 全部被分配过平面波/“棍子” 若还有“棍子”，则寻找具有最小平面波数量的 processor（若平面波数量相等，则寻找最少的“棍子”）继续分配。 重复过程 4 如此一来记录被分配在每个 processor 上的平面波和棍子数量： 变量（所属 PW_Basis 类） 意义 this->npw_per 各 processor 被分配平面波数量 this->nst_per 各 processor 被分配“棍子”数量 this->fftixy2ip 从“棍子”translated (x,y)-pair 到 processor index 的映射，即通过“棍子”所在(x,y)到 processor 的映射关系：cpp // module_basis/module_pw/pw_distributeg_method1.cpp:line 282 this->fftixy2ip[st_i[is] * this->fftny + st_j[is]] = ipmin; translated pair 实际为一维索引，使用 x*fftny + y。进而 fftixy2ip[st_i[is] * this->fftny + st_j[is]] 实现了从“棍子”索引到 processor 索引的映射。 this->startnsz_per 每个包含“棍子”的 processor 其第一个 z-axis grid point 的编号，从 0 开始，跨 processor。 关于 this->startnsz_per 意义的介绍，见辅助阅读材料：Appendix.2 平面波倒空间分发详解。 请自行阅读 PW_Basis::collect_st() 和 PW_Basis::divide_sticks_1() 函数代码： PW_Basis::collect_st()：https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_basis/module_pw/pw_distributeg_method1.cpp#L122 PW_Basis::divide_sticks_1()：https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_basis/module_pw/pw_distributeg_method1.cpp#L247 分发后在 processor 间的广播则显而易见： void PW_Basis::distribution_method1() { .... if (poolrank == 0) this->count_pw_st(st_length2D, st_bottom2D); #ifdef __MPI MPI_Bcast(&this->npwtot, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&this->nstot, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&liy, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&riy, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&lix, 1, MPI_INT, 0, this->pool_world); MPI_Bcast(&rix, 1, MPI_INT, 0, this->pool_world); #endif if(poolrank == 0) { #ifdef __MPI .... this->collect_st(st_length2D, st_bottom2D, st_i, st_j, st_length); .... this->divide_sticks_1(st_i, st_j, st_length); .... } #ifdef __MPI MPI_Bcast(st_length2D, this->fftnxy, MPI_INT, 0, this->pool_world); MPI_Bcast(st_bottom2D, this->fftnxy, MPI_INT, 0, this->pool_world); MPI_Bcast(this->nst_per, this->poolnproc, MPI_INT, 0 , this->pool_world); MPI_Bcast(this->npw_per, this->poolnproc, MPI_INT, 0 , this->pool_world); #endif this->npw = this->npw_per[this->poolrank]; this->nst = this->nst_per[this->poolrank]; this->nstnz = this->nst * this->nz; .... 映射表：OOP？ 在倒空间平面波的分发过程中，共建立过四个映射表，分别是 this->fftixy2ip, this->istot2ixy, this->ig2isz 和 this->is2fftixy，其意义分别为： 映射表名称 意义 来源 备注 this->fftixy2ip（同上表） 从“棍子”xy 平面折合坐标到 processor index 的映射，即通过“棍子”所在(x,y)到 processor 的映射，可以用来在 processor 之间 switch PW_Basis::divide_sticks_1()(Link) 折合：索引的 2d->1d：index_folded = x*this->fftny + y;index = x*this->ny + y;折叠：gamma_only 时，实际 fftnx 或 fftny 是 0.5 倍实空间格点数量（nx 或 ny）。 this->istot2ixy 从“棍子”索引到非折叠倒空间折合坐标的映射 PW_Basis::get_istot2ixy()(Link) this->ig2isz 从平面波的 processor 内索引，到其倒空间平移后 z 坐标的映射 PW_Basis::get_ig2isz_is2fftixy(Link) this->is2fftixy 每个 processor 各有一份，建立从 procesor 内“棍子”索引到其折叠后倒空间 xy 平面折合坐标的映射 PW_Basis::get_ig2isz_is2fftixy(Link) 映射表的建立是为了解决实际问题，因此需要思考从建立起来的映射表，可以获得何种信息（processor-local 和 processor-global）。 对其中两个由 rank0 processor 建立的映射表也进行了分发： void PW_Basis::distribution_method1() { .... if(poolrank == 0) { #ifdef __MPI .... this->collect_st(st_length2D, st_bottom2D, st_i, st_j, st_length); .... this->divide_sticks_1(st_i, st_j, st_length); .... this->get_istot2ixy(st_i, st_j); .... #else .... #endif } #ifdef __MPI .... MPI_Bcast(this->fftixy2ip, this->fftnxy, MPI_INT, 0, this->pool_world); MPI_Bcast(this->istot2ixy, this->nstot, MPI_INT, 0, this->pool_world); .... #endif .... } 分发后处理 void PW_Basis::setuptransform() { ModuleBase::timer::tick(this->classname, \"setuptransform\"); this->distribute_r(); this->distribute_g(); this->getstartgr(); .... void PW_Basis::getstartgr() { if(this->gamma_only) this->nmaxgr = ( this->npw > (this->nrxx+1)/2 ) ? this->npw : (this->nrxx+1)/2; else this->nmaxgr = ( this->npw > this->nrxx ) ? this->npw : this->nrxx; this->nmaxgr = (this->nz * this->nst > this->nxy * nplane) ? this->nz * this->nst : this->nxy * nplane; delete[] this->numg; this->numg = new int[poolnproc]; delete[] this->startg; this->startg = new int[poolnproc]; delete[] this->startr; this->startr = new int[poolnproc]; delete[] this->numr; this->numr = new int[poolnproc]; for (int ip = 0;ip numg[ip] = this->nst_per[poolrank] * this->numz[ip]; for (int ip = 0;ip numr[ip] = this->nst_per[ip] * this->numz[poolrank]; this->startg[0] = 0; for (int ip = 1;ip startg[ip] = this->startg[ip-1] + this->numg[ip-1]; this->startr[0] = 0; for (int ip = 1;ip startr[ip] = this->startr[ip-1] + this->numr[ip-1]; } 即 this->numg, this->numr 分别是： 从当前 processor 从实空间 z 方向格点/xy 平面到所有 processors 的倒空间 sticks 的映射数量， 以及当前 processor 从倒空间到所有 processors 所拥有 this->numz，即实空间 z 方向格点/xy 平面数量的映射数量。 this->startg 和 this->startr 则为 this->numg 和 this->numr 的 correspondence 的 starting index。 下面将要调用 PW_Basis::ft:clear() 函数，再之后将和 FFTW 以及 MPI 库进行交互，完成 FFT 操作的准备工作。但至此，所有平面波和实空间格点的分发工作已经完成。 Special topic: utilization of FFTW library in ABACUS void PW_Basis::setuptransform() { .... this->ft.clear(); if(this->xprime) this->ft.initfft(this->nx,this->ny,this->nz,this->lix,this->rix,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); else this->ft.initfft(this->nx,this->ny,this->nz,this->liy,this->riy,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); this->ft.setupFFT(); .... } 暂略 PW_Basis::collect_local_pw() 接下来以一个简单的函数来检验之前的学习效果： void PW_Basis::collect_local_pw() { if(this->npw ig_ggeq0 = -1; // change name of this variable from ig_gge0 to ig_ggeq0 delete[] this->gg; this->gg = new double[this->npw]; delete[] this->gdirect; this->gdirect = new ModuleBase::Vector3[this->npw]; delete[] this->gcar; this->gcar = new ModuleBase::Vector3[this->npw]; ModuleBase::Vector3 f; for(int ig = 0 ; ig npw ; ++ig) { int isz = this->ig2isz[ig]; int iz = isz % this->nz; int is = isz / this->nz; int ixy = this->is2fftixy[is]; int ix = ixy / this->fftny; int iy = ixy % this->fftny; if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; f.x = ix; f.y = iy; f.z = iz; this->gg[ig] = f * (this->GGT * f); this->gdirect[ig] = f; this->gcar[ig] = f * this->G; if(this->gg[ig] ig_ggeq0 = ig; } } 在这个函数里，折合索引的还原分别由 int isz = this->ig2isz[ig]; int iz = isz % this->nz; int is = isz / this->nz; 和 int ixy = this->is2fftixy[is]; int ix = ixy / this->fftny; int iy = ixy % this->fftny; 完成，负数索引的还原则由 if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; 完成。因为当前不同 prcoessor 已经具有不同数量被分发的实空间格点和倒空间格点（即平面波），因此即使每个 processor 执行上述相同的代码内容，其结果也将不相同。 ⚙ 坐标的打包和解包功能可能适合封装成为函数进行调用，或抽象更高级的数据结构，通过重载括号的方式使用。 void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->collect_local_pw(); .... PW_Basis::collect_uniqgg() void ESolver_FP::Init(Input& inp, UnitCell& cell) { .... this->pw_rho->collect_uniqgg(); .... 这个函数的功能为单调地（递减）存储平面波的模，即对于倒空间中点所对应的平面波的能量，对于包含兼并的情况则只存储一次，分别存放在 tmpgg2 和 gg_uniq 中，而 tmpgg 则是费空间的存储方式：每个平面波都有其对应存储的模长，且一一对应。 void PW_Basis::collect_uniqgg() { if(this->npw ig_gge0 = -1; delete[] this->ig2igg; this->ig2igg = new int [this->npw]; int *sortindex = new int [this->npw]; double *tmpgg = new double [this->npw]; double *tmpgg2 = new double [this->npw]; ModuleBase::Vector3 f; for(int ig = 0 ; ig npw ; ++ig) { int isz = this->ig2isz[ig]; int iz = isz % this->nz; int is = isz / this->nz; int ixy = this->is2fftixy[is]; int ix = ixy / this->fftny; int iy = ixy % this->fftny; if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; f.x = ix; f.y = iy; f.z = iz; tmpgg[ig] = f * (this->GGT * f); if(tmpgg[ig] ig_gge0 = ig; } ModuleBase::GlobalFunc::ZEROS(sortindex, this->npw); ModuleBase::heapsort(this->npw, tmpgg, sortindex); int igg = 0; this->ig2igg[sortindex[0]] = 0; tmpgg2[0] = tmpgg[0]; double avg_gg = tmpgg2[igg]; int avg_n = 1; for (int ig = 1; ig npw; ++ig) { if (std::abs(tmpgg[ig] - tmpgg2[igg]) > 1.0e-8) { tmpgg2[igg] = avg_gg / double(avg_n); ++igg; tmpgg2[igg] = tmpgg[ig]; avg_gg = tmpgg2[igg]; avg_n = 1; } else { avg_n++; avg_gg += tmpgg[ig]; } this->ig2igg[sortindex[ig]] = igg; } tmpgg2[igg] = avg_gg / double(avg_n); this->ngg = igg + 1; delete[] this->gg_uniq; this->gg_uniq = new double [this->ngg]; for(int igg = 0 ; igg ngg ; ++igg) gg_uniq[igg] = tmpgg2[igg]; delete[] sortindex; delete[] tmpgg; delete[] tmpgg2; } 因此调用出平面波模长的方法为 this->gg_uniq[this->ig2igg[ipw]]。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 3 下篇：Introduction to ABACUS: Path to PW calculation - Part 5 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-path5.html":{"url":"develop-path5.html","title":"Introduction to ABACUS: Path to PW calculation - Part 5","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 5 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 5 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class 盯紧数据流：Constructor the ESolver_KS() 跟随继承关系，我们从 ESolver_FP 来到 ESolver_KS，之后我们还会进入下一层 ESolver_KS_PW。和之前一样，我们仍然需要关心从 ESolver_FP 到 ESolver_KS，多了哪些数据成员，数据成员在何时被分配内存，何时拥有具体数值，对之后理解程序的整体流程控制十分重要。 check 头文件中数据成员的声明，并且牢记父类的各成员也在当前类中存在： namespace ModuleESolver { template class ESolver_KS : public ESolver_FP { public: ....// constructor and destructor declarations omitted // present class parent class inherited // （will not re-introduce here） double scf_thr; ModulePW::PW_Basis* pw_rho; double drho; ModulePW::PW_Basis_Big* pw_big; int maxniter; elecstate::ElecState* pelec = nullptr; int niter; Charge chr; bool conv_elec; ModuleSymmetry::Symmetry symm; int out_freq_elec; psi::Psi>* psi = nullptr; psi::Psi* psid = nullptr; Structure_Factor sf; K_Vectors kv; ....// member function(s) omitted protected: hsolver::HSolver* phsol = nullptr; hamilt::Hamilt* p_hamilt = nullptr; ModulePW::PW_Basis_K* pw_wfc = nullptr; Charge_Mixing* p_chgmix = nullptr; wavefunc wf; Charge_Extra CE; std::string basisname; 从构造函数中查看哪些量被初始化： namespace ModuleESolver { template ESolver_KS::ESolver_KS() { .... scf_thr = GlobalV::SCF_THR; drho = 0.0; maxniter = GlobalV::SCF_NMAX; niter = maxniter; out_freq_elec = GlobalV::OUT_FREQ_ELEC; pw_wfc = new ModulePW::PW_Basis_K_Big(GlobalV::device_flag, GlobalV::precision_flag); ModulePW::PW_Basis_K_Big* tmp = static_cast(pw_wfc); tmp->setbxyz(INPUT.bx,INPUT.by,INPUT.bz); p_chgmix = new Charge_Mixing(); p_chgmix->set_rhopw(this->pw_rho); p_chgmix->set_mixing(INPUT.mixing_mode, INPUT.mixing_beta, INPUT.mixing_ndim, INPUT.mixing_gg0, INPUT.mixing_tau); if (std::abs(INPUT.mixing_beta + 10.0) need_auto_set(); this->wf.init_wfc = INPUT.init_wfc; this->wf.mem_saver = INPUT.mem_saver; this->wf.out_wfc_pw = INPUT.out_wfc_pw; this->wf.out_wfc_r = INPUT.out_wfc_r; } 因此当调用 ESolver_KS::ESolver_KS() 时，除了父类中各函数会被初始化外，另有 wavefunc 类 wf、Charge_Extra 类 CE 被初始化并分配内存，此外还有 hsolver::HSolver 类 phsol、hamilt::Hamilt 类 p_hamilt、ModulePW::PW_Basis_K 类 pw_wfc、Charge_Mixing 类 p_chgmix 指针被创建。在执行构造函数过程中，有 pw_wfc、p_chgmix 被分配内存，因此调用其构造函数。 wavefunc 类数据成员 在头文件中初始化值 在构造函数中初始化值 allocate out_wfc_pw out_wfc_r 0 init_wfc, mem_saver R, Rmax Charge_Extra 类数据成员 在头文件中初始化值 在构造函数中初始化值 istep 0 pot_order, rho_extr dis_old1, dis_old2, dis_now nulltpr alpha,beta ⚙ 两类均基本没有数据成员在对象建立时被赋值。然而通过上面代码块第 23-26 行可以发现，wavefunc 类 wf 的数据成员直接可以被访问，直接导入（拷贝）Input 类对象 INPUT 的数据成员，即 wavefunc 类的数据成员处于直接暴露的状态，这违反了封装理念。更好一点的做法是为每个类建立 getter 和 setter 函数，通过此两者来访问和修改成员变量，但更多的封装理念此处不再赘述。 接下来我们对 ESolver_KS() 中的其他操作以及其具体结果进行介绍。 Constructor the ModulePW::PW_Basis_K_Big() ModulePW::PW_Basis_K_Big 类的构造函数进行过一次重载，此时调用的版本为重载版本。在重载版本中，完全为继承 PW_Basis 的构造函数对应版本，但内容简单： namespace ModulePW { class PW_Basis_Big: public PW_Basis { public: .... PW_Basis_Big(std::string device_, std::string precision_) : PW_Basis(device_, precision_) {} namespace ModulePW { .... PW_Basis::PW_Basis(std::string device_, std::string precision_) : device(std::move(device_)), precision(std::move(precision_)) { classname=\"PW_Basis\"; this->ft.set_device(this->device); this->ft.set_precision(this->precision); } void FFT::set_device(std::string device_) { this->device = std::move(device_); } void FFT::set_precision(std::string precision_) { this->precision = std::move(precision_); } Constructor the Charge_Mixing() 我们按照相同路数查看 Charge_Mixing 类的构造函数： Charge_Mixing::Charge_Mixing() { rstep = 0; dstep = rstep - 1; initp = false; initb = false; } 以及其所属类的指针 p_chgmix 的相关调用操作： p_chgmix = new Charge_Mixing(); p_chgmix->set_rhopw(this->pw_rho); p_chgmix->set_mixing(INPUT.mixing_mode, INPUT.mixing_beta, INPUT.mixing_ndim, INPUT.mixing_gg0, INPUT.mixing_tau); // using bandgap to auto set mixing_beta if (std::abs(INPUT.mixing_beta + 10.0) need_auto_set(); else if (INPUT.mixing_beta > 1.0 || INPUT.mixing_beta Charge_mixing::set_rhopw() 函数的操作十分简单，即从括号中形参复制到自己的成员变量 Charge_mixing::rhopw 中，其中形参类型被指定为 ModulePW::PW_Basis*。 void Charge_Mixing::set_rhopw(ModulePW::PW_Basis* rhopw_in) { this->rhopw = rhopw_in; } void Charge_Mixing::set_mixing(const std::string &mixing_mode_in, const double &mixing_beta_in, const int &mixing_ndim_in, const double &mixing_gg0_in, const bool &mixing_tau_in) { this->mixing_mode = mixing_mode_in; this->mixing_beta = mixing_beta_in; this->mixing_ndim = mixing_ndim_in; this->mixing_gg0 = mixing_gg0_in; //mohan add 2014-09-27 this->mixing_tau = mixing_tau_in; .... } 而因为在 module_io/input.cpp 中有 INPUT.mixing 初始化为-10，因此 if 判断中的满足意味着默认值未被修改，因而调用 Charge_mixing::need_auto_set()，将 Charge_mixing::autoset 置为 true。 void Charge_Mixing::need_auto_set() { this->autoset = true; } Trigger: ESolver_KS::Init() template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { ESolver_FP::Init(inp,ucell); ucell.cal_nelec(GlobalV::nelec); XC_Functional::set_xc_type(ucell.atoms[0].ncpp.xc_func); .... this->kv.set(this->symm, GlobalV::global_kpoint_card, GlobalV::NSPIN, ucell.G, ucell.latvec); .... if(GlobalV::BASIS_TYPE==\"pw\" || GlobalV::CALCULATION==\"get_wf\") { #ifdef __MPI this->pw_wfc->initmpi(GlobalV::NPROC_IN_POOL, GlobalV::RANK_IN_POOL, POOL_WORLD); #endif this->pw_wfc->initgrids(inp.ref_cell_factor * ucell.lat0, ucell.latvec, this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz); this->pw_wfc->initparameters(false, inp.ecutwfc, this->kv.nks, this->kv.kvec_d.data()); #ifdef __MPI if(INPUT.pw_seed > 0) { MPI_Allreduce(MPI_IN_PLACE, &this->pw_wfc->ggecut, 1, MPI_DOUBLE, MPI_MAX , MPI_COMM_WORLD); } #endif this->pw_wfc->setuptransform(); for (int ik = 0; ik kv.nks; ++ik) this->kv.ngk[ik] = this->pw_wfc->npwk[ik]; this->pw_wfc->collect_local_pw(); .... } GlobalC::Pgrid.init(this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz, this->pw_rho->nplane, this->pw_rho->nrxx, pw_big->nbz, pw_big->bz); this->sf.setup_structure_factor(&GlobalC::ucell, this->pw_rho); CE.Init_CE(GlobalC::ucell.nat); } 首先调用了两函数，以 UnitCell::cal_nelec() 计算体系中总电子数，并存储在 GlobalV::nelec，以及 XC_Functional::set_xc_type() 根据输入文件中设置参数，为三个泛函相关量（XC_Functional::func_id, XC_Functional::func_type 和 XC_Functional::use_libxc）进行赋值，见 source/module_hamilt_general/module_xc/xc_funtional.cpp: line 26（Link）。 变量 数据类型 描述 XC_Functional::func_id std::vector 首先将交换泛函压入，然后是关联泛函。预先通过宏对每种泛函和整数间进行对应，见 source/module_hamilt_general/module_xc/xc_funcs.h（Link） XC_Functional::func_type int LDA: 1; GGA: 2; meta-GGA: 3; hybrid GGA: 4; hybrid meta-GGA: 5 XC_Functional::use_libxc bool 因 Symmetry::analy_sys()功能尚未完全部署，暂时跳过。 波函数 k 点采样：K_Vectors::set() 在一般的第一性原理软件中，或对建模为周期性体系（认定其中包含平移对称性的体系）而言，平移对称性决定了\\mathbf{k}是量子数之一，因此为区分态，并且计算态，k 点采样对于准确计算体系的性质尤为重要（尽量准确计算占据态），但这一 k 点所对应\\mathbf{k}需要和原本用于展开波函数的平面波基其\\mathbf{G}加以区分：\\mathbf{G}（通过 ecut 决定）只能决定当前待求波函数的精度，但还并不能决定当前体系的性质能否计算准确。回顾 Bloch 定理，在 k 点\\mathbf{k}，第 n 个能级在实空间坐标表象下的波函数为： \\psi_{\\text{n}\\mathbf{k}}(\\mathbf{r})=e^{i\\mathbf{k}\\cdot\\mathbf{r}}u_{\\text{n}\\mathbf{k}}(\\mathbf{r}) 平面波基的\\mathbf{G}出现在 Bloch 调幅函数u_{\\text{n}\\mathbf{k}}(\\mathbf{r})中： u_{\\text{n}\\mathbf{k}}(\\mathbf{r})=\\sum_{\\mathbf{G}}c_\\mathbf{G}^{(\\text{n}\\mathbf{k})}e^{i\\mathbf{G}\\cdot\\mathbf{r}}。 老生常谈，平移对称性实际上是指\\psi_{\\text{n}\\mathbf{k}}(\\mathbf{r}+n\\mathbf{a})=\\psi_{\\text{n}\\mathbf{k}}(\\mathbf{r})，则\\psi_{\\text{n}\\mathbf{k}}(\\mathbf{r}+n\\mathbf{a})=e^{i\\mathbf{k}\\cdot(\\mathbf{r}+n\\mathbf{a})}u_{\\text{n}\\mathbf{k}}(\\mathbf{r}+n\\mathbf{a})。认定 Bloch 函数必有该性质，则实际上需要满足： 2N\\pi=n(\\mathbf{k}\\cdot\\mathbf{a}), 一维：2N\\pi/n|\\mathbf{a}|=|\\mathbf{k}| 因此不同 k 点的考虑实际是在考虑体系的不同平移对称性。当 k 点采样无穷多时，即等同于考虑体系（波函数）的所有平移对称性。 void K_Vectors::set(const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { .... this->nspin = nspin_in; if(this->nspin==4) this->nspin = 1;//zhengdy-soc .... bool read_succesfully = this->read_kpoints(k_file_name); #ifdef __MPI Parallel_Common::bcast_bool(read_succesfully); #endif if(!read_succesfully) {....} std::string skpt1=\"\"; std::string skpt2=\"\"; if(!berryphase::berry_phase_flag && ModuleSymmetry::Symmetry::symm_flag != -1) { bool match = true; this->ibz_kpoint(symm, ModuleSymmetry::Symmetry::symm_flag, skpt1, GlobalC::ucell, match); #ifdef __MPI Parallel_Common::bcast_bool(match); #endif if (!match) {....} if (ModuleSymmetry::Symmetry::symm_flag || is_mp) { this->update_use_ibz(); this->nks = this->nkstot = this->nkstot_ibz; } } this->set_both_kvec(reciprocal_vec, latvec, skpt2); if(GlobalV::MY_RANK==0) {....} int deg = 0; if(GlobalV::NSPIN == 1) deg = 2; else if(GlobalV::NSPIN == 2||GlobalV::NSPIN==4) deg = 1; else ModuleBase::WARNING_QUIT(\"K_Vectors::set\", \"Only available for nspin = 1 or 2 or 4\"); this->normalize_wk(deg); GlobalC::Pkpoints.kinfo(nkstot); #ifdef __MPI this->mpi_k(); #endif this->set_kup_and_kdw(); this->print_klists(GlobalV::ofs_running); } k 点生成：K_Vectors::read_kpoints()及变量赋值回溯复习 来到 K_Vectors::read_kpoints() 函数，对于前三条件判断，第一则为让非 rank0 processors 退出该函数， bool K_Vectors::read_kpoints(const std::string &fn) { ModuleBase::TITLE(\"K_Vectors\", \"read_kpoints\"); if (GlobalV::MY_RANK != 0) return 1; .... if(GlobalV::GAMMA_ONLY_LOCAL) { .... } else if (GlobalV::KSPACING[0] > 0.0) { .... 第二和三涉及 GlobalV 中相关参数，按照 Introduction to ABACUS: Path to PW calculation - Part 1 相同方法进行变量赋值回溯，举例对于 GlobalV::GAMMA_ONLY_LOCAL: 首先鼠标右键拉取菜单，选择“查找所有引用”， 仔细检查侧边栏 Vscode 给出引用查找结果 基于我们当前对 ABACUS 工作流的了解，单击左侧 input_conv.cpp 文件后，跳转到 input_conv.cpp 相关行（line 328）： 证明此参数可能也在 Input 类方法中被读取。切换到文件浏览器侧边栏后直接打开 input.cpp，查找 \"gamma_only_local\" 相关内容： 寻得有效赋值操作： 寻找何时有 “gamma_only == 1” 条件： 然而，并非只要将 gamma_only 关键词在 INPUT 文件中置为 true 即可，因为在 line 2350，实际上 pw 基不支持该参数，因此对于 esolver_type == esolver_ks_pw 的情况，gamma_only 为 false 而 gamma_only_local 也从未改变其默认值 false。 类似地我们回溯 GlobalV::kspacing[3]，发现在 input.cpp 中有： Full List of INPUT Keywords ‒ ABACUS documentation 图 1. 善用Ctrl+F 即如果指定了一个值，则 kspacing[1] 和 kspacing[2] 拥有和 kspacing[0] 相同值，若定义三个值，则三个值各不相同，通过 Input::read_kspacing() 实现。定义值后，将覆盖写入 KPT 文件，因此在之后的读取过程中读入的结果其实是刚刚写的结果。 从 examples 文件夹中，可以知道 KPT 文件可能具有的格式，以及在当前函数中会被读取到何变量中。 examples/scf/pw_Si2/INPUT 和 KPT: INPUT_PARAMETERS #Parameters (General) pseudo_dir ../../../tests/PP_ORB symmetry 1 #Parameters (Accuracy) basis_type pw ecutwfc 60 scf_thr 1e-8 scf_nmax 100 K_POINTS 0 Gamma 4 4 4 0 0 0 examples/band/pw_Al/INPUT1 和 KPT: INPUT_PARAMETERS #Parameters (General) pseudo_dir ../../../tests/PP_ORB calculation scf ntype 1 symmetry 0 #Parameters (Methos) basis_type pw ecutwfc 50 scf_thr 1.0e-8 // about iteration scf_nmax 100 smearing_method gauss smearing_sigma 0.01 #Parameters (File) out_chg 1 K_POINTS 0 Gamma 4 4 4 0 0 0 examples/band/pw_Al/INPUT2 和 KLINES（❗ 注意，此时 kpoint_file 参数被赋予 KLINES）: INPUT_PARAMETERS #Parameters (General) kpoint_file KLINES pseudo_dir ../../../tests/PP_ORB calculation nscf ntype 1 symmetry 0 #Parameters (Methos) ecutwfc 50 basis_type pw pw_diag_thr 1e-10 pw_diag_nmax 100 #Parameters (Accuracy) smearing_method gauss smearing_sigma 0.01 #Parameters (File) init_chg file out_band 1 K_POINTS 8 Line 0.0 0.0 0.0 20 0.5 -0.5 0.5 20 0.0 0.0 0.5 20 0.0 0.0 0.0 20 0.25 0.25 0.25 20 0.5 -0.5 0.5 1 0.25 0.25 0.25 20 0.0 0.0 0.5 1 相应地从 klist.cpp line 230（Link）开始，是读取 KPT 文件的相关行。在这里，我们并不逐行解读可读性强，容易理解的代码，而是将可能的情况汇总于下表： K_Vector 类中数据成员 KPT 文件中位置（行数） 取值 k_nkstot 2 0 >0, Depending on exact data kword 3 \"Gamma\" \"Monkhorst-Pack\" \"Cartesian\" \"Direct\" \"Line_Cartesian\" \"Line_Direct\"/“Line” is_mp true true false(default) false(default) false(default) false(default) k_type 0 1 nmp 4 Depending on exact data Depending on exact data koffset 4 Depending on exact data Depending on exact data k 点手动指定模式：[i]: 第 i-1 个 k 点的索引，其中 i 的取值范围由 nkstot 决定，在 KPT 文件中则从第 2 行读取。 kvec_c[i].x/y/z ≥4 Depending on exact data Depending on exact data kvec_d[i].x/y/z ≥4 K_Vectors::Monkhorst_Pack() generated K_Vectors::Monkhorst_Pack() generated Depending on exact data Depending on exact data wk[i] ≥4 K_Vectors::Monkhorst_Pack()generated K_Vectors::Monkhorst_Pack()generated Depending on exact data Depending on exact data 1.0 1.0 kc_done false(defalult) false(default) true true kd_done true true true true nkstot nmp[0]*nmp[1]*nmp[2] nmp[0]*nmp[1]*nmp[2] Depending on exact data Depending on exact data Depending on exact data Depending on exact data nk nkstot nkstot nkstot nkstot nkstot nkstot 备注 斜体变量实际为被 K_Vectors::Monkhorst_Pack() 函数赋值 \"Monkhorst-Pack\" 和 \"Gamma\" 方式对 k 空间采样： 图 2. klist.cpp line 486: K_Vectors::Monkhorst_Pack_formula(), k_type = 0 and 1 以这两种采样方式所给定的在 this->kvec_d 数组中存储顺序： 图 3. klist.cpp line 520: const int i = mpnx * mpny * (z - 1) + mpnx * (y - 1) + (x - 1) k 点归约、后处理与并行同步 归约：K_Vectors::ibz_kpoint() 在按照一定方法（Monkhorst-Pack、直接给定 k 点、Kpath）采样 k 点之后，需要根据对称性减少 k 点数量，使得计算量减少。对称操作可以使得 k vector 发生置换，或使得 k vector 不变。 void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... ModuleBase::Vector3 gb1(ucell.G.e11, ucell.G.e12, ucell.G.e13); ModuleBase::Vector3 gb2(ucell.G.e21, ucell.G.e22, ucell.G.e23); ModuleBase::Vector3 gb3(ucell.G.e31, ucell.G.e32, ucell.G.e33); ModuleBase::Vector3 gk1(gb1.x / nmp[0], gb1.y / nmp[0], gb1.z / nmp[0]); ModuleBase::Vector3 gk2(gb2.x / nmp[1], gb2.y / nmp[1], gb2.z / nmp[1]); ModuleBase::Vector3 gk3(gb3.x / nmp[2], gb3.y / nmp[2], gb3.z / nmp[2]); ModuleBase::Matrix3 gk(gk1.x, gk1.y, gk1.z, gk2.x, gk2.y, gk2.z, gk3.x, gk3.y, gk3.z); .... bool include_inv = false; std::vector kgmatrix(48 * 2); ModuleBase::Matrix3 inv(-1, 0, 0, 0, -1, 0, 0, 0, -1); ModuleBase::Matrix3 ind(1, 0, 0, 0, 1, 0, 0, 0, 1); .... int nrotkm; if (use_symm) {....} else if (is_mp) { nrotkm = 2; kgmatrix[0] = ind; kgmatrix[1] = inv; } ModuleBase::Matrix3* kkmatrix = new ModuleBase::Matrix3 [nrotkm]; symm.gmatrix_convert(kgmatrix.data(), kkmatrix, nrotkm, ucell.G, gk); .... void Symmetry::gmatrix_convert(const ModuleBase::Matrix3* sa, ModuleBase::Matrix3* sb, const int n, const ModuleBase::Matrix3 &a, const ModuleBase::Matrix3 &b)const { ModuleBase::Matrix3 ai = a.Inverse(); ModuleBase::Matrix3 bi = b.Inverse(); for (int i=0;i Symmetry::gmatrix_convert() 函数为对称操作在 3 维空间的矩阵表象进行变换，该函数可以写为如下形式： BA^{-1}O_iAB^{-1}=(AB^{-1})^{-1}O_i(AB^{-1}), i=1,2 O_1=\\begin{pmatrix} 1 &0 &0 \\\\ 0 &1 &0 \\\\ 0 &0 &1 \\end{pmatrix}, O_2=\\begin{pmatrix} -1 &0 &0 \\\\ 0 &-1 &0 \\\\ 0 &0 &-1 \\end{pmatrix} A=\\frac{\\text{lat}_0}{2\\pi}\\begin{pmatrix} b_{11}&b_{12}&b_{13}\\\\ b_{21}&b_{22}&b_{23}\\\\ b_{31}&b_{32}&b_{33} \\end{pmatrix}, B=\\frac{\\text{lat}_0}{2\\pi}\\begin{pmatrix} b_{11}/\\text{nk}_1&b_{12}/\\text{nk}_1&b_{13}/\\text{nk}_1\\\\ b_{21}/\\text{nk}_2&b_{22}/\\text{nk}_2&b_{23}/\\text{nk}_2\\\\ b_{31}/\\text{nk}_3&b_{32}/\\text{nk}_3&b_{33}/\\text{nk}_3 \\end{pmatrix}, AB^{-1}=\\begin{pmatrix} \\text{nk}_1&0&0\\\\ 0&\\text{nk}_2&0\\\\ 0&0&\\text{nk}_3\\\\ \\end{pmatrix} ，where b_{ij} is the j-th component of i-th canonically defined reciprocal vector. In principle \\mathbf{a}_i\\cdot\\mathbf{b}_j=2\\pi\\delta_{ij}, but the G (ucell.G) defined here is latvec.inverse().transpose(), where every element is rescaled by factor 1/lat0, therefore the multiplication between G and latvec cannot obtain 2\\pi but 1. Actually matrix A can relate to B directly via: TA=B, where T matrix is, \\begin{pmatrix} 1/\\text{nk}_1&0&0\\\\ 0&1/\\text{nk}_2&0\\\\ 0&0&1/\\text{nk}_3\\\\ \\end{pmatrix} if (!use_sym), kkmatrix[0]= (AB^{-1})^{-1}O_1(AB^{-1})= \\begin{pmatrix} 1/\\text{nk}_1&0&0\\\\ 0&1/\\text{nk}_2&0\\\\ 0&0&1/\\text{nk}_3\\\\ \\end{pmatrix}\\begin{pmatrix} 1 &0 &0 \\\\ 0 &1 &0 \\\\ 0 &0 &1 \\end{pmatrix}\\begin{pmatrix} \\text{nk}_1&0&0\\\\ 0&\\text{nk}_2&0\\\\ 0&0&\\text{nk}_3\\\\ \\end{pmatrix}\\\\ =\\begin{pmatrix} 1 &0 &0 \\\\ 0 &1 &0 \\\\ 0 &0 &1 \\end{pmatrix} if (!use_sym), kkmatrix[1]= (AB^{-1})^{-1}O_2(AB^{-1})= \\begin{pmatrix} 1/\\text{nk}_1&0&0\\\\ 0&1/\\text{nk}_2&0\\\\ 0&0&1/\\text{nk}_3\\\\ \\end{pmatrix}\\begin{pmatrix} -1 &0 &0 \\\\ 0 &-1 &0 \\\\ 0 &0 &-1 \\end{pmatrix}\\begin{pmatrix} \\text{nk}_1&0&0\\\\ 0&\\text{nk}_2&0\\\\ 0&0&\\text{nk}_3\\\\ \\end{pmatrix}\\\\ =\\begin{pmatrix} -1 &0 &0 \\\\ 0 &-1 &0 \\\\ 0 &0 &-1 \\end{pmatrix} 即实际上对于 is_mp 但 !use_symm 的情况，kgmatrix 和 kkmatrix 中内容相同。在当前情况，ucell.G=A，gk=B， ucell.G*gk.Inverse()=AB^{-1}, =A(TA)^{-1}=AA^{-1}T^{-1}=\\begin{pmatrix} \\text{nk}_1&0&0\\\\ 0&\\text{nk}_2&0\\\\ 0&0&\\text{nk}_3\\\\ \\end{pmatrix} gk*ucell.G.Inverse()=BA^{-1}, =TAA^{-1}=\\begin{pmatrix} 1/\\text{nk}_1&0&0\\\\ 0&1/\\text{nk}_2&0\\\\ 0&0&1/\\text{nk}_3\\\\ \\end{pmatrix} 对于当前所考虑的最简单情况，!use_sym，使得原本采样 k 点坐标（或矢量）由 reciprocal space（kvec_d: k vector in Direct coordinate）变化到 k-lattice space（kvec_d_k: k vector in Direct coordinate transformed in k lattice space）： void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... for (int i=0;i 图 4. 1-dimensional example 图 5. 2-dimensional example k 点归约通过 C++11 开始支持的匿名函数实现： void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... /// @brief PBC, wrap kvec_d into [-0.5, 0.5) auto restrict_kpt = [&symm](ModuleBase::Vector3 &kvec){ // in (-0.5, 0.5] kvec.x = fmod(kvec.x + 100.5-0.5*symm.epsilon, 1)-0.5+0.5*symm.epsilon; kvec.y = fmod(kvec.y + 100.5-0.5*symm.epsilon, 1)-0.5+0.5*symm.epsilon; kvec.z = fmod(kvec.z + 100.5-0.5*symm.epsilon, 1)-0.5+0.5*symm.epsilon; // in [0, 1) // kvec.x = fmod(kvec.x + 100 + symm.epsilon, 1) - symm.epsilon; // kvec.y = fmod(kvec.y + 100 + symm.epsilon, 1) - symm.epsilon; // kvec.z = fmod(kvec.z + 100 + symm.epsilon, 1) - symm.epsilon; if(std::abs(kvec.x) 之后遍历当前体系所具有的所有对称操作，记录新的 k vector（记为 kvec_rot_k）。可以预见，不管是在 k-lattice space 还是 reciprocal space，对称操作应当一致，即 k-lattice space vector 经对称操作后转换回到 reciprocal space 后，应当与直接在 reciprocal space 的 k vector 经历对称操作后结果（kvec_rot）严格相等： void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... for (int i = 0; i 之后匹配已经记录的 kvec_d（在变量 kvec_d_ibz 中，std::vector<> 容器），如果是新的则记录，如果是旧的则提高 k 点权重，用于后续计算需要 k 点平均的物理量。k 点归约部分的程序框图大致如下： 经过 k 点归约，下列变量数据成员的值被改变： 修改变量 意义 this->nkstot_ibz i:irreducible，即当前不可约布里渊区中 k 点数量，小于等于 this->nkstot this->kvec_d_ibz Direct 坐标下的 k 点坐标（归约后） this->wk_ibz 归约后 k 点坐标权重 this->ibz2bz 索引映射，从归约后 k 点索引到归约前。归约后存储在 this->kvec_d_ibz，而归约前存储在 this->kvec_d，可以通过 this->kvec_d[ibz2bz[index1]] 访问到归约前，内容应当相同，也可直接访问到 Cartesian：this->kvec_c[ibz2bz[index1]] 归约前，各 k 点权重均为\\frac{1}{\\text{nkstot}}，归约后则各不可约 k 点权重值需乘简并度： void K_Vectors::ibz_kpoint(const ModuleSymmetry::Symmetry &symm, bool use_symm,std::string& skpt, const UnitCell &ucell, bool& match) { .... for (int k=0; knkstot_ibz; ++k) { if ( symm.equal(kvec_rot.x, this->kvec_d_ibz[k].x) && symm.equal(kvec_rot.y, this->kvec_d_ibz[k].y) && symm.equal(kvec_rot.z, this->kvec_d_ibz[k].z)) { already_exist = true; this->wk_ibz[k] += weight; exist_number = k; break; } } 该函数的具体实现请自主阅读（Link）。 后处理：K_Vectors::update_use_ibz() 然而到达上层函数 K_Vectors::set(): line 105 后，以下量被更新： 被更新变量 具体值 this->nkstot this->nkstot_ibz this->kvec_d this->kvec_d_ibz this->wk this->wk_ibz this->kd_done true this->kc_done false ⚙ 如此一来 this->*_ibz 不应当为成员变量，而是应该在更新左列各量后销毁。 void K_Vectors::update_use_ibz( void ) { if (GlobalV::MY_RANK!=0) return; ModuleBase::TITLE(\"K_Vectors\",\"update_use_ibz\"); assert( nkstot_ibz > 0 ); this->nkstot = this->nkstot_ibz; ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running,\"nkstot now\",nkstot); this->kvec_d.resize(this->nkstot * nspin); for (int i = 0; i nkstot; ++i) { this->kvec_d[i] = this->kvec_d_ibz[i]; this->wk[i] = this->wk_ibz[i]; } this->kd_done = true; this->kc_done = false; return; } 可见该任务仍然只分配给 rank0 processor 去处理（之后在 K_Vectors::mpi_k() 函数进行广播）。之后同步 this->kvec_c 和 this->kvec_d。❗ 对于 kvec_d 已知而 kvec_d 未知的情况，对其进行了数值噪声的简单处理。而对于 kvec_c 已知而 kvec_d 为止的情况则并没有处理： void K_Vectors::set(const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { .... this->set_both_kvec(reciprocal_vec, latvec, skpt2); .... int deg = 0; if(GlobalV::NSPIN == 1) deg = 2; else if(GlobalV::NSPIN == 2||GlobalV::NSPIN==4) deg = 1; else .... .... void K_Vectors::set_both_kvec(const ModuleBase::Matrix3 &G, const ModuleBase::Matrix3 &R,std::string& skpt) { .... if (!kc_done && kd_done) { for (int i = 0;i 而对于更一般的，科学计算软件编写过程中需要注意的各种数值噪声、精度损失问题，见（文档缺失）。 分发与并行同步：K_Vectors::mpi_k() 生成、归约并进行过简单的 k 点后处理后，接下来对 k 点进行分发（记住 k 点的 MPI 并行在平面波基矢量下是比平面波并行和能带数并行更有效的并行方式，因为每个 k 点的 Kohn-Sham 方程求解基本都是独立的，所以并行效率较高）。 void K_Vectors::set(const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { .... this->normalize_wk(deg); GlobalC::Pkpoints.kinfo(nkstot); #ifdef __MPI this->mpi_k(); #endif 在调用 GlobalC::Pkpoints.kinfo(nkstot) 及 K_Vectors::mpi_k() 函数，以对当前已经读取和建立的相关数据成员在 processors 间进行广播之前，还经过了 this->wk 的重新归一化过程（函数 K_Vectors::normalize_wk()），由于只涉及具体数值而不涉及分发，因此将在下一节介绍。首先只关注分发。如前所述，由于 Parallel_Kpoints 类对象 PKpoints 是全局变量，因此可以直接调用其函数 Parallel_Kpoints::kinfo()。 void Parallel_Kpoints::kinfo(int &nkstot) { #ifdef __MPI Parallel_Common::bcast_int(nkstot); this->get_nks_pool(nkstot); this->get_startk_pool(nkstot); this->get_whichpool(nkstot); #endif return; } Parallel_Kpoints::kinfo() 函数完成三步骤的处理（由于已经完成过平面波的分发代码阅读，此处代码比较简单，故略过。Link）： （Parallel_Kpoints::get_nks_pool()）计算每个 processor/pool 所承担的 k 点数量。让每个 processor 都具有一份 nkstot 的拷贝，之后调用 Parallel_Kpoints::get_nks_pool() 进行计算。和平面波类似地，只不过此处 k point 并行方式为通过用户指定 KPAR 参数，之后以均分为基本原则，但对前 remain 个 processors 多分一个 k 点，即“getnks（of each）pool()”，分得 k 点数量记录在 Parallel_Kpoints::nks_pool 数组中，其中索引 runs over GlobalV::KPAR。 （Parallel_Kpoints::get_startk_pool()）计算每个 processor 对 k 点进行索引的连续编号，之后存储在 Parallel_Kpoints::startk_pool 中，索引仍然 runs over GlobalV::KPAR。 （Parallel_Kpoints::get_whichpool()）whichpool 是 Parallel_Kpoints 类内一个数据成员，其索引 runs over 所有 k 点。this->whichpool 提供了从 k 点可以找到对应 processor 的功能。 然后来到 K_Vectors::mpi_k() 函数。 #ifdef __MPI void K_Vectors::mpi_k(void) { .... Parallel_Common::bcast_bool(kc_done); Parallel_Common::bcast_bool(kd_done); Parallel_Common::bcast_int(nspin); Parallel_Common::bcast_int(nkstot); Parallel_Common::bcast_int(nmp, 3); Parallel_Common::bcast_double(koffset, 3); this->nks = GlobalC::Pkpoints.nks_pool[GlobalV::MY_POOL]; int nks_minimum = this->nks; Parallel_Reduce::gather_min_int_all( nks_minimum ); .... std::vector isk_aux(nkstot); std::vector wk_aux(nkstot); std::vector kvec_c_aux(nkstot*3); std::vector kvec_d_aux(nkstot*3); if (GlobalV::MY_RANK == 0) { for (int ik = 0;ik renew(this->nks * this->nspin); int k_index = 0; for (int i = 0;i 该函数第 12 行为每个 processor 分配了一定数量的 k 点，❗ 注意，此时每个 processor 的 K_Vectors::nks 的数量已经不同。之后在第 41 行，已经按照 this->nks*this->nspin 大小 resize 数组，而非原本的 this->nkstot*this->nspin。K_Vectors::mpi_k() 函数运行结束时，各 processor 已经拥有数量和内容不相同的 this->isk, this->wk, this->kvec_d 以及 this->kvec_c。即分配的 processor-特征变量是直接的 k 点坐标。 Unrestricted Kohn-Sham (UKS) case 贯穿刚刚的过程我们默认了只关心 RKS，即 Restricted Kohn-Sham scheme，对于非限制性情况（即不限制两自旋 channel 必须具有相同空间轨道）却丝毫未提及，仅在 K_Vectors::set() 函数的一开始见过对于 noncolinear 情况，设置 nspin 由 4 到 1。特别地，对于更加一般的情况，nspin=2 是最基本和常见的 scheme。 在归一化 this->wk 的过程中，对于不同数量的 spin-channel 已经具有不同的策略： void K_Vectors::set( const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { .... int deg = 0; if(GlobalV::NSPIN == 1) deg = 2; } else if(GlobalV::NSPIN == 2||GlobalV::NSPIN==4) deg = 1; .... this->normalize_wk(deg); void K_Vectors::normalize_wk(const int &degspin) { if(GlobalV::MY_RANK!=0) return; double sum = 0.0; for (int ik = 0;ik wk[ik]; .... for (int ik = 0;ik wk[ik] /= sum; for (int ik = 0;ik wk[ik] *= degspin; } 在一开始对 this->kvec_c、this->kvec_d、this->wk 等量就进行过 nspin 相关的内存空间分配： void K_Vectors::set(const ModuleSymmetry::Symmetry &symm, const std::string &k_file_name, const int& nspin_in, const ModuleBase::Matrix3 &reciprocal_vec, const ModuleBase::Matrix3 &latvec) { //K_Vectors::set(): line 69 this->nspin = nspin_in; .... if(this->nspin==4) { this->nspin = 1;//zhengdy-soc } 导入 nspin 到 this->nspin 之后，在 K_Vectors::read_kpoints() 函数中对 this->kvec_c, this->kvec_d, this->wk, this->isk, this->ngk 共四个 std::vector> 类数据成员调用 std::vector::resize() 函数。而在先前的 k 点坐标导入中，无论是哪种方式，均只存储在第一个 spin channel 中，即前 nkstot 或前 nkstot_ibz 个元素中，直到 K_Vectors::set_kup_and_kdw() 函数，才对第二个 spin channel 进行设置（简单对第一个 spin channel 的 k vectors 进行复制）。 void K_Vectors::set_kup_and_kdw(void) { switch (nspin) { case 1: for (int ik = 0; ik isk[ik] = 0; break; case 2: for (int ik = 0; ik kvec_c[ik+nks] = kvec_c[ik]; this->kvec_d[ik+nks] = kvec_d[ik]; this->wk[ik+nks] = wk[ik]; this->isk[ik] = 0; this->isk[ik+nks] = 1; } this->nks *= 2; this->nkstot *= 2; break; case 4: for (int ik = 0; ik isk[ik] = 0; break; } } 发现实际上对于 nspin=2 的情况，this->kvec_c, kvec_d, wk 三个数据均 alpba 和 beta spin-channel 内容相同，但靠 this->isk 来区分是哪种自旋。⚙ 但其实已经不存在 nspin=4 的情况，因为在 K_Vectors::set() 中，nspin=1 和 nspin=4 效果相同。 跳过 Print_Info::setup_parameters() 的信息输出，下一篇内容将直接到平面波基波函数的初始化。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 4 下篇：Introduction to ABACUS: Path to PW calculation - Summary 1 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-sm1.html":{"url":"develop-sm1.html","title":"Introduction to ABACUS: Path to PW calculation - Summary 1","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Summary 1 作者：黄一珂，邮箱：huangyk@aisi.ac.cn；金祖鑫，邮箱：jinzx@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Summary 1 &#x1F3EE;写在前面 经过 Introduction to ABACUS: Path to PW calculation 的 Part1 到 5，我们已经阅读过上百行程序。在继续之前，有必要将已经解读过的内容再次就重点进行回顾，并凝练和一定程度的抽象。牢记本系列内容组织的两原则： 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 主题 1：dataflow 1. 全局变量 不仅在上篇（Part 5）的最后，在 k 点分发时我们看到了在 GlobalC 中声明为 extern 的 Parallel_Kpoints 类对象 Pkpoints，在很多地方会被直接调用的 UnitCell 类对象 ucell，以及实际上最一开始看到的 Input 类对象 INPUT，也被声明为 extern。 extern 标识变量的好处(1)是跨文件/跨模块可用，以至于可以尽量缩减每个函数的形参表体积，(2)维持变量的唯一性，若又有其他变量具有相同名字，则编译阶段无法通过。但缺点是 extern 变量可能被修改，修改后则所有用到该 extern 变量的地方均受影响。另外 extern 的使用不当可能会(1)破坏封装性，为函数、变量、类、模块带来深度耦合，为之后的开发工作带来困难，(2)带来异常大的程序运行内存开销——因为有些变量确实可以具有短于整个程序的生命周期。 另一方面，如果有 extern 变量的生命周期和整个程序相同，可能给开发者带来困难：判断其何时何阶段具有何值就更有难度。 2. 输入文件读取 综合前 5 篇介绍的内容，结合 ABACUS workflow 的赋值顺序，将有关的全局变量总结如下： 主题 2：分发存储 1. 格点分发 在 Part 4，我们解读过 ABACUS 关于实空间格点与倒空间格点的分发策略。我们需要重新确定所分发的产物是什么。 实际上，在实空间进行积分的量基本都和电荷密度\\rho有关，因此格点数量实际通过 ecutrho 来控制。同时考虑到 FFT 的维数问题，因此基本要求是实空间和倒空间格点数目完全一致（除去 gamma_only 情况），即 this->fftnx = this->nx; this->fftny = this->ny; this->fftnz = this->nz; 1.1 实空间格点（link） 实空间格点的分发策略分两步： xyz 三维实空间沿 z 轴切片 切片按照先按 processors 均分，若有余则再按顺序分配 实空间格点划分后在 PW_Basis 类中，如下成员变量被赋值： PW_Basis 类内数据成员 变量意义 this->numz 列表，每个 processor 所分得 xy 平面数量 this->nplane 当前 processor 所分得 xy 平面数量 this->startz 列表，每个 processor 分得 xy 平面后，所具有平面沿 z 方向的起始索引 this->startz_current 当前 processor 分得 xy 平面后，所具有平面沿 z 方向的起始索引 this->nrxx 当前 processor 分得实空间格点数量 因此实空间的格点分发对于每个 processor 来说，能够特征识别的仅仅是 this->nplane 和 this->startz_current，主要为以上两量具有特征，且真正进行运算时，可以根据 this->startz_current 来分配数据（作为结果地，this->nrxx 是 processor 具有的实空间格点数）。 可以预想，对于三维空间的数据，可以以 this->startz_current 为依据分配具有数据的格点给不同 processor，也可使用一个 processor，访问 this->startz 数组来实现三维空间格点数据在 processor 间的分发。 1.2 倒空间格点（link） 倒空间的格点分发策略分两步： 首先在 ecutrho 划定倒空间球壳（我们约定，以后简称“ecutrho/ecutwfc 球壳”）内沿 z 方向划分出不同数量的“棍子”，即每根“棍子”包含一定数量的相同(x,y)而不同 z 的倒空间格点 将“棍子”长度按照降序排列后，按照“当前所有 processors 中具有最小‘棍子’累计高度的，优先分配”为原则进行分发 倒空间格点划分后在 PW_Basis 类中，如下成员变量被赋值： PW_Basis 类内数据成员 变量意义 this->startnsz_per 每个包含“棍子”的 processor 其第一个 z-axis grid point 的编号，从 0 开始，跨 processor。 this->npw 当前 processor 分得平面波数量（亦即倒空间格点数量） this->npw_per 列表，每个 processor 分得平面波数量（亦即倒空间格点数量） this->nst 当前 processor 分得“棍子”数量 this->nst_per 列表，每个 processor 分得“棍子”数量 this->nstnz this->nstnz = this->nst * this->nz this->npwtot 平面波总数 this->fftixy2ip 从“棍子”translated (x,y)-pair 到 processor index 的映射 this->istot2ixy 从“棍子”索引到非折叠倒空间折合坐标的映射 this->ig2isz 从平面波的 processor 内索引，到其倒空间平移后 z 坐标的映射 this->is2fftixy 每个 processor 各有一份，建立从 procesor 内“棍子”索引到其折叠后倒空间 xy 平面折合坐标的映射 this->numg 列表，从当前 processor 从实空间 z 方向格点/xy 平面到所有 processors 的倒空间 sticks 的映射数量 this->numr 列表，当前 processor 从倒空间到所有 processors 所拥有 this->numz，即实空间 z 方向格点/xy 平面数量的映射数量 this->startg 列表，this->numg 的从当前 processor 到所有 processor 的映射的起始索引 this->startr 列表，this->numr 的从当前 processor 到所有 processor 的映射的起始索引 this->ig2igg 从归约前平面波索引到归约后模长列表的索引的映射 this->gg_uniq 列表，归约后平面波数量 由于倒空间格点的分发比较复杂，因此各个 processor 分得的格点，需要从 ecutrho 球壳中格点到 processor 进行 mapping，也需要方便地从 processor 中格点方便地知道其所对应（x,y,z）。 举例定义分发后的某倒空间格点为（ip, is, iz），其中 ip 为 index_processor，is 为 index_stick_processor，即在当前 processor 中“棍子”的索引，iz 为 index_z_stick，即在当前“棍子”中格点的索引（实际等价于 z 坐标的索引），则（&#x1F600; 以下建立两坐标系的双向 1-1 映射过程可以出成思考题）： （ip, is, iz）→（x, y, z）：ip 人为给定、this->is2fftixy 确定从（ip, is）到（x, y）映射，iz 则实际上可以直接换算——因为 ecutrho 球壳关于 z=0 平面上下对称。 （x, y, z）→（ip, is, iz）：this->fftixy2ip 确定 ip，在 ip 中得到 this->nst，再访问当前 processor 的 this->is2fftixy，核对（x, y），得到 is，然后转换 z 到 iz。 2. k 点分发（link） k 点的分发策略分三步： 按照用户给定方式生成 k 点：Gamma、Monkhorst-Pack、给定 k 点、k path 通过确定的对称性，对所生成的 k 点进行对称变换，对 k 点数量进行归约 k 点先按 processor 均分，若有余则再按顺序分配 k 点分发后在 K_Vectors 类中，主要有如下成员变量被赋值： PW_Basis 类内数据成员 变量意义 this->kvec_c 列表，当前 processor 分得 k 点的 Cartesian 坐标 this->kvec_d 列表，当前 processor 分得 k 点的 Direct 坐标 this->wk 列表，当前 processor 分得 k 点的权重 this->isk 列表，当前 processor 分得 k 点的 spin channel, 0: alpha, 1: beta this->nks 当前 processor 分得 k 点的数量 this->nkstot k 点总数 因此 k 点分发直接获得 k 点坐标和对应权重，以及 spin channel 的标识。 开发初步尝试：doxygen 注释和单元测试 1. 程序注释规范 1.1 现状介绍 诚然这个系列的文档是为让 ABACUS 新晋开发者更快熟悉 ABACUS 代码，清楚 ABACUS 中各个变量和功能可能声明、初始化和实现的位置，以及变量间的从属关系，但文档的发行速度和更新速度远慢于 ABACUS 新版本的开发。因为这一点，ABACUS 开发团队同时希望 ABACUS 的信息 self-contained，即在每个程序文件中都有足够详尽的关于当前文件内容的注释，以及其他可能需要的信息。 然而由于 ABACUS 的历史较长，ABACUS 的开发者也所属组织和单位众多，因此除了代码风格多样外，注释风格也十分多样。格式和缩写各异的注释使得代码整洁程度下降，因此代码主体的可读性降低，并且注释的可读性也难以保证。 目前在 ABACUS 中存在的代码注释风格按添加注释的位置分类主要包括两种：随行注释和 Section 注释。 然而，在头文件中添加 section 型注释可能会导致在 vscode 中讲注释显示在临近的第一个变量/函数上（如上图，会显示在 NPROC 上），而其他各变量和函数均保持未注释状态，此时在其他代码位置鼠标悬停时不会有注释显式。 1.2 基本注释原则 1.2.1 Doxygen 注释 ABACUS 现在推进 doxygen 格式的注释。Doxygen 注释在 vscode 中可以使用插件进行模板插入： Doxygen 函数注释样例： 1.2.2 若干注意事项 对于某个类中数据成员和成员函数的注释，请添加在相应的头文件中，避免在源文件中添加此类注释。对于程序代码的注释则没有要求，只需保证清晰明了。 （对于头文件中添加的函数注释）特别对于一些 void 类型函数，形参表中变量既有输入也有输出的，在 @param 字段注明“[in]”或者\"[out]\"作为标识 @brief 字段尽量保证描述清晰且语言简洁，更多的内容可以添加在 @details 字段 注意事项等可以添加在 @attention 字段 1.3 为了更平滑的开发和维护：扩展注释内容 1.3.1 模块封装化注释 封装、继承和多态是包括 C++ 在内的高级编程语言的核心理念。良好的封装有助于保护程序运行的稳定性，同时有利于开发工作的开展。然而，封装不仅仅是局部而言对某个类的封装，更应该将封装的理念应用于整体的程序设计。程序整体组织层面的封装，有利于在程序因一定需求需大幅改变结构时，能够稳定运行而不出错，同时能够实现各部分的独立、高效开发。 现阶段 ABACUS 缺乏模块层级的注释，即对于某个模块（module）究竟需要传入哪些参数/物理量/性质，传出哪些参数/物理量/性质，是尚未总结和落实到文档中的方面。 1.3.2 上游-下游函数注释 另一方面，除去 vscode 自身所包含的“查找所有引用”/“转到引用”的功能外，鼓励为函数添加注释时，添加 @note 字段，注明引用该函数的下游函数，即：考虑到通过 vscode“查看定义”，以及函数本身的调用方式可以方便查找到当前函数的上游函数，但在上游函数却较为困难获知被何下游函数调用。 注释下游函数有利于局部重构工作的开展。 2. 单元测试 大型程序包含数量众多的函数，对 C++ 等支持 OOP 的语言来说，也包含更多的类等。保障程序中各函数的顺利和正确执行，是保障程序整体能够运行的基础。对于数值计算软件来说，除去正常运行测试外，之后也应包括数值精度测试，这一理念的前提是开发者具有数值计算软件的编程常识，如避免小数位数丢失、DivideZeroError、相减精度丢失等数值错误，同时也将推动 ABACUS 在精度方面进行一定数量的小范围重构，符合 2023 Q2 推行的“测试驱动开发（Test Driven Development, TDD）”理念。 2.1 单元测试的设计原则 独立性：在设计和编写单元测试时，应当尽可能减少对其他部分函数的依赖，当作其他函数并未测试，因此可靠性不能保证。 高覆盖：对于程序流程控制出现分支的情况，应酌情对所有分支进行全面覆盖，以保证所有分支的函数和运算都可以正常执行。 自动：禁止出现 stdin 交互 快速：因为仅需要测试函数是否正常运行，是否可以得到预期结果，因此需要尽可能避免使用需要高时间复杂度的计算方式，而是使用尽可能简单（可以 unphysical）的数据，尽可能快地得出结果，可以考虑对预期结果进行硬编码。 2.2 对 private 变量的访问 由于当前 ABACUS 代码的封装并不完善，部分函数声明为 private 却仍然需要测试。另一方面，getter 和 setter 函数在原则上应当是从外部直接访问私有变量的唯一方式，但在使用之前也需要进行有效性测试。考虑到这两点，我们不得不尝试访问 private 或 protected 变量和成员函数。目前而言 ABACUS 中对 private 变量访问的方式主要有两种： #define private public，已知此种方式有一定情况不兼容，从而导致无法编译通过。 我们曾对访问 private 成员的方法进行过讨论，搜集到解决方案如下：https://github.com/deepmodeling/abacus-develop/issues/2666 C++ 委员会有关于几种访问私有成员的方式及其讨论：http://www.gotw.ca/gotw/076.htm 2.3 更多细节补充 ABACUS 的单元测试依靠 Googletest 框架实现。关于 Googletest 的安装、单元测试的运行、单元测试的注释规范等，见：ABACUS 测试者必知必会 。 为保证本地机器的工作不受影响，建议单元测试的编译和进行在 Bohrium 平台进行。 3. Fork and Pull request：在 ABACUS 上发布你的注释和单元测试，甚至更多！ 3.1 Fork 和 Pull request Fork 是便于进行多人协作开发的机制，其“叉子”体现在： 从待开发的软件仓库其软件的开发时间线创建时间线分支，即 Fork，到自己的仓库 在自己的仓库进行的任何改动将不会直接影响到原程序的时间线，但可以通过代码改动比较，来尽可能无冲突地将多人的改动进行合并 提交自己的改动，将自己 Fork 出的时间线和原有时间线进行合并的操作称为 Pull request (PR) 3.2 工作流示例 1 Fork ABACUS Github 仓库到自己的账号下 在自己的 ABACUS 仓库选择同步到 Github Desktop 在 Github Desktop 中选择自己的 ABACUS 仓库，之后选择在 Vscode 中打开 在 Vscode 上进行代码修改，每一次改动的保存都会同步被 Github Desktop 记录 重新编译、进行测试 在 Github Desktop 里选择左下角“Commit to develop”，然后“Push origin”将代码改动 push 到自己的 ABACUS 仓库 Github Desktop 中选择打开自己的仓库，再次审核代码改动后创建 pull request，待自动代码编译检查通过与代码人工审核 3.3 工作流示例2 Contributing to ABACUS ‒ ABACUS documentation 附：如何在飞书中平滑地分享文档 权限简介 在进行文档写作前，请确定自己账号所在的组织（如深势科技“DP”或北京科学智能研究院“AISI”）。一般而言对于创建的文档，非本人外的访问均需要文档作者进行分享，或在其他地方获得文档链接后，其阅读权限需要向作者发送权限申请。根据作者对文档的开放程度，可以分别赋予可阅读、可编辑、可管理权限，其权限自由度由低到高。 然而对于组织外，一般无文档阅读权限。 无限制访问 为了解决这一问题，可以在文档管理中按照如下方式设置： （电脑端） 打开文档，在文档右上角依次选择： （手机端） 系列链接 INPUT 读取：Introduction to ABACUS: Path to PW calculation - Part 1 STRU 读取：Introduction to ABACUS: Path to PW calculation - Part 2 赝势读取：Introduction to ABACUS: Path to PW calculation - Part 3 平面波并行与分发：Introduction to ABACUS: Path to PW calculation - Part 4 k 点并行与分发：Introduction to ABACUS: Path to PW calculation - Part 5 下篇：Introduction to ABACUS: Path to PW calculation - Part 6 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-path6.html":{"url":"develop-path6.html","title":"Introduction to ABACUS: Path to PW calculation - Part 6","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 6 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 6 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class 我们来到 ModuleESolver::ESolver_KS::Init()，在 source/module_esolver/esolver_ks.cpp: line105（link）： template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... if(GlobalV::BASIS_TYPE==\"pw\" || GlobalV::CALCULATION==\"get_wf\") { //Envelope function is calculated as lcao_in_pw //new plane wave basis #ifdef __MPI this->pw_wfc->initmpi(GlobalV::NPROC_IN_POOL, GlobalV::RANK_IN_POOL, POOL_WORLD); #endif this->pw_wfc->initgrids(inp.ref_cell_factor * ucell.lat0, ucell.latvec, this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz); this->pw_wfc->initparameters(false, inp.ecutwfc, this->kv.nks, this->kv.kvec_d.data()); #ifdef __MPI if(INPUT.pw_seed > 0) MPI_Allreduce(MPI_IN_PLACE, &this->pw_wfc->ggecut, 1, MPI_DOUBLE, MPI_MAX , MPI_COMM_WORLD); //qianrui add 2021-8-13 to make different kpar parameters can get the same results #endif this->pw_wfc->setuptransform(); for (int ik = 0; ik kv.nks; ++ik) this->kv.ngk[ik] = this->pw_wfc->npwk[ik]; this->pw_wfc->collect_local_pw(); this->print_wfcfft(inp, GlobalV::ofs_running); } PW_Basis_k::initgrids() ⚠ 注意，在 ESolver_KS 的构造函数中有 namespace ModuleESolver { template ESolver_KS::ESolver_KS() { .... pw_wfc = new ModulePW::PW_Basis_K_Big(GlobalV::device_flag, GlobalV::precision_flag); ModulePW::PW_Basis_K_Big* tmp = static_cast(pw_wfc); 因此对 pw_wfc 中成员函数的调用，和 pw_rho 类似地，此处会调用到其派生类 PW_Basis_K_Big 的对象 tmp 的成员函数。另一方面在 Introduction to ABACUS: Path to PW calculation - Part 4，我们对 PW_Basis_Big::initgrids() 在形参表中不包含 nx, ny 和 nz 的重载情况进行了介绍。当时使用 ecutrho，生成了 nx, ny, nz，bx，by，bz 及其组合，以及倒空间 fftnx, fftny 和 fftnz，然后分别将格点进行了实空间和倒空间的分发，为切片和“棍子”为分配基本单元，在 processors 间进行分发。 此处继续沿用依靠 Input::ecutrho 生成的 nx, ny 和 nz，调用包含 nx, ny 和 nz 在形参表中的 PW_Basis_K::initgrids() 函数（和 PW_Basis_Big 类不同，PW_Basis_K_Big 类并未重载 initgrids()）, template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... this->pw_wfc->initgrids(inp.ref_cell_factor * ucell.lat0, ucell.latvec, this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz); .... 以寻找适配于当前（格点数量增多后）nx, ny 和 nz 的新的 ecutwfc 球半径（PW_Basis_K::gridecut_lat）。 &#x1F914;思考时间 这样做的结果是什么？让 ecutwfc 等于 ecutrho 的操作正确吗？ 图 1. update cutoff value based on factorized nx, ny and nz nx, ny 和 nz 实空间格点数量增多的原因？→ 回顾 nx, ny 和 nz 的生成方式：在给定 ecutwfc 球半径后（通过 ecutrho），在可以分辨每个倒空间中点的情况下所确定出的最小格点数量。之后在给定的 ecutwfc 球中分别寻找可能达到的最大的 x/y/z 格点数，作为 nx, ny 和 nz，然后进行(2, 3, 5)-factorization，此处从 \\Delta l_i=\\frac{\\sqrt{\\text{ecut}}}{n_i^\\text{min}}\\le|\\mathbf{b}_i|→n_i^\\text{min}\\ge\\frac{\\sqrt{\\text{ecut}}}{|\\mathbf{b}_i|}→n_i↑, \\Delta l_i↓ 关系出发正向搜索，会使得 nx, ny 和 nz 增大。 void PW_Basis::initgrids( const double lat0_in, const ModuleBase::Matrix3 latvec_in, // Unitcell lattice vectors const int nx_in, int ny_in, int nz_in ) { this->lat0 = lat0_in; this->tpiba = ModuleBase::TWO_PI / this->lat0; this->tpiba2 = this->tpiba*this->tpiba; this->latvec = latvec_in; this->omega = std::abs(latvec.Det()) * lat0 * lat0 * lat0; this->GT = latvec.Inverse(); this->G = GT.Transpose(); this->nx = nx_in; this->ny = ny_in; this->nz = nz_in; this->nxy = this->nx * this->ny; this->nxyz = this->nxy * this->nz; int *ibox = new int[3]; ibox[0] = int((this->nx-1)/2)+1; ibox[1] = int((this->ny-1)/2)+1; ibox[2] = int((this->nz-1)/2)+1; this->gridecut_lat = 1e20; int count = 0; for(int igz = -ibox[2]; igz poolnproc != this->poolrank) continue; /* distribute this task over all processors */ if(std::abs(igx) f; f.x = igx; f.y = igy; f.z = igz; double modulus = f * (this->GGT * f); /* if the surface vector has norm shorter than radius of present Bloch sphere, shrink the sphere */ if(modulus gridecut_lat) { this->gridecut_lat = modulus; } } } } #ifdef __MPI MPI_Allreduce(MPI_IN_PLACE, &this->gridecut_lat, 1, MPI_DOUBLE, MPI_MIN , this->pool_world); #endif this->gridecut_lat -= 1e-6; delete[] ibox; return; } 注意，在第 32 行，对该任务进行了分发，使用 MPI 函数 MPI_Allreduce() 以 MPI_MIN 对不同 processor 进行归并，得到其中最小的 this->gridecut_lat，之后共享给所有 processors。 PW_Basis_K::initparameters() 之后使用 PW_Basis_K::initparameters() 函数读取经过 k 点生成、归并、分发后读取的 kvec_c 与 kvec_d、nks 等参数。这三个两存储在 ESolver_FP 对象的 K_Vectors kv 数据成员中： template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... if(GlobalV::BASIS_TYPE==\"pw\" || GlobalV::CALCULATION==\"get_wf\") { .... this->pw_wfc->initparameters(false, inp.ecutwfc, this->kv.nks, this->kv.kvec_d.data()); .... 使得 pw_wfc 以下数值更新（initparameters()函数链接->link）： 属于 PW_Basis_k pw_wfc 的成员变量 取值 意义 this->nks ESolver_FP::K_Vectors::nks 当前 processor 所分得 k 点数量 this->kvec_c ESolver_FP::K_Vectors::kvec_c 采样的 k 点的 Cartesian 坐标 this->kvec_d ESolver_FP::K_Vectors::kvec_d 采样的 k 点的 Direct 坐标 this->gk_ecut (\\sqrt{\\text{this->ggecut}}-|\\mathbf{k}|)^2 min((sqrt(Input::ecutrho)-\\k\\max)^2, Input::ecutwfc) this->ggecut \\min(\\text{Input::ecutrho},(\\sqrt{\\text{Input::ecutwfc}}+|\\mathbf{k}|)^2) 由Input::ecutrho决定nx/ny/nz决定this->gridecut_lat，以及直接的Input::ecutwfc叠加k点后的最大平面波能量，两者其中小值 this->gamma_only false 仅 gamma 点 this->xprime true 是否 x 优先 FFT 变换 this->fftnx, this->fftny, this->fftnz, this->fftnxy, this->fftnxyz, this->nx, this->ny, this->nz, this->fftnx*this->fftny, this->fftnz*this->fftnxy, 倒空间格点数量 this->distribution_type 1 倒空间格点分发方式，默认 1 this->d_kvec_c ESolver_FP::K_Vectors::kvec_d.data() kvec_c 的指针 （for words in red）因此在 ABACUS 当前的实现中，只取更大的 ecutwfc 并不会带来波函数精度的提升，因为 ggecut 同时还受到 ecutrho 的限制：在所有采样的 k 点\\mathbf{k}中，不允许存在用于展开波函数的某平面波基其|\\mathbf{G+k}|超过电荷密度中用于展开的平面波的|\\mathbf{G}|。 之后跨 processors 对 this->ggecut 进行归并，所有 processors 均取跨 processors 中 this->ggecut 最高的那个值。 #ifdef __MPI if(INPUT.pw_seed > 0) MPI_Allreduce(MPI_IN_PLACE, &this->pw_wfc->ggecut, 1, MPI_DOUBLE, MPI_MAX , MPI_COMM_WORLD); //qianrui add 2021-8-13 to make different kpar parameters can get the same results #endif 格点分发 pw_wfc 和 pw_rho 格点分发的相同与不同：PW_Basis_K::setuptransform() 和 PW_Basis::setuptransform() 完全相同，或说 ESolver_KS::pw_wfc 和 ESolver_FP::pw_rho 完全相同地，此处按照实空间进行格点分发，以及平面波所对应的倒空间进行倒空间格点分发。仍然实际调用其派生类 *_Big::distrbute_r()，但 PW_Basis_K_Big 没有重载 initgrids() 函数。可以预见，如果 ecutwfc 取得足够大，则实际上波函数的倒空间分发和电荷密度的完全相同。另外和 ESolver_FP::pw_rho 所不同的是 PW_Basis_K::setuptransform() 多出来一个 PW_Basis_K::setupIndGk() 函数： void PW_Basis::setuptransform() { ModuleBase::timer::tick(this->classname, \"setuptransform\"); this->distribute_r(); this->distribute_g(); this->getstartgr(); this->ft.clear(); if(this->xprime) this->ft.initfft(this->nx,this->ny,this->nz,this->lix,this->rix,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); else this->ft.initfft(this->nx,this->ny,this->nz,this->liy,this->riy,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); this->ft.setupFFT(); ModuleBase::timer::tick(this->classname, \"setuptransform\"); } void PW_Basis_K::setuptransform() { ModuleBase::timer::tick(this->classname, \"setuptransform\"); this->distribute_r(); this->distribute_g(); this->getstartgr(); this->setupIndGk(); this->ft.clear(); if(this->xprime) this->ft.initfft(this->nx,this->ny,this->nz,this->lix,this->rix,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); else this->ft.initfft(this->nx,this->ny,this->nz,this->liy,this->riy,this->nst,this->nplane,this->poolnproc,this->gamma_only, this->xprime); this->ft.setupFFT(); ModuleBase::timer::tick(this->classname, \"setuptransform\"); } PW_Basis_K::setupIndGk() PW_Basis_K::setupIndGk() 函数首先计算每个 k 点具有的平面波数量（因为有些 k 点的 k 向量加上平面波向量 G 之后可能会超出截断半径，因此不同 k 点的平面波数量可能会有小的差别），之后赋值给 this->npwk（实际上 this->npwk 是一维数组，具有 this->nks 的长度，而 this->nks 实际上是分发后 k 点数量，即实际上可能每个 processor 被分配到不止一个 k 点），并且在扫描当前 processor 所有的平面波时，同时计算跨 k 点的当前 processor 具有最大平面波数量，存储在 this->npwk_max 中。 在扫描平面波过程中所调用的 PW_Basis_K::cal_GplusK_cartesian() 函数则不外乎之前提到的实现在（ip, is, iz）到（x, y, z）之间的映射关系，此处反而是更加简单的情况：从 processor 所分配的某个平面波 ig，映射到其模长，实现如下： ModuleBase::Vector3 PW_Basis_K:: cal_GplusK_cartesian(const int ik, const int ig) const { int isz = this->ig2isz[ig]; int iz = isz % this->nz; int is = isz / this->nz; int ix = this->is2fftixy[is] / this->fftny; int iy = this->is2fftixy[is] % this->fftny; if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; ModuleBase::Vector3 f; f.x = ix; f.y = iy; f.z = iz; f = f * this->G; ModuleBase::Vector3 g_temp_ = this->kvec_c[ik] + f; return g_temp_; } 上述代码中 f=f*this->G 操作实现了平面波的坐标从 Direct 到 Cartesian 的转换。即 PW_Basis_K::cal_GplusK_cartesian() 函数实现从第 ik 个 k 点，第 ig 个平面波到其向量和的计算。当 ecutwfc 给定较小时，取平面波其对应倒空间矢量模长小于等于 ecutwfc 所对应矢量（但按照 ggecut 进行平面波的分发）： &#x1F914;思考时间 如果 ecutwfc != ggecut 会怎样？是否会有内存空间的浪费？ 平面波“棍子”分发时的能量比较： void PW_Basis::count_pw_st( int* st_length2D, // the number of planewaves that belong to the stick located on (x, y). int* st_bottom2D // the z-coordinate of the bottom of stick on (x, y). ) { .... int length = 0; // number of planewave on stick (x, y). for (int iz = iz_start; iz GGT * f); if (modulus ggecut || this->full_pw) { if (length == 0) st_bottom2D[index] = iz; // length == 0 means this point is the bottom of stick (x, y). ++this->npwtot; ++length; if(iy riy) this->riy = iy; if(iy > this->liy) this->liy = iy; if(ix rix) this->rix = ix; if(ix > this->lix) this->lix = ix; } } if (length > 0) { st_length2D[index] = length; ++this->nstot; } .... } processor 上平面波计数： void PW_Basis_K::setupIndGk() { .... this->npwk_max = 0; delete[] this->npwk; this->npwk = new int [this->nks]; for (int ik = 0; ik nks; ik++) { int ng = 0; for (int ig = 0; ig npw ; ig++) { const double gk2 = this->cal_GplusK_cartesian(ik, ig).norm2(); if (gk2 gk_ecut) ++ng; // this->gk_ecut may be equilvalent with ecutwfc } this->npwk[ik] = ng; .... if ( this->npwk_max npwk_max = ng; } .... 而作为回溯，this->npw 和 this->nks 分别在倒空间格点的分发阶段 PW_Basis::distribution_method1()（该函数 PW_Basis_K 直接从 PW_Basis 继承）和 PW_Basis_K::initparameters() 被赋值，赋值来源分别是 npw_per[this->poolrank]、st_length 和 ESolver_KS::K_Vectors::nks，后者来源于 K_Vectors::mpi_k() 函数。 接下来建立两映射表： //get igl2isz_k and igl2ig_k if(this->npwk_max igl2isz_k = new int [this->nks * this->npwk_max]; delete[] igl2ig_k; this->igl2ig_k = new int [this->nks * this->npwk_max]; for (int ik = 0; ik nks; ik++) { int igl = 0; for (int ig = 0; ig npw ; ig++) { const double gk2 = this->cal_GplusK_cartesian(ik, ig).norm2(); if (gk2 gk_ecut) { this->igl2isz_k[ik*npwk_max + igl] = this->ig2isz[ig]; this->igl2ig_k[ik*npwk_max + igl] = ig; ++igl; } } } .... return; } 由于此处的命名过于抽象，我们可以直接添加注释在头文件，之后提交 PR： class PW_Basis_K : public PW_Basis { public: .... /// @brief flattened, sparse 2d matrix whose row index runs over planewaves distributed on present processor and column index for kpoint (distributed on present processor, also), the matrix element value is PW_Basis::isz. isz is flattened index of (is, iz), where the is, is index of stick on present processor and iz is z index of FFT grid. \"Sparse\" means not every kpoint has as many as npwk_max planewaves, but the unflattened 2D matrix has dimension of npwk_max*nks, which means there will be empty elements (unreasonable isz value). igl is index of g-vector (equilvalent with planewave) local, the \"local\" means every kpoint. int *igl2isz_k=nullptr; .... /// @brief flattened, sparse 2d matrix established in the same way as this->igl2isz_k, mapping from (igl,ik) to ig, ig is index of planewave in present processor, for more info., see comment of this->igl2isz_k. int *igl2ig_k=nullptr; 而 this->igl2isz_k 这一矩阵的使用在紧接着的 PW_Basis_K::collect_local_pw() 中即将展现。 之后反向更新 ESolver_KS::K_Vectors::ngk 中值： template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... for (int ik = 0; ik kv.nks; ++ik) { this->kv.ngk[ik] = this->pw_wfc->npwk[ik]; } .... 后处理 PW_Basis_K::collect_local_pw() 展现了 this->igl2isz_k 如此抽象的 mapping 的使用方法（此处计算平面波的 Cartesian 坐标，即以 0 点为中心的截断半径内的平面波的坐标）： void PW_Basis_K::collect_local_pw() { if(this->npwk_max gk2 = new double[this->npwk_max * this->nks]; this->gcar = new ModuleBase::Vector3[this->npwk_max * this->nks]; .... ModuleBase::Vector3 f; for(int ik = 0 ; ik nks ; ++ik) { ModuleBase::Vector3 kv = this->kvec_d[ik]; for(int igl = 0 ; igl npwk[ik] ; ++igl) { int isz = this->igl2isz_k[ik * npwk_max + igl]; int iz = isz % this->nz; int is = isz / this->nz; int ixy = this->is2fftixy[is]; int ix = ixy / this->fftny; int iy = ixy % this->fftny; if (ix >= int(this->nx/2) + 1) ix -= this->nx; if (iy >= int(this->ny/2) + 1) iy -= this->ny; if (iz >= int(this->nz/2) + 1) iz -= this->nz; f.x = ix; f.y = iy; f.z = iz; this->gk2[ik * npwk_max + igl] = (f+kv) * (this->GGT * (f+kv)); this->gcar[ik * npwk_max + igl] = f * this->G; } } .... this->d_gcar = reinterpret_cast(&this->gcar[0][0]); this->d_gk2 = this->gk2; .... } 的确，尽管我们以稀疏方式存储满足模长小于等于 Input::ecutwfc 的平面波的 isz，也不用担心访问到空元素：this->npwk 数组的存在，标定了究竟对于每一个存储在当前 processor 上的 k 点，有多少个平面波，且此时 this->npwk 里“平面波数量”已经是 ig 和 ik correlate 的结果：他们必须使得平面波模长小于等于 Input::ecutwfc。因此循环 k 点索引即可得到平面波数量，进而根据平面波数量可以获得局部平面波索引 igl，之后使用 igl 与 ik 访问刚刚建立的映射表 this->igl2isz_k，得到 isz，然后使用 isz 和 is、iz 的关系得到后两者，is 传入 this->is2fftixy 映射表，得到平面波的倒空间 Direct 坐标。 经过|\\mathbf{G+k}|以及坐标变换，得到 this->gk2 和 this->gcar，并且使用指针（this->d_gcar、this->d_gk2）指向两者。 至此，我们比起 ESolver_FP::pw_rho 的倒空间分发，多知道了和 k 点相关的众多属性：因波函数本身的平移对称性决定了其和 k 点的相关性，因而 k 点必然参与在内。 GlobalC::Parallel_Grid::init() template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... GlobalC::Pgrid.init(this->pw_rho->nx, this->pw_rho->ny, this->pw_rho->nz, this->pw_rho->nplane, this->pw_rho->nrxx, pw_big->nbz, pw_big->bz); // mohan add 2010-07-22, update 2011-05-04 .... Parallel_Grid::init() 函数将 PW_Basis pw_rho 的实空间格点数据存储到 Parallel_Grid 类中，并且根据 KPAR 用户设置参数，使得\\mathbf{k}点的分发策略同时适用于实空间格点。 void Parallel_Grid::init(const int &ncx_in, const int &ncy_in, const int &ncz_in, const int &nczp_in, const int &nrxx_in, const int &nbz_in, const int &bz_in) { .... const int remain_pro = nprocgroup%GlobalV::KPAR; for(int i=0; inproc_in_pool[i]++; } this->numz = new int*[GlobalV::KPAR]; this->startz = new int*[GlobalV::KPAR]; this->whichpro = new int*[GlobalV::KPAR]; for(int ip=0; ipnumz[ip] = new int[nproc]; this->startz[ip] = new int[nproc]; this->whichpro[ip] = new int[this->ncz]; ModuleBase::GlobalFunc::ZEROS(this->numz[ip], nproc); ModuleBase::GlobalFunc::ZEROS(this->startz[ip], nproc); ModuleBase::GlobalFunc::ZEROS(this->whichpro[ip], this->ncz); } this->allocate = true; this->z_distribution(); .... } void Parallel_Grid::z_distribution(void) { assert(allocate); int* startp = new int[GlobalV::KPAR]; startp[0] = 0; for(int ipool=0; ipool0) startp[ipool] = startp[ipool-1] + nproc_in_pool[ipool-1]; for(int iz=0; iz=startz[ipool][nproc-1]) { whichpro[ipool][iz] = startp[ipool] + nproc-1; break; } else if(iz>=startz[ipool][proc] && iz PW_Basis_K::setupIndGk() 已经将分发后 k 点和平面波基函数（倒空间格点）相互耦合，最终获得的 processor-specific igl2isz_k 可以实现\\mathbf{k}和\\mathbf{G}的合并存储，即相当于实现了\\mathbf{k}和\\mathbf{G}的一并分发。 我们之前使用 pw_rho 的 PW_Basis::initgrids() 函数对用于电荷密度\\rho的实空间格点数量进行过初始化，也指定了分发策略。也为继承自 ESolver_FP 类的 ModulePW::PW_Basis_Big 类对象 pw_big 数据成员 bx, by, bz, nbx, nby 和 nbz： namespace ModuleESolver { class ESolver_FP : public ESolver { public: .... ModulePW::PW_Basis_Big* pw_big; /// ESolver_FP::ESolver_FP() { pw_rho = new ModulePW::PW_Basis_Big(GlobalV::device_flag, GlobalV::precision_flag); pw_big = static_cast(pw_rho); pw_big->setbxyz(INPUT.bx, INPUT.by, INPUT.bz); .... } Parallel_Grid::init() 调用 Parallel_Grid::z_distribution() 实现具体的分发过程，具体确定了以下三个列表的值： 变量 Dimension 意义 this->numz N(groups)*N(proc_in_group), N(groups)由 GlobalV::KPAR 决定，即该二维索引实际上是一维索引（rank of processor）的展开 存储每个组中每个 processor 所分得 xy 平面的个数。在 Parallel_Grid::z_distribution() 具体实现中，每次为一个 processor 分配一个 bz，即 big grid contained xyplanes，一共分配 nbz 个 xyplane this->startz N(groups)*N(proc_in_group) 每个组中每个 processor 分得的 xy 平面中最小 z 坐标 this->whichpro N(groups)*N(xyplane) 每个组所分得平面归属于哪个 processor ⚙ 在阅读 Parallel_Grid::init() 时还会发现另一个 Parallel_Grid::init_final_scf() 函数，其和 Parallel_Grid::init() 具有高度的相似性。 结构因子计算：ModuleESolver::ESolver_FP::Structure_Factor::setup_structure_factor() template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... // Calculate Structure factor this->sf.setup_structure_factor(&GlobalC::ucell, this->pw_rho); 固体物理中结构因子S(\\mathbf{G})以 atom type-by-atom type 定义为 S_\\alpha(\\mathbf{G})=\\sum_{\\mathbf{G}}{\\sum_{i}^{N_{\\alpha}}{e^{-i\\mathbf{G}\\cdot\\mathbf{\\tau}_{\\alpha,i}}}} 其中\\mathbf{G}为当前晶格所允许的倒空间矢量，即\\mathbf{G}=\\sum_{i}^3{m_i\\mathbf{b}_i}, m_i\\in Z, \\alpha为当前原子种类，i为当前盒子内\\alpha类型原子的索引，N_\\alpha为该种类原子数量。其会出现在任何涉及原子性质加和得到倒空间相应量的过程中： V(\\mathbf{G})=\\int{d\\mathbf{r} e^{i\\mathbf{G}\\cdot\\mathbf{r}} \\sum_{\\mathbf{T}}{ \\sum_{\\alpha}^{N}{ \\sum_{i}^{n^\\alpha} {V^{\\alpha}(\\mathbf{r}-\\mathbf{\\tau}_{\\alpha i}-\\mathbf{T})} } } } =\\sum_\\alpha{V^\\alpha(\\mathbf{G})S^\\alpha(\\mathbf{G})} void Structure_Factor::setup_structure_factor(UnitCell* Ucell, const ModulePW::PW_Basis* rho_basis) { .... const std::complex ci_tpi = ModuleBase::NEG_IMAG_UNIT * ModuleBase::TWO_PI; this->strucFac.create(Ucell->ntype, rho_basis->npw); // itype, iG-vector table .... bool usebspline; if(nbspline > 0) usebspline = true; else usebspline = false; 我们首先考虑不加 b 样条的情况： if(usebspline){....} else { for (int it=0; itntype; it++) /* runs over all atomtypes */ { const int na = Ucell->atoms[it].na; const ModuleBase::Vector3 * const tau = Ucell->atoms[it].tau; ....//parallelization with openmp is omitted in this line for (int ig=0; ignpw; ig++) /* runs over G-vectors */ { const ModuleBase::Vector3 gcar_ig = rho_basis->gcar[ig]; std::complex sum_phase = ModuleBase::ZERO; for (int ia=0; iastrucFac(it,ig) = sum_phase; } } } 注意，来自于形参表的 rho_basis->npw 决定了具体结构因子的倒空间波矢\\mathbf{G}具体取值（取值直接来自 rho_basis->gcar，实际即 pw_rho->gcar，由 INPUT.ecutrho 确定）。然后计算了e^{i\\mathbf{G}\\cdot\\mathbf{\\tau}_{\\alpha i}}在实空间格点上的 map： void Structure_Factor::setup_structure_factor(UnitCell* Ucell, const ModulePW::PW_Basis* rho_basis) { .... int i,j; //ng; this->eigts1.create(Ucell->nat, 2*rho_basis->nx + 1); this->eigts2.create(Ucell->nat, 2*rho_basis->ny + 1); this->eigts3.create(Ucell->nat, 2*rho_basis->nz + 1); .... ModuleBase::Vector3 gtau; int inat = 0; for (i = 0; i ntype; i++) { .... for (j = 0; j atoms[i].na;j++) { gtau = Ucell->G * Ucell->atoms[i].tau[j]; for (int n1 = -rho_basis->nx; n1 nx;n1++) { double arg = n1 * gtau.x; this->eigts1(inat, n1 + rho_basis->nx) = ModuleBase::libm::exp( ci_tpi*arg ); } for (int n2 = -rho_basis->ny; n2 ny;n2++) { double arg = n2 * gtau.y; this->eigts2(inat, n2 + rho_basis->ny) = ModuleBase::libm::exp( ci_tpi*arg ); } for (int n3 = -rho_basis->nz; n3 nz;n3++) { double arg = n3 * gtau.z; this->eigts3(inat, n3 + rho_basis->nz) = ModuleBase::libm::exp( ci_tpi*arg ); } inat++; } } this->z_eigts1 = this->eigts1.c; this->z_eigts2 = this->eigts2.c; this->z_eigts3 = this->eigts3.c; } 经过 Structure_Factor::setup_structure_factor() 函数，计算好的以[原子种类，G-vectors（从 pw_rho）]2D 数组存储结构因子被存储在 ESolver_KS::Structure_Factor::strucFac 中，属于 ESolver_KS 类（当前）对象 p_esolver 的 Structure_Factor 类对象为 sf。同理，还存储了 p_esolver->sf.eigts1, 2 和 3，以及 p_esolver->sf.z_eigts1, 2, 3。this->eigts1, 2, 3 按照如下方式取值： \\text{eigts}_1[i]=e^{i2\\pi(n_1\\mathbf{b}_1)\\cdot\\mathbf{\\tau}_i}, Ucell->G 所存储的是 G 矩阵，其中是倒空间 3 个基矢量，而n_1\\mathbf{b}_1\\equiv\\mathbf{G}_1，因此仍然有 \\text{eigts}_1[i]=e^{i\\mathbf{G}_1[i]\\cdot\\mathbf{\\tau}_i}。 即 this->eigts(i), i=1,2,3 中所存储的是由 INPUT.ecutrho 所确定的球形区域中每个倒空间格点对每个原子的结构因子，或相位项。 电荷外推初始化：Charge_Extra::Init_CE() template void ESolver_KS::Init(Input& inp, UnitCell& ucell) { .... // Initialize charge extrapolation CE.Init_CE(GlobalC::ucell.nat); } 基本原理 在分子动力学（Molecular dynamics, MD）模拟，或 Born-Oppenheimer MD（BOMD）过程中，由于每步进行完整 SCF 成本较高，使用一定的电荷外推方法，用于构造 Hamiltonian 算符可以节约大部分时间。原本的电荷外推方法原理为： \\rho \\left( t+\\Delta t \\right) =\\rho \\left( t \\right) +\\alpha \\left[ \\rho \\left( t \\right) -\\rho \\left( t-\\Delta t \\right) \\right] +\\beta \\left[ \\rho \\left( t-\\Delta t \\right) -\\rho \\left( t-2\\Delta t \\right) \\right] 波函数其实也按照此方法进行外推，但需要注意波函数能级在 MD 过程中两步间可能发生交换，因此需要额外保证最小化\\min\\sum_{\\text{n}\\mathbf{k}}||\\Psi _{\\mathrm{n}\\mathbf{k}}\\left( t \\right) -\\Psi _{\\mathrm{n}\\mathbf{k}}\\left( t-\\Delta t \\right) ||。 \\alpha和\\beta的确定方法为使得\\sum_i^N{||\\mathbf{r}_{i}^{\\prime}-\\mathbf{r}_i\\left( t+dt \\right) ||^2}最小化，其中 \\mathbf{r}_{i}^{\\prime}\\equiv \\mathbf{r}_i\\left( t \\right) +\\alpha \\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-\\Delta t \\right) \\right] +\\beta \\left[ \\mathbf{r}_i\\left( t-\\Delta t \\right) -\\mathbf{r}_i\\left( t-2\\Delta t \\right) \\right] 。由此可有： \\alpha =\\frac{b_1a_{22}-b_2a_{12}}{\\det A}, \\beta =\\frac{b_2a_{11}-b_2a_{21}}{\\det A} A 矩阵的矩阵元a_{ij}定义为： \\begin{cases} a_{11}=\\sum_i^N{|\\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-\\Delta t \\right) |^2}\\\\ a_{12}=a_{21}=\\sum_i^N{\\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-\\Delta t \\right) \\right] \\cdot \\left[ \\mathbf{r}_i\\left( t-\\Delta t \\right) -\\mathbf{r}_i\\left( t-2\\Delta t \\right) \\right]}\\\\ a_{22}=\\sum_i^N{|\\mathbf{r}_i\\left( t-\\Delta t \\right) -\\mathbf{r}_i\\left( t-2\\Delta t \\right) |^2}\\\\ \\end{cases} B 矢量的定义为： \\begin{cases} b_1=-\\sum_i^N{\\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t+\\Delta t \\right) \\right] \\cdot \\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-\\Delta t \\right) \\right]}\\\\ b_2=-\\sum_i^N{\\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t+\\Delta t \\right) \\right] \\cdot \\left[ \\mathbf{r}_i\\left( t \\right) -\\mathbf{r}_i\\left( t-2\\Delta t \\right) \\right]}\\\\ \\end{cases} 。1999 年，Dario Alfe 提出了新的电荷外推方式，将电荷分割为原子贡献部分和 delta 项： \\rho \\left( t \\right) =\\rho _{\\mathrm{at}}\\left( t \\right) +\\delta \\rho \\left( t \\right) 。采用相同的外推模式，但只外推\\delta\\rho(t)，\\rho_\\text{at}(t+\\Delta t)的值可以迅速在实空间求得： \\delta \\rho \\left( t+\\Delta t \\right) =\\delta \\rho \\left( t \\right) +\\alpha \\left[ \\delta \\rho \\left( t \\right) -\\delta \\rho \\left( t-\\Delta t \\right) \\right] +\\beta \\left[ \\delta \\rho \\left( t-\\Delta t \\right) -\\delta \\rho \\left( t-2\\Delta t \\right) \\right] ， \\rho \\left( t+\\Delta t \\right) =\\rho _{\\mathrm{at}}\\left( t+\\Delta t \\right) +\\delta \\rho \\left( t+\\Delta t \\right) 。另一种实现 BOMD 的方法为 CPMD，即通过给予电子相较于离子极小的质量，导致电子和离子的振动耦合尽可能小，从而使用经典的 MD 方法可以进行 BOMD。但由于计算机算力的更新迭代与应用场景更高的精度要求，目前 CPMD 已经逐渐退出历史舞台。 &#x1F914;思考时间 电荷外推的“旧”方法和 D. Alfe 提出的新方法根本区别在哪里？从物理图像层面考虑看看！ 代码细节 void Charge_Extra::Init_CE(const int& natom) { if(GlobalV::chg_extrap == \"none\") pot_order = 0; else if(GlobalV::chg_extrap == \"atomic\") pot_order = 1; else if(GlobalV::chg_extrap == \"first-order\") pot_order = 2; else if(GlobalV::chg_extrap == \"second-order\") pot_order = 3; else { ModuleBase::WARNING_QUIT(\"Charge_Extra\",\"charge extrapolation method is not available !\"); } if(pot_order == 3) { dis_old1 = new ModuleBase::Vector3[natom]; dis_old2 = new ModuleBase::Vector3[natom]; dis_now = new ModuleBase::Vector3[natom]; } alpha = 1.0; beta = 0.0; } 关于该类的其他函数请自行阅读。关于 GlobalV::chg_extrap： //input_conv.cpp GlobalV::chg_extrap = INPUT.chg_extrap; //input.cpp void Input::Default(void) { .... chg_extrap = \"atomic\"; // xiaohui modify 2015-02-01 .... } bool Input::Read(const std::string &fn) { .... while (ifs.good()) { .... else if (strcmp(\"chg_extrap\", word) == 0) // xiaohui modify 2015-02-01 { read_value(ifs, chg_extrap); // xiaohui modify 2015-02-01 } .... } .... } void Input::Default_2(void) { .... else if (calculation == \"get_pchg\") { .... chg_extrap = \"atomic\"; // xiaohui modify 2015-02-01 .... } else if (calculation == \"get_wf\") { .... chg_extrap = \"atomic\"; // xiaohui modify 2015-02-01 .... } .... } void Input::Check() { .... if (chg_extrap == \"dm\" && basis_type == \"pw\") // xiaohui add 2013-09-01, xiaohui modify 2015-02-01 { ModuleBase::WARNING_QUIT( \"Input\", \"wrong 'chg_extrap=dm' is only available for local orbitals.\"); // xiaohui modify 2015-02-01 } .... } 下篇我们将回到再上一层函数，ESolver_KS_PW::Init() 中去。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Summary 1 下篇：Introduction to ABACUS: Path to PW calculation - Part 7 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-path7.html":{"url":"develop-path7.html","title":"Introduction to ABACUS: Path to PW calculation - Part 7","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 7 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 7 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class 终于来到和原本 p_esolver 相同的类的成员函数 Init()： template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { ESolver_KS::Init(inp, ucell); // phsol == nullptr) { this->phsol = new hsolver::HSolverPW(this->pw_wfc, &this->wf); } // Initialize ElecState if (this->pelec == nullptr) { this->pelec = new elecstate::ElecStatePW(this->pw_wfc, &(this->chr), &(this->kv), this->pw_rho, this->pw_big); } // Initialize the charge density this->pelec->charge->allocate(GlobalV::NSPIN); this->pelec->omega = GlobalC::ucell.omega; // Initialize the potential if (this->pelec->pot == nullptr) { this->pelec->pot = new elecstate::Potential(this->pw_rho, &GlobalC::ucell, &(GlobalC::ppcell.vloc), &(this->sf), &(this->pelec->f_en.etxc), &(this->pelec->f_en.vtxc)); } this->Init_GlobalC(inp, ucell); if (GlobalV::ocp) this->pelec->fixed_weights(GlobalV::ocp_kb); } Initialization of HSolverPW object Constructor 首先来到按照注释划分的第一部分“Initialize HSolver”（line 6，HSolver 就是求解体系哈密顿量的求解器）： template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { ESolver_KS::Init(inp, ucell); // Initialize HSolver if (this->phsol == nullptr) { this->phsol = new hsolver::HSolverPW(this->pw_wfc, &this->wf); } 其实 phsol（此处命名逻辑为 p 代表 Pointer，hsol 为 HSolver 的缩写）并非是 ESolver_KS_PW 类中数据成员，而是在 ESolver_KS 中，这意味着 ESolver_KS 的派生类均有可能使用这一数据成员。稍加搜索，发现 ESolver_KS_LCAO::Init() 中也有类似操作： void ESolver_KS_LCAO::Init(Input& inp, UnitCell& ucell) { .... // init HSolver if (this->phsol == nullptr) { this->phsol = new hsolver::HSolverLCAO(this->LOWF.ParaV); this->phsol->method = GlobalV::KS_SOLVER; } 另一点可以预料的是，在基类 ESolver_KS 的声明中，phsol 起始被声明为基类 HSolver 类对象，而非直接地 HSolverPW 这一派生类对象，这一操作再次体现了 C++ 的多态编程思路。具体在当前 Init 函数中，phsol 被分配内存时调用的 HSolverPW 类构造函数，其形参表中，pw_wfc 是属于 PW_Basis_K（以及其派生类 PW_Basis_K_Big）类对象，继承自 ESolver_KS。wf 是 wavefunc 类对象，也继承自 ESolver_KS，这体现了仅对于 ESolver_KS 层级而言需要带有 k 点的平面波波函数，以及波函数的存储类，而再上一级 ESolver_FP 则不一定需要这两者。平行而言 ESolver_OF 也属于“FP”，但在 ESolver_FP 的派生类 ESolver_OF 中，丝毫没有关于平面波波函数的数据成员： 派生类 HSolverPW 的构造函数其结构十分简单： template HSolverPW::HSolverPW(ModulePW::PW_Basis_K* wfc_basis_in, wavefunc* pwf_in) { this->classname = \"HSolverPW\"; this->wfc_basis = wfc_basis_in; this->pwf = pwf_in; this->diag_ethr = GlobalV::PW_DIAG_THR; } ，即将 ESolver_KS::pw_wfc 复制进 HSolverPW 的数据成员 wfc_basis，ESolver_KS::wf 到 HSolverPW::pwf。 Initialization of ElecState object Constructor 接下来来到 ESolver_KS_PW::Init()“第二部分”中 ElecState 类对象的初始化。 template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { .... // init ElecState, if (this->pelec == nullptr) { this->pelec = new elecstate::ElecStatePW(this->pw_wfc, &(this->chr), &(this->kv), this->pw_rho, this->pw_big); } 和 phsol 同样地，这一次 pelec 是继承自 ESolver_FP 类（因此说明 FP 不仅 KS 派生类需要电荷这一物理量），但 pelec 实际被声明为基类 ElecState 的指针，在 ESolver_KS_PW::Init() 中被分配以其派生类 ElecStatePW 的内存空间（同样地也有 ElecStateLCAO 派生类等），因此调用派生类构造函数： template ElecStatePW::ElecStatePW(ModulePW::PW_Basis_K *wfc_basis_in, Charge* chg_in, K_Vectors *pkv_in, ModulePW::PW_Basis* rhopw_in, ModulePW::PW_Basis_Big* bigpw_in) : basis(wfc_basis_in) { this->classname = \"ElecStatePW\"; this->init_ks(chg_in, pkv_in, pkv_in->nks, rhopw_in, bigpw_in); } 在该构造函数的函数体外初始化了成员变量 basis 以 ESolver_KS::pw_wfc。除了设置 ElecStatePW::classname 这一数据成员的具体值外，调用 ElecState::init_ks() 函数（显然继承自基类）。 ElecState::init_ks() void ElecState::init_ks(Charge* chg_in, // pointer for class Charge const K_Vectors* klist_in, int nk_in, ModulePW::PW_Basis* rhopw_in, const ModulePW::PW_Basis_Big* bigpw_in) { this->charge = chg_in; this->charge->set_rhopw(rhopw_in); this->klist = klist_in; this->bigpw = bigpw_in; // init nelec_spin with nelec and nupdown this->init_nelec_spin(); // autoset and check GlobalV::NBANDS, nelec_spin is used when NSPIN==2 this->cal_nbands(); // initialize ekb and wg this->ekb.create(nk_in, GlobalV::NBANDS); this->wg.create(nk_in, GlobalV::NBANDS); } Link Charge* ElecState::charge to Charge ESolver_FP::chg ⚠ 注意在 ElecState/ElecStatePW 类中的数据成员 charge 是 Charge 类指针，被赋值为 ESolver_FP 类的 Charge 类对象，即使得 ElecState 类的 Charge 类指针指向 ESolver_FP 的 chr 数据成员。 namespace ModuleESolver { class ESolver_FP : public ESolver { public: .... elecstate::ElecState* pelec = nullptr; Charge chr; ModuleSymmetry::Symmetry symm; .... K_Vectors kv; 因此 this->charge = chg_in; this->charge->set_rhopw(rhopw_in); 的意义在于由 ElecState::init_ks() 作为被包含在 ESolver_FP（或说 ESolver）对象中的 Charge 类对象 chg 和 PW_Basis 类 pw_rho 的连接。（是否冗余？） 变量 ElecState::klist、ElecState::bigpw、ElecState::rhopw 传入的实参也类似，同样来自于 ESolver_FP。 void Charge::set_rhopw(ModulePW::PW_Basis* rhopw_in) { this->rhopw = rhopw_in; } &#x1F914;在变量命名过程中应当注意避免随意 context 用于展开电荷的 PW_Basis 类指针 包含 Big FFT grid 的用于电荷展开的 PW_Basis_Big 类指针 ElecState 数据成员 bigpw ElecState::init_ks() rhopw_in bigpw_in ESolver_KS_PW::Init() pw_rho pw_big ESolver_FP 数据成员 pw_rho pw_big Charge 数据成员 rhopw Calculate numbers of electrons in different spin channels ElecState::init_nelec_spin() 函数的调用为 this->nelec_spin 赋值，其中 GlobalV::nupdown 的意义已经在（Introduction to ABACUS: Path to PW calculation - Part 2 ）介绍，为 up 和 down spin 的差值： void ElecState::init_nelec_spin() { this->nelec_spin.resize(GlobalV::NSPIN); if (GlobalV::NSPIN == 2) { // in fact, when TWO_EFERMI(nupdown in INPUT is not 0.0), nelec_spin will be fixed. this->nelec_spin[0] = (GlobalV::nelec + GlobalV::nupdown) / 2.0; this->nelec_spin[1] = (GlobalV::nelec - GlobalV::nupdown) / 2.0; } } Get number of bands to solve: ElecState::cal_nbands() ElecState::cal_nbands() 函数的调用为 GlobalV::NBANDS（需要计算的能带数量）这一全局变量赋值或对通过 INPUT 文件中 nbands 关键词进行赋值的值进行合理性检查。对于未在 INPUT 文件中进行赋值的情况，则在此函数之前仍然保持值为 0，之后的赋值策略为： void ElecState::cal_nbands() { .... if (GlobalV::LSPINORB == 1) occupied_bands = static_cast(GlobalV::nelec); /* it can only be the case of uks, but if so, the following method for calculating NBANDS will make this variable meaningless cuz never used! */ if ((occupied_bands - std::floor(occupied_bands)) > 0.0) { occupied_bands = std::floor(occupied_bands) + 1.0; // mohan fix 2012-04-16 } .... ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, \"occupied bands\", occupied_bands); if (GlobalV::NBANDS == 0) { if (GlobalV::NSPIN == 1) { const int nbands1 = static_cast(occupied_bands) + 10; const int nbands2 = static_cast(1.2 * occupied_bands) + 1; GlobalV::NBANDS = std::max(nbands1, nbands2); if (GlobalV::BASIS_TYPE != \"pw\") GlobalV::NBANDS = std::min(GlobalV::NBANDS, GlobalV::NLOCAL); } else if (GlobalV::NSPIN == 4) { const int nbands3 = GlobalV::nelec + 20; const int nbands4 = static_cast(1.2 * GlobalV::nelec) + 1; GlobalV::NBANDS = std::max(nbands3, nbands4); if (GlobalV::BASIS_TYPE != \"pw\") GlobalV::NBANDS = std::min(GlobalV::NBANDS, GlobalV::NLOCAL); } else if (GlobalV::NSPIN == 2) { /* max() is because the keyword nupdown can either be positive or negative */ const double max_occ = std::max(this->nelec_spin[0], this->nelec_spin[1]); const int nbands3 = static_cast(max_occ) + 11; const int nbands4 = static_cast(1.2 * max_occ) + 1; GlobalV::NBANDS = std::max(nbands3, nbands4); if (GlobalV::BASIS_TYPE != \"pw\") GlobalV::NBANDS = std::min(GlobalV::NBANDS, GlobalV::NLOCAL); } ModuleBase::GlobalFunc::AUTO_SET(\"NBANDS\", GlobalV::NBANDS); } &#x1F914;思考时间 Is there any differences bewteen the ways to assign default values for number of bands to calculate in ABACUS and Quantum ESPRESSO? 回溯：GlobalV::nelec 的值从 ESolver_KS::Init() 调用时确定（具体调用 UnitCell::cal_nelec()，Introduction to ABACUS: Path to PW calculation - Part 5）。 //module_base/global_variable.cpp GlobalV::NBANDS = 0; //module_io/input.cpp INPUT.nbands = 0; //module_io/input.cpp::Read() else if (strcmp(\"nbands\", word) == 0) // number of atom bands { read_value(ifs, nbands); } //module_io/input_conv.cpp GlobalV::NBANDS = INPUT.nbands; 对于赋值的情况则需要对其合理性进行检查，一方面是对使用 smearing 时候的 nbands 数量（对于能级简并度较高的情况，SCF 过程中能级的变化将引起能量的变化剧烈，因此可以通过 smearing 方法弥散最高占据能级附近的电子布居，使得能量变化剧烈程度减少。smearing 的具体参照一方面可以由独立费米子体系所遵循 Fermi-Dirac 统计借鉴而来，或直接采用 Gauss 分布。控制 smearing 的参数取值越大，电子偏离“0 温”越严重，但可以加速电子迭代的收敛。实际计算时，一般对半导体或者绝缘体、或者有 gap 的系统，可以不取 smearing，或者 smearing 不起作用；如果对金属系统，可以适当取一点 smearing 加速收敛，但太大容易引起结果不准确）： void ElecState::cal_nbands() { .... if (GlobalV::NBANDS == occupied_bands) { if (Occupy::gauss()) { ModuleBase::WARNING_QUIT(\"ElecState::cal_nbands\", \"for smearing, num. of bands > num. of occupied bands\"); } } Occupy 是在 input_conv 被调用时所赋值的对象， //module_io/input_conv.cpp line 589 Occupy::decision(INPUT.occupations, INPUT.smearing_method, INPUT.smearing_sigma); 而 Occupy::gauss() 的功能仅仅为： class Occupy { public: .... static const bool& gauss(void) {return use_gaussian_broadening;} 剩余部分： void ElecState::cal_nbands() { .... if (GlobalV::NBANDS == 0) {....} else { if (GlobalV::NBANDS nelec_spin[0]) { ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, \"nelec_up\", this->nelec_spin[0]); ModuleBase::WARNING_QUIT(\"ElecState::cal_nbands\", \"Too few spin up bands!\"); } if (GlobalV::NBANDS nelec_spin[1]) { ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, \"nelec_down\", this->nelec_spin[1]); ModuleBase::WARNING_QUIT(\"ElecState::cal_nbands\", \"Too few spin down bands!\"); } } } Others this->pelec->charge->allocate(GlobalV::NSPIN); this->pelec->omega = GlobalC::ucell.omega; 第二行将当前晶胞体积赋值给 ElecState 指针中该成员变量，第一行则为 Charge* ElecState::charge 申请内存空间： void Charge::allocate(const int& nspin_in) { ModuleBase::TITLE(\"Charge\", \"allocate\"); this->nrxx = this->rhopw->nrxx; // number of distributed real space grid points this->nxyz = this->rhopw->nxyz; // total number of real space grid points this->ngmc = this->rhopw->npw; // number of distributed planewaves if (allocate_rho == true) { this->destroy(); allocate_rho = false; } assert(allocate_rho == false); this->nspin = nspin_in; ....// standard output omitted here rho = new double*[nspin]; rhog = new std::complex*[nspin]; rho_save = new double*[nspin]; rhog_save = new std::complex*[nspin]; if (elecstate::get_xc_func_type() == 3 || elecstate::get_xc_func_type() == 5) { kin_r = new double*[nspin]; kin_r_save = new double*[nspin]; } //spin-by-spin (sbs) for (int is = 0; is [ngmc]; // charge density in reciprocal space sbs rho_save[is] = new double[nrxx]; // backup of rho rhog_save[is] = new std::complex[ngmc]; // backup of rhog ....// initialize above four arrays of present spin with zeros if (elecstate::get_xc_func_type() == 3 || elecstate::get_xc_func_type() == 5) { kin_r[is] = new double[nrxx]; kin_r_save[is] = new double[nrxx]; ....// initialize above two arrays of present spin with zeros } } .... // memory record omitted this->rho_core = new double[nrxx]; // core charge in real space this->rhog_core = new std::complex[ngmc]; // reciprocal core charge ....// initialize above two arrays of present spin with zeros .... // memory record omitted this->allocate_rho = true; } Initialization of Potential template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { .... // Initialize the potential. if (this->pelec->pot == nullptr) { this->pelec->pot = new elecstate::Potential(this->pw_rho, &GlobalC::ucell, &(GlobalC::ppcell.vloc), &(this->sf), &(this->pelec->f_en.etxc), &(this->pelec->f_en.vtxc)); } 接下来将各与势能相关变量的内存地址拉取到 ElecStatePW* ESolver_KS_PW::pelec 的指针成员 Potential* pot 下（继承自基类 ElecState），Potential 类构造函数被调用，初始化 pot 指针： namespace elecstate { Potential::Potential(const ModulePW::PW_Basis* rho_basis_in, const UnitCell* ucell_in, const ModuleBase::matrix* vloc_in, Structure_Factor* structure_factors_in, double* etxc_in, double* vtxc_in): ucell_(ucell_in), vloc_(vloc_in), structure_factors_(structure_factors_in), etxc_(etxc_in), vtxc_(vtxc_in) { this->rho_basis_ = rho_basis_in; this->fixed_mode = true; this->dynamic_mode = true; // allocate memory for Potential. this->allocate(); } 在 Potential 构造函数的形参表中，我们发现了从未出现过的 ModuleBase::matrix* GlobalC::ppcell 变量，以及 fenergy ElecState::f_en 变量，这些变量以内存地址形式存入 ElecStatePW* ESolver_KS_PW::pelec 中。对于 Potential::allocate() 函数，则不出例外地为数组申请内存空间： void Potential::allocate() { ModuleBase::TITLE(\"Potential\", \"allocate\"); int nrxx = this->rho_basis_->nrxx; if (nrxx == 0) return; this->v_effective_fixed.resize(nrxx); this->v_effective.create(GlobalV::NSPIN, nrxx); .... // memory record omitted if (elecstate::get_xc_func_type() == 3 || elecstate::get_xc_func_type() == 5) { this->vofk_effective.create(GlobalV::NSPIN, nrxx); .... // memory record omitted } if (GlobalV::device_flag == \"gpu\") {....} else { if (GlobalV::precision_flag == \"single\") {....} else { this->d_v_effective = this->v_effective.c; this->d_vofk_effective = this->vofk_effective.c; } // There's no need to allocate memory for double precision pointers while in a CPU environment } } // module_elecstate/potentials/potential_new.h class Potential : public PotBase { ....//google-style indent? private: .... std::vector v_effective_fixed; // Potential 和其基类 PotBase 拥有漂亮的类注释文档（link）： Initialization of rest parts of GlobalC GlobalC 和 GlobalV 是两个特殊的类，如第一版开发者文档所提到，此两种类的收益为避免过大的形参表，但负向收益为带来对两类中全局变量意外覆盖读写的隐患，因此在 ABACUS 的未来版本中，会逐步弃用 GlobalC 和 GlobalV，转而使用对象：利用高度且合理的封装方式，每次传入对象，对象包含各自相关的数据成员和函数。但就当前而言，GlobalC 提供了一些全局类。此处剩余的一些全局类申请内存空间、被初始化。 template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { if (this->psi != nullptr) delete this->psi; this->psi = this->wf.allocate(this->kv.nks, this->kv.ngk.data(), this->pw_wfc->npwk_max); // init pseudopotential GlobalC::ppcell.init(GlobalC::ucell.ntype, &this->sf, this->pw_wfc); // initalize local pseudopotential GlobalC::ppcell.init_vloc(GlobalC::ppcell.vloc, this->pw_rho); // Initalize non local pseudopotential GlobalC::ppcell.init_vnl(GlobalC::ucell); GlobalC::ppcell.cal_effective_D(); // create GlobalC::ppcell.tab_at , for trial wave functions. this->wf.init_at_1(&this->sf); // Initial start wave functions this->wf.wfcinit(this->psi, this->pw_wfc); // denghui added 20221116 this->kspw_psi = GlobalV::device_flag == \"gpu\" || GlobalV::precision_flag == \"single\" ? new psi::Psi, Device>(this->psi[0]) : reinterpret_cast, Device>*>(this->psi); ....//memory record omitted here } &#x1F4DD;笔者的话 这里有一个有趣的东西是 kspw_psi（在求力部分还有 __kspw_psi）。有兴趣的读者可以自行查看对于 gpu 或者单精度情况，在调用的 psi 构造函数中发生了什么。 实际上，kspw_psi 支持了异构计算，而 psi，如 esolver_fp.h 声明中，实际上只为 psi::Psi, Device = psi::DEVICE_CPU>* 类指针。因此真正计算架构-dependent 的是 kspw_psi。ESolver_KS_PW 为支持异构计算，整个类为模板类。在 psi 被分配内存空间后，为 kspw_psi 赋予了其数据的可达性（accessibility），reinterpret_cast 或者复制内容。 Psi Psi 是 ABACUS 中一类特殊的数据结构，用于存储波函数（平面波基函数系数）信息。其包含如下数据成员： namespace psi { template class Psi { public: int npol = 1; .... private: T* psi = nullptr; // avoid using C++ STL AbacusDevice_t device = {}; // track the device type (CPU, GPU and SYCL are supported currented) Device* ctx = {}; // an context identifier for obtaining the device variable // dimensions int nk = 1; // number of k points int nbands = 1; // number of bands int nbasis = 1; // number of basis mutable int current_k = 0; // current k point mutable int current_b = 0; // current band index mutable int current_nbasis = 1; // current number of basis of current_k // current pointer for getting the psi mutable T* psi_current = nullptr; // psi_current = psi + psi_bias; mutable int psi_bias = 0; const int* ngk = nullptr; bool k_first = true; .... }; } Codes 我们首先阅读为 Psi 申请内存空间的代码 psi::Psi> *wavefunc::allocate(const int nks, const int *ngk, const int npwx_in) { /* parameter list: nks: number of kpoints distributed on present processor ngk: number of planewaves on kpoints respectively on present processor npwx_in: maximal number of planewaves across all kpoints distributed on present processor */ this->npwx = npwx_in; assert(npwx > 0); assert(nks > 0); // if use spin orbital, do not double nks but double allocate evc and wanf2. int prefactor = 1; if(GlobalV::NSPIN==4) prefactor = GlobalV::NPOL;//added by zhengdy-soc const int nks2 = nks; psi::Psi>* psi_out = nullptr; ....// non-pw cases are omitted else { psi_out = new psi::Psi>(nks2, GlobalV::NBANDS, npwx * GlobalV::NPOL, ngk); ....// standard output and memory record omitted } return psi_out; } 即 wavefunc::allocate() 函数核心功能为为不同基组类型按照不同方式分配内存空间，仍然需要调用 psi 自己的构造函数。psi 的构造函数的重载共有 6 个（以及 1 个默认构造函数）： template class Psi { public: // Constructor 1: basic Psi(); // Constructor 2: specify ngk only, should call resize() later Psi(const int* ngk_in); // Constructor 3: specify nk, nbands, nbasis, ngk, and do not need to call resize() later Psi(int nk_in, int nbd_in, int nbs_in, const int* ngk_in = nullptr); // Constructor 4: copy a new Psi which have several k-points and several bands from inputted psi_in Psi(const Psi& psi_in, const int nk_in, int nband_in = 0); // Constructor 5: a wrapper of a data pointer, used for Operator::hPsi() // in this case, fix_k can not be used Psi(T* psi_pointer, const Psi& psi_in, const int nk_in, int nband_in = 0); // Constructor 6: initialize a new psi from the given psi_in Psi(const Psi& psi_in); // Constructor 7: initialize a new psi from the given psi_in with a different class template // in this case, psi_in may have a different device type. template Psi(const Psi& psi_in); 此处我们调用的是\"Constructor 3\"： template Psi::Psi(int nk_in, int nbd_in, int nbs_in, const int* ngk_in) { this->ngk = ngk_in; this->current_b = 0; this->current_k = 0; this->npol = GlobalV::NPOL; this->device = device::get_device_type(this->ctx); this->resize(nk_in, nbd_in, nbs_in); // Currently only GPU's implementation is supported for device recording! ....//device recording omitted } template void Psi::resize(const int nks_in, const int nbands_in, const int nbasis_in) { assert(nks_in > 0 && nbands_in >= 0 && nbasis_in > 0); // This function will delete the psi array first(if psi exist), then malloc a new memory for it. resize_memory_op()(this->ctx, this->psi, nks_in * nbands_in * nbasis_in, \"no_record\"); this->nk = nks_in; this->nbands = nbands_in; this->nbasis = nbasis_in; this->current_nbasis = nbasis_in; this->psi_current = this->psi; // GlobalV::ofs_device //psi.h line 130 using resize_memory_op = psi::memory::resize_memory_op; //module_psi/kernels/memory_op.h namespace psi { namespace memory { template struct resize_memory_op { void operator()(const Device* dev, FPTYPE*& arr, const size_t size, const char* record_in = nullptr); }; //module_psi/kernels/memory_op.cpp namespace psi{ namespace memory{ template struct resize_memory_op { void operator()(const psi::DEVICE_CPU* dev, FPTYPE*& arr, const size_t size, const char* record_in) { if (arr != nullptr) free(arr); arr = (FPTYPE*) malloc(sizeof(FPTYPE) * size); std::string record_string; if(record_in != nullptr) record_string = record_in; else record_string = \"no_record\"; if(record_string != \"no_record\" ) { ModuleBase::Memory::record(record_string , sizeof(FPTYPE) * size); } } }; 因此 Psi 类对象最终使用 resize_memory_op() 来为 Psi::psi 数据成员进行内存申请，用于存储波函数信息/其同样是 3d-flatten，即申请的实际上是一级指针，规模为 [ikpoint][iband][ibasis]。 Feature: struct with overloaded \"()\", extends the way of defining functions Psi 申请内存时使用了在之前介绍的 ABACUS 代码中从未出现过的方式，即创建模板类结构体，之后在其中重载括号运算符，以调用函数的方式使用重载的括号。这种方式为 C++ 结构体所独有，是固定特性，对原本的函数实现方式实现了更大范围的拓展，结合 using 关键字，可以达到模板类实例化、封装、多态等效果。 并且 resize_memory_op()(this->ctx, this->psi, nks_in * nbands_in * nbasis_in, \"no_record\"); 实际可以写为 resize_memory_op(this->ctx, this->psi, nks_in * nbands_in * nbasis_in, \"no_record\"); 和原本的函数使用方法更加相似。类似的例子还有关于 Psi 类对象其他内存空间的操作： namespace psi { template class Psi { public: .... private: .... using set_memory_op = psi::memory::set_memory_op; using delete_memory_op = psi::memory::delete_memory_op; using resize_memory_op = psi::memory::resize_memory_op; using synchronize_memory_op = psi::memory::synchronize_memory_op; }; } // end of namespace psi template struct delete_memory_op { /// @brief free memory for multi-device /// \\param dev : the type of computing device /// \\param arr : the input array void operator()(const Device* dev, FPTYPE* arr); }; template struct delete_memory_op { void operator()(const psi::DEVICE_CPU* dev, FPTYPE* arr) { free(arr); } }; template struct set_memory_op { /// @brief memset for multi-device /// \\param dev : the type of computing device /// \\param var : the specified constant value /// \\param size : array size /// Output Parameters /// \\param arr : output array initialized by the input value void operator()(const Device* dev, FPTYPE* arr, const int var, const size_t size); }; template struct set_memory_op { void operator()(const psi::DEVICE_CPU* dev, FPTYPE* arr, const int var, const size_t size) { ModuleBase::OMP_PARALLEL([&](int num_thread, int thread_id) { int beg, len; ModuleBase::BLOCK_TASK_DIST_1D(num_thread, thread_id, size, (size_t)4096/sizeof(FPTYPE), beg, len); memset(arr + beg, var, sizeof(FPTYPE)*len); }); } }; template struct synchronize_memory_op { /// @brief memcpy for multi-device /// \\param dev_out : the type of computing device of arr_out /// \\param dev_in : the type of computing device of arr_in /// \\param arr_in : input array /// \\param size : array size /// Output Parameters /// \\param arr_out : output array initialized by the input array void operator()( const Device_out* dev_out, const Device_in* dev_in, FPTYPE* arr_out, const FPTYPE* arr_in, const size_t size); }; template struct synchronize_memory_op { void operator()( const psi::DEVICE_CPU* dev_out, const psi::DEVICE_CPU* dev_in, FPTYPE* arr_out, const FPTYPE* arr_in, const size_t size) { ModuleBase::OMP_PARALLEL([&](int num_thread, int thread_id) { int beg, len; ModuleBase::BLOCK_TASK_DIST_1D(num_thread, thread_id, size, (size_t)4096/sizeof(FPTYPE), beg, len); memcpy(arr_out + beg, arr_in + beg, sizeof(FPTYPE)*len); }); } }; 这种方式实现了模板函数的偏特化（partial specialization）需求（see cppreference），即首先实例化其中一个模板参数，之后再在其他地方实例化另一个。在更新的 C++20 版本中，使用 concepts（requires, see C++20）可以达到类似效果（see cppstories）。 在 ESolver_KS_PW()::init()的最后还有如下语句： this->kspw_psi = GlobalV::device_flag == \"gpu\" || GlobalV::precision_flag == \"single\" ? new psi::Psi, Device>(this->psi[0]) : reinterpret_cast, Device>*>(this->psi); 我们不考虑 GPU 和单精度的情况，因此以上等价于： this->kspw_psi = reinterpret_cast>*>(this->psi); pseudopot_cell_vnl Before init() 我们之前没有特别关注过这个被声明在 GlobalC 里的全局类（line 278），这里我们首先非常粗略回顾其顾名思义的非局域项的原理，之后在下一篇中对该类成员函数的一些细节进行详细说明（但仍然不会逐行逐句进行“翻译”）。该类的名字 pseudopot_cell_vnl 实际上是 pseudopotential_cell_V(potential)_nonlocal 的缩写。首先简单介绍 Kleinman-Bylander 方法（Phys. Rev. Lett. 48, 1425（1982））将 pseudopotential 分为完全非局域和局域部分： \\hat{V}^{\\mathrm{KB}}=\\sum_{l=0}^{l_{max}}{\\sum_{m=-l}^{+l}{\\sum_{i=1}{|\\chi _{lm,i}\\rangle V_{li}^{KB}\\langle \\chi _{lm,i}|}}}. Therefore the fully nonlocal part of pp. has projectors of different angular momentum, magnetic quantum number and basis functions. That is to say, this projector will project one state onto some basic states at such kind of resolution. The basis of projector, is constructed in this way: > \\chi _{lm,i}\\left( \\mathbf{r} \\right) =\\langle \\mathbf{r}|\\chi _{lm,i}\\rangle =R_{l,i}\\left( r \\right) Y_{lm}\\left( \\hat{\\mathbf{r}} \\right) > It is, similar with a hydrogen wavefunction that has radial part and angular part. The angular part, is represented by spherical harmonic function, and basis function, is only used for constructing radial part of the basis of projector \\hat{V}^{KB}. However, what is V^{KB}_{li} ? How is it calculated? V_{li}^{KB}=\\langle \\varphi _{li}|\\delta V_l|\\varphi _{li}\\rangle , where \\delta V_l=V_l(r)-V^{local}(r), from semilocal pp. V_l(r) (the one may directly read from portable pp. files like *.UPF), subtract the local part from it, leaving term \\delta V_l(r), is angular momentum-resoluted, while the local part is not. Imagine \\delta V_l(r) itself has its eigenspace and for each axis there is an eigenvalue. Any state can be expanded by eigenvectors \\{|v_{li}\\rangle\\} of \\delta V_l(r)-space. Thus, |\\varphi _{li}\\rangle =\\sum_k{c_{ik}|v_{lk}\\rangle}, > \\langle \\varphi _{li}|\\delta V_l|\\varphi _{li}\\rangle =\\langle \\varphi _{li}|\\sum_j{|v_{lj}\\rangle v_{lj}\\langle v_{lj}|}\\varphi _{li}\\rangle > \\ =\\sum{k^{\\prime}}{c{ik^{\\prime}}^{\\dagger}\\langle v{lk^{\\prime}}}|\\sum_j{|v{lj}\\rangle v{lj}\\langle v{lj}|}\\sumk{c{ik}|v{lk}\\rangle} \\ =\\sum{k^{\\prime}}{\\sumk{\\sum_j{c{ik^{\\prime}}^{\\dagger}c{ik}\\langle v{lk^{\\prime}}|v{lj}\\rangle v{lj}\\langle v{lj}|v{lk}\\rangle}}} \\ =\\sum{k^{\\prime}}{\\sum_k{\\sum_j{c{ik^{\\prime}}^{\\dagger}c{ik}\\delta {k^{\\prime}j}\\delta {kj}v{lj}}}} \\ =\\sumj{c{ij}^{\\dagger}c{ij}v{lj}}=\\sumj{c{ij}^{2}v{lj}} \\ =v{l1}\\left( c{i1}^{2} \\right) +v{l2}\\left( c{i2}^{2} \\right) +... > The result above is, norm of vector/state |\\varphi{li}\\rangle in eigen-space of operator \\delta Vl. > It is the same for any other kinds of scalar product, thus Schmidt orthogonalization in any arbitrary space has a more general form. For example, states {\\varphi{li}} is \\delta V_l-space-orthogonalized version of eigenstates of V_l(r), the semilocal pp employing KS eq.: > > |\\varphi {li}\\rangle =|\\psi {li}\\rangle -\\sum{i^{\\prime}=1}^{i-1}{|\\varphi {li^{\\prime}}\\rangle \\frac{\\langle \\varphi {li^{\\prime}}|\\delta V_l|\\psi {li^{\\prime}}\\rangle}{\\langle \\varphi {li^{\\prime}}|\\delta V_l|\\varphi {li^{\\prime}}\\rangle}} > > The term V^{local} is however, somewhat arbitrary, a sphericallly symmetrical charge distribution is directly given in this paper as: > > \\rho^{local}(r)=A\\exp[-(\\frac{\\sinh(abr)}{\\sinh(br)})^2] > > Parameters aand b are arbitrary. In paper ais optimized to 1.82/r_{core}$$, b is 1. 另一方面，自 ABACUS 开始运行时便调用其构造函数的 pseudopot_cell_vnl，有如下数据成员具有初始值： 变量 默认值 意义 备注 multi_proj false 是否使用多个投影子（projector） s_deeq, d_deeq, c_deeq_nc, z_deeq_nc nullptr s_nhtol, s_nhtolm, s_indv, s_tab nullptr c_vkb nullptr Kleinman-Bylander 完全非局域赝势 d_nhtol, d_nhtolm, d_indv, d_tab nullptr z_vkb nullptr Kleinman-Bylander 完全非局域赝势 wfcpw nullptr 平面波基波函数的指针 Init() 被赋值为 PW_Basis_K* ESolver_KS_PW::pw_wfc psf nullptr 结构因子指针 Init() 被赋值为 Structure_Factor* ESolver_KS_PW::sf 在下一篇中，我们将更加细致地探究这个类的其他被 Init_GlobalC() 函数所调用的成员函数。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 6 下篇：Introduction to ABACUS: Path to PW calculation - Part 8 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-path8.html":{"url":"develop-path8.html","title":"Introduction to ABACUS: Path to PW calculation - Part 8","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 8 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 8 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Driver Driver::atomic_world() Driver::driver_run() 多层继承：Init() functions in esolver class Initialization of rest parts of GlobalC pseudopot_cell_vnl pseudopot_cell_vnl::init() init() 函数赋值以下变量，并为指针和数组进行初始化： 变量 意义 操作 wfcpw ESolver_KS_PW 对象中 PW_Basis_K 类指针 exact value psf ...对象中 Structure_Factor 类指针 exact value lmaxkb 跨原子种类的 projector 最大角动量 exact value nhm 原子种类的 projector 最大数量 zero nkb 所有原子的 projector 数量总和 zero indv 映射表，从[原子种类索引][projector 全局索引]到“原子种类内 projector 索引” zero nhtol 映射表，从[原子种类索引][projector 全局索引]到 projector 角量子数 l zero nhtolm 映射表，从[原子种类索引][projector 全局索引]到 projector 的(l,m)-pair: 0: s, 1/2/3: p, 4/5/6/7/8: d, ... zero nhtoj 映射表，从[原子种类索引][projector 全局索引]到 projector 总角量子数 zero deeq 赝势block 中数据（projector-projector），存储为[自旋 channel 索引][原子种类索引][projector1 索引][projector2 索引] zero deeq_nc Spin-orbit coupling case specific deeq zero z_deeq_nc double 指针，指向 deeq_nc d_deeq double 指针，指向 deeq exact value d_indv double 指针，指向 indv exact value d_nhtol double 指针，指向 nhtol exact value d_nhtolm double 指针，指向 nhtolm exact value dvan 赝势 projector 间，存储为[原子种类][projector1 全局索引][projector2 全局索引] zero dvan_so Spin-orbit coupling case specific dvan, 存储为[自旋 channel 索引][原子种类][projector1 全局索引][projector2 全局索引] zero becsum 存储为[自选channel索引][原子索引][(projectori,projectorj)-pair数量/2] zero lmaxq 2 * this->lmaxkb + 1; exact value vkb 倒空间V^{KB}值，即V_i(\\mathbf{G}_j)^{KB}, i\\inN(projector)，j\\inN(planewaves) zero GlobalV::NQX 球 Bessel 函数的 q-空间格点数量 exact value tab 插值表，表值\\frac{4\\pi}{\\sqrt{\\Omega}}\\int{r^2\\text{d}r\\beta_{\\alpha i}(r)j_l(qr)}, 存储为[原子种类][projector 索引][q索引] zero tab_at 原子波函数插值表 zero z_vkb double 指针，指向 vkb d_tab double 指针，指向 tab 因此部分函数冗长但功能简单，可读性强，因此不逐行解读，如需寻找代码细节，请自行阅读（link）。 pseudopot_cell_vnl::init_vloc() code template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { .... //================================= // initalize local pseudopotential //================================= GlobalC::ppcell.init_vloc(GlobalC::ppcell.vloc, this->pw_rho); ModuleBase::GlobalFunc::DONE(GlobalV::ofs_running, \"LOCAL POTENTIAL\"); //VL_in_pw.cpp void pseudopot_cell_vl::init_vloc(ModuleBase::matrix& vloc_in, const ModulePW::PW_Basis* rho_basis) { .... double *vloc1d = new double[rho_basis->ngg]; ModuleBase::GlobalFunc::ZEROS(vloc1d, rho_basis->ngg); this->allocate(rho_basis->ngg); for (int it = 0; it ngg); this->zp[it] = atom->ncpp.zv; if(numeric[it]==true) { this->vloc_of_g(atom->ncpp.msh, atom->ncpp.rab, atom->ncpp.r, atom->ncpp.vloc_at, this->zp[it], vloc1d, rho_basis); } else ModuleBase::WARNING_QUIT(\"init_vloc\",\"not available now.\"); if(it>=0 && it=0) ModuleBase::GlobalFunc::COPYARRAY(vloc1d, &vloc_in(it, 0), rho_basis->ngg); } delete[] vloc1d; this->print_vloc(rho_basis); } 回顾在 Part 3（Introduction to ABACUS: Path to PW calculation - Part 3）曾经读取过赝势到 UnitCell::atom.ncpp 数据成员中，pseudopot_cell_vl::init_vloc() 函数调用 pseudopot_cell_vl::vloc_of_g() 对实空间局域势进行傅里叶变换： V_{\\mathrm{loc}}\\left( \\mathbf{G} \\right) =\\mathscr{F} \\left[ V_{\\mathrm{loc}}\\left( \\mathbf{r} \\right) \\right] =\\mathscr{F} \\left[ V_{\\mathrm{loc}}\\left( \\mathbf{r} \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right] -\\frac{Ze^2}{r}\\mathscr{F} \\left[ \\mathrm{erf}\\left( r \\right) \\right] 后一项具有解析解， \\frac{Ze^2}{r}\\mathscr{F} \\left[ \\mathrm{erf}\\left( r \\right) \\right] =Ze^2\\frac{\\exp \\left[ -\\frac{|\\mathbf{G}|^2}{4} \\right]}{|\\mathbf{G}|^2} 前一项的傅里叶变换可以继续化简： \\mathscr{F} \\left[ V_{\\mathrm{loc}}\\left( \\mathbf{r} \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right] =\\frac{1}{\\Omega}\\int{\\mathrm{d}\\mathbf{r}e^{-i\\mathbf{G}\\cdot \\mathbf{r}}\\left[ V_{\\mathrm{loc}}\\left( \\mathbf{r} \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{1}{\\Omega}\\int{r^2\\mathrm{d}r\\int_0^{\\pi}{\\sin \\theta \\mathrm{d}\\theta}\\int_0^{2\\pi}{\\mathrm{d}\\phi}e^{-i|\\mathbf{G}||\\mathbf{r}|\\cos \\theta}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{2\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\int_0^{\\pi}{\\sin \\theta \\mathrm{d}\\theta}e^{-i|\\mathbf{G}|r\\cos \\theta}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{2\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\int_1^{-1}{\\mathrm{d}t}e^{-i|\\mathbf{G}|rt}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{2\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\frac{e^{i|\\mathbf{G}|r}-e^{-i|\\mathbf{G}|r}}{i|\\mathbf{G}|r}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} =\\frac{4\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\frac{\\sin \\left( |\\mathbf{G}|r \\right)}{|\\mathbf{G}|r}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]} 最后得到： V_{\\mathrm{loc}}\\left( \\mathbf{G} \\right) =\\frac{4\\pi}{\\Omega}\\int{r^2\\mathrm{d}r\\frac{\\sin \\left( |\\mathbf{G}|r \\right)}{|\\mathbf{G}|r}\\left[ V_{\\mathrm{loc}}\\left( r \\right) +\\frac{Ze^2}{r}\\mathrm{erf}\\left( r \\right) \\right]}-Ze^2\\frac{\\exp \\left[ -\\frac{|\\mathbf{G}|^2}{4} \\right]}{|\\mathbf{G}|^2} &#x1F914;思考时间 Write a piece of code to calculate the term above! Compare with the version in ABACUS source code, what are your pros and what are your cons? If you are confident enough with your codes in aspect of well-documenting, clean-formatting and even efficiency and accurancy, why not pull a request to replace the present one? Do it! Relevant topic: a glimpse of Ewald summation 数值计算过程中需要考虑更多的技术问题，对于函数积分的可收敛性是其中一个重要的方面。erf(x)和 erfc(x)分别定义为： \\mathrm{erf}\\left( x \\right) \\equiv \\int_0^x{\\exp \\left[ -t^2 \\right] \\mathrm{d}t} \\mathrm{erfc}\\left( x \\right) \\equiv 1-\\mathrm{erf}\\left( x \\right) 就实际应用场景而言，原子势能就是其中之一。为避免V(r)=-\\frac{Ze^2}{r}的傅里叶变换可能存在的积分发散，使用 erf(x)来 rescale 它，得到： V^\\text{loc}(r)\\equiv V(r)\\text{erf}(r) V^\\text{nloc}(r)\\equiv V(r)\\text{erfc}(r) 进而让V^\\text{nloc}(r)在倒空间进行加和，V^\\text{loc}(r)在实空间进行加和。 &#x1F914; 思考时间 The following reading materials are generated by OpenAI GPT-4, read it and try to understand the use of erf(x) function Ewald summation is a method used to compute long-range electrostatic interactions in periodic systems. It's especially important in simulations of crystalline solids and other periodic systems because the straightforward summation of pairwise Coulomb interactions converges very slowly due to the long-range nature of the interaction. Here's a brief outline with the essential mathematical details: The Problem In a periodic system, the electrostatic energy U due to a set of charged particles can be written as: U=\\frac{1}{2}\\sum_{ij, \\mathbf{T}}{\\frac{q_iq_j}{|\\mathbf{\\tau}_i-\\mathbf{\\tau}_j+\\mathbf{T}|}} Where: q_i and q_j are the charges of particles i and j. \\mathbf{\\tau}_i and \\mathbf{\\tau}_j are their positions. \\mathbf{T} represents a lattice vector of the periodic system. The summation over \\mathbf{T} includes all periodic replicas of the system. Ewald's Idea Ewald summation splits the Coulomb interaction into two parts: Short-range, real-space sum: This converges quickly in real space. Long-range, reciprocal-space sum: This converges quickly in Fourier (reciprocal) space. The Split To achieve this, Ewald introduced a splitting function \\text{erf}(r)/r (complementary error function) such that: > \\frac{1}{r}=\\frac{\\text{erf}(\\alpha r)}{r}+\\frac{\\text{erfc}(\\alpha r)}{r} > \\text{erf} is the error function. \\alpha is a free parameter that can be chosen to optimize convergence. The first term on the right-hand side is short-ranged and is treated in real space. The second term is treated in reciprocal space. The Two Parts Real-Space Sum: U_\\text{real}=\\frac{1}{2}\\sum_{ij, \\mathbf{T}}{q_iq_j\\frac{\\text{erf}(\\alpha|\\mathbf{\\tau}_i-\\mathbf{\\tau}_j+\\mathbf{T}|)}{|\\mathbf{\\tau}_i-\\mathbf{\\tau}_j+\\mathbf{T}|}} (Only nearby terms are summed, as this converges quickly in real space.) Reciprocal-Space Sum: U_\\text{recip}=\\frac{1}{2\\pi\\Omega}\\sum_{\\mathbf{G}\\neq0}{\\frac{\\exp[-\\frac{G^2}{4\\alpha^2}]}{G^2}|\\sum_{i}{q_i\\exp[i\\mathbf{G}\\cdot\\mathbf{r}_i]}|^2} Where \\mathbf{G} are the reciprocal lattice vectors and \\Omega is the volume of the unit cell. An additional self-energy term and surface term are added to correct for the self-interaction and surface effects. Conclusion The Ewald summation provides a more efficient way to compute the electrostatic interactions in a periodic system. By treating short-range interactions in real space and long-range interactions in reciprocal space, both parts converge much faster than the naive pairwise sum. &#x1F914;思考时间 More specifically the Ewald summation technique, there are many derivatives of it, for the Ewald summation takes a large part of computation time in classical Molecular dyanmics simulation. Further reading: PME (Particle Mesh Ewald summation), SPME (Smoothed Particle Mesh Ewald summation). Nonlocal pseudopotential initialization template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { .... //====================================== // Initalize non local pseudopotential //====================================== GlobalC::ppcell.init_vnl(GlobalC::ucell); ModuleBase::GlobalFunc::DONE(GlobalV::ofs_running, \"NON-LOCAL POTENTIAL\"); GlobalC::ppcell.cal_effective_D(); pseudopot_cell_vnl::init_vnl() 在上篇（Introduction to ABACUS: Path to PW calculation - Part 7 ）和 init() 函数中（link）已经阐明各变量的意义，init_vnl()则对非局域赝势相关变量（nhtol, nhtolm, nhtoj, indv, dvan/dvan_so, tab 等）进行了实际的赋值操作，使其符合表（link）中描述。考虑到篇幅限制和实际需求，此处 SOC 相关部分略过，但保留链接可供自行查看：link pseudopot_cell_vnl::cal_effective_D() 先前实际上已经对D_{ij}的出现位置进行过介绍（Introduction to ABACUS: Path to PW calculation - Part 3 ），此处 cal_effective_D() 则实现的是从 dvan（[原子种类][global index of projectori][global index of projectorj]）到 deeq（[ispin][global index of atom][index of projectori][index of projectorj]）的数据拷贝。 void pseudopot_cell_vnl::cal_effective_D(void) { ModuleBase::TITLE(\"pseudopot_cell_vnl\", \"cal_effective_D\"); for (int iat = 0; iat deeq(is, iat, ih, jh) = this->dvan(it, ih, jh); this->deeq(is, iat, jh, ih) = this->dvan(it, ih, jh); if(ih != jh && std::fabs(this->deeq(is, iat, ih, jh))>0.0) { this->multi_proj = true; } } } } } } if (GlobalV::device_flag == \"gpu\") {....} else { if (GlobalV::precision_flag == \"single\") {....} } } 亦即对于 nspin≤2 的情况，一开始的 projector 其配置完全相同，而对于 nspin=4 的情况，ispin=0 和 3 的数值和 nspin≤2 的 ispin=0 和 1 相同，而 ispin=1 和 2 则在此处被初始化为 std::complex(0.,0.)。 到这里，GlobalC::pseudopot_cell_vnl ppcell 中大部分数据成员的值均从 UnitCell::atoms::ncpp 中获得，即实现了如下数据传输方式： 即赝势数据从 upf 文件经 UnitCell::atom.ncpp 解析，上传至 GlobalC 中，详细其对应类为 GlobalC::pseudopot_cell_vnl，具体实例化对象为 ppcell。这一操作类似于 Input::INPUT 解析 INPUT 文件，上传至 GlobalV，唯一的区别是 GlobalV 直接以散装变量方式存储。 &#x1F527;重构信息 回顾当前 ABACUS 版本中从外部读入数据的传递模式： STRU 文件的读取，使用的为 UnitCell 中方法，UnitCell 中存储，并且 UnitCell 本身也属于 GlobalC，为全局变量。 KPT 文件的读取，使用 K_Vectors 类中方法，但 K_Vectors 对象被声明在 ESolver_FP 中，并非 GlobalC。 INPUT 文件的读取，使用 Input 类中方法，Input 被声明为 extern，其成员函数 Input::input_conv() 将大部分变量传到 GlobalV，少部分直接传到具体的类数据成员中。 &#x1F616; somewhat in mess wavefunc wf_atomic::init_at_1() template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { .... //================================================== // create GlobalC::ppcell.tab_at , for trial wave functions. //================================================== this->wf.init_at_1(&this->sf); 回忆 wavefunc 实际为 ESolver_KS 中数据成员，因 ESolver_FP 还包括 ESolver_OF 即 orbital-free dft 方法，此种方法不需要显式的波函数，而 init_GlobalC 是 ESolver_KS_PW 类成员函数，因此其中所有\"this->\"都为当前类对象的指针。init_at_1() 由 wavefunc 类继承自 wf_atomic，此函数归一化了原子的 pswfc（\\tilde{\\phi}^\\alpha_{i}(r)，即赝波函数，pseudo wavefunction），之后对其求 tab_at(it, ic, iq) = \\frac{4\\pi}{\\sqrt{\\Omega}}\\int_{0}^{r_\\text{cut}}{j_l(qr)\\tilde{\\phi}^\\alpha_{i}(r)r^2dr} 。注意如 Part 3 所提到，实际读取的 pswfc 已经乘以 r。 wavefunc::wfcinit() template void ESolver_KS_PW::Init_GlobalC(Input& inp, UnitCell& cell) { .... //================================ // Initial start wave functions //================================ this->wf.wfcinit(this->psi, this->pw_wfc); void wavefunc::wfcinit(psi::Psi> *psi_in, ModulePW::PW_Basis_K *wfc_basis) { .... if (GlobalV::BASIS_TYPE == \"pw\") { if (this->irindex != nullptr) delete[] this->irindex; this->irindex = new int[wfc_basis->fftnxy]; wfc_basis->getfftixy2is(this->irindex); } .... } ASE philosophy: the so-called dynamics 我们通过 ESolver 初始化工作流，之后使用 Relax_Driver 类对象运行工作流。 void Driver::driver_run() { .... if(GlobalV::CALCULATION == \"md\") { Run_MD::md_line(GlobalC::ucell, p_esolver, INPUT.mdp); } else // scf; cell relaxation; nscf; etc { Relax_Driver rl_driver; rl_driver.relax_driver(p_esolver); } 这是我们首次提到这个类，检查发现 Relax_Driver 并非直接显式包含在当前 driver_run.cpp 中，而是位于 #include \"module_hamilt_pw/hamilt_pwdft/global.h\" ，可以发现 #include \"module_relax/relax_driver.h\" 。一窥 Relax_Driver 类的数据成员： class Relax_Driver { public: Relax_Driver(){}; ~Relax_Driver(){}; void relax_driver(ModuleESolver::ESolver *p_esolver); private: // mohan add 2021-01-28 // mohan moved this variable from electrons.h to relax_driver.h int istep = 0; double etot = 0; // new relaxation method Relax rl; // old relaxation method Relax_old rl_old; }; 因为我们只考虑 PW-SCF 计算任务，因此 Relax 和 Relax_old 类成员我们可暂且不去关心。Relax_Driver 类构造函数直接在当前头文件中定义为空，因此只剩下 Relax_Driver::relax_driver() 成员函数： void Relax_Driver::relax_driver(ModuleESolver::ESolver *p_esolver) { ....//omit output and timer if (GlobalV::CALCULATION == \"relax\" || GlobalV::CALCULATION == \"cell-relax\") {....} this->istep = 1; ....//omit force and stree step defnition bool stop = false; while (istep Run(istep - 1, GlobalC::ucell); ....//omit timer if (GlobalV::CALCULATION == \"scf\" || GlobalV::CALCULATION == \"relax\" || GlobalV::CALCULATION == \"cell-relax\") { this->etot = p_esolver->cal_Energy(); ....// omit, calculate and gather all parts of total ionic forces ....// omit, calculate and gather all parts of stress if (GlobalV::CALCULATION == \"relax\" || GlobalV::CALCULATION == \"cell-relax\") {....} } } ....//omit timer ++istep; } ....//omit output and timer } 通过检查 ESolver 各派生类和基类之间的继承关系，ESolver_KS::Run() 为此时实际调用的函数。 ESolver::Run()/ESolver_KS::Run() template void ESolver_KS::Run(const int istep, UnitCell& ucell) { ....//omit totally irelevant lines else { ....//omit timer this->beforescf(istep); //Something else to do before the iter loop ....//omit record and output bool firstscf = true; this->conv_elec = false; this->niter = this->maxniter; for (int iter = 1; iter maxniter; ++iter) { writehead(GlobalV::ofs_running, istep, iter); #ifdef __MPI auto iterstart = MPI_Wtime(); ....//omit non-mpi case #endif double diag_ethr = this->phsol->set_diagethr(istep, iter, drho); eachiterinit(istep, iter); this->hamilt2density(istep, iter, diag_ethr); if(GlobalV::MY_STOGROUP == 0) { drho = p_chgmix->get_drho(pelec->charge, GlobalV::nelec); double hsolver_error = 0.0; if (firstscf) { firstscf = false; hsolver_error = this->phsol->cal_hsolerror(); if (hsolver_error > drho) { diag_ethr = this->phsol->reset_diagethr(GlobalV::ofs_running, hsolver_error, drho); this->hamilt2density(istep, iter, diag_ethr); drho = p_chgmix->get_drho(pelec->charge, GlobalV::nelec); hsolver_error = this->phsol->cal_hsolerror(); } } this->conv_elec = (drho scf_thr); // If drho conv_elec) { if (drho pelec->cal_bandgap(); bandgap_for_autoset = this->pelec->bandgap; } else { this->pelec->cal_bandgap_updw(); bandgap_for_autoset = std::min(this->pelec->bandgap_up, this->pelec->bandgap_dw); } p_chgmix->auto_set(bandgap_for_autoset, GlobalC::ucell); } p_chgmix->mix_rho(iter, pelec->charge); } } #ifdef __MPI MPI_Bcast(&drho, 1, MPI_DOUBLE , 0, PARAPW_WORLD); MPI_Bcast(&this->conv_elec, 1, MPI_DOUBLE , 0, PARAPW_WORLD); MPI_Bcast(pelec->charge->rho[0], this->pw_rho->nrxx, MPI_DOUBLE, 0, PARAPW_WORLD); #endif updatepot(istep, iter); eachiterfinish(iter); #ifdef __MPI double duration = (double)(MPI_Wtime() - iterstart); ....//omit non-mpi case #endif printiter(iter, drho, duration, diag_ethr); if (this->conv_elec) { this->niter = iter; bool stop = this->do_after_converge(iter); if(stop) break; } } afterscf(istep); ....//omit timer } }; 下一篇我们将基于 ESolver_KS::Run() 正式步入 ABACUS 的主要工作部分，并暂时将 Relax_Driver::relax_driver() 函数提级为一级标题。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 7 下篇：Introduction to ABACUS: Path to PW calculation - Part 9 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-path9.html":{"url":"develop-path9.html","title":"Introduction to ABACUS: Path to PW calculation - Part 9","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 9 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 9 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 &#x1F914;Walk out! From now on, more codes and fewer explanations, try to understand more ABACUS codes on your own! Relax_Driver::relax_driver() void Relax_Driver::relax_driver(ModuleESolver::ESolver *p_esolver) { ....//omit timer and record if (GlobalV::CALCULATION == \"relax\" || GlobalV::CALCULATION == \"cell-relax\") {....} this->istep = 1; int force_step = 1; // pengfei Li 2018-05-14 int stress_step = 1; bool stop = false; while (istep Run(istep - 1, GlobalC::ucell); 考虑到我们目前仅考虑 pw-scf 的情况，因此跳过第一个 if 判断。GlobalV::RELAX_NMAX 的值在 global_variable.cpp 中被初始化为 20，因此忽略关于 OUT_LEVEL 的判断，来到 p_esolver->Run(istep - 1, GlobalC::ucell); 目前 p_esolver 实际为 ESolver_KS_PW 类，上级基类分别为 ESolver_KS, ESolver_FP, ESolver。Run() 函数在 ESolver 类中被声明为纯虚函数，由于 ESolver_KS_PW 和 ESolver_FP 中并无 Run() 函数定义，ESolver_KS 中定义的 Run() 函数 namespace ModuleESolver { template class ESolver_KS : public ESolver_FP { public: .... virtual void Run(const int istep, UnitCell& cell) override; 会被调用。 ESolver_KS::Run() Source code: ESolver_KS::Run() Visualization: Beforescf beforescf() 函数在 ESolver_KS 中为虚函数，实际调用 ESolver_KS_PW 该派生类对函数的重载。 namespace ModuleESolver { template class ESolver_KS : public ESolver_FP { .... protected: // Something to do before SCF iterations. virtual void beforescf(int istep) {}; Build Hamilton operator 我们省略 relax 和 vcrelax 的部分，来到 p_hamilt 这一属于 hmilt::HamiltPW 类指针的内存刷新（delete and new）： template void ESolver_KS_PW::beforescf(int istep) { .... if (GlobalC::ucell.cell_parameter_updated) {....} if (GlobalC::ucell.ionic_position_updated) {....} if (this->p_hamilt != nullptr) { delete reinterpret_cast*>(this->p_hamilt); this->p_hamilt = nullptr; } // allocate HamiltPW if (this->p_hamilt == nullptr) { this->p_hamilt = new hamilt::HamiltPW(this->pelec->pot, this->pw_wfc, &this->kv); } auto vdw_solver = vdw::make_vdw(GlobalC::ucell, INPUT); if (vdw_solver != nullptr) this->pelec->f_en.evdw = vdw_solver->get_energy(); .... } 这一刷新操作使得 HamiltPW 的构造函数再次被调用，构造 Hamiltonian 算符： template HamiltPW::HamiltPW(elecstate::Potential* pot_in, ModulePW::PW_Basis_K* wfc_basis, K_Vectors* pkv) { this->classname = \"HamiltPW\"; const auto tpiba2 = static_cast(GlobalC::ucell.tpiba2); const auto tpiba = static_cast(GlobalC::ucell.tpiba); const int* isk = pkv->isk.data(); const FPTYPE* gk2 = wfc_basis->get_gk2_data(); if (GlobalV::T_IN_H) { Operator, Device>* ekinetic = new Ekinetic>(....); if(this->ops == nullptr) this->ops = ekinetic; else this->ops->add(ekinetic); } if (GlobalV::VL_IN_H) { std::vector pot_register_in; if (GlobalV::VION_IN_H) pot_register_in.push_back(\"local\"); if (GlobalV::VH_IN_H) pot_register_in.push_back(\"hartree\"); pot_register_in.push_back(\"xc\"); if (GlobalV::imp_sol) pot_register_in.push_back(\"surchem\"); if (GlobalV::EFIELD_FLAG) pot_register_in.push_back(\"efield\"); if (GlobalV::GATE_FLAG) pot_register_in.push_back(\"gatefield\"); if(pot_register_in.size()>0) { pot_in->pot_register(pot_register_in); Operator, Device>* veff = new Veff>(....); if(this->ops == nullptr) this->ops = veff; else this->ops->add(veff); Operator, Device>* meta = new Meta>(....); this->ops->add(meta); } } if (GlobalV::VNL_IN_H) { Operator, Device>* nonlocal = new Nonlocal>(....); if(this->ops == nullptr) this->ops = nonlocal; else this->ops->add(nonlocal); } } 稍加观察就可以发现，T_IN_H、VL_IN_H、VION_IN_H 等量控制了 Hamilton 算符中包含项的多少：https://abacus.deepmodeling.com/en/latest/advanced/input_files/input-main.html#variables-useful-for-debugging HamiltPW 和其基类 Hamilt 包含数据成员关系如下： Operator (ops)在 Hamilt 中的存储方式类似链表： Operator 类 Operator 类中各算符继承关系如下： 其中算符可能具有部分共享变量。在 HamiltPW 的构造函数中，省略了动能算符、有效势能算符、Meta 算符和非局域算符的构造函数形参表，其具体内容分别为： Kinetic term: the kinetic operator template HamiltPW::HamiltPW(elecstate::Potential* pot_in, ModulePW::PW_Basis_K* wfc_basis, K_Vectors* pkv) { .... if (GlobalV::T_IN_H) { .... Operator, Device>* ekinetic = new Ekinetic>(tpiba2, gk2, wfc_basis->nks, wfc_basis->npwk_max); //source/module_basis/module_pw/pw_basis_k.cpp: line 351 template <> float * PW_Basis_K::get_gk2_data() const { return this->s_gk2; } template <> double * PW_Basis_K::get_gk2_data() const { return this->d_gk2; } //line 246, in function PW_Basis_K::collect_local_pw() this->d_gk2 = this->gk2; //line 217, in function PW_Basis_K::collect_local_pw() this->gk2[ik * npwk_max + igl] = (f+kv) * (this->GGT * (f+kv)); template Ekinetic>::Ekinetic( FPTYPE tpiba2_in, const FPTYPE* gk2_in, const int gk2_row, const int gk2_col) { this->classname = \"Ekinetic\"; this->cal_type = pw_ekinetic; this->tpiba2 = tpiba2_in; this->gk2 = gk2_in; this->gk2_row = gk2_row; this->gk2_col = gk2_col; this->device = psi::device::get_device_type(this->ctx); if( this->tpiba2 gk2 == nullptr) { ModuleBase::WARNING_QUIT(\"EkineticPW\", \"Constuctor of Operator::EkineticPW is failed, please check your code!\"); } } Potential terms Review: Potential类对象的初始化在ESolver_KS_PW::Init()（link） template void ESolver_KS_PW::Init(Input& inp, UnitCell& ucell) { .... if (this->pelec->pot == nullptr) { this->pelec->pot = new elecstate::Potential(this->pw_rho, &GlobalC::ucell, &(GlobalC::ppcell.vloc), &(this->sf), &(this->pelec->f_en.etxc), &(this->pelec->f_en.vtxc)); } .... } 其中 Potential::v_effective_fixed 和 Potential::v_effective 均按照所分发得到实空间格点数量进行内存申请（Introduction to ABACUS: Path to PW calculation - Part 7），但 nrxx 暗示着已经是一维化的数组，而并不直接保持(x, y, z)的形式访问： //source/module_elecstate/potentials/potential_new.cpp Potential::Potential() line 16 namespace elecstate { Potential::Potential(.... // allocate memory for Potential. this->allocate(); } .... /*------------------------------------------------------------------------------------*/ //source/module_elecstate/potentials/potential_new.cpp Potential::allocate() this->v_effective_fixed.resize(nrxx); this->v_effective.create(GlobalV::NSPIN, nrxx); .... // memory record omitted if (elecstate::get_xc_func_type() == 3 || elecstate::get_xc_func_type() == 5) { this->vofk_effective.create(GlobalV::NSPIN, nrxx); .... // memory record omitted Effective potential operator &#x1F914;C++ programming topic: polymorphism Potential is a good example illustrating the use of polymorphism. You can find a base class pointer is created and then used to point to a derived class object. template HamiltPW::HamiltPW(elecstate::Potential* pot_in, ModulePW::PW_Basis_K* wfc_basis, K_Vectors* pkv) { .... if(pot_register_in.size()>0) { .... pot_in->pot_register(pot_register_in); Operator, Device>* veff = new Veff>(isk, pot_in->get_v_effective_data(), pot_in->get_effective_v().nr, pot_in->get_effective_v().nc, wfc_basis); .... void Potential::pot_register(std::vector& components_list) { if (this->components.size() > 0) { for (auto comp: this->components) delete comp; this->components.clear(); } for (auto comp: components_list) { PotBase* tmp = this->get_pot_type(comp); this->components.push_back(tmp); } this->fixed_done = false; } PotBase* Potential::get_pot_type(const std::string& pot_type) { ModuleBase::TITLE(\"Potential\", \"get_pot_type\"); if (pot_type == \"local\") { return new PotLocal(this->vloc_, &(this->structure_factors_->strucFac), this->rho_basis_); } else if (pot_type == \"hartree\") { return new PotHartree(this->rho_basis_); } else if (pot_type == \"xc\") { return new PotXC(this->rho_basis_, this->etxc_, this->vtxc_, &(this->vofk_effective)); } else if (pot_type == \"surchem\") { return new PotSurChem(this->rho_basis_, this->structure_factors_, this->v_effective_fixed.data(), &GlobalC::solvent_model); } else if (pot_type == \"efield\") { return new PotEfield(this->rho_basis_, this->ucell_, GlobalV::DIP_COR_FLAG); } else if (pot_type == \"gatefield\") { return new PotGate(this->rho_basis_, this->ucell_); } .... } //source/module_elecstate/potentials/potential_new.cpp line 251 template <> double * Potential::get_v_effective_data() { return this->v_effective.nc > 0 ? this->d_v_effective : nullptr; } template Veff>::Veff(const int* isk_in, const FPTYPE* veff_in, const int veff_row, const int veff_col, const ModulePW::PW_Basis_K* wfcpw_in) { this->classname = \"Veff\"; this->cal_type = pw_veff; this->isk = isk_in; this->veff = veff_in; //note: \"veff = nullptr\" means that this core does not treat potential but still treats wf. this->veff_row = veff_row; this->veff_col = veff_col; this->wfcpw = wfcpw_in; resmem_complex_op()(this->ctx, this->porter, this->wfcpw->nmaxgr, \"Veff::porter\"); resmem_complex_op()(this->ctx, this->porter1, this->wfcpw->nmaxgr, \"Veff::porter1\"); if (this->isk == nullptr || this->wfcpw == nullptr) { ModuleBase::WARNING_QUIT(\"VeffPW\", \"Constuctor of Operator::VeffPW is failed, please check your code!\"); } } meta-GGA operator Operator, Device>* meta = new Meta>(tpiba, isk, pot_in->get_vofk_effective_data(), pot_in->get_effective_vofk().nr, pot_in->get_effective_vofk().nc, wfc_basis); template Meta>::Meta(FPTYPE tpiba_in, const int* isk_in, const FPTYPE* vk_in, const int vk_row, const int vk_col, const ModulePW::PW_Basis_K* wfcpw_in) { this->classname = \"Meta\"; this->cal_type = pw_meta; this->isk = isk_in; this->tpiba = tpiba_in; this->vk = vk_in; this->vk_row = vk_row; this->vk_col = vk_col; this->wfcpw = wfcpw_in; resmem_complex_op()(this->ctx, this->porter, this->wfcpw->nmaxgr, \"Meta::porter\"); if(this->isk == nullptr || this->tpiba wfcpw == nullptr) { ModuleBase::WARNING_QUIT(\"MetaPW\", \"Constuctor of Operator::MetaPW is failed, please check your code!\"); } } Non-local potential operator template Nonlocal>::Nonlocal(const int* isk_in, const pseudopot_cell_vnl* ppcell_in, const UnitCell* ucell_in, const ModulePW::PW_Basis_K* wfc_basis) { this->classname = \"Nonlocal\"; this->cal_type = pw_nonlocal; this->wfcpw = wfc_basis; this->isk = isk_in; this->ppcell = ppcell_in; this->ucell = ucell_in; this->deeq = this->ppcell->template get_deeq_data(); this->deeq_nc = this->ppcell->template get_deeq_nc_data(); this->vkb = this->ppcell->template get_vkb_data(); if( this->isk == nullptr || this->ppcell == nullptr || this->ucell == nullptr) { ModuleBase::WARNING_QUIT(\"NonlocalPW\", \"Constuctor of Operator::NonlocalPW is failed, please check your code!\"); } } 之后到达 vdw 能量计算函数 vdw::make_vdw()。 Van der Waals calculation: vdw class template void ESolver_KS_PW::beforescf(int istep) { .... auto vdw_solver = vdw::make_vdw(GlobalC::ucell, INPUT); if (vdw_solver != nullptr) { this->pelec->f_en.evdw = vdw_solver->get_energy(); } .... code 查看 make_vdw() 函数，发现其返回 std::unique_ptr 类对象，即 Vdw 实例化的 std::unique_ptr 智能指针。智能指针的优点是会在程序结束时自动释放内存空间，而不会产生内存泄漏问题。 为简单起见，这里我们首先不考虑 vdw 项贡献，因此我们在 INPUT 文件中对 vdw_corr 关键词赋值为判断条件之外的参数是，make_vdw 将返回空指针 nullptr，因此接下来的复制操作不会被执行，f_en.evdw 维持默认值 0。 std::unique_ptr make_vdw(const UnitCell &ucell, const Input &input) { if (ucell.nat vdw_ptr = make_unique(ucell); vdw_ptr->parameter().initial_parameters(input); vdw_ptr->parameter().initset(ucell); return vdw_ptr; } else if (input.vdw_method == \"d3_0\" || input.vdw_method == \"d3_bj\") { std::unique_ptr vdw_ptr = make_unique(ucell); vdw_ptr->parameter().initial_parameters(input); return vdw_ptr; } else return nullptr; } std::vector, std::map 和 std::unordered_map 与智能指针简介 基础的 C++ 知识可以知道，数组和指针等价，尤其依靠一维指针来实现长度可变的一维数组，对于一维以上也是同理。然而，（裸）指针的使用具有较大的内存泄漏风险，且涉及元素访问的操作均需要自行实现。使用 std::vector 这一标准库容器可以对这种应用需求进行替代。对比（裸）指针，std::vector 具有以下优点（generated by Chat-AISI）： There are several advantages of using std::vector compared to a bare pointer: Dynamic memory management: std::vector automatically manages the memory allocation and deallocation for you, so you don't have to worry about manually allocating and deallocating memory. Automatic resizing: std::vector can automatically resize itself when new elements are added or removed, which makes it more convenient to use than a bare pointer. Bounds checking: std::vector provides bounds checking, which means that it will throw an exception if you try to access an element that is out of bounds. This can help prevent bugs and improve the safety of your code. Iterators: std::vector provides iterators that allow you to easily traverse the elements in the vector. This can make it easier to write algorithms that operate on the elements of the vector. Standard library algorithms: std::vector is part of the C++ standard library, which means that it can be used with a wide range of standard library algorithms. This can make it easier to write code that is more concise and easier to read. 同理 std::map 数据类型提供了支持两种数据类型不同的变量间 1-1 映射关系的批量存储，而 std::unordered_map 额外支持了基于 key-value pair 的乱序访问（类似于 Python 中的字典数据结构）。 指针的常见应用场景之二便是保存对象的内存地址，尤其对于 OOP 场景，我们希望通过内存地址来访问已经建立的 std::vector 对象，而不是直接进行深拷贝，以降低内存的消耗。然而，每当 std::vector 等上述容器进行扩容时，都会在内存中重新申请空间，即是说 std::vector 不具有固定的内存地址。为了使得指针能够按照指向的内容来进行锁定，我们可以使用智能指针。 智能指针是 C++11 开始支持的（新 ps.：但 C++11 本身已经不新了）特性，常见类型有两种，分别为 std::unique_ptr 和 std::shared_ptr。这两种智能指针的区别为是否允许多个指针对内存进行访问，前者不允许，后者允许。两种指针的使用方式和普通指针保持大致相同，但创建操作变更为 make_unique 或 make_shared（examples provided by Chat-AISI）： #include int main() { // Create a unique_ptr to an integer and initialize it with a new integer std::unique_ptr myInt = std::make_unique(42); // Use the unique_ptr to access the integer value std::cout #include int main() { // Create a shared_ptr to an integer and initialize it with a new integer std::shared_ptr myInt = std::make_shared(42); // Create another shared_ptr to the same integer std::shared_ptr myInt2 = myInt; // Use the shared_ptrs to access the integer value std::cout 我们可以使用如下方式以 std::shared_ptr 绑定一个基于 std::vector 实现的矩阵： #include #include std::vector> M; for (int irow=0; irow OneRow; for (int icol=0; icol>> M_ptr = make_shared>>(M); Ewald 关于最基本的 Ewald 的原理已经在上篇中提到。 template void ESolver_KS_PW::beforescf(int istep) { .... this->pelec->f_en.ewald_energy = H_Ewald_pw::compute_ewald(GlobalC::ucell, this->pw_rho, this->sf.strucFac); .... } ElecState::init_scf()：review the philosophy describing electronic state template void ESolver_KS_PW::beforescf(int istep) { .... this->pelec->init_scf(istep, this->sf.strucFac); .... } ElecState 类已经出现多次，在正式的对角化开始前，我们有必要完全了解 ElecState 类如何被设计，以描述电子态（Electronic State）： &#x1F914;批判式思考 寻找可能的冗余变量！ void ElecState::init_scf(const int istep, const ModuleBase::ComplexMatrix& strucfac) { this->charge->set_rho_core(strucfac); if (istep == 0) { this->charge->init_rho(this->eferm, strucfac, this->bigpw->nbz, this->bigpw->bz); } this->charge->renormalize_rho(); this->pot->init_pot(istep, this->charge); } Charge::set_rho_core() void Charge::set_rho_core( const ModuleBase::ComplexMatrix &structure_factor ) { ....//omit timer and comments bool bl = false; for (int it = 0; it 我们首先不考虑 noncolinear 情况，因此该函数直接返回。 Charge::init_rho() 我们考虑 calculation = 'scf' 的情况，且 init_chg 为默认值 'atomic'，则在 Input::Default2() 函数中，init_chg 关键字不会被因 calculation = 'nscf' 等条件的满足自动转换为 init_chg = 'file'， else if (calculation == \"nscf\" || calculation == \"get_S\") { ....//omit other cases.... if (init_chg != \"file\") { init_chg = \"file\"; ModuleBase::GlobalFunc::AUTO_SET(\"init_chg\", init_chg); } } 因此在 Charge::init_rho() 函数中，实际执行操作很简单： void Charge::init_rho(elecstate::efermi& eferm_iout, const ModuleBase::ComplexMatrix& strucFac, const int& nbz, const int& bz) { ....//omit timer if (GlobalV::init_chg == \"atomic\") // mohan add 2007-10-17 { this->atomic_rho(GlobalV::NSPIN, GlobalC::ucell.omega, rho, strucFac, GlobalC::ucell); if (XC_Functional::get_func_type() == 3 || XC_Functional::get_func_type() == 5) { const double pi = 3.141592653589790; const double fact = (3.0 / 5.0) * pow(3.0 * pi * pi, 2.0 / 3.0); for (int is = 0; is rhopw->nrxx; ++ir) { kin_r[is][ir] = fact * pow(std::abs(rho[is][ir]) * GlobalV::NSPIN, 5.0 / 3.0) / GlobalV::NSPIN; } } } } ....// omit other cases #ifdef __MPI this->init_chgmpi(nbz, bz); #endif } Charge::atomic_rho() Charge::atomic_rho() 函数初始化了不同自旋分量的电荷密度。考虑每个原子从赝势中读取电荷密度为$\\rho^\\alpha(\\mathbf{r})$，则所有原子的电荷密度加和为： \\rho(\\mathbf{r})\\equiv\\sum_{\\mathbf{T}}{\\sum_{\\alpha,i}{\\rho^\\alpha(\\mathbf{r}-\\mathbf{\\tau}_{\\alpha,i}-\\mathbf{T})}} 其 Fourier transform： \\rho(\\mathbf{G})=\\frac{1}{\\Omega_\\text{cell}}\\int_{\\Omega_\\text{cell}}{\\rho(\\mathbf{r})e^{-i\\mathbf{G}\\cdot\\mathbf{r}}d\\mathbf{r}} \\rho(\\mathbf{G})=\\frac{1}{\\Omega_\\text{cell}}\\sum_{\\mathbf{T}}\\int_{\\Omega_\\text{cell}}{\\sum_{\\alpha,i}{\\rho^\\alpha(\\mathbf{r}-\\mathbf{\\tau}_{\\alpha,i}-\\mathbf{T})e^{-i\\mathbf{G}\\cdot\\mathbf{r}}}}d\\mathbf{r}^\\prime 令\\mathbf{r}^\\prime+\\mathbf{\\tau}_ {\\alpha,i}\\equiv\\mathbf{r}，并在下文中标记S^\\alpha(\\mathbf{G})\\equiv\\sum_{i}^{n^\\alpha}{e^{-i\\mathbf{G}\\cdot\\mathbf{\\tau}_{\\alpha,i}}}： \\rho(\\mathbf{G})=\\frac{1}{\\Omega_\\text{cell}}\\sum_{\\mathbf{T}}\\int_{\\Omega_\\text{cell}}{\\sum_{\\alpha,i}{\\rho^\\alpha(\\mathbf{r}^\\prime-\\mathbf{T})e^{-i\\mathbf{G}\\cdot(\\mathbf{r}^\\prime+\\mathbf{\\tau}_{\\alpha,i})}}}d\\mathbf{r}^\\prime =\\int_{\\text{all space}}{\\sum_{\\alpha,i}{\\rho^\\alpha(\\mathbf{r}^\\prime)e^{-i\\mathbf{G}\\cdot(\\mathbf{r}^\\prime+\\mathbf{\\tau}_{\\alpha,i})}}}d\\mathbf{r}^\\prime =\\int_{\\text{all space}}{\\sum_{\\alpha,i}{\\rho^\\alpha(\\mathbf{r}^\\prime)e^{-i\\mathbf{G}\\cdot(\\mathbf{r}^\\prime+\\mathbf{\\tau}_{\\alpha,i})}}}d\\mathbf{r}^\\prime =\\sum_\\alpha{(\\int_\\text{all space}{\\rho^\\alpha(\\mathbf{r^\\prime})e^{-i\\mathbf{G}\\cdot\\mathbf{r}^\\prime}}d\\mathbf{r}^\\prime)\\sum_i{e^{-i\\mathbf{G}\\cdot\\mathbf{\\tau}_{\\alpha,i}}}} =\\sum_\\alpha{\\rho^\\alpha(\\mathbf{G})S^\\alpha(\\mathbf{G})} 但对 nspin = 2 和 nspin = 4 的情况要更加复杂： 将\\rho(\\mathbf{G})在每个 processor 上进行 iFFT， void Charge::atomic_rho(const int spin_number_need, const double& omega, double** rho_in, const ModuleBase::ComplexMatrix& strucFac, const UnitCell& ucell) const // Peize Lin refactor 2021.04.08 { ....//omit superposition of atomic charges for (int is = 0; is rhopw->recip2real(&rho_g3d(is, 0), rho_in[is]); // decrete integral here for (int ir = 0; ir rhopw->nrxx; ++ir) ne[is] += rho_in[is][ir]; ne[is] *= omega / (double)this->rhopw->nxyz; #ifdef __MPI Parallel_Reduce::reduce_double_pool(ne[is]); #endif ....//omit things following 之后对 rho_in 进行 scale，GlobalV::nelec 在此处被赋值 →（Introduction to ABACUS: Path to PW calculation - Part 5）。 void Charge::atomic_rho(const int spin_number_need, const double& omega, double** rho_in, const ModuleBase::ComplexMatrix& strucFac, const UnitCell& ucell) const // Peize Lin refactor 2021.04.08 { ....//omit superposition of atomic charges, ifft to realspace saved in rho_in and electron number checking ModuleBase::GlobalFunc::OUT(GlobalV::ofs_warning, \"total electron number from rho\", ne_tot); ModuleBase::GlobalFunc::OUT(GlobalV::ofs_warning, \"should be\", GlobalV::nelec); for (int is = 0; is rhopw->nrxx; ++ir) rho_in[is][ir] = rho_in[is][ir] / ne_tot * GlobalV::nelec; ....//omit timer and return } 其余细节请自行阅读该函数：link。 &#x1F914;批判式思考 Charge::atomic_rho() 函数中，对匿名函数的使用是否合理？ Charge::init_chgmpi() 该函数对每个 processor 分得实空间格点数量进行计算： void Charge::init_chgmpi(const int& nbz, const int& bz) { // NPROC_IN_STOGROUP is 1 as default if (GlobalV::NPROC_IN_STOGROUP % GlobalV::KPAR == 0) {....} else { this->use_intel_pool = false; delete[] rec; rec = new int[GlobalV::NPROC_IN_POOL]; delete[] dis; dis = new int[GlobalV::NPROC_IN_POOL]; const int ncxy = this->rhopw->nx * this->rhopw->ny; for (int ip = 0; ip rhopw->numz[ip] * ncxy; dis[ip] = this->rhopw->startz[ip] * ncxy; } } } Charge::renormalize_rho() void Charge::renormalize_rho(void) { ....//omit outputs const double sr = this->sum_rho(); const double normalize_factor = GlobalV::nelec / sr; for (int is = 0; is \\text{sr}=\\sum_\\omega{\\sum_i^{n_\\text{grid}}{\\rho^\\omega(r_i)\\Delta v}}, \\Delta v=\\frac{\\Omega_\\text{cell}}{n_\\text{grid}}，实际为离散积分。 &#x1F914;批判式思考 寻找在 Charge 类中对离散积分实现的冗余 Potential::init_pot() void Potential::init_pot(int istep, const Charge* chg) { ....//omit timer assert(istep >= 0); // fixed components only calculated in the beginning of SCF this->fixed_done = false; this->update_from_charge(chg, this->ucell_); ....//omit timer and return } Potential::update_from_charge() void Potential::update_from_charge(const Charge* chg, const UnitCell* ucell) { ModuleBase::TITLE(\"Potential\", \"update_from_charge\"); ModuleBase::timer::tick(\"Potential\", \"update_from_charge\"); if (!this->fixed_done) { this->cal_fixed_v(this->v_effective_fixed.data()); this->fixed_done = true; } ....//omit gpu and single precision support this->cal_v_eff(chg, ucell, this->v_effective); ....//omit timer and return } Potential::cal_fixed_v() void Potential::cal_fixed_v(double* vl_pseudo) { ....//omit timer this->v_effective_fixed.assign(this->v_effective_fixed.size(), 0.0); //v_effective_fixed's datatype is std::vector for (size_t i = 0; i components.size(); i++) { //components' datatype is std::vector if (this->components[i]->fixed_mode) { this->components[i]->cal_fixed_v(vl_pseudo); } } ....//omit timer } 即此时将所有 v_effective_fixed 中元素设置为 0。 Potential::cal_v_eff() void Potential::cal_v_eff(const Charge* chg, const UnitCell* ucell, ModuleBase::matrix& v_eff) { ....//omit timer int nspin_current = this->v_effective.nr; int nrxx = this->v_effective.nc; // first of all, set v_effective to zero. this->v_effective.zero_out(); // add fixed potential components // nspin = 2, add fixed components for all // nspin = 4, add fixed components on first colomn for (int i = 0; i v_effective_fixed.data(), this->get_effective_v(i), nrxx); } } // cal effective by every components for (size_t i = 0; i components.size(); i++) { if (this->components[i]->dynamic_mode) this->components[i]->cal_v_eff(chg, ucell, v_eff); } ....//omit timer } 也将 v_effective 中部分元素初始化为 0（对 nspin = 1 或 2，设置所有自旋分量的所有元素为 0，nspin = 4，设置 nspin 第一分量中所有元素为 0）。components 在 potential_new.h 中被声明为 PotBase 的 std::vector 容器，因此对于通过 register 压入的每一种 Potential，其 cal_v_eff() 都会调用不同的派生类实现（cal_v_eff() 在 PotBase 里是虚函数）。 以 Hartree term 举例，cal_v_eff() 计算了 Hartree term energy contribution： void PotHartree::cal_v_eff(const Charge* chg, const UnitCell* ucell, ModuleBase::matrix& v_eff) { v_eff += H_Hartree_pw::v_hartree(*ucell, const_cast(this->rho_basis_), v_eff.nr, chg->rho); return; } ModuleBase::matrix H_Hartree_pw::v_hartree(const UnitCell &cell, ModulePW::PW_Basis *rho_basis, const int &nspin, const double *const *const rho) { ModuleBase::TITLE(\"H_Hartree_pw\", \"v_hartree\"); ModuleBase::timer::tick(\"H_Hartree_pw\", \"v_hartree\"); std::vector> Porter(rho_basis->nmaxgr); const int nspin0 = (nspin == 2) ? 2 : 1; for (int is = 0; is nrxx; ir++) Porter[ir] += std::complex(rho[is][ir], 0.0); } rho_basis->real2recip(Porter.data(), Porter.data()); double ehart = 0.0; std::vector> vh_g(rho_basis->npw); #ifdef _OPENMP #pragma omp parallel for reduction(+:ehart) #endif for (int ig = 0; ig npw; ig++) { if (rho_basis->gg[ig] >= 1.0e-8) { const double fac = ModuleBase::e2 * ModuleBase::FOUR_PI / (cell.tpiba2 * rho_basis->gg[ig]); ehart += (conj(Porter[ig]) * Porter[ig]).real() * fac; vh_g[ig] = fac * Porter[ig]; } } Parallel_Reduce::reduce_double_pool(ehart); ehart *= 0.5 * cell.omega; H_Hartree_pw::hartree_energy = ehart; rho_basis->recip2real(vh_g.data(), Porter.data()); ModuleBase::matrix v(nspin, rho_basis->nrxx); if (nspin == 4) { #ifdef _OPENMP #pragma omp parallel for schedule(static, 512) #endif for (int ir = 0; ir nrxx; ir++) v(0, ir) = Porter[ir].real(); } else { #ifdef _OPENMP #pragma omp parallel for collapse(2) schedule(static, 512) #endif for (int is = 0; is nrxx; ir++) v(is, ir) = Porter[ir].real(); } .... return v; } Symmetry_rho template void ESolver_KS_PW::beforescf(int istep) { .... // Symmetry_rho should behind init_scf, because charge should be initialized first. Symmetry_rho srho; for (int is = 0; is pelec->charge), this->pw_rho, GlobalC::Pgrid, this->symm); } } As long as we can return, we return. ——woshuode 下篇我们将开始解读 beforescf() 之后，即 SCF 过程。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 8 下篇：Introduction to ABACUS: Path to PW calculation - Part 10 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-path10.html":{"url":"develop-path10.html","title":"Introduction to ABACUS: Path to PW calculation - Part 10","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 10 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 10 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Relax_Driver::relax_driver() ESolver_KS::Run() HSolverPW::set_diagethr() 进入迭代，首先以 HSolverPW::set_diagethr() 函数设置能量收敛限（本身并无复杂的原理，因此安排读者自行阅读代码细节（link））。HSolverPW 构造函数（link）已经对 HSolverPW::diag_ethr 由默认值 0.0 赋值为 GlobalV::PW_DIAG_THR，并且回溯 input_conv.cpp（link）以及 input.cpp（link, link），我们可以知道 GlobalV::PW_DIAG_THR 的默认值为 1.0e-2，用户的一般默认值设置为 1.0e-6。因此无论如何对于上述程序块的第 7 行，都判断为真（注意，if 判断中 1.0e-6 是数值层面的0。相较于纯公式推导，数值计算过程中应当注意来自各方面可能的误差来源： Conventional numerical errors due to unawareness: provided by meta-llama2 Division by zero: This is a classic example of a numerical error that can occur when calculating a function like sin(x)/x as x approaches zero. When x is close to zero, the denominator (x) becomes very small, and the numerator (sin(x)) may become very large due to the amplification effect of the sine function near zero. This can cause the computation to overflow or underflow, resulting in a NaN (Not a Number) value. Loss of significance: This occurs when a number becomes too small to be accurately represented by the available floating-point precision. For example, suppose we have two vectors u and v, both with a magnitude of 1.0, but one has a tiny component in the direction of the other. If we subtract the two vectors, the result will be a vector with a magnitude of 0.0, because the difference between the two vectors is smaller than the machine epsilon (the smallest representable number). However, if we then try to normalize this vector, we may find that its length is no longer 0.0, but rather a small positive value, due to roundoff errors. This can cause the vector to appear non-orthogonal, even though it should be orthogonal. Roundoff errors: These occur when a number is rounded to the nearest representable value, either during computation or when storing intermediate results. Rounding errors can accumulate over time, especially when performing repeated operations, and can eventually cause significant errors in the final result. For example, suppose we compute the dot product of two vectors using the formula dot(u,v) = u_1v_1 + u_2v_2 + ... + u_n*v_n. If any of the components of u or v are very small, roundoff errors may cause the computed dot product to differ significantly from the actual value. Cancellation errors: These occur when two nearly equal quantities are subtracted, resulting in a much smaller quantity. For example, suppose we compute the difference between two very large vectors, one of which has a slightly larger magnitude than the other. The subtraction operation may cancel out most of the digits, leaving behind only a few significant figures. This can cause the result to be very small, even though the original vectors were very large. Overflow and underflow: These occur when a computation produces a result that exceeds the maximum or minimum representable value of the available floating-point format. For example, suppose we compute the sum of two very large vectors using the formula sum = u + v. If the sum exceeds the maximum representable value, it will wrap around to a very small value, potentially causing significant errors in downstream computations. Similarly, if the sum is negative and exceeds the minimum representable value in absolute value, it will also wrap around to a very small value. Truncation errors: These occur when an intermediate result is truncated to fit within the available precision, causing the final result to differ from the exact value. For example, suppose we compute the square root of a number using a binary search algorithm that requires us to repeatedly divide the range of possible values in half until we find the correct interval containing the square root. If the range of possible values is very large, we may need to perform many iterations of the algorithm before finding the correct interval, and each iteration will introduce a small amount of truncation error. Over time, these errors can add up and cause the final result to differ significantly from the exact value. Aliasing: This occurs when a periodic function is sampled at a rate that is not sufficient to capture its full frequency content. For example, suppose we compute the discrete Fourier transform of a periodic function using a finite number of samples. If the sampling rate is not high enough, aliasing effects may cause the reconstructed function to contain spurious features or artifacts that do not correspond to the underlying physical phenomenon. Numerical instability: This occurs when a computation involves very large or very small numbers, or when the computation involves unstable mathematical operations like division by zero or taking the inverse of a very small number. Unstable computations can cause the result to vary widely depending on slight changes in the input parameters or intermediate results, leading to non-deterministic or chaotic behavior. An example of numerical instability is the Lorenz attractor, which exhibits chaotic behavior for certain parameter values despite being derived from simple, deterministic equations ），HSolverPW::diag_ethr = 1.0e-2，到达流程图的下一部分。 ESolver_KS_PW::eachiterinit() template void ESolver_KS::Run(const int istep, UnitCell& ucell) { .... for (int iter = 1; iter maxniter; ++iter) { .... eachiterinit(istep, iter); .... template void ESolver_KS_PW::eachiterinit(const int istep, const int iter) { if (iter == 1) this->p_chgmix->reset(); this->pelec->f_en.deband_harris = this->pelec->cal_delta_eband(); //(2) save change density as previous charge, // prepared fox mixing. if (GlobalV::MY_STOGROUP == 0) { this->pelec->charge->save_rho_before_sum_band(); } } p_chgmix 为 ESolver_KS 的数据成员，已经在构造函数中被初始化（link），且 mixing_mode, mixing_beta, mixing_ndim, mixing_gg0, mixing_tau 已经根据 Input 类赋值（默认值或用户给定），其数据成员 rhopw 也已赋值 pw_rho。 Charge_Mixing::reset() 函数重置四个数据成员： void Charge_Mixing::reset() // Peize Lin add 2018-11-01 { this->new_e_iteration = true; irstep = 0; idstep = 0; totstep = 0; ....//omit irrelevant conditions } ElecState::cal_delta_eband() double ElecState::cal_delta_eband() const { .... return deband0; // is \\Delta E in the following formulation } 此处涉及到具体且比较复杂的计算，我们此处只阐明原理，读者之后可以根据原理来对比代码（link）进行理解。 Harris functional E^{\\mathrm{Harris}}\\left[ \\rho ^{\\mathrm{in}} \\right] =\\sum_i{n_{\\mathrm{i}}^{\\mathrm{out}}\\langle \\psi _{\\mathrm{i}}^{\\mathrm{out}}|\\hat{H}^{\\mathrm{in}}|\\psi _{\\mathrm{i}}^{\\mathrm{out}}\\rangle}-\\frac{1}{2}\\iint{\\mathrm{d}\\mathbf{r}\\mathrm{d}\\mathbf{r}^{\\prime}\\frac{\\rho ^{\\mathrm{in}}\\left( \\mathbf{r} \\right) \\rho ^{\\mathrm{in}}\\left( \\mathbf{r}^{\\prime} \\right)}{|\\mathbf{r}-\\mathbf{r}^{\\prime}|}}+\\int{\\mathrm{d}\\mathbf{r}\\left( \\epsilon _{\\mathrm{xc}}^{\\mathrm{in}}\\left( \\mathbf{r} \\right) -v_{\\mathrm{xc}}^{\\mathrm{in}}\\left( \\mathbf{r} \\right) \\right) \\rho ^{\\mathrm{in}}\\left( \\mathbf{r} \\right)}+\\sum_{I Non-meta-GGA functional, nspin != 4 case \\Delta E=-\\frac{\\Omega _{\\mathrm{cell}}}{\\sum_p{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}}\\sum_{\\omega}^{\\alpha ,\\beta}{\\sum_i^{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}{\\{[V_{\\mathrm{eff}}^{\\omega}(r_i)-V_{\\mathrm{fixed}}(r_i)]\\rho ^{\\omega}(r_i)\\}}}-2E_{\\mathrm{xx}} (discrete form) \\Delta E=-\\int_{\\Omega _{\\mathrm{cell}}}{d\\mathbf{r}\\int{d\\omega}(V_{\\mathrm{eff}}[\\rho]-V_{\\mathrm{fixed}}[\\rho])\\rho (\\mathbf{r},\\omega )}-2E_{\\mathrm{xx}} (continuous form) Meta-GGA functional, nspin != 4 case \\Delta E=-\\frac{\\Omega _{\\mathrm{cell}}}{\\sum_p{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}}\\sum_{\\omega}^{\\alpha ,\\beta}{\\sum_i^{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}{\\{[V_{\\mathrm{eff}}^{\\omega}(r_i)-V_{\\mathrm{fixed}}(r_i)]\\rho ^{\\omega}(r_i)+\\tau ^{\\omega}(r_i)V_{\\mathrm{ofk}}^{\\omega}(r_i)\\}}}-2E_{\\mathrm{xx}} (discrete form) \\Delta E=-\\int_{\\Omega _{\\mathrm{cell}}}{\\mathrm{d}\\mathbf{r}\\int{\\mathrm{d}\\omega (V_{\\mathrm{eff}}[\\rho]-V_{\\mathrm{fixed}}[\\rho])\\rho (\\mathbf{r},\\omega )+\\tau (\\mathbf{r},\\omega )V_{\\mathrm{ofk}}(\\mathbf{r})}}-2E_{\\mathrm{xx}} (continuous form) Non-meta-GGA functional, nspin = 4 case \\Delta E=-\\frac{\\Omega _{\\mathrm{cell}}}{\\sum_p{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}}\\left[ \\sum_i^{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}{\\left( \\sum_{\\omega}^4{V_{\\mathrm{eff}}^{\\omega}(r_i)\\rho ^{\\omega}(r_i)} \\right) -V_{\\mathrm{fixed}}(r_i)\\rho ^0(r_i)} \\right] -2E_{\\mathrm{xx}} (discrete form) Meta-GGA functional, nspin = 4 case \\Delta E=-\\frac{\\Omega _{\\mathrm{cell}}}{\\sum_p{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}}\\left[ \\sum_i^{n_{\\mathrm{grid}}^{\\mathrm{rs}}(p)}{\\left( \\sum_{\\omega}^4{V_{\\mathrm{eff}}^{\\omega}(r_i)\\rho ^{\\omega}(r_i)} \\right) -V_{\\mathrm{fixed}}(r_i)\\rho ^0(r_i)+\\tau ^0(r_i)V_{\\mathrm{ofk}}^{0}(r_i)} \\right] -2E_{\\mathrm{xx}} (discrete form) , where \\tau ^{\\omega}(r_i)\\equiv \\frac{1}{2}\\sum_i^{\\mathrm{occ}}{\\left( \\nabla \\psi _i\\left( r_i \\right) \\right) ^2} is the kinetic energy density mapped on realspace grid (kin_r), n_{\\mathrm{grid}}^{\\mathrm{rs}}(p) is the number of grid points in realspace (\\text{rs}) distributed on processor p。 (source code link) Charge::save_rho_before_sum_band() 此函数备份电荷密度 rho，当使用 meta-GGA 时，同时备份动能密度 kin_r： void Charge::save_rho_before_sum_band(void) { for (int is = 0; is rhopw->nrxx); if (elecstate::get_xc_func_type() == 3 || elecstate::get_xc_func_type() == 5) ModuleBase::GlobalFunc::DCOPY(kin_r[is], kin_r_save[is], this->rhopw->nrxx); } return; } ESolver_KS_PW::hamilt2density() 然后来到 SCF 迭代的主体——对角化。hamilt2density 即为 Hamiltonian to electron density，从固定的 Hamiltonian 矩阵到新的电荷密度信息。hamilt2density() 函数的主体梗概如下： template void ESolver_KS_PW::hamilt2density(const int istep, const int iter, const double ethr) { if (this->phsol != nullptr) { this->pelec->f_en.eband = 0.0; this->pelec->f_en.demet = 0.0; if ((istep == 0 || istep == 1) && iter == 1) { hsolver::DiagoIterAssist::need_subspace = false; } else { hsolver::DiagoIterAssist::need_subspace = true; } hsolver::DiagoIterAssist::PW_DIAG_THR = ethr; hsolver::DiagoIterAssist::PW_DIAG_NMAX = GlobalV::PW_DIAG_NMAX; this->phsol->solve(this->p_hamilt, this->kspw_psi[0], this->pelec, GlobalV::KS_SOLVER); .... } 不难发现 phsol（pointer to HSolver）所调用其成员函数 solve() 一定是对角化的主体，HSolver 其顾名思义为 Hamiltonian 矩阵的求解器。针对具体的软件编写，我们关心在对角化过程中，究竟需要哪些（哪类）变量。最小地，我们对于 general 的对角化问题最统一的预想为仅仅需要 Hamiltonian 矩阵自身，ABACUS 的方案为： p_hamilt: HamiltPW: Introduction to ABACUS: Path to PW calculation - Part 9，Hamiltonian 的 handle（指针为 handle 实现的实体） kspw_psi: Psi: Introduction to ABACUS: Path to PW calculation - Part 7，Kohn-Sham planewave wavefunction 的 handle，同样指针是 handle 实现实体 pelec: ElecState: Introduction to ABACUS: Path to PW calculation - Part 9，电子态 handle &#x1F914;为了明天 寻找可能存在的变量冗余！ HSolverPW::solve() HSolverPW::solve() 中编写了 HamiltSolvePsiK() 函数的主功能，在 solve 之后则仅仅为能隙的计算。 template void ESolver_KS_PW::hamilt2density(const int istep, const int iter, const double ethr) { .... this->phsol->solve(this->p_hamilt, this->kspw_psi[0], this->pelec, GlobalV::KS_SOLVER); .... } 根据早先的总结，ABACUS 的并行策略应当如图所示： 按照 GlobalV::KPAR 确定并行池数量 每个并行池同时处理 1 个 k 点的计算任务 在 pool 中的 processor，则按照原先分发策略，分别按照实空间和到空间进行并行计算。 作为平行比较，Quantum ESPRESSO 官方不仅提供了更加灵活和精细的并行策略，也提供了基本的教学文档： https://www.quantum-espresso.org/Doc/user_guide/node18.html template void HSolverPW::solve(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, elecstate::ElecState* pes, const std::string method_in, const bool skip_charge) { ....//omit timer this->precondition.resize(psi.get_nbasis()); this->method = method_in; this->initDiagh(); std::vector eigenvalues(pes->ekb.nr * pes->ekb.nc, 0); for (int ik = 0; ik wfc_basis->nks; ++ik) { pHamilt->updateHk(ik); this->updatePsiK(pHamilt, psi, ik); update_precondition(precondition, ik, this->wfc_basis->npwk[ik]); this->hamiltSolvePsiK(pHamilt, psi, eigenvalues.data() + ik * pes->ekb.nc); if(skip_charge) { ....//omit output DiagoIterAssist::avg_iter = 0.0; } } castmem_2d_2h_op()(cpu_ctx, cpu_ctx, pes->ekb.c, eigenvalues.data(), pes->ekb.nr * pes->ekb.nc); this->endDiagh(); if(skip_charge) {....} reinterpret_cast*>(pes)->psiToRho(psi); ....//omit timer and return } 图 1. parallelization over kpoints 图 2. parts on which we are concentrated now HSolverPW::initDiagh() 初始化对角化 template void HSolverPW::initDiagh() { if (this->method == \"cg\") { if(this->pdiagh!=nullptr) { if(this->pdiagh->method != this->method) { delete (DiagoCG*)this->pdiagh; this->pdiagh = new DiagoCG(precondition.data()); this->pdiagh->method = this->method; } } else { this->pdiagh = new DiagoCG(precondition.data()); this->pdiagh->method = this->method; } } else if (this->method == \"dav\") { DiagoDavid::PW_DIAG_NDIM = GlobalV::PW_DIAG_NDIM; if (this->pdiagh != nullptr) { if (this->pdiagh->method != this->method) { delete (DiagoDavid*)this->pdiagh; this->pdiagh = new DiagoDavid(precondition.data()); this->pdiagh->method = this->method; } } else { this->pdiagh = new DiagoDavid( precondition.data()); this->pdiagh->method = this->method; } } else {....} } 若 pdiagh 已经存在，且 diagonalization_method 一致，do nothing，若不一致，delete, new 为当前 method。若 pdiagh 不存在，则按照 method new 相应 method 对应类内存空间。new 具有一致的形式。 图 3. PW和LCAO的代码设计平行关系与调用 HamiltPW::updateHk() and Operator::init() template void HSolverPW::solve(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, elecstate::ElecState* pes, const std::string method_in, const bool skip_charge) { ....//omit timer and previous lines for (int ik = 0; ik wfc_basis->nks; ++ik) { pHamilt->updateHk(ik); template void HamiltPW::updateHk(const int ik) { ModuleBase::TITLE(\"HamiltPW\",\"updateHk\"); this->ops->init(ik); ModuleBase::TITLE(\"HamiltPW\",\"updateHk\"); } template void Operator::init(const int ik_in) { this->ik = ik_in; if(this->next_op != nullptr) this->next_op->init(ik_in); } ik 实参为 k point index，因此最后是将 k point index 赋予每一个 Operator 的 this->ik 数据成员。回忆此操作，实际上建立在 GlobalV::KPAR 的基础上，KPAR 决定同时有多少 k 点并行。要求是 nproc/KPAR > 1，因此实际每个 processor 上不会同时存在多于 1 个 k 点，即同一个 processor 上不存在 Operator 被赋予不同 ik 值的情况。这一操作使得H(\\mathbf{k})的\\mathbf{k}获得更新。 更具体而言，根据每个 processor 上 k 点数量（归约后）nks，可以访问 k vector 的具体坐标，see：Introduction to ABACUS: Path to PW calculation - Part 5 ，即在H(\\mathbf{k})和具体的\\mathbf{k}之间联系实际也有存储。 图 4. Relationship between variables that matter presently HSolverPW::updatePsiK() template void HSolverPW::solve(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, elecstate::ElecState* pes, const std::string method_in, const bool skip_charge) { ....//omit timer and previous lines for (int ik = 0; ik wfc_basis->nks; ++ik) { .... this->updatePsiK(pHamilt, psi, ik); template void HSolverPW::updatePsiK(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, const int ik) { psi.fix_k(ik); if(!this->initialed_psi) { if(GlobalV::BASIS_TYPE==\"pw\") { hamilt::diago_PAO_in_pw_k2(this->ctx, ik, psi, this->wfc_basis, this->pwf, pHamilt); } else {....} } } Psi::fix_k() template void Psi::fix_k(const int ik) const { assert(ik >= 0); this->current_k = ik; if (this->ngk != nullptr && this->npol != 2) this->current_nbasis = this->ngk[ik]; else this->current_nbasis = this->nbasis; this->current_b = 0; if (ik >= this->nk) // this k point is not in present pool { // mem_saver case this->psi_current = const_cast(&(this->psi[0])); this->psi_bias = 0; } else { this->psi_current = const_cast(&(this->psi[ik * this->nbands * this->nbasis])); this->psi_bias = ik * this->nbands * this->nbasis; } } fix_k()函数锁定了当前的 k 点，使得 psi_current 指向当前 psi 一维数组中的正确位置。此处用到了 Psi::ngk 和 Psi::npol 值，这两值曾经出现在 Psi 构造函数中： template Psi::Psi(int nk_in, int nbd_in, int nbs_in, const int* ngk_in) { this->ngk = ngk_in; this->current_b = 0; this->current_k = 0; this->npol = GlobalV::NPOL; this->device = device::get_device_type(this->ctx); this->resize(nk_in, nbd_in, nbs_in); // Currently only GPU's implementation is supported for device recording! device::print_device_info(this->ctx, GlobalV::ofs_device); device::record_device_memory(this->ctx, GlobalV::ofs_device, \"Psi->resize()\", sizeof(T) * nk_in * nbd_in * nbs_in); } 我们的 psi 相关参数设定是在 wavefunc::allocate() 函数（link），即： psi::Psi> *wavefunc::allocate(const int nks, const int *ngk, const int npwx_in) { ... else { // initial psi rather than evc psi_out = new psi::Psi>(nks2, GlobalV::NBANDS, npwx * GlobalV::NPOL, ngk); const size_t memory_cost = nks2 * GlobalV::NBANDS*(GlobalV::NPOL*npwx) * sizeof(std::complex); std::cout Psi::npol 所取 GlobalV::NPOL 则在 input_conv.cpp 中可以找到： if (INPUT.noncolin || INPUT.lspinorb) { GlobalV::NSPIN = 4; } if (GlobalV::NSPIN == 4) { GlobalV::NONCOLIN = INPUT.noncolin; // wavefunctions are spinors with 2 components GlobalV::NPOL = 2; // set the domag variable to make a spin-orbit calculation with zero magnetization GlobalV::DOMAG = false; GlobalV::DOMAG_Z = true; GlobalV::LSPINORB = INPUT.lspinorb; GlobalV::soc_lambda = INPUT.soc_lambda; .... } else { GlobalV::LSPINORB = false; GlobalV::NONCOLIN = false; GlobalV::DOMAG = false; GlobalV::DOMAG_Z = false; GlobalV::NPOL = 1; } hamilt::diago_PAO_in_pw_k2() 接下来到达 HSolverPW::updatePsiK() 调用的第二个函数。 template void HSolverPW::updatePsiK(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, const int ik) { .... if(!this->initialed_psi) { if(GlobalV::BASIS_TYPE==\"pw\") { hamilt::diago_PAO_in_pw_k2(this->ctx, ik, psi, this->wfc_basis, this->pwf, pHamilt); } else {....} } } void diago_PAO_in_pw_k2(const int &ik, psi::Psi> &wvf, ModulePW::PW_Basis_K *wfc_basis, wavefunc *p_wf, hamilt::Hamilt *phm_in) { ModuleBase::TITLE(\"wavefunc\",\"diago_PAO_in_pw_k2\"); const int starting_nw = p_wf->get_starting_nw(); if(starting_nw == 0) return; assert(starting_nw > 0); std::vector etatom(starting_nw, 0.0); const int nbasis = wvf.get_nbasis(); const int nbands = wvf.get_nbands(); const int current_nbasis = wfc_basis->npwk[ik]; if( p_wf->init_wfc==\"random\" || ( p_wf->init_wfc.substr(0,6)==\"atomic\" && GlobalC::ucell.natomwfc == 0 )) { p_wf->random(wvf.get_pointer(),0,nbands,ik, wfc_basis); if(GlobalV::KS_SOLVER==\"cg\") { if(phm_in!= nullptr) { hsolver::DiagoIterAssist::diagH_subspace(phm_in, wvf, wvf, etatom.data()); return; } else ModuleBase::WARNING_QUIT(\"wavefunc\",\"Hamiltonian does not exist!\"); } } else if(p_wf->init_wfc.substr(0,6)==\"atomic\") { ModuleBase::ComplexMatrix wfcatom(starting_nw, nbasis); if(GlobalV::test_wf)ModuleBase::GlobalFunc::OUT(GlobalV::ofs_running, \"starting_nw\", starting_nw); p_wf->atomic_wfc(ik, current_nbasis, GlobalC::ucell.lmax_ppwf, wfc_basis, wfcatom, GlobalC::ppcell.tab_at, GlobalV::NQX, GlobalV::DQ); if (p_wf->init_wfc == \"atomic+random\" && starting_nw == GlobalC::ucell.natomwfc) { p_wf->atomicrandom(wfcatom, 0, starting_nw, ik, wfc_basis); } p_wf->random(wfcatom.c, GlobalC::ucell.natomwfc, nbands, ik, wfc_basis); if(GlobalV::KS_SOLVER==\"cg\") { if(phm_in!= nullptr) { hsolver::DiagoIterAssist::diagH_subspace_init(phm_in, wfcatom.c, wfcatom.nr, wfcatom.nc, wvf, etatom.data()); return; } else ModuleBase::WARNING_QUIT(\"wavefunc\",\"Hamiltonian does not exist!\"); } assert(nbands 且此操作遍历 k 点。 &#x1F914;家庭作业 我们不打算花费太多时间在波函数初始化这个议题上，但是仍然推荐你自主阅读它！仔细看看有时候你搬弄的 starting_wfc/init_wfc/scf_guess 关键词背后到底是怎么运行的吧！ HSolverPW::update_precondition() template void HSolverPW::solve(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, elecstate::ElecState* pes, const std::string method_in, const bool skip_charge) { ....//omit timer and previous lines for (int ik = 0; ik wfc_basis->nks; ++ik) { .... update_precondition(precondition, ik, this->wfc_basis->npwk[ik]); template void HSolverPW::update_precondition(std::vector &h_diag, const int ik, const int npw) { h_diag.assign(h_diag.size(), 1.0); int precondition_type = 2; const auto tpiba2 = static_cast(this->wfc_basis->tpiba2); if (precondition_type == 1) { for (int ig = 0; ig (this->wfc_basis->getgk2(ik,ig)) * tpiba2; h_diag[ig] = std::max(static_cast(1.0), g2kin); } } else if (precondition_type == 2) { for (int ig = 0; ig (this->wfc_basis->getgk2(ik,ig)) * tpiba2; h_diag[ig] = 1 + g2kin + sqrt(1 + (g2kin - 1) * (g2kin - 1)); } } if(GlobalV::NSPIN==4) { const int size = h_diag.size(); for (int ig = 0; ig 对角化时的 preconditioner 一般兼具数学和数值计算的 trick，因此我们只观察其形式而不做过多解读。 Preconditioner of CG diagonalization method: PreconditionerCGDiag.pdf Preconditioner of Davidson diagonalization method: PreconditionerDavidsonDiag.pdf HSolverPW::hamiltSolvePsiK() template void HSolverPW::solve(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, elecstate::ElecState* pes, const std::string method_in, const bool skip_charge) { .... for (int ik = 0; ik wfc_basis->nks; ++ik) { .... // each column corresponds to one energy band, row corresponds to k point. Therefore it // is ekb[ikpoint][iband], see declaration in CLASS elecstate std::vector eigenvalues(pes->ekb.nr * pes->ekb.nc, 0); .... /// solve eigenvector and eigenvalue for H(k), nr, nc are number of rows and columns this->hamiltSolvePsiK(pHamilt, psi, eigenvalues.data() + ik * pes->ekb.nc); .... } template void HSolverPW::hamiltSolvePsiK(hamilt::Hamilt* hm, psi::Psi, Device>& psi, FPTYPE* eigenvalue) { this->pdiagh->diag(hm, psi, eigenvalue); } 回忆刚刚在 initDiagh 函数中，根据不同的对角化方法，pdiagh 被分配不同派生类的内存空间（因此 pdiagh 很可能一开始被声明为 DiagH 基类指针，diag 可能在基类中被声明为纯虚函数）。这里我们跟随 Davidson 方法，因此 pdiag 的 diag 方法实际为 DiagoDavid::diag()。 DiagoDavid::diag() template void DiagoDavid::diag(hamilt::Hamilt* phm_in, psi::Psi, Device>& psi, FPTYPE* eigenvalue_in) { /// record the times of trying iterative diagonalization int ntry = 0; this->notconv = 0; #if defined(__CUDA) || defined(__ROCM) if (this->device == psi::GpuDevice) { resmem_var_op()(this->ctx, this->d_precondition, psi.get_nbasis()); syncmem_var_h2d_op()(this->ctx, this->cpu_ctx, this->d_precondition, this->precondition, psi.get_nbasis()); } #endif do { this->diag_mock(phm_in, psi, eigenvalue_in); ++ntry; } while (DiagoIterAssist::test_exit_cond(ntry, this->notconv)); if (notconv > std::max(5, psi.get_nbands() / 4)) { std::cout notconv; std::cout DiagoDavid::diag_mock()与 ABACUS-BLAS, LAPACK interfaces Source code link: https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_hsolver/diago_david.cpp#L49 图 5. Higher resolution framework of diag_mock() and relationship with other modules and functions &#x1F527;重构信息 diag_mock() will be renamed as diag_once() in the future &#x1F914;复习 Try to recall all details introduced from Part.1 to now as many as possible! In Driver::reading(), it is where Input::Default(), Read() and Default_2(), Input_conv::Convert() are called. From then on, we have parameters defined both from user input and default. In Driver::atomic_world(), it is where real space grid and planewave distributed. Remember ESolver driven the creation and initialization of pw_rho, pw_wfc? PW_Basis and PW_Basis_K? setuptransform(), initgrids(), distribute_r() and _g()? In UnitCell::setup_cell(), we read atom positions, pseudopotentials and kpoints, then we have (ir)reducible k vector list, and so (k+G) the planewave expanded wavefunction. In present contents, we initialize psi, then construct H|psi>, use HSolver flow to orthogonalize and diagonalize it. 基于上图，我们将选择数个关键点进行说明。 1. 对角化维度（ndim）设定 由于平面波数量众多-> 基函数数量众多-> 待对角化 Hamiltonian 矩阵维度巨大，而真正关心特征值/本征值/本征态数量远小于基函数数量，因此考虑使用子空间方法迭代求解其中能量最低的 n 个特征值/特征向量，而非一次性计算全部。由于子空间对角化方法的特性，实际需要对角化的子空间维度比用户所需能带数量要多（ndim 倍），ndim 被设计为用户设定参数： nbasis: Introduction to ABACUS: Path to PW calculation - Part 7 : npwx*GlobalV::NPOL, npwx: maximal number of planewaves among all kpoints, for non-noncolinear cases, GlobalV::NPOL is 1, otherwise is 2. ngk: Introduction to ABACUS: Path to PW calculation - Part 6 current_nbasis: ngk[ik] or nbasis ABACUS Quantum ESPRESSO 在 ABACUS 中，首先对角化子空间维数为 nbnd，若有部分本征值无法收敛，则使子空间维数递增，直到子空间维数增至 ndim*nbnd，然后重新开始计算 Hamiltonian 矩阵（refresh()，保留最初始 psi，即 ndim≥2 必须满足，从 dim=2 开始覆盖），直到达到最大迭代次数或收敛。 2. hpsi_info 在对角化之前，确认被对角化的对象具体形式十分重要。hpsi_info 存储 hpsi 操作后的数据，出现于 template void DiagoDavid::diag_mock(hamilt::Hamilt* phm_in, psi::Psi, Device>& psi, FPTYPE* eigenvalue_in) { .... /// initialize H|psi>... hpsi_info dav_hpsi_in(&basis, psi::Range(1, 0, 0, this->n_band - 1), this->hphi); // pack up |psi>, range (for finding psi on present processor), and H|psi> phm_in->ops->hPsi(dav_hpsi_in); this->cal_elem(this->dim, nbase, this->notconv, basis, this->hphi, this->sphi, this->hcc, this->scc); this->diag_zhegvx(nbase, this->n_band, this->hcc, this->scc, this->nbase_x, this->eigenvalue, this->vcc); .... hpsi_info 的设计非常类似于裸露的，具有迭代器的数据结构，其中迭代器实际来源于 psi::range 这一 psi namespace 中名为 range 的结构体的支持。更加具体而言： a. hpsi_info定义封装 //source/module_hamilt_pwdft/operator_pw/operator_pw.h /// @brief short name of type hamilt::Operator, Device>::hpsi_info, which is a tuple std::tuple*, const psi::Range, FPTYPE*> /// @param Psi const psi::Psi* /// @param Range const psi::Range, a struct in namespace psi, contains information about range, see source/module_psi/psi.h /// @param FPTYPE* pointer to the memory of hpsi /// @note in PW code, different operators donate hPsi independently. run this->act function for the first operator and run all act() for other nodes in chain table using hpsi_info = typename hamilt::Operator, Device>::hpsi_info; b. hpsi_info定义 //source/module_hamilt_general/operator.h typedef std::tuple*, const psi::Range, FPTYPE*> hpsi_info; virtual hpsi_info hPsi(hpsi_info& input)const; c. psi与其赝迭代器range：psi::Psi::psi的多维数组存储 d. hpsi_info的调用方式 template typename OperatorPW::hpsi_info OperatorPW::hPsi( hpsi_info& input) const { ModuleBase::timer::tick(\"OperatorPW\", \"hPsi\"); auto psi_input = std::get(input); std::tuple*, int> psi_info = psi_input->to_range(std::get(input)); int n_npwx = std::get(psi_info); // number of bands or k-points, as explained std::complex *tmhpsi = this->get_hpsi(input); const std::complex *tmpsi_in = std::get(psi_info); if(tmpsi_in == nullptr) { ModuleBase::WARNING_QUIT(\"OperatorPW\", \"please choose correct range of psi for hPsi()!\"); } this->act(psi_input, n_npwx, tmpsi_in, tmhpsi); OperatorPW* node((OperatorPW*)this->next_op); while(node != nullptr) { node->act(psi_input, n_npwx, tmpsi_in, tmhpsi); node = (OperatorPW*)(node->next_op); } ModuleBase::timer::tick(\"OperatorPW\", \"hPsi\"); std::complex* hpsi_pointer = std::get(input); if(this->in_place) { syncmem_complex_op()(this->ctx, this->ctx, hpsi_pointer, this->hpsi->get_pointer(), this->hpsi->size()); delete this->hpsi; this->hpsi = new psi::Psi, Device>(hpsi_pointer, *psi_input, 1, n_npwx/psi_input->npol); } hpsi return hpsi_info(this->hpsi, psi::Range(1, 0, 0, n_npwx/psi_input->npol), hpsi_pointer); } std::get() 方法可以从 tuple 容器里提取相应位置的元素（以引用方式）。 3. 线性代数相关操作 遍布 SchmidtOrth、calc_elem、diag_zhegvx、calc_grad、refresh 和 diag_mock 本体，其中存在很多类似于 BLAS 和 LAPACK 数学库中操作（矢量、矩阵）的命名方式，例如 gemm_op、gemv_op 等。同样地，如此组织操作，是为了尽可能支持模板偏特化。举例来讲，gemm 为 general matrix-matrix multiplication，gemv 则为 general matrix-vector multiplication，更多的使用方式见 BLAS quick reference 以及 LAPACK online documentation（https://www.netlib.org/lapack/explore-html/index.html）：BlasQuickReference.pdf &#x1F527;重构信息 Present Gram-Schmidt orthogonalization need to optimize both for numerical accurancy and performance reasons. &#x1F527;重构信息 Interfaces between ABACUS and basic math libraries like BLAS, LAPACK are ill-designed &#x1F616;, see: https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_hsolver/kernels/math_kernel_op.cpp https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_hsolver/kernels/dngvd_op.cpp For a better design and implementation, see Armadillo Linear Algebra library (https://arma.sourceforge.net/): \\armadillo-12.6.3\\include\\armadillo_bits\\mul_gemm.hpp:line 245 Consider carefully about what can be avoided to expose to developers who only care about the use but not the mechanism of those math libraries. &#x1F527;重构信息 On-going plan: interfaces between ABACUS and basic math libraries will be refactorized for heterogeneous programming (GPU support) 4/. 实际对角化过程 &#x1F914;批判性思考 你认为把 math_kernel_ops.cpp 和.h 文件放在目录 source/module_hsolver/kernels/下是合理的吗？如果不是，哪里可能是更好的选择呢？ 5/. diag_mock()循环结束 if (!this->notconv || (nbase + this->notconv > this->nbase_x) || (dav_iter == DiagoIterAssist::PW_DIAG_NMAX)) { ....//omit timer and comments setmem_complex_op()(this->ctx, psi.get_pointer(), 0, n_band * this->dmx); //()(this->ctx, // fortran-stype comments 'N', 'N', this->dim, // m: row of A,C this->n_band, // n: col of B,C nbase, // k: col of A, row of B this->one, basis.get_pointer(), // A dim * nbase this->dim, this->vcc, // B nbase * n_band this->nbase_x, this->zero, psi.get_pointer(), // C dim * n_band this->dmx ); if (!this->notconv || (dav_iter == DiagoIterAssist::PW_DIAG_NMAX)) { ....//omit timer and comments break; } DiagoCG 概览 在 Conjugated Gradient（共轭梯度法，CG）法中，我们也首先进行 band-by-band matrix 的对角化： \\mathbf{C}^{\\mathbf{\\dagger }}\\mathbf{H}(\\mathbf{G}_1,\\mathbf{G}_2)\\mathbf{C}，其中\\mathbf{H}为以 pw 表象的 Hamiltonian 矩阵： H_{ij}=\\langle \\mathbf{G}_i|\\hat{H}|\\mathbf{G}_j\\rangle \\\\ =\\int{e^{-i\\mathbf{G}_i\\cdot \\mathbf{r}}\\hat{H}e^{i\\mathbf{G}_j\\cdot \\mathbf{r}}\\mathrm{d}\\mathbf{r}} \\\\ =\\delta _{ij}\\frac{1}{2}|\\mathbf{G}_i|^2+V\\left( |\\mathbf{G}_i-\\mathbf{G}_j| \\right) psi 存储的即为$\\mathbf{C}$。我们得到 psi 后，使用 CG 方法 line-by-line（band-by-band）进行 CG 法优化能量，同时保持 line 之间正交。 HSolverPW::endDiagh() 在离开对角化之前，我们仍然有一些细节需要注意。首先再次阅读 HSolverPW::solve() 的 k 点循环部分： template void HSolverPW::solve(hamilt::Hamilt* pHamilt, psi::Psi, Device>& psi, elecstate::ElecState* pes, const std::string method_in, const bool skip_charge) { .... this->initDiagh(); std::vector eigenvalues(pes->ekb.nr * pes->ekb.nc, 0); for (int ik = 0; ik wfc_basis->nks; ++ik) { pHamilt->updateHk(ik); this->updatePsiK(pHamilt, psi, ik); update_precondition(precondition, ik, this->wfc_basis->npwk[ik]); this->hamiltSolvePsiK(pHamilt, psi, eigenvalues.data() + ik * pes->ekb.nc); .... } castmem_2d_2h_op()(cpu_ctx, cpu_ctx, pes->ekb.c, eigenvalues.data(), pes->ekb.nr * pes->ekb.nc); this->endDiagh(); // eigenvalues std::vector 申请内存空间实际为一扁平化二维数组，每个 k 点写入一个批次的本征值数据且平移指针到相应位置，psi 则在每次调用 HSolverPW::updatePsiK() 的时候移动指针，到 psi 扁平化三维数组中对应 k 点位置的能带-基函数起始位置。 k 点循环结束后，将 eigenvalues 的数据赋值给 pes（pointer to elecstate）的 ekb（energies of kpoint-band）数据成员，然后调用 HSolverPW::endDiagh() 函数，删除对角化指针 pdiag: template void HSolverPW::endDiagh() { if(this->method == \"cg\") {....} if(this->method == \"dav\") { delete (DiagoDavid*)this->pdiagh; this->pdiagh = nullptr; } if(DiagoIterAssist::avg_iter > 0.0) { GlobalV::ofs_running::avg_iter / this->wfc_basis->nks ::PW_DIAG_THR::avg_iter = 0.0; } //psi only should be initialed once for PW if(!this->initialed_psi) { this->initialed_psi = true; } } HSolverPW::solve() 函数中最后还调用了 ElecStatePW::psiToRho() 函数，顾名思义该函数将输出新的电荷密度 rho。考虑到这个函数调用了众多子函数，我们将该函数留到下一篇。 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 9 下篇：Introduction to ABACUS: Path to PW calculation - Part 11 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-path11.html":{"url":"develop-path11.html","title":"Introduction to ABACUS: Path to PW calculation - Part 11","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Part 11 作者：黄一珂，邮箱：huangyk@aisi.ac.cn；金祖鑫，邮箱：jinzx@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Part 11 &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Relax_Driver::relax_driver() ESolver_KS::Run() ESolver_KS_PW::hamilt2density() HSolverPW::solve(): the rest ElecStatePW::psiToRho() 当我们从 HSolverPW::solve() 中追溯 psiToRho() 函数的定义时，我们发现 ElecStateLCAO 和 ElecStatePW 均有该方法的实现，因此查看 ElecState 基类，发现声明为虚函数。回忆在 ESolver_KS_PW 中，Init()函数我们已经将其指明指向派生类对象，see Introduction to ABACUS: Path to PW calculation - Part 7，即此处也使用了基于多态的实现。 &#x1F914;批判式思考 Polymorphism is an important technique in C++ for reducing code duplication and improving code reuse. Consider if polymorphism used here is necessary, share your opinions and ideas! template void ElecStatePW::psiToRho(const psi::Psi, Device>& psi) { if (!this->init_rho) this->init_rho_data(); this->calculate_weights(); this->calEBand(); for(int is=0; isctx, this->rho[is], 0, this->charge->nrxx); if (get_xc_func_type() == 3) { setmem_var_op()(this->ctx, this->kin_r[is], 0, this->charge->nrxx); } } for (int ik = 0; ik updateRhoK(psi); } if (GlobalV::device_flag == \"gpu\" || GlobalV::precision_flag == \"single\") {....} this->parallelK(); .... } 到目前为止，我们已经很难想起 ElecStatePW::init_rho() 是否被置为 true。我们使用“查找所有引用”，发现其只有在 ElecState::init_rho_data() 中被置为 true，而该函数之前从未被调用过（只有 psiToRho() 和 rhoBandK() 调用该函数），因此我们来到 init_rho_data()（简单起见，我们忽略 nspin=4, meta-GGA 泛函的情况） template void ElecStatePW::init_rho_data() { if (GlobalV::device_flag == \"gpu\" || GlobalV::precision_flag == \"single\") {....} else { this->rho = reinterpret_cast(this->charge->rho); if (get_xc_func_type() == 3) {....} } resmem_complex_op()(this->ctx, this->wfcr, this->basis->nmaxgr, \"ElecSPW::wfcr\"); resmem_complex_op()(this->ctx, this->wfcr_another_spin, this->charge->nrxx, \"ElecSPW::wfcr_a\"); this->init_rho = true; } 我们让 ElecState::rho 和 ElecState::charge::rho 两指针指向同一内存区域，之后重置了 wfcr 和 wfcr_another_spin 的内存空间。ElecState::calculate_weights() 函数根据 smearing 方法，重新计算费米能级，并输出每个(k,b)-pair（或(\\text{n},\\mathbf{k})-pair）的权重。此处代码较为简单但冗长，留给感兴趣的读者自行阅读。 void ElecState::calculate_weights() { ....//omit timer if (this->skip_weights) return; int nbands = this->ekb.nc; int nks = this->ekb.nr; if (!Occupy::use_gaussian_broadening && !Occupy::fixed_occupations) { // [out] ef: efermi // [out] wg: weight of (k,b)-pair, for unoccupied band, wg=0, otherwise it is wk[ik] if (GlobalV::TWO_EFERMI) // nspin = 2, uks case { Occupy::iweights(nks, this->klist->wk, nbands, this->nelec_spin[0], this->ekb, this->eferm.ef_up, this->wg, 0, this->klist->isk); ....// omit the other spin counter part } else {....} // nspin = 1, rks case, set parameter behind wg to -1 } else if (Occupy::use_gaussian_broadening) { // Gaussian smearing corrected efermi, wg and demet // [out] ef: efermi // [out] wg: the same // [out] demet: Delta Energy for METal if (GlobalV::TWO_EFERMI) // nspin = 2, uks case { double demet_up = 0.0; double demet_dw = 0.0; Occupy::gweights(nks, this->klist->wk, nbands, this->nelec_spin[0], Occupy::gaussian_parameter, Occupy::gaussian_type, this->ekb, this->eferm.ef_up, demet_up, this->wg, 0, this->klist->isk); ....// omit the other spin counter part this->f_en.demet = demet_up + demet_dw; } else {....} // nspin = 1, rks case, set parameter behind wg to -1 #ifdef __MPI // qianrui fix a bug on 2021-7-21 Parallel_Reduce::reduce_double_allpool(this->f_en.demet); #endif } else if (Occupy::fixed_occupations) {....} } 之后利用求得的 wg(ik,ib) 计算了 eband 数值：\\text{eband}=\\sum_{\\mathbf{k}, \\text{n}}{w_{\\text{n}\\mathbf{k}}\\epsilon_{\\text{n}\\mathbf{k}}} void ElecState::calEBand() { double eband = 0.0; for (int ik = 0; ik ekb.nr; ++ik) { for (int ibnd = 0; ibnd ekb.nc; ibnd++) { eband += this->ekb(ik, ibnd) * this->wg(ik, ibnd); } } this->f_en.eband = eband; if (GlobalV::KPAR != 1 && GlobalV::ESOLVER_TYPE != \"sdft\") { this->f_en.eband /= GlobalV::NPROC_IN_POOL; #ifdef __MPI Parallel_Reduce::reduce_double_all(this->f_en.eband); #endif } } template void ElecStatePW::updateRhoK(const psi::Psi, Device>& psi) { this->rhoBandK(psi); } template void ElecStatePW::rhoBandK(const psi::Psi, Device>& psi) { .... if (!this->init_rho) this->init_rho_data(); int ik = psi.get_current_k(); int npw = psi.get_current_nbas(); int current_spin = 0; if (GlobalV::NSPIN == 2) current_spin = this->klist->isk[ik]; int nbands = psi.get_nbands(); const double threshold = ModuleBase::threshold_wg * this->wg(ik, 0); if (GlobalV::NSPIN == 4) {....} else { for (int ibnd = 0; ibnd wg(ik, ibnd) basis->recip_to_real(this->ctx, &psi(ibnd,0), this->wfcr, ik); const auto w1 = static_cast(this->wg(ik, ibnd) / get_ucell_omega()); if (w1 != 0.0) { elecstate_pw_op()(this->ctx, current_spin, this->charge->nrxx, w1, this->rho, this->wfcr); } // kinetic energy density, if interested, see source code online: // https://github.com/deepmodeling/abacus-develop/blob/develop/source/module_elecstate/elecstate_pw.cpp#L196 if (get_xc_func_type() == 3) {....} } } } 这里我们将波函数从倒空间变换到了实空间（this->wfcr），然后使用这一量在 this->charge->nrxx 格点上，进行了叠加，存储在 ElecState::rho 里，并且因为 ElecState::rho 和 ElecState::charge::rho 指向同一片内存空间，因此使用 ElecState::charge::rho 访问该内存空间时，值也已经改变。即此处，我们已经根据 scf 结果更新了电荷密度 rho 的数值。 &#x1F914;批判性思考 你认为创建不止一个指针来管理同一片内存区域是否是个好主意？可能存在什么缺点或者隐患？如果不是，你是否有更好的办法？ 离开 HSolverPW::solve() 函数刷新 ElecState::ekb、psi::Psi::psi 之后，来到计算带隙的部分： template void ESolver_KS_PW::hamilt2density(const int istep, const int iter, const double ethr) { if (this->phsol != nullptr) { .... this->phsol->solve(this->p_hamilt, this->kspw_psi[0], this->pelec, GlobalV::KS_SOLVER); if (GlobalV::out_bandgap) { if (!GlobalV::TWO_EFERMI) this->pelec->cal_bandgap(); else this->pelec->cal_bandgap_updw(); } } else {....} // calculate the delta_harris energy according to new charge density. // mohan add 2009-01-23 this->pelec->cal_energies(1); Symmetry_rho srho; for (int is = 0; is pelec->charge), this->pw_rho, GlobalC::Pgrid, this->symm); } // compute magnetization, only for LSDA(spin==2) GlobalC::ucell.magnet.compute_magnetization(this->pelec->charge->nrxx, this->pelec->charge->nxyz, this->pelec->charge->rho, this->pelec->nelec_spin.data()); this->pelec->f_en.deband = this->pelec->cal_delta_eband(); } 因这部分代码非常简单，请自行阅读：cal_bandgap()、cal_bandgap_updw()。 ElecState::cal_energies() void ElecState::cal_energies(const int type) { this->f_en.hartree_energy = get_hartree_energy(); this->f_en.efield = get_etot_efield(); this->f_en.gatefield = get_etot_gatefield(); if (GlobalV::imp_sol) {....} #ifdef __LCAO if (GlobalV::dft_plus_u) {....} #endif #ifdef __DEEPKS if (GlobalV::deepks_scf) {....} #endif if (type == 1) // harris { this->f_en.calculate_harris(); } else // etot { this->f_en.calculate_etot(); } } double ElecState::get_hartree_energy() { return H_Hartree_pw::hartree_energy; } ，H_Hartree_pw::hartree_energy 已经在 PotHartree::cal_v_eff() 所调用的 H_Hartree_pw::v_hartree() 被计算、赋值（see Introduction to ABACUS: Path to PW calculation - Part 9 ）。 Harris and Kohn-Sham energies fenergy::calculate_harris() double fenergy::calculate_harris() { etot_harris = eband + deband_harris + (etxc - etxcc) + ewald_energy + hartree_energy + demet + descf + exx + efield + gatefield + evdw + esol_el + esol_cav + edftu + edeepks_scf; return etot_harris; } fenergy::calculate_etot() double fenergy::calculate_etot() { etot = eband + deband + (etxc - etxcc) + ewald_energy + hartree_energy + demet + descf + exx + efield + gatefield + evdw + esol_el + esol_cav + edftu + edeepks_scf; return etot; } 我们尝试查找左侧函数中所有已经被赋值的项： eband：psiToRho() 中已经计算 deband_harris：当前未计算 etxc, etxcc：当前未计算 demet：psiToRho() 中已经计算 descf：当前未计算 exx：当前未计算 GlobalC::ucell.magnet.compute_magnetization() 该函数源码十分简单，请自行阅读。该函数计算了 tot_magnetization 和 abs_magnetization，（对于 nspin=2 case）分别定义为： tot_magnetization = \\int{d\\mathbf{r}(\\rho^\\alpha(\\mathbf{r})-\\rho^\\beta(\\mathbf{r}))} abs_magnetization = \\int{d\\mathbf{r}(|\\rho^\\alpha(\\mathbf{r})-\\rho^\\beta(\\mathbf{r})|)} nspin = 4 的情况请自行阅读。 ElecState::cal_delta_eband() 我们已经在上篇中解读过该函数（Introduction to ABACUS: Path to PW calculation - Part 10），到目前为止，区别于上一次调用，此次调用时电荷密度 rho 已经改变，因此在代码中： double ElecState::cal_delta_eband() const { double deband0 = 0.0; double deband_aux = 0.0; const double* v_eff = this->pot->get_effective_v(0); const double* v_fixed = this->pot->get_fixed_v(); const double* v_ofk = nullptr; if (get_xc_func_type() == 3 || get_xc_func_type() == 5) { v_ofk = this->pot->get_effective_vofk(0); } for (int ir = 0; ir charge->rhopw->nrxx; ir++) { deband_aux -= this->charge->rho[0][ir] * (v_eff[ir] - v_fixed[ir]); if (get_xc_func_type() == 3 || get_xc_func_type() == 5) { deband_aux -= this->charge->kin_r[0][ir] * v_ofk[ir]; } } if (GlobalV::NSPIN == 2) { v_eff = this->pot->get_effective_v(1); v_ofk = this->pot->get_effective_vofk(1); for (int ir = 0; ir charge->rhopw->nrxx; ir++) { deband_aux -= this->charge->rho[1][ir] * (v_eff[ir] - v_fixed[ir]); if (get_xc_func_type() == 3 || get_xc_func_type() == 5) { deband_aux -= this->charge->kin_r[1][ir] * v_ofk[ir]; } } } else if (GlobalV::NSPIN == 4) {....} #ifdef __MPI MPI_Allreduce(&deband_aux, &deband0, 1, MPI_DOUBLE, MPI_SUM, POOL_WORLD); #else deband0 = deband_aux; #endif deband0 *= this->omega / this->charge->rhopw->nxyz; deband0 -= 2 * this->f_en.exx; return deband0; } 凡是涉及 charge->rho 的项其最终计算结果均会有所差别。 Charge_Mixing::get_drho() get_drho() 函数拥有良好的注释，可以帮助读者理解函数所执行内容。 nspin=1 时密度的变化量为： \\mathrm{drho}=\\left( \\frac{1}{2}\\Omega _{\\mathrm{cell}} \\right) \\left( 4\\pi e^2 \\right) \\sum_{\\mathbf{G}\\ne 0}{\\frac{\\Delta \\rho \\left( -\\mathbf{G} \\right) \\Delta \\rho \\left( \\mathbf{G} \\right)}{\\left( \\frac{2\\pi}{|a_0|}|\\mathbf{G}| \\right) ^2}} nspin=2: s=\\left( 4\\pi e^2 \\right) f_{\\Gamma}\\left( \\frac{1}{2}\\Omega _{\\mathrm{cell}} \\right) \\left\\{ \\sum_{\\mathbf{G}\\ne 0}{\\frac{\\left[ \\Delta \\rho ^{\\alpha}\\left( -\\mathbf{G} \\right) +\\Delta \\rho ^{\\beta}\\left( -\\mathbf{G} \\right) \\right] \\left[ \\Delta \\rho ^{\\alpha}\\left( \\mathbf{G} \\right) +\\Delta \\rho ^{\\beta}\\left( \\mathbf{G} \\right) \\right]}{\\left( \\frac{2\\pi}{|a_0|}|\\mathbf{G}| \\right) ^2}+\\frac{\\left[ \\Delta \\rho ^{\\alpha}\\left( 0 \\right) +\\Delta \\rho ^{\\beta}\\left( 0 \\right) \\right] \\left[ \\Delta \\rho ^{\\alpha}\\left( 0 \\right) +\\Delta \\rho ^{\\beta}\\left( 0 \\right) \\right]}{\\left( 2\\pi \\right) ^2}+}\\sum_{\\mathbf{G}\\ne 0}{\\frac{\\left[ \\Delta \\rho ^{\\alpha}\\left( -\\mathbf{G} \\right) -\\Delta \\rho ^{\\beta}\\left( -\\mathbf{G} \\right) \\right] \\left[ \\Delta \\rho ^{\\alpha}\\left( \\mathbf{G} \\right) -\\Delta \\rho ^{\\beta}\\left( \\mathbf{G} \\right) \\right]}{\\left( 2\\pi \\right) ^2}} \\right\\} 关于 drho 的讨论可参考 Ewald summation 简介。get_drho() 计算了密度的变化量，为判断波函数收敛提供参考。 HSolverPW::cal_hsolerror() template FPTYPE HSolverPW::cal_hsolerror() { return this->diag_ethr * static_cast(std::max(1.0, GlobalV::nelec)); } ，而 diag_ethr 在 HSolverPW::set_diagethr() 函数中被设置为 1E-2（见 Introduction to ABACUS: Path to PW calculation - Part 10）。若无法小于 drho，则重置 diag_ethr 后再次进行对角化、计算 drho，然后计算 hsolerror 值。 Charge_Mixing::auto_set() 从 ESolver_KS::Run() 函数中，esolver_ks_pw.cpp 第 277 行可以知道，判断 scf 是否收敛的标准实际判断电荷密度： this->conv_elec = (drho scf_thr); 但如果仍然有 drho ，则不进行 charge mixing 操作，否则进行 charge mixing： if (drho conv_elec) { if (drho pelec->cal_bandgap(); bandgap_for_autoset = this->pelec->bandgap; } else { this->pelec->cal_bandgap_updw(); bandgap_for_autoset = std::min(this->pelec->bandgap_up, this->pelec->bandgap_dw); } p_chgmix->auto_set(bandgap_for_autoset, GlobalC::ucell); } //conv_elec = this->estate.mix_rho(); p_chgmix->mix_rho(iter, pelec->charge); //----------charge mixing done----------- } auto_set() 函数则为 charge mixing 设置默认值（如果 auto_set 的 flag 被设置为 true）： Charge_Mixing::mix_rho() Mixing Charge mixing 是一种加快 SCF 收敛的技术，其混合 SCF 过程中一定步数范围内的电荷密度，作为下一步电荷密度的实际使用数值。 Broyden 和 Kerker mixing 现在常见的 charge mixing 方法有 Broyden、Kerker、Pulay 等，其中 Broyden 和 Kerker mixing 方法的原理可见 VASP wiki（link）。 Pulay mixing Pulay mixing 则使用 DIIS（Direct inversion in the iterative subspace）方法计算 mixing 系数，考虑到 DIIS 在不仅 charge mixing，在其他优化方法中也经常使用，我们对 DIIS 的原理进行简要介绍。 在 VASP 的 SCF（Link），Quantum ESPRESSO（Link）、CP2K（Link）、Gaussian（Link）中都可以看到 DIIS 算法，其核心为求解如下矩阵的解\\{c_i\\}： \\left( \\begin{matrix} 0& -1& -1& \\cdots& -1\\\\ -1& B_{11}& B_{12}& \\cdots& \\,\\,\\\\ \\cdots& \\,\\,& \\,\\,& \\,\\,& \\,\\,\\\\ \\,\\,& \\cdots& \\,\\,& B_{ij}& \\,\\,\\\\ \\cdots& \\,\\,& \\,\\,& \\,\\,& \\,\\,\\\\ \\end{matrix} \\right) \\left( \\begin{array}{c} -\\lambda\\\\ c_1\\\\ \\cdots\\\\ c_2\\\\ \\cdots\\\\ \\end{array} \\right) =\\left( \\begin{array}{c} -1\\\\ 0\\\\ \\cdots\\\\ 0\\\\ \\cdots\\\\ \\end{array} \\right) ， 或写成非矩阵形式则为二次型的导数为 0 条件，亦即最小二乘法： \\lambda+\\sum_{j=1}^N{c_jB_{ij}}=0$, $\\sum_{i=1}^N{c_i}=1$，$\\leftarrow\\frac{1}{2}\\sum_{i,j=1}^N{c_i c_jB_{ij}}+\\lambda(\\sum_{i=1}^N{c_i}-1)=f^\\text{DIIS}(\\{c_i\\}) ，其中B_{ij}=\\langle\\mathbf{e}_i|\\mathbf{e}_j\\rangle$，或记$|\\mathbf{e}\\rangle=\\sum_{i=1}^N{c_i|\\mathbf{e}_i\\rangle}，则 f^\\text{DIIS}=\\langle\\mathbf{e}|\\mathbf{e}\\rangle+\\lambda(\\sum^N_{i=1}{c_i}-1) CDIIS 因此在以上 DIIS 框架下，Pulay 提出 error vector$|\\mathbf{e}\\rangle$可以具有的形式为（example implementation in pyscf: link）： |\\mathbf{e}\\rangle\\equiv\\sum^N_{i=1}{(\\mathbf{FDS-SDF})}=\\sum^N_{i=1}{c_i(\\mathbf{F}\\mathbf{D}_i\\mathbf{S}-\\mathbf{S}\\mathbf{D}_i\\mathbf{F})} EDIIS EDIIS 在 DIIS 基础上混合了能量项，其 working function 变为： f^{\\mathrm{EDIIS}}=\\sum_{i=1}^N{c_iE\\left( \\mathbf{D}_i \\right)}-\\frac{1}{2}\\sum_{i.j=1}^N{c_ic_j\\mathrm{Tr}\\left[ \\left( \\mathbf{F}_i-\\mathbf{F}_j \\right) \\cdot \\left( \\mathbf{D}_i-\\mathbf{D}_j \\right) \\right]} GEDIIS 自 Gaussian 09 发布以来，对于几何优化任务，Gaussian 的默认策略调整为 GEDIIS。GEDIIS 中需要用最小二乘法达成的最小化函数构造方式如下： f^\\text{GEDIIS} =\\sum_{i=1}^N{c_iE\\left( \\mathbf{R}_i \\right)}-\\frac{1}{2}\\sum_{i.j=1}^N{c_ic_j\\left( \\mathbf{g}_i-\\mathbf{g}_j \\right) \\left( \\mathbf{R}_i-\\mathbf{R}_j \\right)} 组合系数仍然要满足$\\sum_{i=1}^N{c_i}=1$条件，$\\mathbf{g}_i$为第 i 步的梯度。 ABACUS 实现 图 1. mixing方法的通用框架设计 实际上，并非仅有 charge density 一个物理量可以进行 mixing，其他物理量，诸如波函数、Hamiltonian 矩阵、密度矩阵和自旋密度等都可以进行 mixing。实际 mixing 过程中 mixing dimension 通常在 10-20，即需要存储 10-20 个 SCF 迭代步的数据。为了在支持异构计算的同时减少 CPU-GPU 数据交换，对数据存储同样有异构化需求，因此使用了 ABACUS 中支持异构数据存储的 Tensor container。在 mixing 具体操作上，采用了继承方式： ESolver_KS::updatepot() template void ESolver_KS_PW::updatepot(const int istep, const int iter) { if (!this->conv_elec) { if (GlobalV::NSPIN == 4) {....} this->pelec->pot->update_from_charge(this->pelec->charge, &GlobalC::ucell); this->pelec->f_en.descf = this->pelec->cal_delta_escf(); } else { this->pelec->cal_converged(); } } Not converged case Potential::update_from_charge() void Potential::update_from_charge(const Charge* chg, const UnitCell* ucell) { ModuleBase::TITLE(\"Potential\", \"update_from_charge\"); ModuleBase::timer::tick(\"Potential\", \"update_from_charge\"); if (!this->fixed_done) { this->cal_fixed_v(this->v_effective_fixed.data()); this->fixed_done = true; } this->cal_v_eff(chg, ucell, this->v_effective); ....// omit GPU, single float point support and timer } ElecState::cal_delta_escf() /// @brief calculate descf double ElecState::cal_delta_escf() const { ModuleBase::TITLE(\"energy\", \"delta_escf\"); double descf = 0.0; // now rho1 is \"mixed\" charge density // and rho1_save is \"output\" charge density // because in \"deband\" the energy is calculated from \"output\" charge density, // so here is the correction. // only potential related with charge is used here for energy correction // on the fly calculate it here by v_effective - v_fixed const double* v_eff = this->pot->get_effective_v(0); const double* v_fixed = this->pot->get_fixed_v(); const double* v_ofk = nullptr; if (get_xc_func_type() == 3 || get_xc_func_type() == 5) { v_ofk = this->pot->get_effective_vofk(0); } for (int ir = 0; ir charge->rhopw->nrxx; ir++) { descf -= (this->charge->rho[0][ir] - this->charge->rho_save[0][ir]) * (v_eff[ir] - v_fixed[ir]); if (get_xc_func_type() == 3 || get_xc_func_type() == 5) {....} } if (GlobalV::NSPIN == 2) { v_eff = this->pot->get_effective_v(1); if (get_xc_func_type() == 3 || get_xc_func_type() == 5) {....} for (int ir = 0; ir charge->rhopw->nrxx; ir++) { descf -= (this->charge->rho[1][ir] - this->charge->rho_save[1][ir]) * (v_eff[ir] - v_fixed[ir]); if (get_xc_func_type() == 3 || get_xc_func_type() == 5) { descf -= (this->charge->kin_r[1][ir] - this->charge->kin_r_save[1][ir]) * v_ofk[ir]; } } } if (GlobalV::NSPIN == 4) {....} #ifdef __MPI Parallel_Reduce::reduce_double_pool(descf); #endif descf *= this->omega / this->charge->rhopw->nxyz; return descf; } Converged case ElecState::cal_converged() /// @brief calculation if converged void ElecState::cal_converged() { this->pot->get_vnew(this->charge, this->vnew); this->vnew_exist = true; this->f_en.descf = 0.0; } Potential::get_vnew() void Potential::get_vnew(const Charge* chg, ModuleBase::matrix& vnew) { ModuleBase::TITLE(\"Potential\", \"get_vnew\"); vnew.create(this->v_effective.nr, this->v_effective.nc); vnew = this->v_effective; this->update_from_charge(chg, this->ucell_); //(used later for scf correction to the forces ) for (int iter = 0; iter v_effective.c[iter] - vnew.c[iter]; } } ESolver_KS::eachiterfinish() template void ESolver_KS_PW::eachiterfinish(const int iter) { // print_eigenvalue(GlobalV::ofs_running); this->pelec->cal_energies(2); // We output it for restarting the scf. ....// omit ofstream output of demanded properties such as electron density and wfc, see this function on Github } 此时我们不再计算 Harris functional 而是 Kohn-Sham functional. （我们省略了 ESolver_KS::printiter() 函数，即 scf 过程中的输出。关于该函数的实现细节，请自行阅读：link） ESolver_KS::do_after_converge() 我们假设经过许多轮 scf 后，密度已经达到收敛标准，则到达这一函数。ESolver_KS 中声明该函数为 virtual namespace ModuleESolver { template class ESolver_KS : public ESolver_FP { public: .... protected: .... virtual bool do_after_converge(int& iter){return true;} template void ESolver_KS::Run(const int istep, UnitCell& ucell) { if (!(GlobalV::CALCULATION == \"scf\" || GlobalV::CALCULATION == \"md\" || GlobalV::CALCULATION == \"relax\" || GlobalV::CALCULATION == \"cell-relax\")) {....} else { .... for (int iter = 1; iter maxniter; ++iter) { .... if (this->conv_elec) { this->niter = iter; bool stop = this->do_after_converge(iter); if(stop) break; } } .... ，但在 ESolver_KS_PW 中则实际并无该函数的定义，但对于 LCAO 基组，则确实重新定义了这一函数。 ESolver_KS::afterscf() 该函数进行了数个性质的输出。 template void ESolver_KS_PW::afterscf(const int istep) { this->create_Output_Potential(istep).write(); // save charge difference into files for charge extrapolation if (GlobalV::CALCULATION != \"scf\") { this->CE.save_files(istep, GlobalC::ucell, #ifdef __MPI this->pw_big, #endif this->pelec->charge, &this->sf); } if (GlobalV::out_chg) { for (int is = 0; is create_Output_Rho(is, istep).write(); if (XC_Functional::get_func_type() == 3 || XC_Functional::get_func_type() == 5) { this->create_Output_Kin(is, istep).write(); } } } if (this->wf.out_wfc_pw == 1 || this->wf.out_wfc_pw == 2) { std::stringstream ssw; ssw psi[0], this->kv, this->pw_wfc); } ModuleIO::output_convergence_after_scf(this->conv_elec, this->pelec->f_en.etot); ModuleIO::output_efermi(this->conv_elec, this->pelec->eferm.ef); if (GlobalV::OUT_LEVEL != \"m\") { this->pelec->print_eigenvalue(GlobalV::ofs_running); } if (this->device == psi::GpuDevice) { castmem_2d_d2h_op()(this->psi[0].get_device(), this->kspw_psi[0].get_device(), this->psi[0].get_pointer() - this->psi[0].get_psi_bias(), this->kspw_psi[0].get_pointer() - this->kspw_psi[0].get_psi_bias(), this->psi[0].size()); } } 结语 至此，我们结束了 ESolver_KS::Run() 函数的全部内容，返回 Relax_Driver::relax_driver() 函数。考虑到我们关注的是 pw-scf 任务，因此并不对原子坐标和晶胞参数进行 relax，所以 relax_driver() 函数也在 scf 收敛后退出，到达 ESolver::postprocess()（但该函数为虚函数，因此到达 ESolver_KS_PW::postprocess()）。 在该函数中，主要对电子态、DOS、能带性质、实空间波函数等进行输出，在 esolver_ks_pw.cpp 的第 737 行，则进行了平面波和球 Bessel 函数的 overlap 积分输出： if (winput::out_spillage psi[0], this->sf, this->kv, this->pw_wfc); ModuleBase::GlobalFunc::DONE(GlobalV::ofs_running, \"BASIS OVERLAP (Q and S) GENERATION.\"); } Q 和 S 矩阵将用于 SIAB（Systematically improvable optimized atomic basis sets）程序，进行数值原子轨道生成的依据。生成数值原子轨道后，则可以在使用数值原子轨道为基组的基础上，使用 ABACUS 的基于数值原子轨道（线性组合原子轨道 LCAO，basis_type lcao）方法进行模拟，这将是我们下一个部分，Introduction to ABACUS: Path to LCAO calculation 系列的起点。 ESolver_KS_PW::postprocess() 对于计算电导率的情况还可以调用 KG 方法进行计算，但对 KG 的解读已经超出了本部分的讨论范围。 &#x1F914;“家庭作业” For now we are trying to make all ABACUS output look well-organized, you may try to participate in practical ABACUS developing starting from formatting those output information. With the newly merged Formatter library, you browse the source code and find somewhere to improve. Submit your pull request after local testing, do not hesititate! Instruction of Formatter library: ABACUS formatter 库使用说明书 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 10 下篇：Introduction to ABACUS: Path to PW calculation - Summary Final 游园惊梦：Introduction to ABACUS: Path to PW calculation - Part 1 下个章节：Introduction to ABACUS: Path to LCAO calculation - Part 1 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-sm2.html":{"url":"develop-sm2.html","title":"Introduction to ABACUS: Path to PW calculation - Summary Final","keywords":"","body":"Introduction to ABACUS: Path to PW calculation - Summary Final 作者：黄一珂，邮箱：huangyk@aisi.ac.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 飞书链接：Introduction to ABACUS: Path to PW calculation - Summary Final &#x1F4C3;写在前面 不脱离代码——避免读者看完手册后对代码没有一丁点概念 不堆砌代码解释——避免平庸的代码解释，努力兼顾拉近读者和代码距离的同时，做到提纲挈领，不逐行复制代码后进行停留在代码语义上的解释 Flow：ABACUS 里的工作流 回忆我们的起点，从 main() 函数出发，经过 MPI 初始化后到达 Driver，然后到 Driver_run()。是 Driver_run() 唤起了整个程序的实际运行部分，其实迄今为止我们所看到的所有“故事”，都发生在 Driver_run() 的 ESolver::init()，以及 Relax_Driver::run()。 我们同样也拥有更低层级的 driver，比如 ESolver_KS::Run() 函数，实际上 ESolver 的 Run() 函数只关心 SCF，即只关心“求得能量”，尽管有另一个相似命名的模块，HSolver，其关注的范围其实更小：只关注 Hamiltonian 矩阵的对角化。 因此我们可以画出一个分层级的 workflow，在不同 workflow 上引导的则是 driver： 另有 Run_md 和 Relax_Driver 是平行关系，但由于我们目前仍未正式涉及 MD 的相关代码，因此不在上图中画出。 Interface：串联模块的组织模式 Inteface 设计的必要性 遗憾的是，GlobalV 和 GlobalC 虽然提供了“参数上云、用时下载”这一概念并方便了对待模拟体系的描述相关参数传递和热点函数调用，但对于单元测试来讲却并非好的设计，尤其对于 GlobalC。我们可能在编写单元测试（以确定模块功能正常运作）时，会遇到对过多变量进行初始化的问题，例如我们只想使用 UnitCell GlobalC::ucell，include GlobalC 的头文件后，却发现了诸多的“undefined reference to Parallel_Kpoints”等问题。 从设计上来讲，这是发生了类间耦合，尽管这种耦合可能在设计之初未被预计到。因此为了能够尽可能大地减少基于 GlobalC 的类间耦合，更加提倡不使用 GlobalC，而是从具体的某个类被定义的地方设计接口（指针进行调用），如对于一个类 illustrate_interface 的函数 illustrative_f，我们如果需要使用 UnitCell GlobalC::ucell，不写成： void illustrate_interface::illustrative_f() { .... std::cout 而是在 illustrate_interface 类中创建一个 interface： class illustrate_interface { private: UnitCell* p_ucell; }; 该 interface 可以在构造函数中被指定，也可以使用相应 setter 函数。之后对 illustrative_f 函数的编写就成为： void illustrate_interface::illustrative_f() { .... std::cout p_ucell 如此一来使得实际所使用的 GlobalC 中类（比如 UnitCell）和其他类解耦开。 （单元测试）尽情 mock 你想要使用的类 假设你想要在单元测试中使用一些函数，但你 include 实现那个函数的 cpp 文件后发现出现了很多棘手的 undefined reference to xxx，应该怎么办？又或者在你 include 的类中有其他的类对象作为成员，然后编译器提示报错 undefined reference to [class]::[class]()，怎么办？ 除了可以尝试使用 gmock 这个 googletest 提供的函数框架外，第二种思路只需要记住一件事：因为你只 include 了头文件，所以你可以实现当中的任何函数，而非必须包含进来它原本的实现（即所对应的原本的cpp文件）。 如果类 Parallel_Grid 对你无关紧要，但是确实在某个类或者命名空间中出现了这个类对象的声明，那么你可以在单元测试 cpp 文件中对它的构造函数和析构函数进行定义： Parallel_Grid::parallel_grid(){ } Parallel_Grid::~parallel_grid(){ } 然后避免再和原本的 cpp 文件一同进行编译，即在 CMakeLists.txt 的 SOURCE 中或 LIBS 中认真查看是否还包含该类的原始定义。如果有所遗漏，则会出现 multiple definition of xxx(), ..., first defined here ... 的编译报错，即同一签名函数拥有多重定义。 &#x1F914;思考时间 Read unittest module_io/test/bessel_basis_test.cpp and module_io/test/CMakeLists.txt, try to understand dependencies and how they are eliminated by redefinition of those functions whose declarations are included. 层级与功能：设计理念的思考 相较于 GlobalC，GlobalV 则是更成熟/成功的一个类，其部分原因为保持了功能划分意义上的单纯性：data-carrier。 在实际编程过程中，除了将类进行明确的功能区分外，还可以按照类的实际存储数据类型和函数的功能与密度进行二次划分，例如对于 ESolver 和 Relax_Driver（或 Driver 类），他们本身并不涉及到直接和被模拟体系相关的数据存储，即 ESolver 等类是程序流程控制的实现。 另一种类是我们之前介绍过的 ModulePW::PW_Basis_K 和 PW_Basis，其存储了平面波的数量和实空间、倒空间分发信息，以及 psi::Psi 类，存储了平面波基波函数的相关信息，并且基于这种类的二次划分，即该类被称为“数据载体（data carrier）”类，psi::Psi 进行了异构化支持，用于在 GPU 和 CPU 进行异构计算，同理，Charge_Mixing 存储数据的类也是 data-carrier。 当然在第一性原理软件中出现最多的还是直接和功能相关，即“功能类”。最基本地，我们有 module_relax，module_hsolver 等。这些类只提供在整个模拟流程中的具体实现方法，本身并不（应该）存储大量数据，而只应对所使用方法等信息有所基本描述即可。 因此可以按照上述方法将现有主要类按照如下关系进行划分： 。前文提到过关于接口设计的相关方法，然而如果接口以及链接接口的场所（即发生链接的函数所述类）不进行精心设计，则仍然无法保证程序具有清晰结构，从而为程序主体的运行带来隐患，单元测试的编写带来困难，“单元编译”变得更加难以实现。 举例对于 Hamilt 类，实际上提供 Hamiltonian 和相关算符，则其必然按照层级从上往下依次从 ESolver 和 Hamilt，Operator 类进行初始化，之后返回 ESolver，执行下一项动作，而不是在其他地方进行 Hamilt 对象初始化，然后将可能的数据的类在 Hamilt 进行直接链接，这无疑加重了类间耦合关系。 效率与正确性：并行与异构化编程 minimize data exchange 由于 OMP 和 MPI 的默认内存共享机制不同，MPI 可能会需要在 processor（进程）间收发数据。然而频繁进行数据的收发会带来明显的时间运行成本，因此合理设计 MPI processor 之间收发的具体数据，最小化数据传输规模，同样是并行编程的一个重要考虑方面。 对于异构编程同样如此。在 Charge_Mixing 类中，由于电荷密度、动能密度和密度矩阵的数据存储规模较大，频繁在 CPU 和 GPU 之间进行数据交换过于浪费时间，因此三个量的存储也进行异构化编程，具体实现为 container::Tensor 类。关于该类的实现，请自行阅读代码（link）。 全局单例（singleton） OMP 的粒度为线程（thread），线程间共享内存，因此为避免共享内存的各线程同时创建变量，并且顺序不同地进行读写，造成预期之外的结果时，可以使用全局单例模式进行对象的创建，以下方式称为 Mayers' Singleton Pattern： #include struct singleton_t { static singleton_t& instance() { static singleton_t instance; return instance; } // instance singleton_t(const singleton_t &) = delete; singleton_t& operator = (const singleton_t &) = delete; private: singleton_t() {} ~singleton_t() {} public: void out(){ printf(\"out\\n\"); } }; // struct singleton_t int main() { singleton_t::instance().out(); return 0; } 该类中，拷贝构造函数和默认构造函数均被删除或隐藏，亦无法使用“=”运算符进行对象的传递。 &#x1F914;“家庭作业” Read function Atom::bcast_atom(), write a code to support distribution of 3-layered std::vector (e.g.: std::vector>>) Only a little bit challenging :) 系列链接 上篇：Introduction to ABACUS: Path to PW calculation - Part 11 下篇：&#x1F6A7;（施工中） Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-pyabacus1.html":{"url":"develop-pyabacus1.html","title":"Pyabacus 文档一：用户手册","keywords":"","body":"Pyabacus 文档一：用户手册 作者：白晨旭 审核：陈默涵 单位：北京大学 最后更新时间：2024-11-15 一、简介 pyabacus 是密度泛函理论软件 ABACUS（原子算筹）的 Python 接口，提供了与 ABACUS 软件交互的 Python API。 该项目基于 pybind11 和 scikit-build-core 构建。 二、模块 pyabacus 当前提供以下模块： io：pyabacus 中的输入/输出模块。 Cell：用于单元结构的模块，将 Python 中的 ModuleNAO 与用户输入连接。 ModuleBase：基本数学函数模块。 ModuleNAO：数值原子轨道 (NAO) 模块。 hsolver：用于求解哈密顿量的模块。 三、安装 我们建议用户使用 conda 进行安装，conda 是一个开源的软件包管理系统和环境管理系统，可以方便的管理不同版本的 Python 和软件包。用户可以按照以下步骤安装 Pyabacus： 创建一个虚拟环境，并且激活虚拟环境 conda create -n pyabacus python=3.8 & conda activate pyabacus 下载 ABACUS 软件 cd {your_working_directory} git clone https://github.com/abacusmodeling/abacus-develop.git cd abacus-develop/python/pyabacus 安装 ABACUS 所需的依赖库 使用 pip install -v . 安装 Pyabacus，或者使用 pip install .[test] 安装 Pyabacus 及其测试环境的依赖库(使用 pip install -v .[test] -i https://pypi.tuna.tsinghua.edu.cn/simple 加速安装过程)。 四、调用 用户可以通过以下代码调用 Pyabacus 的接口： import pyabacus s = pyabacus.ModuleBase.Sphbes() s.sphbesj(1, 0.0) 0.0 上面的代码调用了 ABACUS 的 ModuleBase::Sphbes 模块。 目前，我们移植了下面几个模块： ModuleBase::Sphbes ModuleBase::Integral RadialCollection TwoCenterIntegrator hsolver::dav_subspace 在 Python 中调用这些模块的方法可见 examples 文件夹内示例。 五、示例 examples 文件夹中包含了一些 Pyabacus 的示例脚本，用户可以通过这些示例脚本了解 Pyabacus 的使用方法。 运行 examples 文件夹中的 python vis_nao.py 以可视化数值原子轨道。 $ cd examples/ $ python vis_nao.py 运行 examples 文件夹中的 python ex_s_rotate.py 来检查 S 矩阵。 $ cd examples/ $ python ex_s_rotate.py norm(S_e3 - S_numer) = 3.341208104032616e-15 运行 examples 文件夹中的 python diago_matrix.py 来对角化一个矩阵 $ cd examples/ $ python diago_matrix.py eigenvalues calculated by pyabacus: [-0.38440611 0.24221155 0.31593272 0.53144616 0.85155108 1.06950155 1.11142051 1.12462152] eigenvalues calculated by scipy: [-0.38440611 0.24221155 0.31593272 0.53144616 0.85155108 1.06950154 1.11142051 1.12462151] error: [9.26164700e-12 2.42959514e-10 2.96529468e-11 7.77933273e-12 7.53686002e-12 2.95628810e-09 1.04678111e-09 7.79106313e-09] 六、测试 Pyabacus 使用 pytest 进行单元测试，用户可以在 abacus-develop/python/pyabacus/tests 目录下使用 pytest -v 命令进行单元测试。 七、结语 以上就是 Pyabacus 的一些基本安装和使用方法，如果读者对进一步交流感兴趣，欢迎登录 ABACUS 的 github 网站进行进一步的交流。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-pyabacus2.html":{"url":"develop-pyabacus2.html","title":"Pyabacus 文档二：HSolver 模块","keywords":"","body":"Pyabacus 文档二：HSolver 模块 作者：白晨旭 审核：陈默涵 单位：北京大学 最后更新时间：2024-11-15 一、简介 目前，pyabacus.hsolver 内实现了三种对角化算法的 python 化，分别是 hsolver.dav_subspace、hsolver.davidson 与 hsolver.cg，其签名分别如下： def dav_subspace( # 矩阵-向量组乘法函数，接收一个numpy数组，返回一个numpy数组 mvv_op: Callable[[NDArray[np.complex128]], NDArray[np.complex128]], # 对角化过程中的特征向量组初猜 init_v: NDArray[np.complex128], # 矩阵维度 dim: int, # 要求的特征值个数，从最小的特征值开始，算法会求解num_eigs个特征值 num_eigs: int, # 预处理向量 precondition: NDArray[np.float64], # 基组允许容纳的向量个数(dav_ndim * nband个) dav_ndim: int = 2, # 迭代误差 tol: float = 1e-2, # 最大迭代次数 max_iter: int = 1000, # 是否使用子空间函数 need_subspace: bool = False ) -> Tuple[NDArray[np.float64], NDArray[np.complex128]]: # dav_subspace会返回一个元组，分别为特征值数组与其对应的特征向量集合 def dav_subspace( # 矩阵-向量组乘法函数，接收一个numpy数组，返回一个numpy数组 mvv_op: Callable[[NDArray[np.complex128]], NDArray[np.complex128]], # 对角化过程中的特征向量组初猜 init_v: NDArray[np.complex128], # 矩阵维度 dim: int, # 要求的特征值个数，从最小的特征值开始，算法会求解num_eigs个特征值 num_eigs: int, # 预处理向量 precondition: NDArray[np.float64], # 基组允许容纳的向量个数(dav_ndim * nband个) dav_ndim: int = 2, # 迭代误差 tol: float = 1e-2, # 最大迭代次数 max_iter: int = 1000, # 是否使用PAW方法 use_paw: bool = False ) -> Tuple[NDArray[np.float64], NDArray[np.complex128]]: # davidson会返回一个元组，分别为特征值数组与其对应的特征向量集合 def cg( # 矩阵-向量组乘法函数，接收一个numpy数组，返回一个numpy数组 mvv_op: Callable[[NDArray[np.complex128]], NDArray[np.complex128]], # 对角化过程中的特征向量组初猜 init_v: NDArray[np.complex128], # 矩阵维度 dim: int, # 要求的特征值个数，从最小的特征值开始，算法会求解num_eigs个特征值 num_eigs: int, # 预处理向量 precondition: NDArray[np.float64], # 迭代误差 tol: float = 1e-2, # 最大迭代次数 max_iter: int = 1000, # 是否使用子空间函数 need_subspace: bool = False, # 计算模式：自洽场/非自洽场 scf_type: bool = False, # 进程数 nproc_in_pool: int = 1 ) -> Tuple[NDArray[np.float64], NDArray[np.complex128]]: # cg会返回一个元组，分别为特征值数组与其对应的特征向量集合 二、安装 pyabacus 我们建议用户使用 conda 进行安装，conda 是一个开源的软件包管理系统和环境管理系统，可以方便的管理不同版本的 Python 和软件包。用户可以按照以下步骤安装 pyabacus： 创建一个虚拟环境，并且激活虚拟环境 conda create -n pyabacus python=3.8 & conda activate pyabacus 下载 ABACUS cd {your_working_directory} git clone https://github.com/abacusmodeling/abacus-develop.git cd abacus-develop/python/pyabacus 安装 ABACUS 所需的依赖库 使用 pip install -v . 安装 pyabacus，或者使用 pip install .[test] 安装 Pyabacus 及其测试环境的依赖库(使用 pip install -v .[test] -i https://pypi.tuna.tsinghua.edu.cn/simple 加速安装过程)。 三、调用对角化算法 三种对角化方法签名几乎一致，只有微小的差别，调用方法也相同，下面统一用 diago 指代。 在调用这两个函数前，首先我们需要读取一个矩阵，我们可以从 https://sparse.tamu.edu/PARSEC 上下载，之后使用 scipy 读取，并且确定要求的特征值个数（示例中为 8 个）： h_mat = scipy.io.loadmat(mat_file)['Problem']['A'][0, 0] dim = h_mat.shape[0] num_eigs = 8 我们也可以用 numpy 生成一个对角占优的 Hermitian 矩阵： n = 500 h_mat = np.random.rand(n,n) h_mat = h_mat + h_mat.conj().T + np.diag(np.random.random(n))*10 之后，我们可以定义 mvv_op 算子： def mvv_op(x): return h_mat.dot(x) # 如果你愿意的话，也可以定义为一个lambda函数 # mvv_op = lambda x: h_mat.dot(x) 选取初猜 v0： v0 = np.random.rand(nbasis, nband) 计算预处理子 precond，由于这里我们读取的矩阵为对角占优的稀疏矩阵，所以我们可以取出矩阵的对角元组成新的矩阵 D，并且计算 D 的逆作为矩阵的近似逆。 diag_elem = h_mat.diagonal() # 为了数值稳定，防止部分对角元过小（接近0）导致 # 其倒数为无穷大，我们将小于1e-8的点设置为1e-8 diag_elem = np.where(np.abs(diag_elem) 做完上述一系列准备工作后，我们即可调用 pyabacus 的算法来计算特征值问题了！ # 下面的diago可按需替换为dav_subspace或davidson e, v = diago( mm_op, v0, nbasis, nband, precond, dav_ndim=8, # cg法无该参数 tol=1e-8, max_iter=1000 ) print(f'eigenvalues calculated by pyabacus is: \\n', e) 四、结语 以上就是 Pyabacus 的一些基本安装和使用方法，如果读者对进一步交流感兴趣，欢迎登录 ABACUS 的 github 网站进行进一步的交流。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"develop-pyabacus3.html":{"url":"develop-pyabacus3.html","title":"Pyabacus 文档三：开发者指南","keywords":"","body":"Pyabacus 文档三：开发者指南 作者：白晨旭 审核：陈默涵 单位：北京大学 最后更新时间：2024-11-15 一、简介 欢迎来到 pyabacus 项目！pyabacus 是国产第一性原理软件 ABACUS（中文名原子算筹）的 Python 接口，它旨在为用户提供了便捷的 Python API，使用户能够利用 Python 语言更灵活地实现电子结构计算并分析结果。本文档主要针对开发者撰写，以下是本文档的目录 项目结构 根目录 CMake 配置 模块 CMake 配置 Python 化上手指南 Python 化指南 如何编写单元测试 如何参与开源贡献 资料汇总 读者可以参考该系列文档的前两个文档来熟悉 pyabacus。如果读者希望做出贡献，本指南将帮助您了解项目结构、开发流程和代码贡献方式。 二、结构 2.1 目录结构 pyabacus 项目的目录结构如下所示： pyabacus/ ├── CMakeLists.txt └── src ├── pyabacus │ └── {your_module} │ ├── {interface}.py │ └── __init__.py └── {your_module} ├── {your_code}.cpp └── CMakeLists.txt 项目采用 pybind11 和 scikit-build-core 构建，借助 CMake 构建工具链。因此，CMakeLists.txt 的配置是深入理解项目结构的关键。 2.2 根目录 CMake 配置 根目录下的 CMakeLists.txt 是 pyabacus 项目的主要配置文件。它设置了项目、查找必要的依赖项、配置构建选项，并为不同模块包含子目录。以下是文件中每部分的详细说明： cmake_minimum_required(VERSION 3.15...3.26) # 项目设置 project( ${SKBUILD_PROJECT_NAME} VERSION ${SKBUILD_PROJECT_VERSION} LANGUAGES CXX) 此部分设置项目名称、版本和使用的编程语言（本项目中为 C++）。项目名称和版本分别从 SKBUILD_PROJECT_NAME 和 SKBUILD_PROJECT_VERSION 变量中获取。 # 查找 Python 和 pybind11 find_package(Python REQUIRED COMPONENTS Interpreter Development.Module) find_package(pybind11 CONFIG REQUIRED) 该部分查找所需的 Python 和 pybind11 包。 # 设置源路径 set(ABACUS_SOURCE_DIR \"${PROJECT_SOURCE_DIR}/../../source\") set(BASE_PATH \"${ABACUS_SOURCE_DIR}/module_base\") set(NAO_PATH \"${ABACUS_SOURCE_DIR}/module_basis/module_nao\") set(HSOLVER_PATH \"${ABACUS_SOURCE_DIR}/module_hsolver\") set(PSI_PATH \"${ABACUS_SOURCE_DIR}/module_psi\") set(ENABLE_LCAO ON) list(APPEND CMAKE_MODULE_PATH \"${PROJECT_SOURCE_DIR}/../../cmake\") 此部分设置了各种源路径和配置选项，定义了不同模块的路径并附加了自定义的 CMake 模块路径。 # 添加数学库 if(DEFINED ENV{MKLROOT} AND NOT DEFINED MKLROOT) set(MKLROOT \"$ENV{MKLROOT}\") endif() if(MKLROOT) set(MKL_INTERFACE lp64) set(ENABLE_MPI ON) if (ENABLE_MPI) find_package(MPI REQUIRED) include_directories(${MPI_CXX_INCLUDE_PATH}) endif() set(USE_OPENMP ON) if(USE_OPENMP) find_package(OpenMP REQUIRED) set (CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}\") add_link_options(${OpenMP_CXX_LIBRARIES}) endif() find_package(MKL REQUIRED) add_definitions(-D__MKL) include_directories(${MKL_INCLUDE} ${MKL_INCLUDE}/fftw) if(NOT ENABLE_DEEPKS) list(APPEND math_libs IntelMKL::MKL) endif() if(CMAKE_CXX_COMPILER_ID MATCHES Intel) list(APPEND math_libs -lifcore) endif() else() find_package(FFTW3 REQUIRED) add_compile_definitions(__FFTW3) find_package(LAPACK REQUIRED) include_directories(${FFTW3_INCLUDE_DIRS}) list(APPEND math_libs FFTW3::FFTW3 LAPACK::LAPACK) if(ENABLE_LCAO) find_package(ScaLAPACK REQUIRED) list(APPEND math_libs ScaLAPACK::ScaLAPACK) endif() endif() 此部分配置数学库。它检查 Intel 数学核心库 (MKL) 的可用性并在可用时进行配置。如果 MKL 不可用，则改用 FFTW3 和 LAPACK。同时，若启用 MPI 和 OpenMP，也进行相应配置。 # 添加包含目录 include_directories( ${BASE_PATH} ${ABACUS_SOURCE_DIR} ${ABACUS_SOURCE_DIR}/module_base/module_container ) 此部分添加了项目所需的包含目录。 # 添加基本库 set(CMAKE_POSITION_INDEPENDENT_CODE ON) # 添加 base 模块 set(BASE_BINARY_DIR \"${PROJECT_SOURCE_DIR}/build/base\") add_subdirectory(${ABACUS_SOURCE_DIR}/module_base ${BASE_BINARY_DIR}) # 添加 parameter 模块 set(PARAMETER_BINARY_DIR \"${PROJECT_SOURCE_DIR}/build/parameter\") add_subdirectory(${ABACUS_SOURCE_DIR}/module_parameter ${PARAMETER_BINARY_DIR}) # 添加 orb 模块 set(ORB_BINARY_DIR \"${PROJECT_SOURCE_DIR}/build/orb\") add_subdirectory(${ABACUS_SOURCE_DIR}/module_basis/module_ao ${ORB_BINARY_DIR}) 此部分设置位置无关代码标志，并为 base、parameter、orb 模块添加子目录，指定这些模块的构建目录。 # 设置 RPATH execute_process( COMMAND \"${PYTHON_EXECUTABLE}\" -c \"from distutils.sysconfig import get_python_lib; print(get_python_lib())\" OUTPUT_VARIABLE PYTHON_SITE_PACKAGES OUTPUT_STRIP_TRAILING_WHITESPACE ) 此部分设置 Python 包目录的运行时搜索路径 (RPATH)，使用 Python 命令获取 site-packages 路径并将其存储在 PYTHON_SITE_PACKAGES 变量中。 # 将包名设置为 pyabacus set(TARGET_PACK pyabacus) set(CMAKE_INSTALL_RPATH \"${PYTHON_SITE_PACKAGES}/${TARGET_PACK}\") 此部分将包名设置为 pyabacus，并配置安装 RPATH 以包含 Python site-packages 目录。 # 为子模块添加子目录 add_subdirectory(${PROJECT_SOURCE_DIR}/src/hsolver) add_subdirectory(${PROJECT_SOURCE_DIR}/src/ModuleBase) add_subdirectory(${PROJECT_SOURCE_DIR}/src/ModuleNAO) 此部分为模块添加子目录，每个子目录包含自己的 CMakeLists.txt 以进行进一步配置。 通过遵循此结构，CMakeLists.txt 文件确保了所有必要的依赖项被找到、配置并包含在构建过程中。它还设置了项目环境并包含不同组件的子模块。 2.3 模块 CMake 配置 以下示例为模块（如 pyabacus.hsolver）的 CMakeLists.txt 文件： # 添加 diago 动态链接库 list(APPEND _diago ${HSOLVER_PATH}/diago_dav_subspace.cpp ${HSOLVER_PATH}/diago_david.cpp ${HSOLVER_PATH}/diag_const_nums.cpp ${HSOLVER_PATH}/diago_iter_assist.cpp ${HSOLVER_PATH}/kernels/dngvd_op.cpp ${HSOLVER_PATH}/kernels/math_kernel_op.cpp ${BASE_PATH}/kernels/math_op.cpp ${BASE_PATH}/module_device/device.cpp ${BASE_PATH}/module_device/memory_op.cpp ${PSI_PATH}/psi.cpp ) add_library(diagopack SHARED ${_diago}) target_link_libraries(diagopack base parameter container orb ${math_libs} ${OpenBLAS_LIBRARIES} ${LAPACK_LIBRARIES} ) list(APPEND pymodule_hsolver ${PROJECT_SOURCE_DIR}/src/hsolver/py_hsolver.cpp ) # 使用 pybind11 添加 Python 模块 pybind11_add_module(_hsolver_pack MODULE ${pymodule_hsolver}) # 将依赖项和 pybind11 库链接到模块 target_link_libraries(_hsolver_pack PRIVATE pybind11::headers diagopack) target_compile_definitions(_hsolver_pack PRIVATE VERSION_INFO=${PROJECT_VERSION}) set_target_properties(diagopack PROPERTIES INSTALL 2.4 Python 化上手指南 Pybind 简单教程（外部链接，感觉写的比较简单，可以直接阅读官方文档）里边有我入门 pybind11 时做的一些笔记，可以理解为官方文档的部分摘抄和学习 阅读 pybind11 with cmake，了解如何搭配 cmake 使用 pybind11 我们的项目使用 pybind11+cmake+scikit-build-core 构建，所以可以下载 scikit-build-core template 仓库，搞懂里边的代码，尝试跑一个 demo 出来 有任何与 scikit-build-core 相关的问题可以查阅 scikit-build-core 文档 阅读 pyabacus README，简单了解 pyabacus 目前的模块结构，尝试按照 README 编译 pyabacus 并跑通（可以运行 python/pyabacus/examples 内的 python 脚本） 阅读 pyabacus How to contribute，同步阅读 pyabacus 下各文件夹内 CMakeLists，理解它们之间的关系。本文档中给出了该部分的中文翻译，可对照查看。 同步地，可以看一下 src/hsolver 内的代码，其结构如下 {method}.hpp 为对应算法的头文件，头文件中将 hsolver 内对应算法进行了一定的包装，加入了 pybind 的一些头文件以方便调用 py_hsolver.cpp 为 pybind11 绑定，将三个方法对应的类绑定到 python ../pyabacus/hsolver 内的两个 py 文件将类的细节隐藏，用函数在外层抽象，将三个算法以函数的形式暴露给 python 了解了上面几点，你大概就了解了如何 Python 化 ABACUS 的一个模块，剩下需要搞懂的是 你要 Python 化的模块，按照面向对象的思想，你可以只搞懂对应模块的头文件中暴露出来的 public 方法的接口 但是，如果想要优化/防止 python 化过度影响效率，最好要搞懂其原理 作为高性能计算软件，我们时常与裸指针/底层数据打交道，但是我们处理的数据通常是矩阵 or 张量，所以一定要从源码中弄清楚数据的存储方式：行优先/列优先 不要想当然，作为有着”历史积累“的软件，不同模块可能使用不用方式存储 例如：davidson 算法与 dav_subspace 中的裸指针采用列优先方式，与 fortran 一致，while CG 算法中的 tensor 的底层数据是行优先方式，与 C++ 习惯及 NumPy 中一致 如何编写单元测试 可以阅读 tests 文件夹内的代码，同时查阅 pytest 文档 提交 PR 前一定要做好单元测试，确保功能没有问题！ 看到一片绿色写着 PASS 时候是很有成就感的~ 对上面问题有了基本的了解以后，我们就可以进行开发了！祝你在开发的过程中好运~ 三、资料汇总 Pybind 简单教程 pybind11 with cmake scikit-build-core template scikit-build-core 文档 pyabacus README pyabacus How to contribute pytest 文档 寻找在 GitHub 上参与开源项目的方法 GitHub Issues 快速入门 https://zhuanlan.zhihu.com/p/697280920 四、结语 以上就是 Pyabacus 的一些基本安装和使用方法，如果读者对进一步交流感兴趣，欢迎登录 ABACUS 的 github 网站进行进一步的交流。 Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"algorithm-wannier.html":{"url":"algorithm-wannier.html","title":"最大局域化 Wannier 函数方法简介","keywords":"","body":"最大局域化 Wannier 函数方法简介 作者：刘人熙，邮箱：rxliu@stu.pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/11/09 一、Wannier 函数是什么？ 电子的能量和波函数是电子结构计算中最关心的物理量之一，了解电子的这两个性质，就能进一步了解电子乃至原子体系的更多性质。 在周期性势场中，电子波函数满足布洛赫定理（Bloch Theorem），该定理指出，当电子处于满足 V(\\mathbf{r}+\\mathbf{R})=V(\\mathbf{r}) 的周期性势场V(\\mathbf{r})下时，电子的本征波函数\\psi_{n\\mathbf{k}}(\\mathbf{r})满足公式\\psi_{n\\mathbf{k}}(\\mathbf{r})=e^{i\\mathbf{k}\\cdot\\mathbf{r}}u_{n\\mathbf{k}}(\\mathbf{r})， 其中u_{n\\mathbf{k}}(\\mathbf{r})是另一个周期性函数，满足 u_{n\\mathbf{k}}(\\mathbf{r})=u_{n\\mathbf{k}}(\\mathbf{r}+\\mathbf{R})，这里的\\mathbf{R}代表晶格矢量。 图 1 左列展示了一维情况下一些布洛赫波函数的形态，即通常情况下，电子波函数在实空间中是非局域的。 事实上，电子波函数的模平方代表电子出现的概率密度，能被实验验证。在计算中，可以发现电子波函数有一个可调节的“相位因子“，这个随机的相位因子可以导致计算出来的电子波函数在实空间的局域程度不同。因此，长期以来，人们一直在探索什么形式的电子波函数适合描述例如共价键这样的物理性质，Wannier 函数就是常用的一种方法。 Wannier 函数就是一种周期性势场中的电子波函数表示方法，早在 1937 年，Gregory H. Wannier 最早定义了周期性势场中的波函数可以写成： |\\mathbf{R}n\\rangle=\\frac{V}{(2\\pi)^3}\\int_{BZ}d\\mathbf{k}e^{-i\\mathbf{k}\\cdot\\mathbf{R}}|\\psi_{n\\mathbf{k}}\\rangle 这里的 V 代表晶格体积。从公式直观上看，这相当于在第一布里渊区中对电子波函数做傅立叶变换，也就是对各个本征态波函数\\psi_{n\\mathbf{k}}按照e^{-i\\mathbf{k}\\cdot\\mathbf{R}}的权重做加权平均，把各个本征态“折叠”到\\mathbf{R}晶格中，实现局域化。得到的波函数|\\mathbf{R}n\\rangle被称作 Wannier 函数，一维的图示如图 1 右列。 图 1. 左列：不同k点对应的布洛赫波函数；右列：不同晶格中的Wannier函数。 易于验证 Wannier 函数是正交归一的，布洛赫波函数可以通过逆傅立叶变换从 Wannier 函数得到： |\\psi_{n\\mathbf{k}}\\rangle=\\sum_{\\mathbf{R}}e^{i\\mathbf{k}\\cdot\\mathbf{R}}|\\mathbf{R}n\\rangle 于是对于同一个能带的子空间来说，布洛赫波函数和 Wannier 函数都可以构成电子波函数的完备表示，也就是 P_n= \\sum_{\\mathbf{R}}|\\mathbf{R}n\\rangle\\langle\\mathbf{R}n|=\\sum_{\\mathbf{k}}|\\psi_{n\\mathbf{k}}\\rangle\\langle\\psi_{n\\mathbf{k}}|。 二、最大局域化 Wannier 函数 2.1 Wannier 函数的不唯一性 Wannier 的局域化定义简单直接，深受学界欢迎，但是它存在随规范变化因而不唯一的问题。这种不唯一性来源于布洛赫波的不唯一性，对于非简并的n\\mathbf{k}态的本征波函数\\psi_{n\\mathbf{k}}，规范变换后的\\psi_{n\\mathbf{k}}e^{i\\phi(\\mathbf{k})}（\\phi(\\mathbf{k})为实数）同样是本征态，二者之间只差一个相位因子。但是这样一来，布洛赫波中的u_{n\\mathbf{k}}分量就变成了u_{n\\mathbf{k}}e^{i\\phi(\\mathbf{k})}，Wannier 函数就变成了\\frac{V}{(2\\pi)^3}\\int_{BZ}d\\mathbf{k}e^{-i\\mathbf{k}\\cdot\\mathbf{R}+i\\phi(\\mathbf{k})}|\\psi_{n\\mathbf{k}}\\rangle，得到的 Wannier 函数就完全不一样了。 在简并情况下，比如说 J 个能带构成一组互相相交的能带，和其他能带不相交，这时这 J 个能带的本征波函数做幺正变换，依然可以构成本征波函数，也就是 |\\tilde{\\psi}_{n\\mathbf{k}}\\rangle=\\sum_{m}U_{mn}^{\\mathbf{k}}|\\psi_{m\\mathbf{k}}\\rangle 依然是本征态，他们可以张成对应于这 J 个能带的同一个线性空间，该线性空间的投影算符可以写作 P_{\\mathbf{k}}=\\sum_{n=1}^{J}|\\psi_{n\\mathbf{k}}\\rangle\\langle\\psi_{n\\mathbf{k}}|=\\sum_{m=1}^{J}|\\tilde\\psi_{m\\mathbf{k}}\\rangle\\langle\\tilde\\psi_{m\\mathbf{k}}|。 第二个等号具体证明如下： \\sum_{m=1}^{J}|\\tilde\\psi_{m\\mathbf{k}}\\rangle\\langle\\tilde\\psi_{m\\mathbf{k}}|=\\sum_{m=1}^{J}\\sum_{pq}^{J}U_{mp}^{\\mathbf{k}}|\\psi_{p\\mathbf{k}}\\rangle U^{\\mathbf{k}*}_{qm}\\langle\\psi_{q\\mathbf{k}}| =\\sum_{pq}^{J}\\sum_{m=1}^{J}U^{\\mathbf{k}*}_{qm}U_{mp}^{\\mathbf{k}}|\\psi_{p\\mathbf{k}}\\rangle\\langle\\psi_{q\\mathbf{k}}|=\\sum_{pq}^{J}\\delta_{pq}|\\psi_{p\\mathbf{k}}\\rangle\\langle\\psi_{q\\mathbf{k}}|=\\sum_{p=1}^{J}|\\psi_{p\\mathbf{k}}\\rangle\\langle\\psi_{p\\mathbf{k}}| 也就是说一组或者一个孤立的能带的投影算符是不随规范变换的。 这时不同规范下的 Wannier 函数的变换会更为复杂，Wannier 函数也存在不唯一确定的问题。 所以是否可以选取一个给定的规范，可以在一个系统上给出唯一的一组 Wannier 函数，满足我们在第一部分中提出的两个动机呢？这个简单的问题并没有在固体物理建立的最初几十年里有一个完整的解答。 2.2 独立的能带的 Wannier 函数的 spread 函数 直到 1997 年，Nicola Marzari 和 David Vanderbilt 在文献[1]提出，可以针对一组孤立的 J 个能带（也可以是单独一个孤立的能带），要求 Wannier 函数在晶格内的 spread 最小，以此作为规范，所谓的 spread 就是在 Wannier 函数上位置 r 的方差 \\Omega=\\sum_{n}\\langle\\mathbf{0}n|\\mathbf{r}^2|\\mathbf{0}n\\rangle-|\\langle\\mathbf{0}n|\\mathbf{r}|\\mathbf{0}n\\rangle|^2. Marzari 和 Vanderbilt 进一步发现这个 spread 函数可以分为规范不变和随规范变换的两个部分，并且给出了最小化 spread 函数的稳定的数值算法。 具体来说，规范不变的部分是： \\Omega_{I}=\\sum_{n}\\left[\\langle\\mathbf{0}n|\\mathbf{r}^2|\\mathbf{0}n\\rangle-\\sum_{\\mathbf{R}m}|\\langle\\mathbf{R}m|\\mathbf{r}|\\mathbf{0}n\\rangle|^2\\right]， 规范变换的部分是 \\tilde\\Omega=\\sum_{n}\\sum_{\\mathbf{R}m\\neq\\mathbf{0}n}|\\langle\\mathbf{R}m|\\mathbf{r}|\\mathbf{0}n\\rangle|^2， 规范不变的部分可以写作： \\Omega_I=\\sum_{n\\alpha}\\left[\\langle\\mathbf{0}n|r_\\alpha^2|\\mathbf{0}n\\rangle-\\sum_{\\mathbf{R}m}\\langle\\mathbf{0}n|r_\\alpha|\\mathbf{R}m\\rangle\\langle\\mathbf{R}m|r_\\alpha|\\mathbf{0}n\\rangle\\right] =\\sum_{n\\alpha}\\left[\\langle\\mathbf{0}n|r_\\alpha^2|\\mathbf{0}n\\rangle-\\sum_{m}\\langle\\mathbf{0}n|r_{\\alpha}P_{m}r_\\alpha|\\mathbf{0}n\\rangle \\right] =\\sum_{n\\alpha}\\langle\\mathbf{0}n|r_{\\alpha}(1-\\sum_{m}P_{m})r_\\alpha|\\mathbf{0}n\\rangle =\\sum_{n\\alpha}\\langle \\mathbf{0}n|r_{\\alpha}Qr_\\alpha|\\mathbf{0}n\\rangle 上式中最后一个等号使用了定义 P=\\sum_m P_m=\\sum_{\\mathbf{k}m}|\\psi_{m\\mathbf{k}}\\rangle\\langle\\psi_{m\\mathbf{k}}|， Q=1-P， 因为 P 和 Q 算符是考虑的这组孤立能带上的投影矩阵和互补矩阵，所以它们是不随规范变换的，这一点已经在上文证明过。 \\Omega_I可以进一步写成 \\Omega_I=\\sum_{n\\alpha}\\langle\\mathbf{0}n|\\sum_{m}|\\mathbf{0}m\\rangle\\langle \\mathbf{0}m|r_\\alpha Qr_\\alpha|\\mathbf{0}n\\rangle=Tr_{c}(Pr_\\alpha Qr_\\alpha) 这里的角标 c 表示对单个晶格（cell）求迹，也就是只对能带指标求迹。可以看到\\Omega_{I}只和P, Q有关，是规范不变的。我们还可以进一步证明规范不变的部分是非负的，具体来说，\\Omega_{I}可以进一步写作Tr_{c}\\left[(Pr_\\alpha Q)(P r_\\alpha Q)^{\\dagger}\\right]， 这显然是非负的，使用投影矩阵满足 P^2=P, P^\\dagger =P 的性质不难证明该等式。 在布洛赫表象下，Wannier 函数的\\mathbf{r}和\\mathbf{r}^2的均值可以表示为： \\langle\\mathbf{R}n|\\mathbf{r}|\\mathbf{0}m\\rangle=i\\frac{V}{(2\\pi)^2}\\int d\\mathbf{k}e^{i\\mathbf{k}\\cdot\\mathbf{R}}\\langle u_{n\\mathbf{k}}|\\nabla_{\\mathbf{k}}|u_{m\\mathbf{k}}\\rangle, \\langle\\mathbf{R}n|\\mathbf{r}^2|\\mathbf{0}m\\rangle=-\\frac{V}{(2\\pi)^2}\\int d\\mathbf{k}e^{i\\mathbf{k}\\cdot\\mathbf{R}}\\langle u_{n\\mathbf{k}}|\\nabla^2_{\\mathbf{k}}|u_{m\\mathbf{k}}\\rangle 这里直接引用了文献[2]的结果。 这里对 k 的散度在 DFT 中，可以近似表示为相邻的 k 点的波函数之间的差分，具体来说就是： \\nabla f(\\mathbf{k}) = \\sum_{\\mathbf{b}}\\mathbf{b}\\omega_b[f(\\mathbf{k}+\\mathbf{b})-f(\\mathbf{k})]+O(b^2), 这里的\\mathbf{b}是\\mathbf{k}指向相邻 k 点的向量，\\omega_b是一个量纲为b^{-2}的常数权重参数，所以 spread 函数和他的导数都可以表示为布洛赫波函数中的周期性分量之间的内积，也就是 M_{mn}^{\\mathbf{k}, \\mathbf{b}}=\\langle u_{m\\mathbf{k}}|u_{n,\\mathbf{k+b}}\\rangle， 换句话说，密度泛函理论软件只需要提供M_{mn}^{\\mathbf{k,b}}这个物理量，就可以通过优化得出最局域化的 Wannier 函数。 经过一系列推导，可以得到\\Omega_I在布洛赫表象下的表达式： \\Omega_I=\\frac{1}{N}\\sum_{\\mathbf{k,b}}\\omega_b \\left(J-\\sum_{mn}|M_{mn}^{(\\mathbf{k, b})}|^2\\right)=\\frac{1}{N}\\sum_{\\mathbf{k,b}}\\omega_b \\mathrm{Tr}(P^{(\\mathbf{k})}Q^{(\\mathbf{k+b})}) 这里的P^{(\\mathbf{k})}=\\sum_{n}|u_{n\\mathbf{k}}\\rangle\\langle u_{n\\mathbf{k}}|，Q^{(\\mathbf{k})}=1-P^{(\\mathbf{k})}，J是能带数。 考虑到Tr(AB)=||A-B||^2/2，可以看到规范不变的 spread 函数衡量的是每个 k 点与其相邻 k 点上布洛赫波函数张成的线性空间的差别，可以看作是不同 k 点上的线性空间之间的“溢出函数” (spilage function)。换句话说，如果整个布里渊区内的 k 点上，布洛赫波函数张成的空间都一模一样，那么Tr(P^{\\mathbf{k}}Q^{(\\mathbf{k+b})})就是 0，规范不变部分的 spread 函数会直接消失，达到最小值。实际上，\\Omega_I可以看作是这组孤立能带的本征态构成的线性空间的一个本征性质，所以不会随这个线性空间内的表象变换而变化。 在实际的计算中，spread 函数是作为一个整体优化的，但\\Omega_I部分其实不会随优化改变，是一个固定的值。 2.3 纠缠能带的 Wannier 函数的 Spread 函数 2.2 部分简要叙述了对于一组孤立的能带，如何定义 spread 函数、如何将 spread 函数划分为规范不变和随规范变换的部分，以及 spread 函数在布洛赫表象下的表示。上述定义和划分在简并能带的情况是否依然成立呢？答案是肯定的，2001 年，Ivo Souza、Nicola Marzari 和 David Vanderbilt 共同在文献[3]提出了在一组纠缠的能带中抽取部分能带，对其 Wannier 函数做最大局域化的方法。Souza 等人提出了这样一个案例：对铜金属而言，其壳层电子 (3d^{10}4s^1)既包含 d 轨道电子也包含 s 轨道电子，直觉上说，d 轨道电子比较局域化，对应于能带中的窄带；s 轨道电子比较接近自由电子，对应于能带中的宽带。但实际上 s 轨道和 d 轨道发生了杂化，他们的能带是重叠在一起的，难以将 s 和 d 的能带、Wannier 函数区分开。这时，我们可以通过最大局域化 Wannier 函数的方式实现以上目的。 具体的做法是这样的，首先选取一个能量区间（energy window），这个区间包含 d 轨道的能带，也可以包含 s 轨道的能带。对于这个区间内的 k 点，如果只有 d 轨道的能带，就什么都不做；如果既含有 d 轨道也含有 s 轨道，就对这个 k 点的 d 轨道对应的\\Omega_I做最小化。这相当于在 s 和 d 轨道的本征态构成的线性空间里优化 d 轨道构成的子空间S(\\mathbf{k})，使该子空间与其他 k 点上的 d 轨道空间尽可能接近。完成这一步优化后，再按照优化独立能带的 Wannier 函数的办法优化\\tilde\\Omega。 完成优化后，可以通过 Slater-Koster 方法做内插值得到任意 k 点上的能带，从而实现对纠缠能带的解耦，在这个例子里就是可以把 d 轨道对应的能带和 s 轨道对应的能带分开，让他们各自长得像窄带和宽带。具体的做法可以参看文献[3] III F 部分和 IV 部分。 2.4 优化 Wannier 函数的 Spread 函数 在优化 spread 函数时，如果考虑的是纠缠能带中的一部分能带，就需要先优化\\Omega_I，再优化\\tilde\\Omega；如果考虑的是孤立能带，直接优化\\tilde\\Omega。 2.4.1 通过自洽迭代方法优化\\Omega_I 对于纠缠的能带中需要局域化的布洛赫波函数，需要优化的 spread 函数\\Omega_I=\\frac{1}{N_{kp}}\\sum_{\\mathbf{k, b}}\\omega_b \\sum_{m=1}^N \\left[1-\\sum_{n=1}^N |M_{mn}^{(\\mathbf{k, b})}|^2\\right]，其中N是考虑的能带数量，例如在铜的例子中，N=5。因为\\Omega_I是对整个布里渊区求和的，各个 k 点耦合在一起，所以需要自洽迭代地对\\Omega_I做优化。具体来说，在第 i 轮迭代，要求|u^{(i)}_{n\\mathbf{k}}\\rangle, n=1...N正交归一，同时u_{n\\mathbf{k}}^{(i)}可以使\\Omega_I^{(i)}达到极小，运用拉格朗日乘子法，写出变分方程： \\frac{\\delta\\Omega_{I}^{(i)}}{\\delta u^{(i)*}_{n\\mathbf{k}}}+\\sum_{n=1}^N \\Lambda^{(i)}_{nm, \\mathbf{k}}\\frac{\\delta}{\\delta u_{m\\mathbf{k}}^{(i)*}}[\\langle u_{m\\mathbf{k}}^{(i)}|u_{n\\mathbf{k}}^{(i)}\\rangle-\\delta_{mn}]=0 经过一系列线性代数操作（详细步骤在文献[3]III C 部分），得到最后的特征方程： \\left[\\sum_{\\mathbf{b}}\\omega_b \\hat{P}_{\\mathbf{k+b}}^{(i-1)}\\right]|u_{m\\mathbf{k}}^{(i)}\\rangle=\\lambda_{m\\mathbf{k}}^{(i)}|u_{m\\mathbf{k}}^{(i)}\\rangle 其中的\\hat{P}_ {\\mathbf{k+b}}^{(i-1)}是\\mathbf{k+b}上的投影算符\\hat{P}^{(i-1)}_ {\\mathbf{k+b}}=\\sum_{n=1}^{N}|u_{n\\mathbf{k+b}}^{(i-1)}\\rangle\\langle u_{n\\mathbf{k+b}}^{(i-1)}|。如果迭代不稳定，可以采用类似 charge mixing 的方法，线性混合前后两步迭代的\\hat{P}_ {\\mathbf{k+b}}，即[\\hat{P}^{(i)}_ {\\mathbf{k+b}}]_ {in}=\\alpha\\hat{P}_ {\\mathbf{k+b}}^{(i-1)}+(1-\\alpha)[\\hat{P}_ {\\mathbf{k+b}}^{(i-1)}]_ {in}，这里的[\\hat{P}^{(i)}_ {\\mathbf{k+b}}]_ {in}表示第 i 步迭代输入的投影算符，\\hat{P}_{\\mathbf{k+b}}^{(i-1)}表示第 i-1 步输出的投影算符。 在实际计算中，需要在特定的基组上把投影算符展开为矩阵做对角化，在这里选择的是选取的能量区间内原始的布洛赫函数u_{n\\mathbf{k}}（这是必要的，因为优化算法本身不保证每次迭代得到的P_{\\mathbf{k}}^{(i)}仍然落在原始布洛赫函数张成的线性空间里，这里选取基底相当于把新得到的投影算符投影到这个空间里，保证每次迭代得到的布洛赫函数仍在原始的线性空间范围内），所以最终需要对角化的矩阵是Z_{mn}^{(i)}(\\mathbf{k})=\\langle u_{m\\mathbf{k}}|\\sum_{\\mathbf{b}}\\omega_b[\\hat{P}^{(i)}_{\\mathbf{k+b}}]_{in}|u_{n\\mathbf{k}}\\rangle，这是一个大小为N\\times N的厄米矩阵。每次自洽迭代中，需要对每个 k 点对角化Z_{mn}^{(i)}(\\mathbf{k})，得到u_{n\\mathbf{k}}^{(i)}；计算新的投影矩阵，进入下一次迭代。 最后还存在一个初始值Z_{mn}^{(0)}(\\mathbf{k})如何选取的问题，这实际上是在选取初始的子空间S(\\mathbf{k})。这里固然可以选择原始的布洛赫波函数u_{n\\mathbf{k}}构成子空间，但是也可以有意地选择子空间使得其 Wannier 表象更接近我们的直觉认知。比如我们认为 Wannier 函数可能接近于一组名为g_n(\\mathbf{r}), n=1...N的实空间基函数，那么就可以把每个 k 点上的布洛赫波函数投影到这组基函数上：|\\phi_{n\\mathbf{k}}\\rangle=\\sum_{m=1}^{N_{win}}A_{mn}^{(\\mathbf{k})}|u_{m\\mathbf{k}}\\rangle，其中A_{mn}^{(\\mathbf{k})}=\\langle u_{m\\mathbf{k}}|g_{n}\\rangle，N_{win}是能量区间中总能带数。这样的投影轨道还不满足布洛赫波函数正交归一的要求，所以需要对其做正交归一化使其成为新的布洛赫波函数：|u_{n\\mathbf{k}}^{(0)}\\rangle=\\sum_{m=1}^{N}(S^{-1/2})_{mn}|\\phi_{m\\mathbf{k}}\\rangle=\\sum_{m=1}^{N_{win}^{\\mathbf{k}}}(AS^{-1/2})_{mn}|u_{m\\mathbf{k}}\\rangle 其中的重叠矩阵S_{mn}=S_{mn}^{\\mathbf{k}}=\\langle\\phi_{m\\mathbf{k}}|\\phi_{n\\mathbf{k}}\\rangle=(A^{\\dagger}A)_{mn}，这样就可以通过实空间中布洛赫波函数在一组预想的基函数上的投影给出来投影矩阵P_{k}的初猜，从而开始自洽迭代优化。 2.4.2 通过梯度下降方法优化\\tilde \\Omega 获得每个 k 点上需要考虑的布洛赫波函数张成的线性空间S(\\mathbf{k})（也是获得每个 k 点上的投影矩阵P_{\\mathbf{k}}）之后，就可以通过梯度下降法寻找使得 spread 函数最小的规范变换。这里的梯度下降不是对u_{n\\mathbf{k}}做任意的梯度下降，因为需要满足新的u_{n\\mathbf{k}}和原来的u_{n\\mathbf{k}}之间的规范变换关系（幺正变换）。具体的做法是一次对布洛赫波函数做一个微小的转动U_{mn}^{(\\mathbf{k})}=\\delta_{mn}+dW_{mn}^{(\\mathbf{k})}，其中dW_{mn}^{(\\mathbf{k})}=-dW_{mn}^{(\\mathbf{k})\\dagger}是一个反厄米矩阵，从而满足U_{mn}^{(\\mathbf{k})}是幺正的。经过一些推导（详细推导参考文献[1]的 IV B 部分），可以获得 spread 函数的梯度： G^{(\\mathbf{k})}=\\frac{d\\Omega}{dW^{(\\mathbf{k})}}=4\\sum_{\\mathbf{b}}\\omega_b (\\mathcal{A}[R^{(\\mathbf{k,b})}]-\\mathcal{S}[T^{(\\mathbf{k,b})}]) 其中R^{(\\mathbf{k,b})}=M_{mn}^{(\\mathbf{k, b})}M_{nn}^{(\\mathbf{k, b})*}, T_{mn}^{(\\mathbf{k,b})}=\\frac{M_{mn}^{(\\mathbf{k,b})}}{M_{nn}^{(\\mathbf{k,b})}}\\cdot(\\mathrm{Im} \\ln{M_{nn}^{(\\mathbf{k,b})}}+\\mathbf{b}\\cdot\\overline{\\mathbf{r}_n}), \\overline{\\mathbf{r}_n}=-\\frac{1}{N}\\sum_{(\\mathbf{k,b})}\\omega_{b}\\mathbf{b}\\mathrm{Im}\\ln{M_{nn}}^{(\\mathbf{k,b})} 在实际计算中，梯度下降的步长被设置为固定的\\epsilon=\\alpha/4\\omega，其中\\omega=\\sum_{b}\\omega_b，这样微扰矩阵\\Delta W^{(\\mathbf{k})}写作\\Delta W^{(\\mathbf{k})}=\\frac{\\alpha}{\\omega}\\sum_{\\mathbf{b}}\\omega_b (\\mathcal{A}[R^{(\\mathbf{k,b})}]-\\mathcal{S}[T^{(\\mathbf{k,b})}])，因为这个矩阵是反厄米的，所以波函数可以直接按照u_{n\\mathbf{k}}\\to e^{\\Delta W^{(\\mathbf{k})}}u_{n\\mathbf{k}}变换，进入下一次迭代。这时 spread 函数的变化是d\\Omega=-\\frac{\\alpha}{4\\omega}\\sum_{\\mathbf{k}}||G^{(\\mathbf{k})}||^2。 三、参考文献 Nicola Marzari and David Vanderbilt, Maximally localized generalized Wannier functions for composite energy bands, Phys. Rev. B 56, 12847 (1997). (提出最大局域化 Wannier 函数方法的文献) Blount, E. I., Solid State Phys. 13, 305 (1962). (关于 Bloch 状态的诸多基础性质的讨论，最大局域化中\\langle n\\mathbf{R}|\\mathbf{r}|m\\mathbf{0}\\rangle在布洛赫表象下的表达式来源于此) Ivo Souza, Nicola Marzari, and David Vanderbilt, Maximally localized generalized Wannier functions for entangled energy bands, Phys. Rev. B 65, 035109 (2001). (从纠缠能带中解耦出部分能带，做最大局域化 Wannier 函数的文献) Arash A. Mostofi, Jonathan R. Yates, Young-Su Lee, Ivo Souza, David Vanderbilt, Nicola Marzari, wannier90: A tool for obtaining maximally-localised Wannier functions, Comput. Phys. Commun., 178, 9, 685 (2008). (Wannier90 软件的初始文献) Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "},"algorithm-mix.html":{"url":"algorithm-mix.html","title":"电荷密度混合算法介绍","keywords":"","body":"电荷密度混合算法介绍 作者：孙亮，邮箱：l.sun@pku.edu.cn 审核：陈默涵，邮箱：mohanchen@pku.edu.cn 最后更新时间：2023/11/09 一、背景 做基于 Kohn-Sham Density Functional Theory（KSDFT）的第一性原理计算的过程就是求解 Kohn-Sham (KS)方程 [-\\frac{1}{2}\\nabla^2+V_{\\rm{eff}}(r)]\\psi_i^\\sigma(r)=\\varepsilon_i^\\sigma\\psi_i^\\sigma(r),V_{\\rm{eff}}(r)=V_{\\rm ext}(r)+V_{\\rm{H}}(r)+V_{\\rm{xc}}(r) 的过程。由于其中 V_{\\rm{H}}(r)=\\int{\\frac{\\rho(r')}{|r-r'|}dr'},V_{\\rm{xc}}(r) = \\frac{\\delta E_{\\rm{xc}}[\\rho]}{\\delta\\rho(r)} 均依赖于电荷密度\\rho(r)，KS 方程无法直接求解，只能采取迭代的方法，也就是自洽场迭代法（scf, self-consistent field）。其流程可以概括为 \\cdots \\rightarrow \\rho^{i-1} \\rightarrow V_{\\rm{eff}}^{i-1} \\rightarrow \\rho^{i} \\rightarrow V_{\\rm{eff}}^{i} \\rightarrow \\rho^{i+1} \\rightarrow \\cdots 上述过程也可以看作一个不动点问题：\\rho = f(\\rho)，f代表从\\rho^{i-1}到\\rho^i的映射。 我们常常采用电荷密度混合（charge mixing）方法来提升 scf 迭代过程的稳定性和收敛效率，引入 charge mixing 方法后，scf 流程可概括为 \\cdots \\rightarrow \\rho_{\\rm{in}}^{i-1} \\rightarrow V_{\\rm{eff}}^{i-1} \\rightarrow \\rho_{\\rm{out}}^{i-1}  \\stackrel{CM}{\\longrightarrow} \\rho_{\\rm{in}}^{i} \\rightarrow V_{\\rm{eff}}^{i} \\rightarrow \\rho_{\\rm{out}}^{i} \\stackrel{CM}{\\longrightarrow} \\rho_{\\rm{in}}^{i+1} \\rightarrow \\cdots 其中CM表示 charge mixing 方法，它将前几步的电荷密度以一定的比例混合，得到下一步输入f映射的电荷密度\\rho_{\\rm{in}}。 下面我们将介绍几种常用的 charge mixing 方法：plain mixing, Pulay mixing, 以及Broyden mixing方法。这三种算法均已实现在 ABACUS 中。 为了方便，下文中我们统一采用狄拉克符号，比如电荷密度记为|\\rho\\rangle。 二、算法介绍 我们一般定义|F^{i}\\rangle = |\\rho^{i}_ {\\rm{out}}\\rangle - |\\rho^{i}_{\\rm{in}}\\rangle为残差，当它的模\\langle F^{i}|F^{i}\\rangle = 0时，迭代达到收敛。实际计算中，无法真正做到模为零，一般设置一个阈值\\Delta来判断是否收敛。 值得一提的是，下面的推导中，我们都以电荷密度作为变量，但这些算法都适用于 charge mixing 过程中其它量的混合，比如动能密度等。它们也不仅适用于电荷密度混合，也可用于其它的优化问题。 1. Plain mixing Plain mixing，也称 simple mixing，其思路是将|\\rho^{i}_ {\\rm{in}}\\rangle和|\\rho^{i}_ {\\rm{out}}\\rangle做线性组合，得到下一步的|\\rho^{i+1}_{\\rm{in}}\\rangle，为了保证混合前后电子数不变，混合的公式为 |\\rho^{i+1}_{\\rm{in}}\\rangle = (1-\\beta)|\\rho^{i}_{\\rm{in}}\\rangle + \\beta|\\rho^{i}_{\\rm{out}}\\rangle = |\\rho^{i}_{\\rm{in}}\\rangle + \\beta(|\\rho^{i}_{\\rm{out}}\\rangle - |\\rho^{i}_{\\rm{in}}\\rangle) = |\\rho^{i}_{\\rm{in}}\\rangle + \\beta|F^{i}\\rangle, 其中\\beta为 mixing 的步长，可以取 0 到 1 间的实数，\\beta越小，则迭代越稳定，但收敛所需的步数可能越多。（见第三部分，介绍 ABACUS 里面的相关参数） 一般而言，plain mixing 收敛较慢，不在实际计算中采用。 2. Pulay mixing Pulay mixing[1]也叫 direct inversion of the iterative sub-space (DIIS) method，其思路是用前n步的电荷密度\\{|\\rho^{i-n+1}_ {\\rm{in}}\\rangle, \\cdots, |\\rho^{i-1}_ {\\rm{in}}\\rangle, |\\rho^{i}_ {\\rm{in}}\\rangle\\}做线性组合，在此线性空间中找到一个“最佳”的电荷密度|\\rho^i_{\\rm{opt}}\\rangle，使得\\langle F^{i}_ {\\rm{opt}}|F^{i}_ {\\rm{opt}}\\rangle取极小值，再由|\\rho^i_{\\rm{opt}}\\rangle和|F^i_{\\rm{opt}}\\rangle线性组合得到下一步的|\\rho^{i+1}_{\\rm{in}}\\rangle。 下面我们首先给出算法流程，然后进行相应的推导。 2.1 算法流程 需要存储前n步迭代的\\{|\\rho^{i-n+1}_ {\\rm{in}}\\rangle, \\cdots, |\\rho^{i-1}_ {\\rm{in}}\\rangle, |\\rho^{i}_{\\rm{in}}\\rangle\\}和\\{|F^{i-n+1}\\rangle, \\cdots, |F^{i-1}\\rangle, |F^{i}\\rangle\\}， 计算大小为n \\times n的矩阵A,A_{jk} = \\langle F^{i-n+j}|F^{i-n+k}\\rangle； 计算逆矩阵A^{-1}； 计算混合系数\\alpha_j = \\frac{\\sum_k^n{A^{-1}_ {jk}}}{\\sum_{l}^{n}{\\sum_k^n{A^{-1}_{lk}}}}； 更新密度|\\rho^{i+1}_ {\\rm{in}}\\rangle = \\sum_{j=1}^{n}{\\alpha_j \\left(|\\rho^{i-n+j}_{\\rm{in}}\\rangle + \\beta |F^{i-n+j}\\rangle \\right)}，\\beta为 mixing 的步长。 2.2 算法推导 为了记号方便，我们将参与线性组合的前n步电荷密度\\{|\\rho^{i-n+1}_ {\\rm{in}}\\rangle, \\cdots, |\\rho^{i-1}_ {\\rm{in}}\\rangle, |\\rho^{i}_ {\\rm{in}}\\rangle\\}重新标记为\\{|\\rho^{1}_ {\\rm{in}}\\rangle, \\cdots, |\\rho^{n-1}_ {\\rm{in}}\\rangle, |\\rho^{n}_{\\rm{in}}\\rangle\\}。 首先我们定义|\\rho^i_{\\rm{opt}}\\rangle = \\sum_{j=1}^{n}{\\alpha_j |\\rho^j_{\\rm{in}}\\rangle}，为了保证电子数守恒，要求\\sum_{j=1}^{n}{\\alpha_j} = 1。 为了找到最佳的\\{\\alpha_j\\}组合，使得\\langle F^{i}_ {\\rm{opt}}|F^{i}_ {\\rm{opt}}\\rangle取极小值，同时满足\\sum_{j=1}^{n}{\\alpha_j} = 1的条件，我们采用拉格朗日乘子法，定义 L=\\langle F^{i}_{\\rm{opt}}|F^{i}_{\\rm{opt}}\\rangle - \\lambda \\left( \\sum_{j=1}^{n}{\\alpha_j} - 1 \\right). 进一步假设F_{\\rm{opt}}^i[\\rho^{i}_ {\\rm{opt}}] = F_{\\rm{opt}}^i[\\sum_{j=1}^{n}{\\alpha_j \\rho^{i}_ {\\rm{in}}}] = \\sum_{j=1}^{n}{\\alpha_j F^{j}[\\rho^{j}_ {\\rm{in}}]}，即|F_{\\rm{opt}}^i\\rangle = \\sum_{j=1}^{n}{\\alpha_j |F^{j}\\rangle}，上式变为 \\begin{aligned} L &= \\sum_{j=1}^{n}{\\sum_{k=1}^{n}{\\alpha_j \\langle F^j|F^k\\rangle\\alpha_k}} - \\lambda \\left( \\sum_{j=1}^{n}{\\alpha_j} - 1 \\right)\\\\ & = \\sum_{j=1}^{n}{\\sum_{k=1}^{n}{\\alpha_j A_{jk}\\alpha_k}} - \\lambda \\left( \\sum_{j=1}^{n}{\\alpha_j} - 1 \\right). \\end{aligned} 上面我们定义了A_{jk} = \\langle F^j|F^k\\rangle，它满足A_{jk} = A_{kj}。 于是有 \\frac{\\partial L}{\\partial\\alpha_j} = 2\\sum_{k=1}^n{A_{jk}\\alpha_k} - \\lambda = 0 \\longrightarrow 2\\sum_{k=1}^n{A_{jk}\\alpha_k} = \\lambda, 两边同乘A^{-1}_{lj}并对j求和，有 2\\sum_{j=1}^n\\sum_{k=1}^n{A^{-1}_{lj}A_{jk}\\alpha_k} = \\lambda \\sum_{j=1}^n{A^{-1}_{lj}} \\longrightarrow 2\\sum_{k=1}^n{\\delta_{lk}\\alpha_k} = 2\\alpha_l = \\lambda \\sum_{j=1}^n{A^{-1}_{lj}}. 由\\sum_{l=1}^{n}{\\alpha_l} = 1，有\\frac{1}{2}\\lambda\\sum_{l=1}^{n}{\\sum_{j=1}^n{A^{-1}_ {lj}}} = 1，因此\\lambda = \\frac{2}{\\sum_{l}^{n}{\\sum_{j}^n{A^{-1}_{lj}}}}. 代回上式，我们得到最佳混合比例 \\alpha_l = \\frac{\\sum_j^n{A^{-1}_{lj}}}{\\sum_{k}^{n}{\\sum_j^n{A^{-1}_{kj}}}}. 最终，我们得到由前n步电荷密度线性组合可以得到的“最佳”电荷密度|\\rho^i_{\\rm{opt}}\\rangle = \\sum_{j=1}^{n}{\\alpha_j |\\rho^j_{\\rm{in}}\\rangle}，相应的残差|F_{\\rm{opt}}^i\\rangle = \\sum_{j=1}^{n}{\\alpha_j |F^{j}\\rangle}，其中的系数\\alpha_j = \\frac{\\sum_k^n{A^{-1}_ {jk}}}{\\sum_{l}^{n}{\\sum_k^n{A^{-1}_{lk}}}}. 因此下一次迭代的初始电荷密度 \\begin{aligned} |\\rho^{i+1}_{\\rm{in}}\\rangle  & = |\\rho^{i}_{\\rm{opt}}\\rangle + \\beta|F^{i}_{\\rm{opt}}\\rangle\\\\ & = \\sum_{j=1}^{n}{\\alpha_j |\\rho^j_{\\rm{in}}\\rangle} + \\beta \\sum_{j=1}^{n}{\\alpha_j |F^{j}\\rangle}\\\\ & = \\sum_{j=1}^{n}{\\alpha_j \\left(|\\rho^j_{\\rm{in}}\\rangle + \\beta |F^{j}\\rangle \\right)}. \\end{aligned} 3. Broyden mixing Broyden mixing 是拟牛顿法的一种，它的思路是对|F\\rangle的雅可比矩阵的逆进行近似，从而采用牛顿法进行迭代。 在其发展过程中，曾出现过不同的形式，这里我们介绍的是 1988 年 Johnson 提出的 Simplified modified Broyden method[2]，它兼具收敛速度快与内存消耗少的优势，也是 ABACUS 默认采用的 mixing 方法。 我们先给出算法流程，再进行推导，以下推导参考了文献[3]。 3.1 算法流程 首先我们定义|\\Delta\\rho^{i}_ {\\rm{in}}\\rangle = |\\rho^{i}_ {\\rm{in}}\\rangle - |\\rho^{i-1}_{\\rm{in}}\\rangle，|\\Delta F^{i}\\rangle = |F^{i}\\rangle - |F^{i-1}\\rangle。 需要存储前n步迭代的\\{|\\Delta\\rho^{i-n+1}_ {\\rm{in}}\\rangle, |\\Delta\\rho^{i-n+2}_ {\\rm{in}}\\rangle, \\cdots, |\\Delta\\rho^{i}_{\\rm{in}}\\rangle\\}和\\{|\\Delta F^{i-n+1}\\rangle, |\\Delta F^{i-n+2}\\rangle, \\cdots, |\\Delta F^{i}\\rangle\\}， 计算大小为n \\times n的矩阵B,B_{jk}=\\langle\\Delta F^{i-n+j}|\\Delta F^{i-n+k}\\rangle； 计算逆矩阵B^{-1}； 计算混合系数\\alpha_j=-\\sum_{k=1}^{n}{B^{-1}_{jk}\\langle\\Delta F^{i-n+k}|F^{i}\\rangle}； 更新密度|\\rho^{i+1}_ {\\rm{in}}\\rangle = |\\rho^{i}_ {\\rm{in}}\\rangle + \\beta|F^{i}\\rangle + \\sum_{j=1}^{n}\\alpha_{j}\\left(|\\Delta\\rho^{i-n+j}_{\\rm{in}}\\rangle + \\beta|\\Delta F^{i-n+j}\\rangle\\right)，\\beta为 mixing 的步长。 3.2 算法推导 3.2.1 牛顿法 我们首先介绍牛顿法，对于 charge mixing 中的不动点问题\\rho = f(\\rho)，可以改写为 |F\\rangle = |\\rho_{\\rm{out}}\\rangle - |\\rho_{\\rm{in}}\\rangle = 0，这里|\\rho_{\\rm{out}}\\rangle = f(|\\rho_{\\rm{in}}\\rangle)。 假设|F'\\rangle=F[\\rho']=0，且|F\\rangle在|\\rho'\\rangle附近足够光滑，选|\\rho'\\rangle附近的|\\rho_0\\rangle作为出发点，做泰勒展开，有 |F'\\rangle=|F_0\\rangle+J_0(|\\rho'\\rangle-|\\rho_0\\rangle)+\\cdots=0, 其中J_0=\\frac{\\partial F}{\\partial\\rho}|_{\\rho=\\rho_0}为雅可比矩阵，做线性近似后，有 |\\rho'\\rangle=|\\rho_0\\rangle - J_0^{-1}|F_0\\rangle, 由此得到牛顿法的迭代公式 |\\rho^{i+1}_{\\rm{in}}\\rangle=|\\rho^{i}_{\\rm{in}}\\rangle - J_i^{-1}|F^{i}\\rangle, 此公式中出现了雅可比矩阵的逆，精确求解将极为耗时，因此一般通过求解线性方程组来得到它： 记C_i=J^{-1}_i，由|F^{i-1}\\rangle=|F^{i}\\rangle+J_i(|\\rho^{i-1}_ {\\rm{in}}\\rangle-|\\rho^{i}_{\\rm{in}}\\rangle)，有C_i|\\Delta F^{i}\\rangle=|\\Delta\\rho^{i}_{\\rm{in}}\\rangle。 综上，牛顿法的完整迭代公式为 |\\rho^{i+1}_{\\rm{in}}\\rangle=|\\rho^{i}_{\\rm{in}}\\rangle - C_i|F^{i}\\rangle,C_i|\\Delta F^{i}\\rangle=|\\Delta\\rho^{i}_{\\rm{in}}\\rangle. 牛顿法中，需要先求出矩阵C_i，在 charge mixing 的应用场景中，C_i的大小为N\\times N，N为实空间格点数，因此C_i的求解和储存都很不方便。 3.2.2 Broyden 算法 为了克服牛顿法的问题，人们提出了拟牛顿法（quasi-Newton），其基本思路是对C_i进行近似，而不是精确求解。拟牛顿法中，我们一般要求近似的C_i仍然满足C_i|\\Delta F^{i}\\rangle=|\\Delta\\rho^{i}_{\\rm{in}}\\rangle的条件，称为拟牛顿条件。 Simplified modified Broyden method 是拟牛顿法的一种，假设C_{i-1}已知，它通过求解以下优化问题得到C_i： \\min_{C} \\frac{1}{2}\\|C-C_{i-1}\\|^2_{F}, {\\rm{s.t.}}\\ S_{i}=CY_{i}. 其中S_i=(|\\Delta\\rho^{i-n+1}_ {\\rm{in}}\\rangle, |\\Delta\\rho^{i-n+2}_ {\\rm{in}}\\rangle, \\cdots, |\\Delta\\rho^{i}_{\\rm{in}}\\rangle)，Y_i=(|\\Delta F^{i-n+1}\\rangle, |\\Delta F^{i-n+2}\\rangle, \\cdots, |\\Delta F^{i}\\rangle)，均为大小为N\\times n的矩阵，S_{i}=CY_{i}要求C对于前n步的|\\Delta\\rho^{j}_{\\rm{in}}\\rangle和|\\Delta F^{j}\\rangle均满足拟牛顿条件， 我们仍然采用拉格朗日乘子法，定义 L = \\frac{1}{2}\\|C-C'\\|^2_{F} + \\frac{1}{2}u^T\\left(S-CY\\right)^T\\left(S-CY\\right)u, 为了方便，这里我们省去了S_i,Y_i的下标i，并且记C'=C_{i-1}，其中u=(u_1, u_2, \\cdots, u_n)^T为拉格朗日乘子组成的大小为n\\times 1的向量。 将上式展开，有 \\begin{aligned} L =& \\frac{1}{2}\\sum_{j=1}^n\\sum_{k=1}^n\\left(C_{jk}-C'_{jk}\\right)^2\\\\ &+ \\frac{1}{2}\\sum_{j=1}^n\\sum_{k=1}^n{u_j\\left[ \\left(S^TS\\right)_{jk} - 2\\sum_{p=1}^N\\sum_{q=1}^N{S_{pj}C_{pq}Y_{qk}} + \\sum_{p=1}^N\\sum_{q=1}^N\\sum_{l=1}^N{Y_{pj}C_{qp}C_{ql}Y_{lk}} \\right]u_k}, \\end{aligned} 令\\partial L/\\partial{C_{\\mu\\nu}}=0，由上式有 \\frac{\\partial L}{\\partial{C}_{\\mu\\nu}}=C_{\\mu\\nu} - C'_{\\mu\\nu} - \\sum_{j=1}^n\\sum_{k=1}^n{\\left(S_{\\mu j} - \\sum_{l=1}^N{C_{\\mu l}Y_{lj}}\\right)u_ju_kY_{\\nu k}} = 0, 因此 C_{\\mu\\nu} \\approx C'_{\\mu\\nu} + \\sum_{j=1}^n\\sum_{k=1}^n{\\left(S_{\\mu j} - \\sum_{l=1}^N{C'_{\\mu l}Y_{lj}}\\right)u_ju_kY_{\\nu k}}, 注意我们将括号中的C_{\\mu l}近似成了C'_{\\mu l}，上式写成矩阵形式为 C = C'+\\left(S-C' Y\\right)uu^T Y^T, 代入拟牛顿条件S=CY中，要求uu^T = \\left(Y^T Y\\right)^{-1}，因此上述优化问题给出 C_{i} = C_{i-1}+\\left(S_i-C_{i-1} Y_i\\right) \\left(Y_i^T Y_i\\right)^{-1} Y_i^T, 假设C_{i-1}=C_0=-\\beta I，上式变为 C_{i} = -\\beta I + \\left(S_i+\\beta Y_i\\right) \\left(Y_i^T Y_i\\right)^{-1} Y_i^T, 于是迭代公式为 \\begin{aligned} |\\rho^{i+1}_{\\rm{in}}\\rangle &=|\\rho^{i}_{\\rm{in}}\\rangle - C_i|F^{i}\\rangle\\\\ & = |\\rho^{i}_{\\rm{in}}\\rangle - \\left(-\\beta I + \\left(S_i+\\beta Y_i\\right) \\left(Y_i^T Y_i\\right)^{-1} Y_i^T\\right) |F^{i}\\rangle\\\\ & = |\\rho^{i}_{\\rm{in}}\\rangle + \\beta|F^{i}\\rangle - \\left(S_i+\\beta Y_i\\right) \\left(Y_i^T Y_i\\right)^{-1} Y_i^T |F^{i}\\rangle. \\end{aligned} 下面我们将此公式改写成更加清楚的形式，首先令B=Y_i^T Y_i，则B_{jk}=\\langle\\Delta F^{i-n+j}|\\Delta F^{i-n+k}\\rangle，因此 \\begin{aligned} -\\left(Y_i^T Y_i\\right)^{-1} Y_i^T |F^{i}\\rangle &= -B^{-1}\\left(\\langle\\Delta F^{i-n+1}|F^{i}\\rangle, \\langle\\Delta F^{i-n+2}|F^{i}\\rangle, \\cdots, \\langle\\Delta F^{i}|F^{i}\\rangle \\right)^T\\\\ & =\\left(\\alpha_1, \\alpha_2, \\cdots, \\alpha_n \\right)^T, \\end{aligned} 其中\\alpha_j=-\\sum_{k=1}^{n}{B^{-1}_{jk}\\langle\\Delta F^{i-n+j}|F^{i}\\rangle}。 最终 \\begin{aligned} |\\rho^{i+1}_{\\rm{in}}\\rangle  & =  |\\rho^{i}_{\\rm{in}}\\rangle + \\beta|F^{i}\\rangle - \\left(S_i+\\beta Y_i\\right) \\left(Y_i^T Y_i\\right)^{-1} Y_i^T |F^{i}\\rangle\\\\ & = |\\rho^{i}_{\\rm{in}}\\rangle + \\beta|F^{i}\\rangle + \\left(S_i+\\beta Y_i\\right) \\left(\\alpha_1, \\alpha_2, \\cdots, \\alpha_n \\right)^T\\\\ & = |\\rho^{i}_{\\rm{in}}\\rangle + \\beta|F^{i}\\rangle + \\sum_{j=1}^{n}\\alpha_{j}\\left(|\\Delta\\rho^{i-n+j}_{\\rm{in}}\\rangle + \\beta|\\Delta F^{i-n+j}\\rangle\\right). \\end{aligned} 三、ABACUS 相关参数介绍 上述三种算法均已在 ABACUS 中实现，下面我们简要介绍 ABACUS 中 charge mixing 的相关参数，并将它们与上面的公式对应起来，详细文档见链接。 mixing_type：选择 mixing 算法，可选项为 plain, pulay, broyden，分别对应上述三种算法，一般而言，Broyden 算法收敛最快，Pulay 略慢，plain 最慢。默认选项为 broyden。 mixing_beta：对应上述公式中的参数\\beta，\\beta绝对值越小，则收敛过程越稳定，但达到收敛所需的步数可能增多。对于难以收敛的体系，特别是收敛过程中能量出现上下波动的例子，可以尝试减小 mixing_beta。 mixing_ndim：对应上述公式中的参数n，Pulay 和 Broyden 算法会借助过去n步的信息构建下一次迭代的电荷密度，默认值为 8。对于难以收敛的体系，略增大 mixing_ndim 可以增强收敛过程的稳定性。 mixing_gg0：是否采用 Kerker scaling 方法，此方法会在倒空间中给|F\\rangle乘上\\frac{k^2}{k^2+gg0^2}的因子，以抑制混合过程中的高频项，其中k为波矢，gg0由 mixing_gg0 设置。特别是对于难以收敛的金属体系，打开 Kerker 方法可以帮助计算达到收敛。 mixing_tau：是否对动能密度进行混合，适用于使用 meta-GGA 交换关联泛函的场景。 mixing_dftu：是否对密度矩阵进行混合，适用于使用 DFT+U 的场景。 scf_thr：对应于 charge mixing 的收敛判据\\Delta，对于原子轨道基组(LCAO)，默认值为 1e-7，对于平面波基组(PW)，默认值为 1e-9。 scf_thr_type：选择上述公式中内积\\langle f|f\\rangle的定义，以及相应收敛判据的计算方式。 1：\\langle f|g\\rangle = \\iint{\\frac{f(r)g(r')}{|r-r'|}drdr'} = 4\\pi\\int{\\frac{\\mathcal{R}[f^*(k)g(k)]}{k^2}dk}，\\mathcal{R}表示取实部，收敛判据为\\langle\\Delta\\rho|\\Delta\\rho\\rangle ，默认用于 PW 基组； 2：\\langle f|f\\rangle = \\int{f^2(r)dr}，收敛判据为\\int{|\\Delta\\rho|dr} ，默认用于 LCAO 基组。 四、参考文献 [1] Pulay P. Convergence acceleration of iterative sequences. The case of SCF iteration[J]. Chemical Physics Letters, 1980, 73(2): 393-398. [2] Johnson D D. Modified Broyden’s method for accelerating convergence in self-consistent calculations[J]. Physical Review B, 1988, 38(18): 12807. [3] Lin L, Yang C. Elliptic preconditioner for accelerating the self-consistent field iteration in Kohn--Sham density functional theory[J]. SIAM Journal on Scientific Computing, 2013, 35(5): S277-S298. Copyright © mcresearch.gitee.io 2023 all right reserved，powered by Gitbook该文章修订时间： 2025-03-18 15:43:59 "}}